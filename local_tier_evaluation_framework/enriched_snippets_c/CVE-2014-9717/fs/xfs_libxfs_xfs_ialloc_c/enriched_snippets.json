[
  {
    "function_name": "xfs_ialloc_pagi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2182-2197",
    "snippet": "int\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&bp"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ialloc_read_agi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2144-2177",
    "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_freecount"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_count"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_freecount"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "*bpp"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "bpp"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_ialloc_read_agi",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_read_agi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2122-2142",
    "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "*bpp",
            "XFS_AGI_REF"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "XFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp))",
            "XFS_FSS_TO_BB(mp, 1)",
            "0",
            "bpp",
            "&xfs_agi_buf_ops"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGI_DADDR(mp)"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGI_DADDR",
          "args": [
            "mp"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_read_agi",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_agi_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2093-2112",
    "snippet": "static void\nxfs_agi_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_agi_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGI(bp)->agi_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_AGI_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_AGI_CRC_OFF"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "bp"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_agi_verify",
          "args": [
            "bp"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agi_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2042-2073",
          "snippet": "static bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agi_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_agi_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGI(bp)->agi_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_AGI_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_agi_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2075-2091",
    "snippet": "static void\nxfs_agi_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGI_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (XFS_TEST_ERROR(!xfs_agi_verify(bp), mp,\n\t\t\t\tXFS_ERRTAG_IALLOC_READ_AGI,\n\t\t\t\tXFS_RANDOM_IALLOC_READ_AGI))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!xfs_agi_verify(bp)",
            "mp",
            "XFS_ERRTAG_IALLOC_READ_AGI",
            "XFS_RANDOM_IALLOC_READ_AGI"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_agi_verify",
          "args": [
            "bp"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agi_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2042-2073",
          "snippet": "static bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_AGI_CRC_OFF"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agi_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGI_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (XFS_TEST_ERROR(!xfs_agi_verify(bp), mp,\n\t\t\t\tXFS_ERRTAG_IALLOC_READ_AGI,\n\t\t\t\tXFS_RANDOM_IALLOC_READ_AGI))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_agi_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2042-2073",
    "snippet": "static bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_check_agi_unlinked",
          "args": [
            "agi"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_agi_unlinked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2029-2037",
          "snippet": "STATIC void\nxfs_check_agi_unlinked(\n\tstruct xfs_agi\t\t*agi)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++)\n\t\tASSERT(agi->agi_unlinked[i]);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_check_agi_unlinked(\n\tstruct xfs_agi\t\t*agi)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++)\n\t\tASSERT(agi->agi_unlinked[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_level"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGI_GOOD_VERSION",
          "args": [
            "be32_to_cpu(agi->agi_versionnum)"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_versionnum"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGI_MAGIC"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&agi->agi_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "bp"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agi_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t/*\n\t * Validate the magic number of the agi block.\n\t */\n\tif (agi->agi_magicnum != cpu_to_be32(XFS_AGI_MAGIC))\n\t\treturn false;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agi->agi_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\txfs_check_agi_unlinked(agi);\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_check_agi_unlinked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "2029-2037",
    "snippet": "STATIC void\nxfs_check_agi_unlinked(\n\tstruct xfs_agi\t\t*agi)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++)\n\t\tASSERT(agi->agi_unlinked[i]);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_unlinked[i]"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_check_agi_unlinked(\n\tstruct xfs_agi\t\t*agi)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++)\n\t\tASSERT(agi->agi_unlinked[i]);\n}"
  },
  {
    "function_name": "xfs_ialloc_log_agi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1971-2026",
    "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "first",
            "last"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_offsets",
          "args": [
            "fields",
            "offsets",
            "XFS_AGI_NUM_BITS_R2",
            "&first",
            "&last"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "663-693",
          "snippet": "void\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_AGI_BUF"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC)"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGI_MAGIC"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "bp"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
  },
  {
    "function_name": "xfs_ialloc_compute_maxlevels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1939-1957",
    "snippet": "void\nxfs_ialloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (1LL << XFS_INO_AGINO_BITS(mp)) >>\n\t\tXFS_INODES_PER_CHUNK_LOG;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_in_maxlevels = level;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_INO_AGINO_BITS",
          "args": [
            "mp"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (1LL << XFS_INO_AGINO_BITS(mp)) >>\n\t\tXFS_INODES_PER_CHUNK_LOG;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_in_maxlevels = level;\n}"
  },
  {
    "function_name": "xfs_imap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1804-1934",
    "snippet": "int\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\"",
            "__func__",
            "(unsigned long long) imap->im_blkno",
            "(unsigned long long) imap->im_len",
            "XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "offset << mp->m_sb.sb_inodelog"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "blks_per_cluster"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "cluster_agbno"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_OFFSET",
          "args": [
            "mp",
            "ino"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agbno >= chunk_agbno"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap_lookup",
          "args": [
            "mp",
            "tp",
            "agno",
            "agino",
            "agbno",
            "&chunk_agbno",
            "&offset_agbno",
            "flags"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1741-1799",
          "snippet": "STATIC int\nxfs_imap_lookup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agino_t\t\tagino,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\t*chunk_agbno,\n\txfs_agblock_t\t\t*offset_agbno,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\",\n\t\t\t__func__, error, agno);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Lookup the inode record for the given agino. If the record cannot be\n\t * found, then it's an invalid inode number and we should abort. Once\n\t * we have a record, we need to ensure it contains the inode number\n\t * we are looking up.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n\tif (!error) {\n\t\tif (i)\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (!error && i == 0)\n\t\t\terror = -EINVAL;\n\t}\n\n\txfs_trans_brelse(tp, agbp);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\tif (error)\n\t\treturn error;\n\n\t/* check that the returned record contains the required inode */\n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + mp->m_ialloc_inos <= agino)\n\t\treturn -EINVAL;\n\n\t/* for untrusted inodes check it is allocated first */\n\tif ((flags & XFS_IGET_UNTRUSTED) &&\n\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n\t\treturn -EINVAL;\n\n\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n\t*offset_agbno = agbno - *chunk_agbno;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_imap_lookup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agino_t\t\tagino,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\t*chunk_agbno,\n\txfs_agblock_t\t\t*offset_agbno,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\",\n\t\t\t__func__, error, agno);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Lookup the inode record for the given agino. If the record cannot be\n\t * found, then it's an invalid inode number and we should abort. Once\n\t * we have a record, we need to ensure it contains the inode number\n\t * we are looking up.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n\tif (!error) {\n\t\tif (i)\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (!error && i == 0)\n\t\t\terror = -EINVAL;\n\t}\n\n\txfs_trans_brelse(tp, agbp);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\tif (error)\n\t\treturn error;\n\n\t/* check that the returned record contains the required inode */\n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + mp->m_ialloc_inos <= agino)\n\t\treturn -EINVAL;\n\n\t/* for untrusted inodes check it is allocated first */\n\tif ((flags & XFS_IGET_UNTRUSTED) &&\n\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n\t\treturn -EINVAL;\n\n\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n\t*offset_agbno = agbno - *chunk_agbno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "offset << mp->m_sb.sb_inodelog"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "agbno"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset < mp->m_sb.sb_inopblock"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_OFFSET",
          "args": [
            "mp",
            "ino"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icluster_size_fsb",
          "args": [
            "mp"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icluster_size_fsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.h",
          "lines": "32-39",
          "snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_stack_trace",
          "args": [],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "agino"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ino != NULLFSINO"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_imap_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1741-1799",
    "snippet": "STATIC int\nxfs_imap_lookup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agino_t\t\tagino,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\t*chunk_agbno,\n\txfs_agblock_t\t\t*offset_agbno,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\",\n\t\t\t__func__, error, agno);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Lookup the inode record for the given agino. If the record cannot be\n\t * found, then it's an invalid inode number and we should abort. Once\n\t * we have a record, we need to ensure it contains the inode number\n\t * we are looking up.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n\tif (!error) {\n\t\tif (i)\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (!error && i == 0)\n\t\t\terror = -EINVAL;\n\t}\n\n\txfs_trans_brelse(tp, agbp);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\tif (error)\n\t\treturn error;\n\n\t/* check that the returned record contains the required inode */\n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + mp->m_ialloc_inos <= agino)\n\t\treturn -EINVAL;\n\n\t/* for untrusted inodes check it is allocated first */\n\tif ((flags & XFS_IGET_UNTRUSTED) &&\n\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n\t\treturn -EINVAL;\n\n\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n\t*offset_agbno = agbno - *chunk_agbno;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "rec.ir_startino"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "agino - rec.ir_startino"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "agbp"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "agino",
            "XFS_LOOKUP_LE",
            "&i"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\"",
            "__func__",
            "error",
            "agno"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&agbp"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_imap_lookup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agino_t\t\tagino,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\t*chunk_agbno,\n\txfs_agblock_t\t\t*offset_agbno,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\",\n\t\t\t__func__, error, agno);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Lookup the inode record for the given agino. If the record cannot be\n\t * found, then it's an invalid inode number and we should abort. Once\n\t * we have a record, we need to ensure it contains the inode number\n\t * we are looking up.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n\tif (!error) {\n\t\tif (i)\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (!error && i == 0)\n\t\t\terror = -EINVAL;\n\t}\n\n\txfs_trans_brelse(tp, agbp);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\tif (error)\n\t\treturn error;\n\n\t/* check that the returned record contains the required inode */\n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + mp->m_ialloc_inos <= agino)\n\t\treturn -EINVAL;\n\n\t/* for untrusted inodes check it is allocated first */\n\tif ((flags & XFS_IGET_UNTRUSTED) &&\n\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n\t\treturn -EINVAL;\n\n\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n\t*offset_agbno = agbno - *chunk_agbno;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_difree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1664-1739",
    "snippet": "int\nxfs_difree(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\t\tinode,\t\t/* inode to be freed */\n\tstruct xfs_bmap_free\t*flist,\t\t/* extents to free */\n\tint\t\t\t*deleted,/* set if inode cluster was deleted */\n\txfs_ino_t\t\t*first_ino)/* first inode in deleted cluster */\n{\n\t/* REFERENCED */\n\txfs_agblock_t\t\tagbno;\t/* block number containing inode */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for allocation group header */\n\txfs_agino_t\t\tagino;\t/* allocation group inode number */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_mount\t*mp;\t/* mount structure for filesystem */\n\tstruct xfs_inobt_rec_incore rec;/* btree record */\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Break up inode number into its components.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, inode);\n\tif (agno >= mp->m_sb.sb_agcount)  {\n\t\txfs_warn(mp, \"%s: agno >= mp->m_sb.sb_agcount (%d >= %d).\",\n\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagino = XFS_INO_TO_AGINO(mp, inode);\n\tif (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {\n\t\txfs_warn(mp, \"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\",\n\t\t\t__func__, (unsigned long long)inode,\n\t\t\t(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks)  {\n\t\txfs_warn(mp, \"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\",\n\t\t\t__func__, agbno, mp->m_sb.sb_agblocks);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Get the allocation group header.\n\t */\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_ialloc_read_agi() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Fix up the inode allocation btree.\n\t */\n\terror = xfs_difree_inobt(mp, tp, agbp, agino, flist, deleted, first_ino,\n\t\t\t\t &rec);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Fix up the free inode btree.\n\t */\n\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\terror = xfs_difree_finobt(mp, tp, agbp, agino, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\treturn 0;\n\nerror0:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_difree_finobt",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agino",
            "&rec"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_difree_finobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1568-1656",
          "snippet": "STATIC int\nxfs_difree_finobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_inobt_rec_incore\t*ibtrec) /* inobt record */\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\toffset = agino - ibtrec->ir_startino;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_inobt_lookup(cur, ibtrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i == 0) {\n\t\t/*\n\t\t * If the record does not exist in the finobt, we must have just\n\t\t * freed an inode in a previously fully allocated chunk. If not,\n\t\t * something is out of sync.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_GOTO(ibtrec->ir_freecount == 1, error);\n\n\t\terror = xfs_inobt_insert_rec(cur, ibtrec->ir_freecount,\n\t\t\t\t\t     ibtrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read and update the existing record. We could just copy the ibtrec\n\t * across here, but that would defeat the purpose of having redundant\n\t * metadata. By making the modifications independently, we can catch\n\t * corruptions that we wouldn't see if we just copied from one record\n\t * to another.\n\t */\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\tgoto error;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error);\n\n\trec.ir_free |= XFS_INOBT_MASK(offset);\n\trec.ir_freecount++;\n\n\tXFS_WANT_CORRUPTED_GOTO((rec.ir_free == ibtrec->ir_free) &&\n\t\t\t\t(rec.ir_freecount == ibtrec->ir_freecount),\n\t\t\t\terror);\n\n\t/*\n\t * The content of inobt records should always match between the inobt\n\t * and finobt. The lifecycle of records in the finobt is different from\n\t * the inobt in that the finobt only tracks records with at least one\n\t * free inode. Hence, if all of the inodes are free and we aren't\n\t * keeping inode chunks permanently on disk, remove the record.\n\t * Otherwise, update the record with the new information.\n\t */\n\tif (rec.ir_freecount == mp->m_ialloc_inos &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\t} else {\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\nout:\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_difree_finobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_inobt_rec_incore\t*ibtrec) /* inobt record */\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\toffset = agino - ibtrec->ir_startino;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_inobt_lookup(cur, ibtrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i == 0) {\n\t\t/*\n\t\t * If the record does not exist in the finobt, we must have just\n\t\t * freed an inode in a previously fully allocated chunk. If not,\n\t\t * something is out of sync.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_GOTO(ibtrec->ir_freecount == 1, error);\n\n\t\terror = xfs_inobt_insert_rec(cur, ibtrec->ir_freecount,\n\t\t\t\t\t     ibtrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read and update the existing record. We could just copy the ibtrec\n\t * across here, but that would defeat the purpose of having redundant\n\t * metadata. By making the modifications independently, we can catch\n\t * corruptions that we wouldn't see if we just copied from one record\n\t * to another.\n\t */\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\tgoto error;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error);\n\n\trec.ir_free |= XFS_INOBT_MASK(offset);\n\trec.ir_freecount++;\n\n\tXFS_WANT_CORRUPTED_GOTO((rec.ir_free == ibtrec->ir_free) &&\n\t\t\t\t(rec.ir_freecount == ibtrec->ir_freecount),\n\t\t\t\terror);\n\n\t/*\n\t * The content of inobt records should always match between the inobt\n\t * and finobt. The lifecycle of records in the finobt is different from\n\t * the inobt in that the finobt only tracks records with at least one\n\t * free inode. Hence, if all of the inodes are free and we aren't\n\t * keeping inode chunks permanently on disk, remove the record.\n\t * Otherwise, update the record with the new information.\n\t */\n\tif (rec.ir_freecount == mp->m_ialloc_inos &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\t} else {\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\nout:\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasfinobt",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_difree_inobt",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agino",
            "flist",
            "deleted",
            "first_ino",
            "&rec"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_difree_inobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1437-1563",
          "snippet": "STATIC int\nxfs_difree_inobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_bmap_free\t\t*flist,\n\tint\t\t\t\t*deleted,\n\txfs_ino_t\t\t\t*first_ino,\n\tstruct xfs_inobt_rec_incore\t*orec)\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\tilen;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\toff;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n\tASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Look for the entry describing this inode.\n\t */\n\tif ((error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i))) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_lookup() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_get_rec() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t/*\n\t * Get the offset in the inode chunk.\n\t */\n\toff = agino - rec.ir_startino;\n\tASSERT(off >= 0 && off < XFS_INODES_PER_CHUNK);\n\tASSERT(!(rec.ir_free & XFS_INOBT_MASK(off)));\n\t/*\n\t * Mark the inode free & increment the count.\n\t */\n\trec.ir_free |= XFS_INOBT_MASK(off);\n\trec.ir_freecount++;\n\n\t/*\n\t * When an inode cluster is free, it becomes eligible for removal\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_IKEEP) &&\n\t    (rec.ir_freecount == mp->m_ialloc_inos)) {\n\n\t\t*deleted = 1;\n\t\t*first_ino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino);\n\n\t\t/*\n\t\t * Remove the inode cluster from the AGI B+Tree, adjust the\n\t\t * AGI and Superblock inode counts, and mark the disk space\n\t\t * to be freed when the transaction is committed.\n\t\t */\n\t\tilen = mp->m_ialloc_inos;\n\t\tbe32_add_cpu(&agi->agi_count, -ilen);\n\t\tbe32_add_cpu(&agi->agi_freecount, -(ilen - 1));\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_COUNT | XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount -= ilen - 1;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, -ilen);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -(ilen - 1));\n\n\t\tif ((error = xfs_btree_delete(cur, &i))) {\n\t\t\txfs_warn(mp, \"%s: xfs_btree_delete returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\txfs_bmap_add_free(XFS_AGB_TO_FSB(mp, agno,\n\t\t\t\t  XFS_AGINO_TO_AGBNO(mp, rec.ir_startino)),\n\t\t\t\t  mp->m_ialloc_blks, flist, mp);\n\t} else {\n\t\t*deleted = 0;\n\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_inobt_update returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/* \n\t\t * Change the inode free counts and log the ag/sb changes.\n\t\t */\n\t\tbe32_add_cpu(&agi->agi_freecount, 1);\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount++;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, 1);\n\t}\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t*orec = rec;\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_difree_inobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_bmap_free\t\t*flist,\n\tint\t\t\t\t*deleted,\n\txfs_ino_t\t\t\t*first_ino,\n\tstruct xfs_inobt_rec_incore\t*orec)\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\tilen;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\toff;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n\tASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Look for the entry describing this inode.\n\t */\n\tif ((error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i))) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_lookup() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_get_rec() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t/*\n\t * Get the offset in the inode chunk.\n\t */\n\toff = agino - rec.ir_startino;\n\tASSERT(off >= 0 && off < XFS_INODES_PER_CHUNK);\n\tASSERT(!(rec.ir_free & XFS_INOBT_MASK(off)));\n\t/*\n\t * Mark the inode free & increment the count.\n\t */\n\trec.ir_free |= XFS_INOBT_MASK(off);\n\trec.ir_freecount++;\n\n\t/*\n\t * When an inode cluster is free, it becomes eligible for removal\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_IKEEP) &&\n\t    (rec.ir_freecount == mp->m_ialloc_inos)) {\n\n\t\t*deleted = 1;\n\t\t*first_ino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino);\n\n\t\t/*\n\t\t * Remove the inode cluster from the AGI B+Tree, adjust the\n\t\t * AGI and Superblock inode counts, and mark the disk space\n\t\t * to be freed when the transaction is committed.\n\t\t */\n\t\tilen = mp->m_ialloc_inos;\n\t\tbe32_add_cpu(&agi->agi_count, -ilen);\n\t\tbe32_add_cpu(&agi->agi_freecount, -(ilen - 1));\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_COUNT | XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount -= ilen - 1;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, -ilen);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -(ilen - 1));\n\n\t\tif ((error = xfs_btree_delete(cur, &i))) {\n\t\t\txfs_warn(mp, \"%s: xfs_btree_delete returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\txfs_bmap_add_free(XFS_AGB_TO_FSB(mp, agno,\n\t\t\t\t  XFS_AGINO_TO_AGBNO(mp, rec.ir_startino)),\n\t\t\t\t  mp->m_ialloc_blks, flist, mp);\n\t} else {\n\t\t*deleted = 0;\n\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_inobt_update returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/* \n\t\t * Change the inode free counts and log the ag/sb changes.\n\t\t */\n\t\tbe32_add_cpu(&agi->agi_freecount, 1);\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount++;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, 1);\n\t}\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t*orec = rec;\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_ialloc_read_agi() returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&agbp"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\"",
            "__func__",
            "agbno",
            "mp->m_sb.sb_agblocks"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "agino"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\"",
            "__func__",
            "(unsigned long long)inode",
            "(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino)"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "inode"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: agno >= mp->m_sb.sb_agcount (%d >= %d).\"",
            "__func__",
            "agno",
            "mp->m_sb.sb_agcount"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "inode"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_difree(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\t\tinode,\t\t/* inode to be freed */\n\tstruct xfs_bmap_free\t*flist,\t\t/* extents to free */\n\tint\t\t\t*deleted,/* set if inode cluster was deleted */\n\txfs_ino_t\t\t*first_ino)/* first inode in deleted cluster */\n{\n\t/* REFERENCED */\n\txfs_agblock_t\t\tagbno;\t/* block number containing inode */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for allocation group header */\n\txfs_agino_t\t\tagino;\t/* allocation group inode number */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_mount\t*mp;\t/* mount structure for filesystem */\n\tstruct xfs_inobt_rec_incore rec;/* btree record */\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Break up inode number into its components.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, inode);\n\tif (agno >= mp->m_sb.sb_agcount)  {\n\t\txfs_warn(mp, \"%s: agno >= mp->m_sb.sb_agcount (%d >= %d).\",\n\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagino = XFS_INO_TO_AGINO(mp, inode);\n\tif (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {\n\t\txfs_warn(mp, \"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\",\n\t\t\t__func__, (unsigned long long)inode,\n\t\t\t(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks)  {\n\t\txfs_warn(mp, \"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\",\n\t\t\t__func__, agbno, mp->m_sb.sb_agblocks);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Get the allocation group header.\n\t */\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_ialloc_read_agi() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Fix up the inode allocation btree.\n\t */\n\terror = xfs_difree_inobt(mp, tp, agbp, agino, flist, deleted, first_ino,\n\t\t\t\t &rec);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Fix up the free inode btree.\n\t */\n\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\terror = xfs_difree_finobt(mp, tp, agbp, agino, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\treturn 0;\n\nerror0:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_difree_finobt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1568-1656",
    "snippet": "STATIC int\nxfs_difree_finobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_inobt_rec_incore\t*ibtrec) /* inobt record */\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\toffset = agino - ibtrec->ir_startino;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_inobt_lookup(cur, ibtrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i == 0) {\n\t\t/*\n\t\t * If the record does not exist in the finobt, we must have just\n\t\t * freed an inode in a previously fully allocated chunk. If not,\n\t\t * something is out of sync.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_GOTO(ibtrec->ir_freecount == 1, error);\n\n\t\terror = xfs_inobt_insert_rec(cur, ibtrec->ir_freecount,\n\t\t\t\t\t     ibtrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read and update the existing record. We could just copy the ibtrec\n\t * across here, but that would defeat the purpose of having redundant\n\t * metadata. By making the modifications independently, we can catch\n\t * corruptions that we wouldn't see if we just copied from one record\n\t * to another.\n\t */\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\tgoto error;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error);\n\n\trec.ir_free |= XFS_INOBT_MASK(offset);\n\trec.ir_freecount++;\n\n\tXFS_WANT_CORRUPTED_GOTO((rec.ir_free == ibtrec->ir_free) &&\n\t\t\t\t(rec.ir_freecount == ibtrec->ir_freecount),\n\t\t\t\terror);\n\n\t/*\n\t * The content of inobt records should always match between the inobt\n\t * and finobt. The lifecycle of records in the finobt is different from\n\t * the inobt in that the finobt only tracks records with at least one\n\t * free inode. Hence, if all of the inodes are free and we aren't\n\t * keeping inode chunks permanently on disk, remove the record.\n\t * Otherwise, update the record with the new information.\n\t */\n\tif (rec.ir_freecount == mp->m_ialloc_inos &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\t} else {\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\nout:\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_check_agi_freecount",
          "args": [
            "cur",
            "agi"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_agi_freecount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "175-207",
          "snippet": "STATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "77-88",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 1"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "(rec.ir_free == ibtrec->ir_free) &&\n\t\t\t\t(rec.ir_freecount == ibtrec->ir_freecount)",
            "error"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "offset"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 1"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_insert_rec",
          "args": [
            "cur",
            "ibtrec->ir_freecount",
            "ibtrec->ir_free",
            "&i"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_insert_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "114-124",
          "snippet": "STATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "ibtrec->ir_freecount == 1",
            "error"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "ibtrec->ir_startino",
            "XFS_LOOKUP_EQ",
            "&i"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_FINO"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_difree_finobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_inobt_rec_incore\t*ibtrec) /* inobt record */\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\toffset = agino - ibtrec->ir_startino;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_inobt_lookup(cur, ibtrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i == 0) {\n\t\t/*\n\t\t * If the record does not exist in the finobt, we must have just\n\t\t * freed an inode in a previously fully allocated chunk. If not,\n\t\t * something is out of sync.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_GOTO(ibtrec->ir_freecount == 1, error);\n\n\t\terror = xfs_inobt_insert_rec(cur, ibtrec->ir_freecount,\n\t\t\t\t\t     ibtrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read and update the existing record. We could just copy the ibtrec\n\t * across here, but that would defeat the purpose of having redundant\n\t * metadata. By making the modifications independently, we can catch\n\t * corruptions that we wouldn't see if we just copied from one record\n\t * to another.\n\t */\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\tgoto error;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error);\n\n\trec.ir_free |= XFS_INOBT_MASK(offset);\n\trec.ir_freecount++;\n\n\tXFS_WANT_CORRUPTED_GOTO((rec.ir_free == ibtrec->ir_free) &&\n\t\t\t\t(rec.ir_freecount == ibtrec->ir_freecount),\n\t\t\t\terror);\n\n\t/*\n\t * The content of inobt records should always match between the inobt\n\t * and finobt. The lifecycle of records in the finobt is different from\n\t * the inobt in that the finobt only tracks records with at least one\n\t * free inode. Hence, if all of the inodes are free and we aren't\n\t * keeping inode chunks permanently on disk, remove the record.\n\t * Otherwise, update the record with the new information.\n\t */\n\tif (rec.ir_freecount == mp->m_ialloc_inos &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\t} else {\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\nout:\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_difree_inobt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1437-1563",
    "snippet": "STATIC int\nxfs_difree_inobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_bmap_free\t\t*flist,\n\tint\t\t\t\t*deleted,\n\txfs_ino_t\t\t\t*first_ino,\n\tstruct xfs_inobt_rec_incore\t*orec)\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\tilen;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\toff;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n\tASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Look for the entry describing this inode.\n\t */\n\tif ((error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i))) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_lookup() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_get_rec() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t/*\n\t * Get the offset in the inode chunk.\n\t */\n\toff = agino - rec.ir_startino;\n\tASSERT(off >= 0 && off < XFS_INODES_PER_CHUNK);\n\tASSERT(!(rec.ir_free & XFS_INOBT_MASK(off)));\n\t/*\n\t * Mark the inode free & increment the count.\n\t */\n\trec.ir_free |= XFS_INOBT_MASK(off);\n\trec.ir_freecount++;\n\n\t/*\n\t * When an inode cluster is free, it becomes eligible for removal\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_IKEEP) &&\n\t    (rec.ir_freecount == mp->m_ialloc_inos)) {\n\n\t\t*deleted = 1;\n\t\t*first_ino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino);\n\n\t\t/*\n\t\t * Remove the inode cluster from the AGI B+Tree, adjust the\n\t\t * AGI and Superblock inode counts, and mark the disk space\n\t\t * to be freed when the transaction is committed.\n\t\t */\n\t\tilen = mp->m_ialloc_inos;\n\t\tbe32_add_cpu(&agi->agi_count, -ilen);\n\t\tbe32_add_cpu(&agi->agi_freecount, -(ilen - 1));\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_COUNT | XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount -= ilen - 1;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, -ilen);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -(ilen - 1));\n\n\t\tif ((error = xfs_btree_delete(cur, &i))) {\n\t\t\txfs_warn(mp, \"%s: xfs_btree_delete returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\txfs_bmap_add_free(XFS_AGB_TO_FSB(mp, agno,\n\t\t\t\t  XFS_AGINO_TO_AGBNO(mp, rec.ir_startino)),\n\t\t\t\t  mp->m_ialloc_blks, flist, mp);\n\t} else {\n\t\t*deleted = 0;\n\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_inobt_update returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/* \n\t\t * Change the inode free counts and log the ag/sb changes.\n\t\t */\n\t\tbe32_add_cpu(&agi->agi_freecount, 1);\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount++;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, 1);\n\t}\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t*orec = rec;\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_check_agi_freecount",
          "args": [
            "cur",
            "agi"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_agi_freecount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "175-207",
          "snippet": "STATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_IFREE",
            "1"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "tp",
            "agbp",
            "XFS_AGI_FREECOUNT"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_freecount",
            "1"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_inobt_update returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "77-88",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_free",
          "args": [
            "XFS_AGB_TO_FSB(mp, agno,\n\t\t\t\t  XFS_AGINO_TO_AGBNO(mp, rec.ir_startino))",
            "mp->m_ialloc_blks",
            "flist",
            "mp"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "594-635",
          "snippet": "void\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "agno",
            "XFS_AGINO_TO_AGBNO(mp, rec.ir_startino)"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "rec.ir_startino"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_btree_delete returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_freecount",
            "-(ilen - 1)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_count",
            "-ilen"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "rec.ir_startino"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "off"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(rec.ir_free & XFS_INOBT_MASK(off))"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "off"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "off >= 0 && off < XFS_INODES_PER_CHUNK"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_inobt_get_rec() returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_inobt_lookup() returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "agino",
            "XFS_LOOKUP_LE",
            "&i"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_length"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "agino"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC)"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGI_MAGIC"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_difree_inobt(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_bmap_free\t\t*flist,\n\tint\t\t\t\t*deleted,\n\txfs_ino_t\t\t\t*first_ino,\n\tstruct xfs_inobt_rec_incore\t*orec)\n{\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\tilen;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\toff;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n\tASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Look for the entry describing this inode.\n\t */\n\tif ((error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i))) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_lookup() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_get_rec() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t/*\n\t * Get the offset in the inode chunk.\n\t */\n\toff = agino - rec.ir_startino;\n\tASSERT(off >= 0 && off < XFS_INODES_PER_CHUNK);\n\tASSERT(!(rec.ir_free & XFS_INOBT_MASK(off)));\n\t/*\n\t * Mark the inode free & increment the count.\n\t */\n\trec.ir_free |= XFS_INOBT_MASK(off);\n\trec.ir_freecount++;\n\n\t/*\n\t * When an inode cluster is free, it becomes eligible for removal\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_IKEEP) &&\n\t    (rec.ir_freecount == mp->m_ialloc_inos)) {\n\n\t\t*deleted = 1;\n\t\t*first_ino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino);\n\n\t\t/*\n\t\t * Remove the inode cluster from the AGI B+Tree, adjust the\n\t\t * AGI and Superblock inode counts, and mark the disk space\n\t\t * to be freed when the transaction is committed.\n\t\t */\n\t\tilen = mp->m_ialloc_inos;\n\t\tbe32_add_cpu(&agi->agi_count, -ilen);\n\t\tbe32_add_cpu(&agi->agi_freecount, -(ilen - 1));\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_COUNT | XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount -= ilen - 1;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, -ilen);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -(ilen - 1));\n\n\t\tif ((error = xfs_btree_delete(cur, &i))) {\n\t\t\txfs_warn(mp, \"%s: xfs_btree_delete returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\txfs_bmap_add_free(XFS_AGB_TO_FSB(mp, agno,\n\t\t\t\t  XFS_AGINO_TO_AGBNO(mp, rec.ir_startino)),\n\t\t\t\t  mp->m_ialloc_blks, flist, mp);\n\t} else {\n\t\t*deleted = 0;\n\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_inobt_update returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/* \n\t\t * Change the inode free counts and log the ag/sb changes.\n\t\t */\n\t\tbe32_add_cpu(&agi->agi_freecount, 1);\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tpag->pagi_freecount++;\n\t\txfs_perag_put(pag);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, 1);\n\t}\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t*orec = rec;\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dialloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1299-1435",
    "snippet": "int\nxfs_dialloc(\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tparent,\n\tumode_t\t\t\tmode,\n\tint\t\t\tokalloc,\n\tstruct xfs_buf\t\t**IO_agbp,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*agbp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\tint\t\t\tialloced;\n\tint\t\t\tnoroom = 0;\n\txfs_agnumber_t\t\tstart_agno;\n\tstruct xfs_perag\t*pag;\n\n\tif (*IO_agbp) {\n\t\t/*\n\t\t * If the caller passes in a pointer to the AGI buffer,\n\t\t * continue where we left off before.  In this case, we\n\t\t * know that the allocation group has free inodes.\n\t\t */\n\t\tagbp = *IO_agbp;\n\t\tgoto out_alloc;\n\t}\n\n\t/*\n\t * We do not have an agbp, so select an initial allocation\n\t * group for inode allocation.\n\t */\n\tstart_agno = xfs_ialloc_ag_select(tp, parent, mode, okalloc);\n\tif (start_agno == NULLAGNUMBER) {\n\t\t*inop = NULLFSINO;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we have already hit the ceiling of inode blocks then clear\n\t * okalloc so we scan all available agi structures for a free\n\t * inode.\n\t */\n\tif (mp->m_maxicount &&\n\t    mp->m_sb.sb_icount + mp->m_ialloc_inos > mp->m_maxicount) {\n\t\tnoroom = 1;\n\t\tokalloc = 0;\n\t}\n\n\t/*\n\t * Loop until we find an allocation group that either has free inodes\n\t * or in which we can allocate some inodes.  Iterate through the\n\t * allocation groups upward, wrapping at the end.\n\t */\n\tagno = start_agno;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/*\n\t\t * Do a first racy fast path check if this AG is usable.\n\t\t */\n\t\tif (!pag->pagi_freecount && !okalloc)\n\t\t\tgoto nextag;\n\n\t\t/*\n\t\t * Then read in the AGI buffer and recheck with the AGI buffer\n\t\t * lock held.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\tgoto out_alloc;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag_relse_buffer;\n\n\n\t\terror = xfs_ialloc_ag_alloc(tp, agbp, &ialloced);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\n\t\t\tif (error != -ENOSPC)\n\t\t\t\tgoto out_error;\n\n\t\t\txfs_perag_put(pag);\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ialloced) {\n\t\t\t/*\n\t\t\t * We successfully allocated some inodes, return\n\t\t\t * the current context to the caller so that it\n\t\t\t * can commit the current transaction and call\n\t\t\t * us again where we left off.\n\t\t\t */\n\t\t\tASSERT(pag->pagi_freecount > 0);\n\t\t\txfs_perag_put(pag);\n\n\t\t\t*IO_agbp = agbp;\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\nnextag_relse_buffer:\n\t\txfs_trans_brelse(tp, agbp);\nnextag:\n\t\txfs_perag_put(pag);\n\t\tif (++agno == mp->m_sb.sb_agcount)\n\t\t\tagno = 0;\n\t\tif (agno == start_agno) {\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn noroom ? -ENOSPC : 0;\n\t\t}\n\t}\n\nout_alloc:\n\t*IO_agbp = NULL;\n\treturn xfs_dialloc_ag(tp, agbp, parent, inop);\nout_error:\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dialloc_ag",
          "args": [
            "tp",
            "agbp",
            "parent",
            "inop"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1161-1276",
          "snippet": "STATIC int\nxfs_dialloc_ag(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\t/* finobt cursor */\n\tstruct xfs_btree_cur\t\t*icur;\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\tif (!xfs_sb_version_hasfinobt(&mp->m_sb))\n\t\treturn xfs_dialloc_ag_inobt(tp, agbp, parent, inop);\n\n\tpag = xfs_perag_get(mp, agno);\n\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The search algorithm depends on whether we're in the same AG as the\n\t * parent. If so, find the closest available inode to the parent. If\n\t * not, consider the agi hint or find the first free inode in the AG.\n\t */\n\tif (agno == pagno)\n\t\terror = xfs_dialloc_ag_finobt_near(pagino, &cur, &rec);\n\telse\n\t\terror = xfs_dialloc_ag_finobt_newino(agi, cur, &rec);\n\tif (error)\n\t\tgoto error_cur;\n\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\n\t/*\n\t * Modify or remove the finobt record.\n\t */\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\tif (rec.ir_freecount)\n\t\terror = xfs_inobt_update(cur, &rec);\n\telse\n\t\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The finobt has now been updated appropriately. We haven't updated the\n\t * agi and superblock yet, so we can create an inobt cursor and validate\n\t * the original freecount. If all is well, make the equivalent update to\n\t * the inobt using the finobt record and offset information.\n\t */\n\ticur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\terror = xfs_dialloc_ag_update_inobt(icur, &rec, offset);\n\tif (error)\n\t\tgoto error_icur;\n\n\t/*\n\t * Both trees have now been updated. We must update the perag and\n\t * superblock before we can check the freecount for each btree.\n\t */\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\txfs_btree_del_cursor(icur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\n\nerror_icur:\n\txfs_btree_del_cursor(icur, XFS_BTREE_ERROR);\nerror_cur:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\t/* finobt cursor */\n\tstruct xfs_btree_cur\t\t*icur;\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\tif (!xfs_sb_version_hasfinobt(&mp->m_sb))\n\t\treturn xfs_dialloc_ag_inobt(tp, agbp, parent, inop);\n\n\tpag = xfs_perag_get(mp, agno);\n\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The search algorithm depends on whether we're in the same AG as the\n\t * parent. If so, find the closest available inode to the parent. If\n\t * not, consider the agi hint or find the first free inode in the AG.\n\t */\n\tif (agno == pagno)\n\t\terror = xfs_dialloc_ag_finobt_near(pagino, &cur, &rec);\n\telse\n\t\terror = xfs_dialloc_ag_finobt_newino(agi, cur, &rec);\n\tif (error)\n\t\tgoto error_cur;\n\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\n\t/*\n\t * Modify or remove the finobt record.\n\t */\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\tif (rec.ir_freecount)\n\t\terror = xfs_inobt_update(cur, &rec);\n\telse\n\t\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The finobt has now been updated appropriately. We haven't updated the\n\t * agi and superblock yet, so we can create an inobt cursor and validate\n\t * the original freecount. If all is well, make the equivalent update to\n\t * the inobt using the finobt record and offset information.\n\t */\n\ticur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\terror = xfs_dialloc_ag_update_inobt(icur, &rec, offset);\n\tif (error)\n\t\tgoto error_icur;\n\n\t/*\n\t * Both trees have now been updated. We must update the perag and\n\t * superblock before we can check the freecount for each btree.\n\t */\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\txfs_btree_del_cursor(icur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\n\nerror_icur:\n\txfs_btree_del_cursor(icur, XFS_BTREE_ERROR);\nerror_cur:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "agbp"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagi_freecount > 0"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_ag_alloc",
          "args": [
            "tp",
            "agbp",
            "&ialloced"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_ag_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "353-539",
          "snippet": "STATIC int\t\t\t\t/* error code or 0 */\nxfs_ialloc_ag_alloc(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t\t/* alloc group buffer */\n\tint\t\t*alloc)\n{\n\txfs_agi_t\t*agi;\t\t/* allocation group header */\n\txfs_alloc_arg_t\targs;\t\t/* allocation argument structure */\n\txfs_agnumber_t\tagno;\n\tint\t\terror;\n\txfs_agino_t\tnewino;\t\t/* new first inode's number */\n\txfs_agino_t\tnewlen;\t\t/* new number of inodes */\n\tint\t\tisaligned = 0;\t/* inode allocation at stripe unit */\n\t\t\t\t\t/* boundary */\n\tstruct xfs_perag *pag;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * Locking will ensure that we don't have two callers in here\n\t * at one time.\n\t */\n\tnewlen = args.mp->m_ialloc_inos;\n\tif (args.mp->m_maxicount &&\n\t    args.mp->m_sb.sb_icount + newlen > args.mp->m_maxicount)\n\t\treturn -ENOSPC;\n\targs.minlen = args.maxlen = args.mp->m_ialloc_blks;\n\t/*\n\t * First try to allocate inodes contiguous with the last-allocated\n\t * chunk of inodes.  If the filesystem is striped, this will fill\n\t * an entire stripe unit with inodes.\n\t */\n\tagi = XFS_BUF_TO_AGI(agbp);\n\tnewino = be32_to_cpu(agi->agi_newino);\n\tagno = be32_to_cpu(agi->agi_seqno);\n\targs.agbno = XFS_AGINO_TO_AGBNO(args.mp, newino) +\n\t\t     args.mp->m_ialloc_blks;\n\tif (likely(newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length)))) {\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\targs.prod = 1;\n\n\t\t/*\n\t\t * We need to take into account alignment here to ensure that\n\t\t * we don't modify the free list if we fail to have an exact\n\t\t * block. If we don't have an exact match, and every oher\n\t\t * attempt allocation attempt fails, we'll end up cancelling\n\t\t * a dirty transaction and shutting down.\n\t\t *\n\t\t * For an exact allocation, alignment must be 1,\n\t\t * however we need to take cluster alignment into account when\n\t\t * fixing up the freelist. Use the minalignslop field to\n\t\t * indicate that extra blocks might be required for alignment,\n\t\t * but not to use them in the actual exact allocation.\n\t\t */\n\t\targs.alignment = 1;\n\t\targs.minalignslop = xfs_ialloc_cluster_alignment(args.mp) - 1;\n\n\t\t/* Allow space for the inode btree to split. */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * This request might have dirtied the transaction if the AG can\n\t\t * satisfy the request, but the exact block was not available.\n\t\t * If the allocation did fail, subsequent requests will relax\n\t\t * the exact agbno requirement and increase the alignment\n\t\t * instead. It is critical that the total size of the request\n\t\t * (len + alignment + slop) does not increase from this point\n\t\t * on, so reset minalignslop to ensure it is not included in\n\t\t * subsequent requests.\n\t\t */\n\t\targs.minalignslop = 0;\n\t} else\n\t\targs.fsbno = NULLFSBLOCK;\n\n\tif (unlikely(args.fsbno == NULLFSBLOCK)) {\n\t\t/*\n\t\t * Set the alignment for the allocation.\n\t\t * If stripe alignment is turned on then align at stripe unit\n\t\t * boundary.\n\t\t * If the cluster size is smaller than a filesystem block\n\t\t * then we're doing I/O for inodes in filesystem block size\n\t\t * pieces, so don't need alignment anyway.\n\t\t */\n\t\tisaligned = 0;\n\t\tif (args.mp->m_sinoalign) {\n\t\t\tASSERT(!(args.mp->m_flags & XFS_MOUNT_NOALIGN));\n\t\t\targs.alignment = args.mp->m_dalign;\n\t\t\tisaligned = 1;\n\t\t} else\n\t\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\t/*\n\t\t * Need to figure out where to allocate the inode blocks.\n\t\t * Ideally they should be spaced out through the a.g.\n\t\t * For now, just allocate blocks up front.\n\t\t */\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\t/*\n\t\t * Allocate a fixed-size extent of inodes.\n\t\t */\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.prod = 1;\n\t\t/*\n\t\t * Allow space for the inode btree to split.\n\t\t */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If stripe alignment is turned on, then try again with cluster\n\t * alignment.\n\t */\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\t*alloc = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == args.minlen);\n\n\t/*\n\t * Stamp and write the inode buffers.\n\t *\n\t * Seed the new inode cluster with a random generation number. This\n\t * prevents short-term reuse of generation numbers if a chunk is\n\t * freed and then immediately reallocated. We use random numbers\n\t * rather than a linear progression to prevent the next generation\n\t * number from being easily guessable.\n\t */\n\terror = xfs_ialloc_inode_init(args.mp, tp, NULL, agno, args.agbno,\n\t\t\targs.len, prandom_u32());\n\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Convert the results.\n\t */\n\tnewino = XFS_OFFBNO_TO_AGINO(args.mp, args.agbno, 0);\n\tbe32_add_cpu(&agi->agi_count, newlen);\n\tbe32_add_cpu(&agi->agi_freecount, newlen);\n\tpag = xfs_perag_get(args.mp, agno);\n\tpag->pagi_freecount += newlen;\n\txfs_perag_put(pag);\n\tagi->agi_newino = cpu_to_be32(newino);\n\n\t/*\n\t * Insert records describing the new inode chunk into the btrees.\n\t */\n\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t XFS_BTNUM_INO);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_sb_version_hasfinobt(&args.mp->m_sb)) {\n\t\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t\t XFS_BTNUM_FINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * Log allocation group header fields\n\t */\n\txfs_ialloc_log_agi(tp, agbp,\n\t\tXFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO);\n\t/*\n\t * Modify/log superblock values for inode count and inode free count.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, (long)newlen);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, (long)newlen);\n\t*alloc = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error code or 0 */\nxfs_ialloc_ag_alloc(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t\t/* alloc group buffer */\n\tint\t\t*alloc)\n{\n\txfs_agi_t\t*agi;\t\t/* allocation group header */\n\txfs_alloc_arg_t\targs;\t\t/* allocation argument structure */\n\txfs_agnumber_t\tagno;\n\tint\t\terror;\n\txfs_agino_t\tnewino;\t\t/* new first inode's number */\n\txfs_agino_t\tnewlen;\t\t/* new number of inodes */\n\tint\t\tisaligned = 0;\t/* inode allocation at stripe unit */\n\t\t\t\t\t/* boundary */\n\tstruct xfs_perag *pag;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * Locking will ensure that we don't have two callers in here\n\t * at one time.\n\t */\n\tnewlen = args.mp->m_ialloc_inos;\n\tif (args.mp->m_maxicount &&\n\t    args.mp->m_sb.sb_icount + newlen > args.mp->m_maxicount)\n\t\treturn -ENOSPC;\n\targs.minlen = args.maxlen = args.mp->m_ialloc_blks;\n\t/*\n\t * First try to allocate inodes contiguous with the last-allocated\n\t * chunk of inodes.  If the filesystem is striped, this will fill\n\t * an entire stripe unit with inodes.\n\t */\n\tagi = XFS_BUF_TO_AGI(agbp);\n\tnewino = be32_to_cpu(agi->agi_newino);\n\tagno = be32_to_cpu(agi->agi_seqno);\n\targs.agbno = XFS_AGINO_TO_AGBNO(args.mp, newino) +\n\t\t     args.mp->m_ialloc_blks;\n\tif (likely(newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length)))) {\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\targs.prod = 1;\n\n\t\t/*\n\t\t * We need to take into account alignment here to ensure that\n\t\t * we don't modify the free list if we fail to have an exact\n\t\t * block. If we don't have an exact match, and every oher\n\t\t * attempt allocation attempt fails, we'll end up cancelling\n\t\t * a dirty transaction and shutting down.\n\t\t *\n\t\t * For an exact allocation, alignment must be 1,\n\t\t * however we need to take cluster alignment into account when\n\t\t * fixing up the freelist. Use the minalignslop field to\n\t\t * indicate that extra blocks might be required for alignment,\n\t\t * but not to use them in the actual exact allocation.\n\t\t */\n\t\targs.alignment = 1;\n\t\targs.minalignslop = xfs_ialloc_cluster_alignment(args.mp) - 1;\n\n\t\t/* Allow space for the inode btree to split. */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * This request might have dirtied the transaction if the AG can\n\t\t * satisfy the request, but the exact block was not available.\n\t\t * If the allocation did fail, subsequent requests will relax\n\t\t * the exact agbno requirement and increase the alignment\n\t\t * instead. It is critical that the total size of the request\n\t\t * (len + alignment + slop) does not increase from this point\n\t\t * on, so reset minalignslop to ensure it is not included in\n\t\t * subsequent requests.\n\t\t */\n\t\targs.minalignslop = 0;\n\t} else\n\t\targs.fsbno = NULLFSBLOCK;\n\n\tif (unlikely(args.fsbno == NULLFSBLOCK)) {\n\t\t/*\n\t\t * Set the alignment for the allocation.\n\t\t * If stripe alignment is turned on then align at stripe unit\n\t\t * boundary.\n\t\t * If the cluster size is smaller than a filesystem block\n\t\t * then we're doing I/O for inodes in filesystem block size\n\t\t * pieces, so don't need alignment anyway.\n\t\t */\n\t\tisaligned = 0;\n\t\tif (args.mp->m_sinoalign) {\n\t\t\tASSERT(!(args.mp->m_flags & XFS_MOUNT_NOALIGN));\n\t\t\targs.alignment = args.mp->m_dalign;\n\t\t\tisaligned = 1;\n\t\t} else\n\t\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\t/*\n\t\t * Need to figure out where to allocate the inode blocks.\n\t\t * Ideally they should be spaced out through the a.g.\n\t\t * For now, just allocate blocks up front.\n\t\t */\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\t/*\n\t\t * Allocate a fixed-size extent of inodes.\n\t\t */\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.prod = 1;\n\t\t/*\n\t\t * Allow space for the inode btree to split.\n\t\t */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If stripe alignment is turned on, then try again with cluster\n\t * alignment.\n\t */\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\t*alloc = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == args.minlen);\n\n\t/*\n\t * Stamp and write the inode buffers.\n\t *\n\t * Seed the new inode cluster with a random generation number. This\n\t * prevents short-term reuse of generation numbers if a chunk is\n\t * freed and then immediately reallocated. We use random numbers\n\t * rather than a linear progression to prevent the next generation\n\t * number from being easily guessable.\n\t */\n\terror = xfs_ialloc_inode_init(args.mp, tp, NULL, agno, args.agbno,\n\t\t\targs.len, prandom_u32());\n\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Convert the results.\n\t */\n\tnewino = XFS_OFFBNO_TO_AGINO(args.mp, args.agbno, 0);\n\tbe32_add_cpu(&agi->agi_count, newlen);\n\tbe32_add_cpu(&agi->agi_freecount, newlen);\n\tpag = xfs_perag_get(args.mp, agno);\n\tpag->pagi_freecount += newlen;\n\txfs_perag_put(pag);\n\tagi->agi_newino = cpu_to_be32(newino);\n\n\t/*\n\t * Insert records describing the new inode chunk into the btrees.\n\t */\n\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t XFS_BTNUM_INO);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_sb_version_hasfinobt(&args.mp->m_sb)) {\n\t\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t\t XFS_BTNUM_FINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * Log allocation group header fields\n\t */\n\txfs_ialloc_log_agi(tp, agbp,\n\t\tXFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO);\n\t/*\n\t * Modify/log superblock values for inode count and inode free count.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, (long)newlen);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, (long)newlen);\n\t*alloc = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&agbp"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_pagi_init",
          "args": [
            "mp",
            "tp",
            "agno"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_pagi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2182-2197",
          "snippet": "int\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_next_ag",
          "args": [
            "mp"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_next_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "541-554",
          "snippet": "STATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_ag_select",
          "args": [
            "tp",
            "parent",
            "mode",
            "okalloc"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_ag_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "560-676",
          "snippet": "STATIC xfs_agnumber_t\nxfs_ialloc_ag_select(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\tparent,\t\t/* parent directory inode number */\n\tumode_t\t\tmode,\t\t/* bits set to indicate file type */\n\tint\t\tokalloc)\t/* ok to allocate more space */\n{\n\txfs_agnumber_t\tagcount;\t/* number of ag's in the filesystem */\n\txfs_agnumber_t\tagno;\t\t/* current ag number */\n\tint\t\tflags;\t\t/* alloc buffer locking flags */\n\txfs_extlen_t\tineed;\t\t/* blocks needed for inode allocation */\n\txfs_extlen_t\tlongest = 0;\t/* longest extent available */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tneedspace;\t/* file mode implies space allocated */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\txfs_agnumber_t\tpagno;\t\t/* parent (starting) ag number */\n\tint\t\terror;\n\n\t/*\n\t * Files of these types need at least one block if length > 0\n\t * (and they won't fit in the inode, but that's hard to figure out).\n\t */\n\tneedspace = S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode);\n\tmp = tp->t_mountp;\n\tagcount = mp->m_maxagi;\n\tif (S_ISDIR(mode))\n\t\tpagno = xfs_ialloc_next_ag(mp);\n\telse {\n\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\t\tif (pagno >= agcount)\n\t\t\tpagno = 0;\n\t}\n\n\tASSERT(pagno < agcount);\n\n\t/*\n\t * Loop through allocation groups, looking for one with a little\n\t * free space in it.  Note we don't look for free inodes, exactly.\n\t * Instead, we include whether there is a need to allocate inodes\n\t * to mean that blocks must be allocated for them,\n\t * if none are currently free.\n\t */\n\tagno = pagno;\n\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag;\n\n\t\tif (!pag->pagf_init) {\n\t\t\terror = xfs_alloc_pagf_init(mp, tp, agno, flags);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\t/*\n\t\t * Check that there is enough free space for the file plus a\n\t\t * chunk of inodes if we need to allocate some. If this is the\n\t\t * first pass across the AGs, take into account the potential\n\t\t * space needed for alignment of inode chunks when checking the\n\t\t * longest contiguous free space in the AG - this prevents us\n\t\t * from getting ENOSPC because we have free space larger than\n\t\t * m_ialloc_blks but alignment constraints prevent us from using\n\t\t * it.\n\t\t *\n\t\t * If we can't find an AG with space for full alignment slack to\n\t\t * be taken into account, we must be near ENOSPC in all AGs.\n\t\t * Hence we don't include alignment for the second pass and so\n\t\t * if we fail allocation due to alignment issues then it is most\n\t\t * likely a real ENOSPC condition.\n\t\t */\n\t\tineed = mp->m_ialloc_blks;\n\t\tif (flags && ineed > 1)\n\t\t\tineed += xfs_ialloc_cluster_alignment(mp);\n\t\tlongest = pag->pagf_longest;\n\t\tif (!longest)\n\t\t\tlongest = pag->pagf_flcount > 0;\n\n\t\tif (pag->pagf_freeblks >= needspace + ineed &&\n\t\t    longest >= ineed) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\nnextag:\n\t\txfs_perag_put(pag);\n\t\t/*\n\t\t * No point in iterating over the rest, if we're shutting\n\t\t * down.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn NULLAGNUMBER;\n\t\tagno++;\n\t\tif (agno >= agcount)\n\t\t\tagno = 0;\n\t\tif (agno == pagno) {\n\t\t\tif (flags == 0)\n\t\t\t\treturn NULLAGNUMBER;\n\t\t\tflags = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_agnumber_t\nxfs_ialloc_ag_select(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\tparent,\t\t/* parent directory inode number */\n\tumode_t\t\tmode,\t\t/* bits set to indicate file type */\n\tint\t\tokalloc)\t/* ok to allocate more space */\n{\n\txfs_agnumber_t\tagcount;\t/* number of ag's in the filesystem */\n\txfs_agnumber_t\tagno;\t\t/* current ag number */\n\tint\t\tflags;\t\t/* alloc buffer locking flags */\n\txfs_extlen_t\tineed;\t\t/* blocks needed for inode allocation */\n\txfs_extlen_t\tlongest = 0;\t/* longest extent available */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tneedspace;\t/* file mode implies space allocated */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\txfs_agnumber_t\tpagno;\t\t/* parent (starting) ag number */\n\tint\t\terror;\n\n\t/*\n\t * Files of these types need at least one block if length > 0\n\t * (and they won't fit in the inode, but that's hard to figure out).\n\t */\n\tneedspace = S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode);\n\tmp = tp->t_mountp;\n\tagcount = mp->m_maxagi;\n\tif (S_ISDIR(mode))\n\t\tpagno = xfs_ialloc_next_ag(mp);\n\telse {\n\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\t\tif (pagno >= agcount)\n\t\t\tpagno = 0;\n\t}\n\n\tASSERT(pagno < agcount);\n\n\t/*\n\t * Loop through allocation groups, looking for one with a little\n\t * free space in it.  Note we don't look for free inodes, exactly.\n\t * Instead, we include whether there is a need to allocate inodes\n\t * to mean that blocks must be allocated for them,\n\t * if none are currently free.\n\t */\n\tagno = pagno;\n\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag;\n\n\t\tif (!pag->pagf_init) {\n\t\t\terror = xfs_alloc_pagf_init(mp, tp, agno, flags);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\t/*\n\t\t * Check that there is enough free space for the file plus a\n\t\t * chunk of inodes if we need to allocate some. If this is the\n\t\t * first pass across the AGs, take into account the potential\n\t\t * space needed for alignment of inode chunks when checking the\n\t\t * longest contiguous free space in the AG - this prevents us\n\t\t * from getting ENOSPC because we have free space larger than\n\t\t * m_ialloc_blks but alignment constraints prevent us from using\n\t\t * it.\n\t\t *\n\t\t * If we can't find an AG with space for full alignment slack to\n\t\t * be taken into account, we must be near ENOSPC in all AGs.\n\t\t * Hence we don't include alignment for the second pass and so\n\t\t * if we fail allocation due to alignment issues then it is most\n\t\t * likely a real ENOSPC condition.\n\t\t */\n\t\tineed = mp->m_ialloc_blks;\n\t\tif (flags && ineed > 1)\n\t\t\tineed += xfs_ialloc_cluster_alignment(mp);\n\t\tlongest = pag->pagf_longest;\n\t\tif (!longest)\n\t\t\tlongest = pag->pagf_flcount > 0;\n\n\t\tif (pag->pagf_freeblks >= needspace + ineed &&\n\t\t    longest >= ineed) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\nnextag:\n\t\txfs_perag_put(pag);\n\t\t/*\n\t\t * No point in iterating over the rest, if we're shutting\n\t\t * down.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn NULLAGNUMBER;\n\t\tagno++;\n\t\tif (agno >= agcount)\n\t\t\tagno = 0;\n\t\tif (agno == pagno) {\n\t\t\tif (flags == 0)\n\t\t\t\treturn NULLAGNUMBER;\n\t\t\tflags = 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dialloc(\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tparent,\n\tumode_t\t\t\tmode,\n\tint\t\t\tokalloc,\n\tstruct xfs_buf\t\t**IO_agbp,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*agbp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\tint\t\t\tialloced;\n\tint\t\t\tnoroom = 0;\n\txfs_agnumber_t\t\tstart_agno;\n\tstruct xfs_perag\t*pag;\n\n\tif (*IO_agbp) {\n\t\t/*\n\t\t * If the caller passes in a pointer to the AGI buffer,\n\t\t * continue where we left off before.  In this case, we\n\t\t * know that the allocation group has free inodes.\n\t\t */\n\t\tagbp = *IO_agbp;\n\t\tgoto out_alloc;\n\t}\n\n\t/*\n\t * We do not have an agbp, so select an initial allocation\n\t * group for inode allocation.\n\t */\n\tstart_agno = xfs_ialloc_ag_select(tp, parent, mode, okalloc);\n\tif (start_agno == NULLAGNUMBER) {\n\t\t*inop = NULLFSINO;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we have already hit the ceiling of inode blocks then clear\n\t * okalloc so we scan all available agi structures for a free\n\t * inode.\n\t */\n\tif (mp->m_maxicount &&\n\t    mp->m_sb.sb_icount + mp->m_ialloc_inos > mp->m_maxicount) {\n\t\tnoroom = 1;\n\t\tokalloc = 0;\n\t}\n\n\t/*\n\t * Loop until we find an allocation group that either has free inodes\n\t * or in which we can allocate some inodes.  Iterate through the\n\t * allocation groups upward, wrapping at the end.\n\t */\n\tagno = start_agno;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/*\n\t\t * Do a first racy fast path check if this AG is usable.\n\t\t */\n\t\tif (!pag->pagi_freecount && !okalloc)\n\t\t\tgoto nextag;\n\n\t\t/*\n\t\t * Then read in the AGI buffer and recheck with the AGI buffer\n\t\t * lock held.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\tgoto out_alloc;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag_relse_buffer;\n\n\n\t\terror = xfs_ialloc_ag_alloc(tp, agbp, &ialloced);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\n\t\t\tif (error != -ENOSPC)\n\t\t\t\tgoto out_error;\n\n\t\t\txfs_perag_put(pag);\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ialloced) {\n\t\t\t/*\n\t\t\t * We successfully allocated some inodes, return\n\t\t\t * the current context to the caller so that it\n\t\t\t * can commit the current transaction and call\n\t\t\t * us again where we left off.\n\t\t\t */\n\t\t\tASSERT(pag->pagi_freecount > 0);\n\t\t\txfs_perag_put(pag);\n\n\t\t\t*IO_agbp = agbp;\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\nnextag_relse_buffer:\n\t\txfs_trans_brelse(tp, agbp);\nnextag:\n\t\txfs_perag_put(pag);\n\t\tif (++agno == mp->m_sb.sb_agcount)\n\t\t\tagno = 0;\n\t\tif (agno == start_agno) {\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn noroom ? -ENOSPC : 0;\n\t\t}\n\t}\n\nout_alloc:\n\t*IO_agbp = NULL;\n\treturn xfs_dialloc_ag(tp, agbp, parent, inop);\nout_error:\n\txfs_perag_put(pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dialloc_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1161-1276",
    "snippet": "STATIC int\nxfs_dialloc_ag(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\t/* finobt cursor */\n\tstruct xfs_btree_cur\t\t*icur;\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\tif (!xfs_sb_version_hasfinobt(&mp->m_sb))\n\t\treturn xfs_dialloc_ag_inobt(tp, agbp, parent, inop);\n\n\tpag = xfs_perag_get(mp, agno);\n\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The search algorithm depends on whether we're in the same AG as the\n\t * parent. If so, find the closest available inode to the parent. If\n\t * not, consider the agi hint or find the first free inode in the AG.\n\t */\n\tif (agno == pagno)\n\t\terror = xfs_dialloc_ag_finobt_near(pagino, &cur, &rec);\n\telse\n\t\terror = xfs_dialloc_ag_finobt_newino(agi, cur, &rec);\n\tif (error)\n\t\tgoto error_cur;\n\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\n\t/*\n\t * Modify or remove the finobt record.\n\t */\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\tif (rec.ir_freecount)\n\t\terror = xfs_inobt_update(cur, &rec);\n\telse\n\t\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The finobt has now been updated appropriately. We haven't updated the\n\t * agi and superblock yet, so we can create an inobt cursor and validate\n\t * the original freecount. If all is well, make the equivalent update to\n\t * the inobt using the finobt record and offset information.\n\t */\n\ticur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\terror = xfs_dialloc_ag_update_inobt(icur, &rec, offset);\n\tif (error)\n\t\tgoto error_icur;\n\n\t/*\n\t * Both trees have now been updated. We must update the perag and\n\t * superblock before we can check the freecount for each btree.\n\t */\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\txfs_btree_del_cursor(icur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\n\nerror_icur:\n\txfs_btree_del_cursor(icur, XFS_BTREE_ERROR);\nerror_cur:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_check_agi_freecount",
          "args": [
            "cur",
            "agi"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_agi_freecount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "175-207",
          "snippet": "STATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_IFREE",
            "-1"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "tp",
            "agbp",
            "XFS_AGI_FREECOUNT"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_freecount",
            "-1"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dialloc_ag_update_inobt",
          "args": [
            "icur",
            "&rec",
            "offset"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc_ag_update_inobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1123-1152",
          "snippet": "STATIC int\nxfs_dialloc_ag_update_inobt(\n\tstruct xfs_btree_cur\t\t*cur,\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\t*frec,\t/* finobt record */\n\tint\t\t\t\toffset) /* inode offset */\n{\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\tASSERT((XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\n\tXFS_WANT_CORRUPTED_RETURN((rec.ir_free == frec->ir_free) &&\n\t\t\t\t  (rec.ir_freecount == frec->ir_freecount));\n\n\treturn xfs_inobt_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_update_inobt(\n\tstruct xfs_btree_cur\t\t*cur,\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\t*frec,\t/* finobt record */\n\tint\t\t\t\toffset) /* inode offset */\n{\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\tASSERT((XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\n\tXFS_WANT_CORRUPTED_RETURN((rec.ir_free == frec->ir_free) &&\n\t\t\t\t  (rec.ir_freecount == frec->ir_freecount));\n\n\treturn xfs_inobt_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "77-88",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "offset"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "rec.ir_startino + offset"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_OFFSET",
          "args": [
            "mp",
            "rec.ir_startino"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset < XFS_INODES_PER_CHUNK"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset >= 0"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lowbit64",
          "args": [
            "rec.ir_free"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lowbit64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "60-76",
          "snippet": "static inline int xfs_lowbit64(__uint64_t v)\n{\n\t__uint32_t\tw = (__uint32_t)v;\n\tint\t\tn = 0;\n\n\tif (w) {\t/* lower bits */\n\t\tn = ffs(w);\n\t} else {\t/* upper bits */\n\t\tw = (__uint32_t)(v >> 32);\n\t\tif (w) {\n\t\t\tn = ffs(w);\n\t\t\tif (n)\n\t\t\t\tn += 32;\n\t\t}\n\t}\n\treturn n - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_lowbit64(__uint64_t v)\n{\n\t__uint32_t\tw = (__uint32_t)v;\n\tint\t\tn = 0;\n\n\tif (w) {\t/* lower bits */\n\t\tn = ffs(w);\n\t} else {\t/* upper bits */\n\t\tw = (__uint32_t)(v >> 32);\n\t\tif (w) {\n\t\t\tn = ffs(w);\n\t\t\tif (n)\n\t\t\t\tn += 32;\n\t\t}\n\t}\n\treturn n - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dialloc_ag_finobt_newino",
          "args": [
            "agi",
            "cur",
            "&rec"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc_ag_finobt_newino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1080-1117",
          "snippet": "STATIC int\nxfs_dialloc_ag_finobt_newino(\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint error;\n\tint i;\n\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Find the first inode available in the AG.\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_finobt_newino(\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint error;\n\tint i;\n\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Find the first inode available in the AG.\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dialloc_ag_finobt_near",
          "args": [
            "pagino",
            "&cur",
            "&rec"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc_ag_finobt_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "999-1074",
          "snippet": "STATIC int\nxfs_dialloc_ag_finobt_near(\n\txfs_agino_t\t\t\tpagino,\n\tstruct xfs_btree_cur\t\t**ocur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_btree_cur\t\t*lcur = *ocur;\t/* left search cursor */\n\tstruct xfs_btree_cur\t\t*rcur;\t/* right search cursor */\n\tstruct xfs_inobt_rec_incore\trrec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti, j;\n\n\terror = xfs_inobt_lookup(lcur, pagino, XFS_LOOKUP_LE, &i);\n\tif (error)\n\t\treturn error;\n\n\tif (i == 1) {\n\t\terror = xfs_inobt_get_rec(lcur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t\t/*\n\t\t * See if we've landed in the parent inode record. The finobt\n\t\t * only tracks chunks with at least one free inode, so record\n\t\t * existence is enough.\n\t\t */\n\t\tif (pagino >= rec->ir_startino &&\n\t\t    pagino < (rec->ir_startino + XFS_INODES_PER_CHUNK))\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_btree_dup_cursor(lcur, &rcur);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_inobt_lookup(rcur, pagino, XFS_LOOKUP_GE, &j);\n\tif (error)\n\t\tgoto error_rcur;\n\tif (j == 1) {\n\t\terror = xfs_inobt_get_rec(rcur, &rrec, &j);\n\t\tif (error)\n\t\t\tgoto error_rcur;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error_rcur);\n\t}\n\n\tXFS_WANT_CORRUPTED_GOTO(i == 1 || j == 1, error_rcur);\n\tif (i == 1 && j == 1) {\n\t\t/*\n\t\t * Both the left and right records are valid. Choose the closer\n\t\t * inode chunk to the target.\n\t\t */\n\t\tif ((pagino - rec->ir_startino + XFS_INODES_PER_CHUNK - 1) >\n\t\t    (rrec.ir_startino - pagino)) {\n\t\t\t*rec = rrec;\n\t\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t\t*ocur = rcur;\n\t\t} else {\n\t\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t\t}\n\t} else if (j == 1) {\n\t\t/* only the right record is valid */\n\t\t*rec = rrec;\n\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t*ocur = rcur;\n\t} else if (i == 1) {\n\t\t/* only the left record is valid */\n\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t}\n\n\treturn 0;\n\nerror_rcur:\n\txfs_btree_del_cursor(rcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_finobt_near(\n\txfs_agino_t\t\t\tpagino,\n\tstruct xfs_btree_cur\t\t**ocur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_btree_cur\t\t*lcur = *ocur;\t/* left search cursor */\n\tstruct xfs_btree_cur\t\t*rcur;\t/* right search cursor */\n\tstruct xfs_inobt_rec_incore\trrec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti, j;\n\n\terror = xfs_inobt_lookup(lcur, pagino, XFS_LOOKUP_LE, &i);\n\tif (error)\n\t\treturn error;\n\n\tif (i == 1) {\n\t\terror = xfs_inobt_get_rec(lcur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t\t/*\n\t\t * See if we've landed in the parent inode record. The finobt\n\t\t * only tracks chunks with at least one free inode, so record\n\t\t * existence is enough.\n\t\t */\n\t\tif (pagino >= rec->ir_startino &&\n\t\t    pagino < (rec->ir_startino + XFS_INODES_PER_CHUNK))\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_btree_dup_cursor(lcur, &rcur);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_inobt_lookup(rcur, pagino, XFS_LOOKUP_GE, &j);\n\tif (error)\n\t\tgoto error_rcur;\n\tif (j == 1) {\n\t\terror = xfs_inobt_get_rec(rcur, &rrec, &j);\n\t\tif (error)\n\t\t\tgoto error_rcur;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error_rcur);\n\t}\n\n\tXFS_WANT_CORRUPTED_GOTO(i == 1 || j == 1, error_rcur);\n\tif (i == 1 && j == 1) {\n\t\t/*\n\t\t * Both the left and right records are valid. Choose the closer\n\t\t * inode chunk to the target.\n\t\t */\n\t\tif ((pagino - rec->ir_startino + XFS_INODES_PER_CHUNK - 1) >\n\t\t    (rrec.ir_startino - pagino)) {\n\t\t\t*rec = rrec;\n\t\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t\t*ocur = rcur;\n\t\t} else {\n\t\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t\t}\n\t} else if (j == 1) {\n\t\t/* only the right record is valid */\n\t\t*rec = rrec;\n\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t*ocur = rcur;\n\t} else if (i == 1) {\n\t\t/* only the left record is valid */\n\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t}\n\n\treturn 0;\n\nerror_rcur:\n\txfs_btree_del_cursor(rcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_newino"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dialloc_ag_inobt",
          "args": [
            "tp",
            "agbp",
            "parent",
            "inop"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc_ag_inobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "736-993",
          "snippet": "STATIC int\nxfs_dialloc_ag_inobt(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_btree_cur\t*cur, *tcur;\n\tstruct xfs_inobt_rec_incore rec, trec;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\tint\t\t\toffset;\n\tint\t\t\ti, j;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\tASSERT(pag->pagi_init);\n\tASSERT(pag->pagi_inodeok);\n\tASSERT(pag->pagi_freecount > 0);\n\n restart_pagno:\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If in the same AG as the parent, try to get near the parent.\n\t */\n\tif (pagno == agno) {\n\t\tint\t\tdoneleft;\t/* done, to the left */\n\t\tint\t\tdoneright;\t/* done, to the right */\n\t\tint\t\tsearchdistance = 10;\n\n\t\terror = xfs_inobt_lookup(cur, pagino, XFS_LOOKUP_LE, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error0);\n\n\t\tif (rec.ir_freecount > 0) {\n\t\t\t/*\n\t\t\t * Found a free inode in the same chunk\n\t\t\t * as the parent, done.\n\t\t\t */\n\t\t\tgoto alloc_inode;\n\t\t}\n\n\n\t\t/*\n\t\t * In the same AG as parent, but parent's chunk is full.\n\t\t */\n\n\t\t/* duplicate the cursor, search left & right simultaneously */\n\t\terror = xfs_btree_dup_cursor(cur, &tcur);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * Skip to last blocks looked up if same parent inode.\n\t\t */\n\t\tif (pagino != NULLAGINO &&\n\t\t    pag->pagl_pagino == pagino &&\n\t\t    pag->pagl_leftrec != NULLAGINO &&\n\t\t    pag->pagl_rightrec != NULLAGINO) {\n\t\t\terror = xfs_ialloc_get_rec(tcur, pag->pagl_leftrec,\n\t\t\t\t\t\t   &trec, &doneleft);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\terror = xfs_ialloc_get_rec(cur, pag->pagl_rightrec,\n\t\t\t\t\t\t   &rec, &doneright);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t} else {\n\t\t\t/* search left with tcur, back up 1 record */\n\t\t\terror = xfs_ialloc_next_rec(tcur, &trec, &doneleft, 1);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\t/* search right with cur, go forward 1 record. */\n\t\t\terror = xfs_ialloc_next_rec(cur, &rec, &doneright, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * Loop until we find an inode chunk with a free inode.\n\t\t */\n\t\twhile (!doneleft || !doneright) {\n\t\t\tint\tuseleft;  /* using left inode chunk this time */\n\n\t\t\tif (!--searchdistance) {\n\t\t\t\t/*\n\t\t\t\t * Not in range - save last search\n\t\t\t\t * location and allocate a new inode\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto newino;\n\t\t\t}\n\n\t\t\t/* figure out the closer block if both are valid. */\n\t\t\tif (!doneleft && !doneright) {\n\t\t\t\tuseleft = pagino -\n\t\t\t\t (trec.ir_startino + XFS_INODES_PER_CHUNK - 1) <\n\t\t\t\t  rec.ir_startino - pagino;\n\t\t\t} else {\n\t\t\t\tuseleft = !doneleft;\n\t\t\t}\n\n\t\t\t/* free inodes to the left? */\n\t\t\tif (useleft && trec.ir_freecount) {\n\t\t\t\trec = trec;\n\t\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\t\tcur = tcur;\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* free inodes to the right? */\n\t\t\tif (!useleft && rec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* get next record to check */\n\t\t\tif (useleft) {\n\t\t\t\terror = xfs_ialloc_next_rec(tcur, &trec,\n\t\t\t\t\t\t\t\t &doneleft, 1);\n\t\t\t} else {\n\t\t\t\terror = xfs_ialloc_next_rec(cur, &rec,\n\t\t\t\t\t\t\t\t &doneright, 0);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * We've reached the end of the btree. because\n\t\t * we are only searching a small chunk of the\n\t\t * btree each search, there is obviously free\n\t\t * inodes closer to the parent inode than we\n\t\t * are now. restart the search again.\n\t\t */\n\t\tpag->pagl_pagino = NULLAGINO;\n\t\tpag->pagl_leftrec = NULLAGINO;\n\t\tpag->pagl_rightrec = NULLAGINO;\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\tgoto restart_pagno;\n\t}\n\n\t/*\n\t * In a different AG from the parent.\n\t * See if the most recently allocated block has any free.\n\t */\nnewino:\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\tif (j == 1 && rec.ir_freecount > 0) {\n\t\t\t\t/*\n\t\t\t\t * The last chunk allocated in the group\n\t\t\t\t * still has a free inode.\n\t\t\t\t */\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * None left in the last group, search the whole AG\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\tfor (;;) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif (rec.ir_freecount > 0)\n\t\t\tbreak;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\nalloc_inode:\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\terror = xfs_inobt_update(cur, &rec);\n\tif (error)\n\t\tgoto error0;\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\nerror1:\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_inobt(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_btree_cur\t*cur, *tcur;\n\tstruct xfs_inobt_rec_incore rec, trec;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\tint\t\t\toffset;\n\tint\t\t\ti, j;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\tASSERT(pag->pagi_init);\n\tASSERT(pag->pagi_inodeok);\n\tASSERT(pag->pagi_freecount > 0);\n\n restart_pagno:\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If in the same AG as the parent, try to get near the parent.\n\t */\n\tif (pagno == agno) {\n\t\tint\t\tdoneleft;\t/* done, to the left */\n\t\tint\t\tdoneright;\t/* done, to the right */\n\t\tint\t\tsearchdistance = 10;\n\n\t\terror = xfs_inobt_lookup(cur, pagino, XFS_LOOKUP_LE, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error0);\n\n\t\tif (rec.ir_freecount > 0) {\n\t\t\t/*\n\t\t\t * Found a free inode in the same chunk\n\t\t\t * as the parent, done.\n\t\t\t */\n\t\t\tgoto alloc_inode;\n\t\t}\n\n\n\t\t/*\n\t\t * In the same AG as parent, but parent's chunk is full.\n\t\t */\n\n\t\t/* duplicate the cursor, search left & right simultaneously */\n\t\terror = xfs_btree_dup_cursor(cur, &tcur);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * Skip to last blocks looked up if same parent inode.\n\t\t */\n\t\tif (pagino != NULLAGINO &&\n\t\t    pag->pagl_pagino == pagino &&\n\t\t    pag->pagl_leftrec != NULLAGINO &&\n\t\t    pag->pagl_rightrec != NULLAGINO) {\n\t\t\terror = xfs_ialloc_get_rec(tcur, pag->pagl_leftrec,\n\t\t\t\t\t\t   &trec, &doneleft);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\terror = xfs_ialloc_get_rec(cur, pag->pagl_rightrec,\n\t\t\t\t\t\t   &rec, &doneright);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t} else {\n\t\t\t/* search left with tcur, back up 1 record */\n\t\t\terror = xfs_ialloc_next_rec(tcur, &trec, &doneleft, 1);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\t/* search right with cur, go forward 1 record. */\n\t\t\terror = xfs_ialloc_next_rec(cur, &rec, &doneright, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * Loop until we find an inode chunk with a free inode.\n\t\t */\n\t\twhile (!doneleft || !doneright) {\n\t\t\tint\tuseleft;  /* using left inode chunk this time */\n\n\t\t\tif (!--searchdistance) {\n\t\t\t\t/*\n\t\t\t\t * Not in range - save last search\n\t\t\t\t * location and allocate a new inode\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto newino;\n\t\t\t}\n\n\t\t\t/* figure out the closer block if both are valid. */\n\t\t\tif (!doneleft && !doneright) {\n\t\t\t\tuseleft = pagino -\n\t\t\t\t (trec.ir_startino + XFS_INODES_PER_CHUNK - 1) <\n\t\t\t\t  rec.ir_startino - pagino;\n\t\t\t} else {\n\t\t\t\tuseleft = !doneleft;\n\t\t\t}\n\n\t\t\t/* free inodes to the left? */\n\t\t\tif (useleft && trec.ir_freecount) {\n\t\t\t\trec = trec;\n\t\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\t\tcur = tcur;\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* free inodes to the right? */\n\t\t\tif (!useleft && rec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* get next record to check */\n\t\t\tif (useleft) {\n\t\t\t\terror = xfs_ialloc_next_rec(tcur, &trec,\n\t\t\t\t\t\t\t\t &doneleft, 1);\n\t\t\t} else {\n\t\t\t\terror = xfs_ialloc_next_rec(cur, &rec,\n\t\t\t\t\t\t\t\t &doneright, 0);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * We've reached the end of the btree. because\n\t\t * we are only searching a small chunk of the\n\t\t * btree each search, there is obviously free\n\t\t * inodes closer to the parent inode than we\n\t\t * are now. restart the search again.\n\t\t */\n\t\tpag->pagl_pagino = NULLAGINO;\n\t\tpag->pagl_leftrec = NULLAGINO;\n\t\tpag->pagl_rightrec = NULLAGINO;\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\tgoto restart_pagno;\n\t}\n\n\t/*\n\t * In a different AG from the parent.\n\t * See if the most recently allocated block has any free.\n\t */\nnewino:\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\tif (j == 1 && rec.ir_freecount > 0) {\n\t\t\t\t/*\n\t\t\t\t * The last chunk allocated in the group\n\t\t\t\t * still has a free inode.\n\t\t\t\t */\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * None left in the last group, search the whole AG\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\tfor (;;) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif (rec.ir_freecount > 0)\n\t\t\tbreak;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\nalloc_inode:\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\terror = xfs_inobt_update(cur, &rec);\n\tif (error)\n\t\tgoto error0;\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\nerror1:\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasfinobt",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "parent"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "parent"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*cur;\t/* finobt cursor */\n\tstruct xfs_btree_cur\t\t*icur;\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\tif (!xfs_sb_version_hasfinobt(&mp->m_sb))\n\t\treturn xfs_dialloc_ag_inobt(tp, agbp, parent, inop);\n\n\tpag = xfs_perag_get(mp, agno);\n\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_FINO);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The search algorithm depends on whether we're in the same AG as the\n\t * parent. If so, find the closest available inode to the parent. If\n\t * not, consider the agi hint or find the first free inode in the AG.\n\t */\n\tif (agno == pagno)\n\t\terror = xfs_dialloc_ag_finobt_near(pagino, &cur, &rec);\n\telse\n\t\terror = xfs_dialloc_ag_finobt_newino(agi, cur, &rec);\n\tif (error)\n\t\tgoto error_cur;\n\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\n\t/*\n\t * Modify or remove the finobt record.\n\t */\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\tif (rec.ir_freecount)\n\t\terror = xfs_inobt_update(cur, &rec);\n\telse\n\t\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\tgoto error_cur;\n\n\t/*\n\t * The finobt has now been updated appropriately. We haven't updated the\n\t * agi and superblock yet, so we can create an inobt cursor and validate\n\t * the original freecount. If all is well, make the equivalent update to\n\t * the inobt using the finobt record and offset information.\n\t */\n\ticur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\terror = xfs_dialloc_ag_update_inobt(icur, &rec, offset);\n\tif (error)\n\t\tgoto error_icur;\n\n\t/*\n\t * Both trees have now been updated. We must update the perag and\n\t * superblock before we can check the freecount for each btree.\n\t */\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\n\terror = xfs_check_agi_freecount(icur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error_icur;\n\n\txfs_btree_del_cursor(icur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\n\nerror_icur:\n\txfs_btree_del_cursor(icur, XFS_BTREE_ERROR);\nerror_cur:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dialloc_ag_update_inobt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1123-1152",
    "snippet": "STATIC int\nxfs_dialloc_ag_update_inobt(\n\tstruct xfs_btree_cur\t\t*cur,\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\t*frec,\t/* finobt record */\n\tint\t\t\t\toffset) /* inode offset */\n{\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\tASSERT((XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\n\tXFS_WANT_CORRUPTED_RETURN((rec.ir_free == frec->ir_free) &&\n\t\t\t\t  (rec.ir_freecount == frec->ir_freecount));\n\n\treturn xfs_inobt_update(cur, &rec);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inobt_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "77-88",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "(rec.ir_free == frec->ir_free) &&\n\t\t\t\t  (rec.ir_freecount == frec->ir_freecount)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "offset"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_OFFSET",
          "args": [
            "cur->bc_mp",
            "rec.ir_startino"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "frec->ir_startino",
            "XFS_LOOKUP_EQ",
            "&i"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_update_inobt(\n\tstruct xfs_btree_cur\t\t*cur,\t/* inobt cursor */\n\tstruct xfs_inobt_rec_incore\t*frec,\t/* finobt record */\n\tint\t\t\t\toffset) /* inode offset */\n{\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\tASSERT((XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\n\tXFS_WANT_CORRUPTED_RETURN((rec.ir_free == frec->ir_free) &&\n\t\t\t\t  (rec.ir_freecount == frec->ir_freecount));\n\n\treturn xfs_inobt_update(cur, &rec);\n}"
  },
  {
    "function_name": "xfs_dialloc_ag_finobt_newino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "1080-1117",
    "snippet": "STATIC int\nxfs_dialloc_ag_finobt_newino(\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint error;\n\tint i;\n\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Find the first inode available in the AG.\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "rec",
            "&i"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "0",
            "XFS_LOOKUP_GE",
            "&i"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_newino"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_finobt_newino(\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint error;\n\tint i;\n\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Find the first inode available in the AG.\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_inobt_get_rec(cur, rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dialloc_ag_finobt_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "999-1074",
    "snippet": "STATIC int\nxfs_dialloc_ag_finobt_near(\n\txfs_agino_t\t\t\tpagino,\n\tstruct xfs_btree_cur\t\t**ocur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_btree_cur\t\t*lcur = *ocur;\t/* left search cursor */\n\tstruct xfs_btree_cur\t\t*rcur;\t/* right search cursor */\n\tstruct xfs_inobt_rec_incore\trrec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti, j;\n\n\terror = xfs_inobt_lookup(lcur, pagino, XFS_LOOKUP_LE, &i);\n\tif (error)\n\t\treturn error;\n\n\tif (i == 1) {\n\t\terror = xfs_inobt_get_rec(lcur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t\t/*\n\t\t * See if we've landed in the parent inode record. The finobt\n\t\t * only tracks chunks with at least one free inode, so record\n\t\t * existence is enough.\n\t\t */\n\t\tif (pagino >= rec->ir_startino &&\n\t\t    pagino < (rec->ir_startino + XFS_INODES_PER_CHUNK))\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_btree_dup_cursor(lcur, &rcur);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_inobt_lookup(rcur, pagino, XFS_LOOKUP_GE, &j);\n\tif (error)\n\t\tgoto error_rcur;\n\tif (j == 1) {\n\t\terror = xfs_inobt_get_rec(rcur, &rrec, &j);\n\t\tif (error)\n\t\t\tgoto error_rcur;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error_rcur);\n\t}\n\n\tXFS_WANT_CORRUPTED_GOTO(i == 1 || j == 1, error_rcur);\n\tif (i == 1 && j == 1) {\n\t\t/*\n\t\t * Both the left and right records are valid. Choose the closer\n\t\t * inode chunk to the target.\n\t\t */\n\t\tif ((pagino - rec->ir_startino + XFS_INODES_PER_CHUNK - 1) >\n\t\t    (rrec.ir_startino - pagino)) {\n\t\t\t*rec = rrec;\n\t\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t\t*ocur = rcur;\n\t\t} else {\n\t\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t\t}\n\t} else if (j == 1) {\n\t\t/* only the right record is valid */\n\t\t*rec = rrec;\n\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t*ocur = rcur;\n\t} else if (i == 1) {\n\t\t/* only the left record is valid */\n\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t}\n\n\treturn 0;\n\nerror_rcur:\n\txfs_btree_del_cursor(rcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "rcur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1 || j == 1",
            "error_rcur"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "j == 1",
            "error_rcur"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "rcur",
            "&rrec",
            "&j"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "rcur",
            "pagino",
            "XFS_LOOKUP_GE",
            "&j"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "lcur",
            "&rcur"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_finobt_near(\n\txfs_agino_t\t\t\tpagino,\n\tstruct xfs_btree_cur\t\t**ocur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_btree_cur\t\t*lcur = *ocur;\t/* left search cursor */\n\tstruct xfs_btree_cur\t\t*rcur;\t/* right search cursor */\n\tstruct xfs_inobt_rec_incore\trrec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti, j;\n\n\terror = xfs_inobt_lookup(lcur, pagino, XFS_LOOKUP_LE, &i);\n\tif (error)\n\t\treturn error;\n\n\tif (i == 1) {\n\t\terror = xfs_inobt_get_rec(lcur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t\t/*\n\t\t * See if we've landed in the parent inode record. The finobt\n\t\t * only tracks chunks with at least one free inode, so record\n\t\t * existence is enough.\n\t\t */\n\t\tif (pagino >= rec->ir_startino &&\n\t\t    pagino < (rec->ir_startino + XFS_INODES_PER_CHUNK))\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_btree_dup_cursor(lcur, &rcur);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_inobt_lookup(rcur, pagino, XFS_LOOKUP_GE, &j);\n\tif (error)\n\t\tgoto error_rcur;\n\tif (j == 1) {\n\t\terror = xfs_inobt_get_rec(rcur, &rrec, &j);\n\t\tif (error)\n\t\t\tgoto error_rcur;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error_rcur);\n\t}\n\n\tXFS_WANT_CORRUPTED_GOTO(i == 1 || j == 1, error_rcur);\n\tif (i == 1 && j == 1) {\n\t\t/*\n\t\t * Both the left and right records are valid. Choose the closer\n\t\t * inode chunk to the target.\n\t\t */\n\t\tif ((pagino - rec->ir_startino + XFS_INODES_PER_CHUNK - 1) >\n\t\t    (rrec.ir_startino - pagino)) {\n\t\t\t*rec = rrec;\n\t\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t\t*ocur = rcur;\n\t\t} else {\n\t\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t\t}\n\t} else if (j == 1) {\n\t\t/* only the right record is valid */\n\t\t*rec = rrec;\n\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t*ocur = rcur;\n\t} else if (i == 1) {\n\t\t/* only the left record is valid */\n\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t}\n\n\treturn 0;\n\nerror_rcur:\n\txfs_btree_del_cursor(rcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dialloc_ag_inobt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "736-993",
    "snippet": "STATIC int\nxfs_dialloc_ag_inobt(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_btree_cur\t*cur, *tcur;\n\tstruct xfs_inobt_rec_incore rec, trec;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\tint\t\t\toffset;\n\tint\t\t\ti, j;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\tASSERT(pag->pagi_init);\n\tASSERT(pag->pagi_inodeok);\n\tASSERT(pag->pagi_freecount > 0);\n\n restart_pagno:\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If in the same AG as the parent, try to get near the parent.\n\t */\n\tif (pagno == agno) {\n\t\tint\t\tdoneleft;\t/* done, to the left */\n\t\tint\t\tdoneright;\t/* done, to the right */\n\t\tint\t\tsearchdistance = 10;\n\n\t\terror = xfs_inobt_lookup(cur, pagino, XFS_LOOKUP_LE, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error0);\n\n\t\tif (rec.ir_freecount > 0) {\n\t\t\t/*\n\t\t\t * Found a free inode in the same chunk\n\t\t\t * as the parent, done.\n\t\t\t */\n\t\t\tgoto alloc_inode;\n\t\t}\n\n\n\t\t/*\n\t\t * In the same AG as parent, but parent's chunk is full.\n\t\t */\n\n\t\t/* duplicate the cursor, search left & right simultaneously */\n\t\terror = xfs_btree_dup_cursor(cur, &tcur);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * Skip to last blocks looked up if same parent inode.\n\t\t */\n\t\tif (pagino != NULLAGINO &&\n\t\t    pag->pagl_pagino == pagino &&\n\t\t    pag->pagl_leftrec != NULLAGINO &&\n\t\t    pag->pagl_rightrec != NULLAGINO) {\n\t\t\terror = xfs_ialloc_get_rec(tcur, pag->pagl_leftrec,\n\t\t\t\t\t\t   &trec, &doneleft);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\terror = xfs_ialloc_get_rec(cur, pag->pagl_rightrec,\n\t\t\t\t\t\t   &rec, &doneright);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t} else {\n\t\t\t/* search left with tcur, back up 1 record */\n\t\t\terror = xfs_ialloc_next_rec(tcur, &trec, &doneleft, 1);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\t/* search right with cur, go forward 1 record. */\n\t\t\terror = xfs_ialloc_next_rec(cur, &rec, &doneright, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * Loop until we find an inode chunk with a free inode.\n\t\t */\n\t\twhile (!doneleft || !doneright) {\n\t\t\tint\tuseleft;  /* using left inode chunk this time */\n\n\t\t\tif (!--searchdistance) {\n\t\t\t\t/*\n\t\t\t\t * Not in range - save last search\n\t\t\t\t * location and allocate a new inode\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto newino;\n\t\t\t}\n\n\t\t\t/* figure out the closer block if both are valid. */\n\t\t\tif (!doneleft && !doneright) {\n\t\t\t\tuseleft = pagino -\n\t\t\t\t (trec.ir_startino + XFS_INODES_PER_CHUNK - 1) <\n\t\t\t\t  rec.ir_startino - pagino;\n\t\t\t} else {\n\t\t\t\tuseleft = !doneleft;\n\t\t\t}\n\n\t\t\t/* free inodes to the left? */\n\t\t\tif (useleft && trec.ir_freecount) {\n\t\t\t\trec = trec;\n\t\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\t\tcur = tcur;\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* free inodes to the right? */\n\t\t\tif (!useleft && rec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* get next record to check */\n\t\t\tif (useleft) {\n\t\t\t\terror = xfs_ialloc_next_rec(tcur, &trec,\n\t\t\t\t\t\t\t\t &doneleft, 1);\n\t\t\t} else {\n\t\t\t\terror = xfs_ialloc_next_rec(cur, &rec,\n\t\t\t\t\t\t\t\t &doneright, 0);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * We've reached the end of the btree. because\n\t\t * we are only searching a small chunk of the\n\t\t * btree each search, there is obviously free\n\t\t * inodes closer to the parent inode than we\n\t\t * are now. restart the search again.\n\t\t */\n\t\tpag->pagl_pagino = NULLAGINO;\n\t\tpag->pagl_leftrec = NULLAGINO;\n\t\tpag->pagl_rightrec = NULLAGINO;\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\tgoto restart_pagno;\n\t}\n\n\t/*\n\t * In a different AG from the parent.\n\t * See if the most recently allocated block has any free.\n\t */\nnewino:\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\tif (j == 1 && rec.ir_freecount > 0) {\n\t\t\t\t/*\n\t\t\t\t * The last chunk allocated in the group\n\t\t\t\t * still has a free inode.\n\t\t\t\t */\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * None left in the last group, search the whole AG\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\tfor (;;) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif (rec.ir_freecount > 0)\n\t\t\tbreak;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\nalloc_inode:\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\terror = xfs_inobt_update(cur, &rec);\n\tif (error)\n\t\tgoto error0;\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\nerror1:\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_IFREE",
            "-1"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_check_agi_freecount",
          "args": [
            "cur",
            "agi"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_agi_freecount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "175-207",
          "snippet": "STATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "tp",
            "agbp",
            "XFS_AGI_FREECOUNT"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_freecount",
            "-1"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "77-88",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "offset"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "rec.ir_startino + offset"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_OFFSET",
          "args": [
            "mp",
            "rec.ir_startino"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset < XFS_INODES_PER_CHUNK"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset >= 0"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lowbit64",
          "args": [
            "rec.ir_free"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lowbit64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "60-76",
          "snippet": "static inline int xfs_lowbit64(__uint64_t v)\n{\n\t__uint32_t\tw = (__uint32_t)v;\n\tint\t\tn = 0;\n\n\tif (w) {\t/* lower bits */\n\t\tn = ffs(w);\n\t} else {\t/* upper bits */\n\t\tw = (__uint32_t)(v >> 32);\n\t\tif (w) {\n\t\t\tn = ffs(w);\n\t\t\tif (n)\n\t\t\t\tn += 32;\n\t\t}\n\t}\n\treturn n - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_lowbit64(__uint64_t v)\n{\n\t__uint32_t\tw = (__uint32_t)v;\n\tint\t\tn = 0;\n\n\tif (w) {\t/* lower bits */\n\t\tn = ffs(w);\n\t} else {\t/* upper bits */\n\t\tw = (__uint32_t)(v >> 32);\n\t\tif (w) {\n\t\t\tn = ffs(w);\n\t\t\tif (n)\n\t\t\t\tn += 32;\n\t\t}\n\t}\n\treturn n - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "0",
            "XFS_LOOKUP_GE",
            "&i"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_newino"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_next_rec",
          "args": [
            "cur",
            "&rec",
            "&doneright",
            "0"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_next_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "681-707",
          "snippet": "STATIC int\nxfs_ialloc_next_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done,\n\tint\t\t\tleft)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\tif (left)\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\telse\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ialloc_next_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done,\n\tint\t\t\tleft)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\tif (left)\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\telse\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_get_rec",
          "args": [
            "cur",
            "pag->pagl_rightrec",
            "&rec",
            "&doneright"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "709-731",
          "snippet": "STATIC int\nxfs_ialloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agino_t\t\tagino,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ialloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agino_t\t\tagino,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "cur",
            "&tcur"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "j == 1",
            "error0"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_newino"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagi_freecount > 0"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagi_inodeok"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagi_init"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "parent"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "parent"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dialloc_ag_inobt(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agnumber_t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_btree_cur\t*cur, *tcur;\n\tstruct xfs_inobt_rec_incore rec, trec;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\tint\t\t\toffset;\n\tint\t\t\ti, j;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\tASSERT(pag->pagi_init);\n\tASSERT(pag->pagi_inodeok);\n\tASSERT(pag->pagi_freecount > 0);\n\n restart_pagno:\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_INO);\n\t/*\n\t * If pagino is 0 (this is the root inode allocation) use newino.\n\t * This must work because we've just allocated some.\n\t */\n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If in the same AG as the parent, try to get near the parent.\n\t */\n\tif (pagno == agno) {\n\t\tint\t\tdoneleft;\t/* done, to the left */\n\t\tint\t\tdoneright;\t/* done, to the right */\n\t\tint\t\tsearchdistance = 10;\n\n\t\terror = xfs_inobt_lookup(cur, pagino, XFS_LOOKUP_LE, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(j == 1, error0);\n\n\t\tif (rec.ir_freecount > 0) {\n\t\t\t/*\n\t\t\t * Found a free inode in the same chunk\n\t\t\t * as the parent, done.\n\t\t\t */\n\t\t\tgoto alloc_inode;\n\t\t}\n\n\n\t\t/*\n\t\t * In the same AG as parent, but parent's chunk is full.\n\t\t */\n\n\t\t/* duplicate the cursor, search left & right simultaneously */\n\t\terror = xfs_btree_dup_cursor(cur, &tcur);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * Skip to last blocks looked up if same parent inode.\n\t\t */\n\t\tif (pagino != NULLAGINO &&\n\t\t    pag->pagl_pagino == pagino &&\n\t\t    pag->pagl_leftrec != NULLAGINO &&\n\t\t    pag->pagl_rightrec != NULLAGINO) {\n\t\t\terror = xfs_ialloc_get_rec(tcur, pag->pagl_leftrec,\n\t\t\t\t\t\t   &trec, &doneleft);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\terror = xfs_ialloc_get_rec(cur, pag->pagl_rightrec,\n\t\t\t\t\t\t   &rec, &doneright);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t} else {\n\t\t\t/* search left with tcur, back up 1 record */\n\t\t\terror = xfs_ialloc_next_rec(tcur, &trec, &doneleft, 1);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\t/* search right with cur, go forward 1 record. */\n\t\t\terror = xfs_ialloc_next_rec(cur, &rec, &doneright, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * Loop until we find an inode chunk with a free inode.\n\t\t */\n\t\twhile (!doneleft || !doneright) {\n\t\t\tint\tuseleft;  /* using left inode chunk this time */\n\n\t\t\tif (!--searchdistance) {\n\t\t\t\t/*\n\t\t\t\t * Not in range - save last search\n\t\t\t\t * location and allocate a new inode\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto newino;\n\t\t\t}\n\n\t\t\t/* figure out the closer block if both are valid. */\n\t\t\tif (!doneleft && !doneright) {\n\t\t\t\tuseleft = pagino -\n\t\t\t\t (trec.ir_startino + XFS_INODES_PER_CHUNK - 1) <\n\t\t\t\t  rec.ir_startino - pagino;\n\t\t\t} else {\n\t\t\t\tuseleft = !doneleft;\n\t\t\t}\n\n\t\t\t/* free inodes to the left? */\n\t\t\tif (useleft && trec.ir_freecount) {\n\t\t\t\trec = trec;\n\t\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\t\tcur = tcur;\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* free inodes to the right? */\n\t\t\tif (!useleft && rec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t/* get next record to check */\n\t\t\tif (useleft) {\n\t\t\t\terror = xfs_ialloc_next_rec(tcur, &trec,\n\t\t\t\t\t\t\t\t &doneleft, 1);\n\t\t\t} else {\n\t\t\t\terror = xfs_ialloc_next_rec(cur, &rec,\n\t\t\t\t\t\t\t\t &doneright, 0);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t/*\n\t\t * We've reached the end of the btree. because\n\t\t * we are only searching a small chunk of the\n\t\t * btree each search, there is obviously free\n\t\t * inodes closer to the parent inode than we\n\t\t * are now. restart the search again.\n\t\t */\n\t\tpag->pagl_pagino = NULLAGINO;\n\t\tpag->pagl_leftrec = NULLAGINO;\n\t\tpag->pagl_rightrec = NULLAGINO;\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\tgoto restart_pagno;\n\t}\n\n\t/*\n\t * In a different AG from the parent.\n\t * See if the most recently allocated block has any free.\n\t */\nnewino:\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\tif (j == 1 && rec.ir_freecount > 0) {\n\t\t\t\t/*\n\t\t\t\t * The last chunk allocated in the group\n\t\t\t\t * still has a free inode.\n\t\t\t\t */\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * None left in the last group, search the whole AG\n\t */\n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\tfor (;;) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif (rec.ir_freecount > 0)\n\t\t\tbreak;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\nalloc_inode:\n\toffset = xfs_lowbit64(rec.ir_free);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, agno, rec.ir_startino + offset);\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\terror = xfs_inobt_update(cur, &rec);\n\tif (error)\n\t\tgoto error0;\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\terror = xfs_check_agi_freecount(cur, agi);\n\tif (error)\n\t\tgoto error0;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\txfs_perag_put(pag);\n\t*inop = ino;\n\treturn 0;\nerror1:\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\txfs_perag_put(pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_ialloc_get_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "709-731",
    "snippet": "STATIC int\nxfs_ialloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agino_t\t\tagino,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "rec",
            "&i"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "agino",
            "XFS_LOOKUP_EQ",
            "&i"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ialloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agino_t\t\tagino,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ialloc_next_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "681-707",
    "snippet": "STATIC int\nxfs_ialloc_next_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done,\n\tint\t\t\tleft)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\tif (left)\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\telse\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "rec",
            "&i"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ialloc_next_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done,\n\tint\t\t\tleft)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\tif (left)\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\telse\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ialloc_ag_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "560-676",
    "snippet": "STATIC xfs_agnumber_t\nxfs_ialloc_ag_select(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\tparent,\t\t/* parent directory inode number */\n\tumode_t\t\tmode,\t\t/* bits set to indicate file type */\n\tint\t\tokalloc)\t/* ok to allocate more space */\n{\n\txfs_agnumber_t\tagcount;\t/* number of ag's in the filesystem */\n\txfs_agnumber_t\tagno;\t\t/* current ag number */\n\tint\t\tflags;\t\t/* alloc buffer locking flags */\n\txfs_extlen_t\tineed;\t\t/* blocks needed for inode allocation */\n\txfs_extlen_t\tlongest = 0;\t/* longest extent available */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tneedspace;\t/* file mode implies space allocated */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\txfs_agnumber_t\tpagno;\t\t/* parent (starting) ag number */\n\tint\t\terror;\n\n\t/*\n\t * Files of these types need at least one block if length > 0\n\t * (and they won't fit in the inode, but that's hard to figure out).\n\t */\n\tneedspace = S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode);\n\tmp = tp->t_mountp;\n\tagcount = mp->m_maxagi;\n\tif (S_ISDIR(mode))\n\t\tpagno = xfs_ialloc_next_ag(mp);\n\telse {\n\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\t\tif (pagno >= agcount)\n\t\t\tpagno = 0;\n\t}\n\n\tASSERT(pagno < agcount);\n\n\t/*\n\t * Loop through allocation groups, looking for one with a little\n\t * free space in it.  Note we don't look for free inodes, exactly.\n\t * Instead, we include whether there is a need to allocate inodes\n\t * to mean that blocks must be allocated for them,\n\t * if none are currently free.\n\t */\n\tagno = pagno;\n\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag;\n\n\t\tif (!pag->pagf_init) {\n\t\t\terror = xfs_alloc_pagf_init(mp, tp, agno, flags);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\t/*\n\t\t * Check that there is enough free space for the file plus a\n\t\t * chunk of inodes if we need to allocate some. If this is the\n\t\t * first pass across the AGs, take into account the potential\n\t\t * space needed for alignment of inode chunks when checking the\n\t\t * longest contiguous free space in the AG - this prevents us\n\t\t * from getting ENOSPC because we have free space larger than\n\t\t * m_ialloc_blks but alignment constraints prevent us from using\n\t\t * it.\n\t\t *\n\t\t * If we can't find an AG with space for full alignment slack to\n\t\t * be taken into account, we must be near ENOSPC in all AGs.\n\t\t * Hence we don't include alignment for the second pass and so\n\t\t * if we fail allocation due to alignment issues then it is most\n\t\t * likely a real ENOSPC condition.\n\t\t */\n\t\tineed = mp->m_ialloc_blks;\n\t\tif (flags && ineed > 1)\n\t\t\tineed += xfs_ialloc_cluster_alignment(mp);\n\t\tlongest = pag->pagf_longest;\n\t\tif (!longest)\n\t\t\tlongest = pag->pagf_flcount > 0;\n\n\t\tif (pag->pagf_freeblks >= needspace + ineed &&\n\t\t    longest >= ineed) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\nnextag:\n\t\txfs_perag_put(pag);\n\t\t/*\n\t\t * No point in iterating over the rest, if we're shutting\n\t\t * down.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn NULLAGNUMBER;\n\t\tagno++;\n\t\tif (agno >= agcount)\n\t\t\tagno = 0;\n\t\tif (agno == pagno) {\n\t\t\tif (flags == 0)\n\t\t\t\treturn NULLAGNUMBER;\n\t\t\tflags = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_cluster_alignment",
          "args": [
            "mp"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_cluster_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "46-55",
          "snippet": "static inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_pagf_init",
          "args": [
            "mp",
            "tp",
            "agno",
            "flags"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_pagf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2115-2130",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_pagi_init",
          "args": [
            "mp",
            "tp",
            "agno"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_pagi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2182-2197",
          "snippet": "int\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_next_ag",
          "args": [
            "mp"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_next_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "541-554",
          "snippet": "STATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pagno < agcount"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "parent"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_agnumber_t\nxfs_ialloc_ag_select(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\tparent,\t\t/* parent directory inode number */\n\tumode_t\t\tmode,\t\t/* bits set to indicate file type */\n\tint\t\tokalloc)\t/* ok to allocate more space */\n{\n\txfs_agnumber_t\tagcount;\t/* number of ag's in the filesystem */\n\txfs_agnumber_t\tagno;\t\t/* current ag number */\n\tint\t\tflags;\t\t/* alloc buffer locking flags */\n\txfs_extlen_t\tineed;\t\t/* blocks needed for inode allocation */\n\txfs_extlen_t\tlongest = 0;\t/* longest extent available */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tneedspace;\t/* file mode implies space allocated */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\txfs_agnumber_t\tpagno;\t\t/* parent (starting) ag number */\n\tint\t\terror;\n\n\t/*\n\t * Files of these types need at least one block if length > 0\n\t * (and they won't fit in the inode, but that's hard to figure out).\n\t */\n\tneedspace = S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode);\n\tmp = tp->t_mountp;\n\tagcount = mp->m_maxagi;\n\tif (S_ISDIR(mode))\n\t\tpagno = xfs_ialloc_next_ag(mp);\n\telse {\n\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\t\tif (pagno >= agcount)\n\t\t\tpagno = 0;\n\t}\n\n\tASSERT(pagno < agcount);\n\n\t/*\n\t * Loop through allocation groups, looking for one with a little\n\t * free space in it.  Note we don't look for free inodes, exactly.\n\t * Instead, we include whether there is a need to allocate inodes\n\t * to mean that blocks must be allocated for them,\n\t * if none are currently free.\n\t */\n\tagno = pagno;\n\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag;\n\n\t\tif (!pag->pagf_init) {\n\t\t\terror = xfs_alloc_pagf_init(mp, tp, agno, flags);\n\t\t\tif (error)\n\t\t\t\tgoto nextag;\n\t\t}\n\n\t\t/*\n\t\t * Check that there is enough free space for the file plus a\n\t\t * chunk of inodes if we need to allocate some. If this is the\n\t\t * first pass across the AGs, take into account the potential\n\t\t * space needed for alignment of inode chunks when checking the\n\t\t * longest contiguous free space in the AG - this prevents us\n\t\t * from getting ENOSPC because we have free space larger than\n\t\t * m_ialloc_blks but alignment constraints prevent us from using\n\t\t * it.\n\t\t *\n\t\t * If we can't find an AG with space for full alignment slack to\n\t\t * be taken into account, we must be near ENOSPC in all AGs.\n\t\t * Hence we don't include alignment for the second pass and so\n\t\t * if we fail allocation due to alignment issues then it is most\n\t\t * likely a real ENOSPC condition.\n\t\t */\n\t\tineed = mp->m_ialloc_blks;\n\t\tif (flags && ineed > 1)\n\t\t\tineed += xfs_ialloc_cluster_alignment(mp);\n\t\tlongest = pag->pagf_longest;\n\t\tif (!longest)\n\t\t\tlongest = pag->pagf_flcount > 0;\n\n\t\tif (pag->pagf_freeblks >= needspace + ineed &&\n\t\t    longest >= ineed) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn agno;\n\t\t}\nnextag:\n\t\txfs_perag_put(pag);\n\t\t/*\n\t\t * No point in iterating over the rest, if we're shutting\n\t\t * down.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn NULLAGNUMBER;\n\t\tagno++;\n\t\tif (agno >= agcount)\n\t\t\tagno = 0;\n\t\tif (agno == pagno) {\n\t\t\tif (flags == 0)\n\t\t\t\treturn NULLAGNUMBER;\n\t\t\tflags = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_ialloc_next_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "541-554",
    "snippet": "STATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_agirotor_lock"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_agirotor_lock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_agnumber_t\nxfs_ialloc_next_ag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\n\tspin_lock(&mp->m_agirotor_lock);\n\tagno = mp->m_agirotor;\n\tif (++mp->m_agirotor >= mp->m_maxagi)\n\t\tmp->m_agirotor = 0;\n\tspin_unlock(&mp->m_agirotor_lock);\n\n\treturn agno;\n}"
  },
  {
    "function_name": "xfs_ialloc_ag_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "353-539",
    "snippet": "STATIC int\t\t\t\t/* error code or 0 */\nxfs_ialloc_ag_alloc(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t\t/* alloc group buffer */\n\tint\t\t*alloc)\n{\n\txfs_agi_t\t*agi;\t\t/* allocation group header */\n\txfs_alloc_arg_t\targs;\t\t/* allocation argument structure */\n\txfs_agnumber_t\tagno;\n\tint\t\terror;\n\txfs_agino_t\tnewino;\t\t/* new first inode's number */\n\txfs_agino_t\tnewlen;\t\t/* new number of inodes */\n\tint\t\tisaligned = 0;\t/* inode allocation at stripe unit */\n\t\t\t\t\t/* boundary */\n\tstruct xfs_perag *pag;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * Locking will ensure that we don't have two callers in here\n\t * at one time.\n\t */\n\tnewlen = args.mp->m_ialloc_inos;\n\tif (args.mp->m_maxicount &&\n\t    args.mp->m_sb.sb_icount + newlen > args.mp->m_maxicount)\n\t\treturn -ENOSPC;\n\targs.minlen = args.maxlen = args.mp->m_ialloc_blks;\n\t/*\n\t * First try to allocate inodes contiguous with the last-allocated\n\t * chunk of inodes.  If the filesystem is striped, this will fill\n\t * an entire stripe unit with inodes.\n\t */\n\tagi = XFS_BUF_TO_AGI(agbp);\n\tnewino = be32_to_cpu(agi->agi_newino);\n\tagno = be32_to_cpu(agi->agi_seqno);\n\targs.agbno = XFS_AGINO_TO_AGBNO(args.mp, newino) +\n\t\t     args.mp->m_ialloc_blks;\n\tif (likely(newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length)))) {\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\targs.prod = 1;\n\n\t\t/*\n\t\t * We need to take into account alignment here to ensure that\n\t\t * we don't modify the free list if we fail to have an exact\n\t\t * block. If we don't have an exact match, and every oher\n\t\t * attempt allocation attempt fails, we'll end up cancelling\n\t\t * a dirty transaction and shutting down.\n\t\t *\n\t\t * For an exact allocation, alignment must be 1,\n\t\t * however we need to take cluster alignment into account when\n\t\t * fixing up the freelist. Use the minalignslop field to\n\t\t * indicate that extra blocks might be required for alignment,\n\t\t * but not to use them in the actual exact allocation.\n\t\t */\n\t\targs.alignment = 1;\n\t\targs.minalignslop = xfs_ialloc_cluster_alignment(args.mp) - 1;\n\n\t\t/* Allow space for the inode btree to split. */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * This request might have dirtied the transaction if the AG can\n\t\t * satisfy the request, but the exact block was not available.\n\t\t * If the allocation did fail, subsequent requests will relax\n\t\t * the exact agbno requirement and increase the alignment\n\t\t * instead. It is critical that the total size of the request\n\t\t * (len + alignment + slop) does not increase from this point\n\t\t * on, so reset minalignslop to ensure it is not included in\n\t\t * subsequent requests.\n\t\t */\n\t\targs.minalignslop = 0;\n\t} else\n\t\targs.fsbno = NULLFSBLOCK;\n\n\tif (unlikely(args.fsbno == NULLFSBLOCK)) {\n\t\t/*\n\t\t * Set the alignment for the allocation.\n\t\t * If stripe alignment is turned on then align at stripe unit\n\t\t * boundary.\n\t\t * If the cluster size is smaller than a filesystem block\n\t\t * then we're doing I/O for inodes in filesystem block size\n\t\t * pieces, so don't need alignment anyway.\n\t\t */\n\t\tisaligned = 0;\n\t\tif (args.mp->m_sinoalign) {\n\t\t\tASSERT(!(args.mp->m_flags & XFS_MOUNT_NOALIGN));\n\t\t\targs.alignment = args.mp->m_dalign;\n\t\t\tisaligned = 1;\n\t\t} else\n\t\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\t/*\n\t\t * Need to figure out where to allocate the inode blocks.\n\t\t * Ideally they should be spaced out through the a.g.\n\t\t * For now, just allocate blocks up front.\n\t\t */\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\t/*\n\t\t * Allocate a fixed-size extent of inodes.\n\t\t */\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.prod = 1;\n\t\t/*\n\t\t * Allow space for the inode btree to split.\n\t\t */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If stripe alignment is turned on, then try again with cluster\n\t * alignment.\n\t */\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\t*alloc = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == args.minlen);\n\n\t/*\n\t * Stamp and write the inode buffers.\n\t *\n\t * Seed the new inode cluster with a random generation number. This\n\t * prevents short-term reuse of generation numbers if a chunk is\n\t * freed and then immediately reallocated. We use random numbers\n\t * rather than a linear progression to prevent the next generation\n\t * number from being easily guessable.\n\t */\n\terror = xfs_ialloc_inode_init(args.mp, tp, NULL, agno, args.agbno,\n\t\t\targs.len, prandom_u32());\n\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Convert the results.\n\t */\n\tnewino = XFS_OFFBNO_TO_AGINO(args.mp, args.agbno, 0);\n\tbe32_add_cpu(&agi->agi_count, newlen);\n\tbe32_add_cpu(&agi->agi_freecount, newlen);\n\tpag = xfs_perag_get(args.mp, agno);\n\tpag->pagi_freecount += newlen;\n\txfs_perag_put(pag);\n\tagi->agi_newino = cpu_to_be32(newino);\n\n\t/*\n\t * Insert records describing the new inode chunk into the btrees.\n\t */\n\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t XFS_BTNUM_INO);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_sb_version_hasfinobt(&args.mp->m_sb)) {\n\t\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t\t XFS_BTNUM_FINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * Log allocation group header fields\n\t */\n\txfs_ialloc_log_agi(tp, agbp,\n\t\tXFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO);\n\t/*\n\t * Modify/log superblock values for inode count and inode free count.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, (long)newlen);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, (long)newlen);\n\t*alloc = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_IFREE",
            "(long)newlen"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "tp",
            "agbp",
            "XFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_insert",
          "args": [
            "args.mp",
            "tp",
            "agbp",
            "newino",
            "newlen",
            "XFS_BTNUM_FINO"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "129-169",
          "snippet": "STATIC int\nxfs_inobt_insert(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agino_t\t\tnewino,\n\txfs_agino_t\t\tnewlen,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agino_t\t\tthisino;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, btnum);\n\n\tfor (thisino = newino;\n\t     thisino < newino + newlen;\n\t     thisino += XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_inobt_lookup(cur, thisino, XFS_LOOKUP_EQ, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 0);\n\n\t\terror = xfs_inobt_insert_rec(cur, XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INOBT_ALL_FREE, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inobt_insert(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agino_t\t\tnewino,\n\txfs_agino_t\t\tnewlen,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agino_t\t\tthisino;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, btnum);\n\n\tfor (thisino = newino;\n\t     thisino < newino + newlen;\n\t     thisino += XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_inobt_lookup(cur, thisino, XFS_LOOKUP_EQ, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 0);\n\n\t\terror = xfs_inobt_insert_rec(cur, XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INOBT_ALL_FREE, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasfinobt",
          "args": [
            "&args.mp->m_sb"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newino"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "args.mp",
            "agno"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_freecount",
            "newlen"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_count",
            "newlen"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_OFFBNO_TO_AGINO",
          "args": [
            "args.mp",
            "args.agbno",
            "0"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_inode_init",
          "args": [
            "args.mp",
            "tp",
            "NULL",
            "agno",
            "args.agbno",
            "args.len",
            "prandom_u32()"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "218-347",
          "snippet": "int\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.len == args.minlen"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_cluster_alignment",
          "args": [
            "args.mp"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_cluster_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "46-55",
          "snippet": "static inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "args.mp",
            "agno",
            "args.agbno"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_root"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "args.mp",
            "agno",
            "args.agbno"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_root"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(args.mp->m_flags & XFS_MOUNT_NOALIGN)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "args.fsbno == NULLFSBLOCK"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "args.mp",
            "agno",
            "args.agbno"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length))"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_length"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "args.mp",
            "newino"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_newino"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error code or 0 */\nxfs_ialloc_ag_alloc(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t\t/* alloc group buffer */\n\tint\t\t*alloc)\n{\n\txfs_agi_t\t*agi;\t\t/* allocation group header */\n\txfs_alloc_arg_t\targs;\t\t/* allocation argument structure */\n\txfs_agnumber_t\tagno;\n\tint\t\terror;\n\txfs_agino_t\tnewino;\t\t/* new first inode's number */\n\txfs_agino_t\tnewlen;\t\t/* new number of inodes */\n\tint\t\tisaligned = 0;\t/* inode allocation at stripe unit */\n\t\t\t\t\t/* boundary */\n\tstruct xfs_perag *pag;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * Locking will ensure that we don't have two callers in here\n\t * at one time.\n\t */\n\tnewlen = args.mp->m_ialloc_inos;\n\tif (args.mp->m_maxicount &&\n\t    args.mp->m_sb.sb_icount + newlen > args.mp->m_maxicount)\n\t\treturn -ENOSPC;\n\targs.minlen = args.maxlen = args.mp->m_ialloc_blks;\n\t/*\n\t * First try to allocate inodes contiguous with the last-allocated\n\t * chunk of inodes.  If the filesystem is striped, this will fill\n\t * an entire stripe unit with inodes.\n\t */\n\tagi = XFS_BUF_TO_AGI(agbp);\n\tnewino = be32_to_cpu(agi->agi_newino);\n\tagno = be32_to_cpu(agi->agi_seqno);\n\targs.agbno = XFS_AGINO_TO_AGBNO(args.mp, newino) +\n\t\t     args.mp->m_ialloc_blks;\n\tif (likely(newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length)))) {\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\targs.prod = 1;\n\n\t\t/*\n\t\t * We need to take into account alignment here to ensure that\n\t\t * we don't modify the free list if we fail to have an exact\n\t\t * block. If we don't have an exact match, and every oher\n\t\t * attempt allocation attempt fails, we'll end up cancelling\n\t\t * a dirty transaction and shutting down.\n\t\t *\n\t\t * For an exact allocation, alignment must be 1,\n\t\t * however we need to take cluster alignment into account when\n\t\t * fixing up the freelist. Use the minalignslop field to\n\t\t * indicate that extra blocks might be required for alignment,\n\t\t * but not to use them in the actual exact allocation.\n\t\t */\n\t\targs.alignment = 1;\n\t\targs.minalignslop = xfs_ialloc_cluster_alignment(args.mp) - 1;\n\n\t\t/* Allow space for the inode btree to split. */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * This request might have dirtied the transaction if the AG can\n\t\t * satisfy the request, but the exact block was not available.\n\t\t * If the allocation did fail, subsequent requests will relax\n\t\t * the exact agbno requirement and increase the alignment\n\t\t * instead. It is critical that the total size of the request\n\t\t * (len + alignment + slop) does not increase from this point\n\t\t * on, so reset minalignslop to ensure it is not included in\n\t\t * subsequent requests.\n\t\t */\n\t\targs.minalignslop = 0;\n\t} else\n\t\targs.fsbno = NULLFSBLOCK;\n\n\tif (unlikely(args.fsbno == NULLFSBLOCK)) {\n\t\t/*\n\t\t * Set the alignment for the allocation.\n\t\t * If stripe alignment is turned on then align at stripe unit\n\t\t * boundary.\n\t\t * If the cluster size is smaller than a filesystem block\n\t\t * then we're doing I/O for inodes in filesystem block size\n\t\t * pieces, so don't need alignment anyway.\n\t\t */\n\t\tisaligned = 0;\n\t\tif (args.mp->m_sinoalign) {\n\t\t\tASSERT(!(args.mp->m_flags & XFS_MOUNT_NOALIGN));\n\t\t\targs.alignment = args.mp->m_dalign;\n\t\t\tisaligned = 1;\n\t\t} else\n\t\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\t/*\n\t\t * Need to figure out where to allocate the inode blocks.\n\t\t * Ideally they should be spaced out through the a.g.\n\t\t * For now, just allocate blocks up front.\n\t\t */\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\t/*\n\t\t * Allocate a fixed-size extent of inodes.\n\t\t */\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.prod = 1;\n\t\t/*\n\t\t * Allow space for the inode btree to split.\n\t\t */\n\t\targs.minleft = args.mp->m_in_maxlevels - 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If stripe alignment is turned on, then try again with cluster\n\t * alignment.\n\t */\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.agbno = be32_to_cpu(agi->agi_root);\n\t\targs.fsbno = XFS_AGB_TO_FSB(args.mp, agno, args.agbno);\n\t\targs.alignment = xfs_ialloc_cluster_alignment(args.mp);\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\t*alloc = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == args.minlen);\n\n\t/*\n\t * Stamp and write the inode buffers.\n\t *\n\t * Seed the new inode cluster with a random generation number. This\n\t * prevents short-term reuse of generation numbers if a chunk is\n\t * freed and then immediately reallocated. We use random numbers\n\t * rather than a linear progression to prevent the next generation\n\t * number from being easily guessable.\n\t */\n\terror = xfs_ialloc_inode_init(args.mp, tp, NULL, agno, args.agbno,\n\t\t\targs.len, prandom_u32());\n\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Convert the results.\n\t */\n\tnewino = XFS_OFFBNO_TO_AGINO(args.mp, args.agbno, 0);\n\tbe32_add_cpu(&agi->agi_count, newlen);\n\tbe32_add_cpu(&agi->agi_freecount, newlen);\n\tpag = xfs_perag_get(args.mp, agno);\n\tpag->pagi_freecount += newlen;\n\txfs_perag_put(pag);\n\tagi->agi_newino = cpu_to_be32(newino);\n\n\t/*\n\t * Insert records describing the new inode chunk into the btrees.\n\t */\n\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t XFS_BTNUM_INO);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_sb_version_hasfinobt(&args.mp->m_sb)) {\n\t\terror = xfs_inobt_insert(args.mp, tp, agbp, newino, newlen,\n\t\t\t\t\t XFS_BTNUM_FINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * Log allocation group header fields\n\t */\n\txfs_ialloc_log_agi(tp, agbp,\n\t\tXFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO);\n\t/*\n\t * Modify/log superblock values for inode count and inode free count.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, (long)newlen);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, (long)newlen);\n\t*alloc = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ialloc_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "218-347",
    "snippet": "int\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "fbuf"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "fbuf",
            "buffer_list"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "fbuf",
            "0",
            "BBTOB(fbuf->b_length) - 1"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "fbuf->b_length"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ordered_buf",
          "args": [
            "tp",
            "fbuf"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ordered_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "711-724",
          "snippet": "void\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_inode_alloc_buf",
          "args": [
            "tp",
            "fbuf"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_inode_alloc_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "688-701",
          "snippet": "void\nxfs_trans_inode_alloc_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_ALLOC_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_inode_alloc_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_ALLOC_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "mp",
            "free"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&free->di_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ino"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "gen"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DINODE_MAGIC"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_make_iptr",
          "args": [
            "mp",
            "fbuf",
            "i"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_make_iptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.h",
          "lines": "44-49",
          "snippet": "static inline struct xfs_dinode *\nxfs_make_iptr(struct xfs_mount *mp, struct xfs_buf *b, int o)\n{\n\treturn (struct xfs_dinode *)\n\t\t(xfs_buf_offset(b, o << (mp)->m_sb.sb_inodelog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dinode *\nxfs_make_iptr(struct xfs_mount *mp, struct xfs_buf *b, int o)\n{\n\treturn (struct xfs_dinode *)\n\t\t(xfs_buf_offset(b, o << (mp)->m_sb.sb_inodelog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dinode_size",
          "args": [
            "version"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "936-941",
          "snippet": "static inline uint xfs_dinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_dinode);\n\treturn offsetof(struct xfs_dinode, di_crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline uint xfs_dinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_dinode);\n\treturn offsetof(struct xfs_dinode, di_crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_zero",
          "args": [
            "fbuf",
            "0",
            "BBTOB(fbuf->b_length)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "fbuf->b_length"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize * blks_per_cluster",
            "XBF_UNMAPPED"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "agbno + (j * blks_per_cluster)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icreate_log",
          "args": [
            "tp",
            "agno",
            "agbno",
            "mp->m_ialloc_inos",
            "mp->m_sb.sb_inodesize",
            "length",
            "gen"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icreate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icreate_item.c",
          "lines": "159-188",
          "snippet": "void\nxfs_icreate_log(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\tunsigned int\t\tcount,\n\tunsigned int\t\tinode_size,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgeneration)\n{\n\tstruct xfs_icreate_item\t*icp;\n\n\ticp = kmem_zone_zalloc(xfs_icreate_zone, KM_SLEEP);\n\n\txfs_log_item_init(tp->t_mountp, &icp->ic_item, XFS_LI_ICREATE,\n\t\t\t  &xfs_icreate_item_ops);\n\n\ticp->ic_format.icl_type = XFS_LI_ICREATE;\n\ticp->ic_format.icl_size = 1;\t/* single vector */\n\ticp->ic_format.icl_ag = cpu_to_be32(agno);\n\ticp->ic_format.icl_agbno = cpu_to_be32(agbno);\n\ticp->ic_format.icl_count = cpu_to_be32(count);\n\ticp->ic_format.icl_isize = cpu_to_be32(inode_size);\n\ticp->ic_format.icl_length = cpu_to_be32(length);\n\ticp->ic_format.icl_gen = cpu_to_be32(generation);\n\n\txfs_trans_add_item(tp, &icp->ic_item);\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\ticp->ic_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_icreate_zone;",
            "static struct xfs_item_ops xfs_icreate_item_ops = {\n\t.iop_size\t= xfs_icreate_item_size,\n\t.iop_format\t= xfs_icreate_item_format,\n\t.iop_pin\t= xfs_icreate_item_pin,\n\t.iop_unpin\t= xfs_icreate_item_unpin,\n\t.iop_push\t= xfs_icreate_item_push,\n\t.iop_unlock\t= xfs_icreate_item_unlock,\n\t.iop_committed\t= xfs_icreate_item_committed,\n\t.iop_committing = xfs_icreate_item_committing,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_icreate_zone;\nstatic struct xfs_item_ops xfs_icreate_item_ops = {\n\t.iop_size\t= xfs_icreate_item_size,\n\t.iop_format\t= xfs_icreate_item_format,\n\t.iop_pin\t= xfs_icreate_item_pin,\n\t.iop_unpin\t= xfs_icreate_item_unpin,\n\t.iop_push\t= xfs_icreate_item_push,\n\t.iop_unlock\t= xfs_icreate_item_unlock,\n\t.iop_committed\t= xfs_icreate_item_committed,\n\t.iop_committing = xfs_icreate_item_committing,\n};\n\nvoid\nxfs_icreate_log(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\tunsigned int\t\tcount,\n\tunsigned int\t\tinode_size,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgeneration)\n{\n\tstruct xfs_icreate_item\t*icp;\n\n\ticp = kmem_zone_zalloc(xfs_icreate_zone, KM_SLEEP);\n\n\txfs_log_item_init(tp->t_mountp, &icp->ic_item, XFS_LI_ICREATE,\n\t\t\t  &xfs_icreate_item_ops);\n\n\ticp->ic_format.icl_type = XFS_LI_ICREATE;\n\ticp->ic_format.icl_size = 1;\t/* single vector */\n\ticp->ic_format.icl_ag = cpu_to_be32(agno);\n\ticp->ic_format.icl_agbno = cpu_to_be32(agbno);\n\ticp->ic_format.icl_count = cpu_to_be32(count);\n\ticp->ic_format.icl_isize = cpu_to_be32(inode_size);\n\ticp->ic_format.icl_length = cpu_to_be32(length);\n\ticp->ic_format.icl_gen = cpu_to_be32(generation);\n\n\txfs_trans_add_item(tp, &icp->ic_item);\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\ticp->ic_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "XFS_OFFBNO_TO_AGINO(mp, agbno, 0)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_OFFBNO_TO_AGINO",
          "args": [
            "mp",
            "agbno",
            "0"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icluster_size_fsb",
          "args": [
            "mp"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icluster_size_fsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.h",
          "lines": "32-39",
          "snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_check_agi_freecount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "175-207",
    "snippet": "STATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "freecount == be32_to_cpu(agi->agi_freecount)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_freecount"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "cur->bc_mp"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&rec",
            "&i"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "0",
            "XFS_LOOKUP_GE",
            "&i"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_agi\t\t*agi)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!XFS_FORCED_SHUTDOWN(cur->bc_mp))\n\t\t\tASSERT(freecount == be32_to_cpu(agi->agi_freecount));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inobt_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "129-169",
    "snippet": "STATIC int\nxfs_inobt_insert(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agino_t\t\tnewino,\n\txfs_agino_t\t\tnewlen,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agino_t\t\tthisino;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, btnum);\n\n\tfor (thisino = newino;\n\t     thisino < newino + newlen;\n\t     thisino += XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_inobt_lookup(cur, thisino, XFS_LOOKUP_EQ, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 0);\n\n\t\terror = xfs_inobt_insert_rec(cur, XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INOBT_ALL_FREE, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_insert_rec",
          "args": [
            "cur",
            "XFS_INODES_PER_CHUNK",
            "XFS_INOBT_ALL_FREE",
            "&i"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_insert_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "114-124",
          "snippet": "STATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "thisino",
            "XFS_LOOKUP_EQ",
            "&i"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "btnum"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inobt_insert(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agino_t\t\tnewino,\n\txfs_agino_t\t\tnewlen,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\txfs_agnumber_t\t\tagno = be32_to_cpu(agi->agi_seqno);\n\txfs_agino_t\t\tthisino;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno, btnum);\n\n\tfor (thisino = newino;\n\t     thisino < newino + newlen;\n\t     thisino += XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_inobt_lookup(cur, thisino, XFS_LOOKUP_EQ, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 0);\n\n\t\terror = xfs_inobt_insert_rec(cur, XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INOBT_ALL_FREE, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inobt_insert_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "114-124",
    "snippet": "STATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "cur",
            "stat"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\t__int32_t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}"
  },
  {
    "function_name": "xfs_inobt_get_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "93-109",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rec->inobt.ir_free"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->inobt.ir_freecount"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->inobt.ir_startino"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_rec",
          "args": [
            "cur",
            "&rec",
            "stat"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3914-3950",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_inobt_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "77-88",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1904-1959",
          "snippet": "int\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "irec->ir_free"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "irec->ir_freecount"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "irec->ir_startino"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec)\t/* btree record */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\trec.inobt.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}"
  },
  {
    "function_name": "xfs_inobt_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "60-71",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "dir",
            "stat"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
  },
  {
    "function_name": "xfs_ialloc_cluster_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
    "lines": "46-55",
    "snippet": "static inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "mp->m_inode_cluster_size"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasalign",
          "args": [
            "&mp->m_sb"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "399-403",
          "snippet": "static inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_ialloc_cluster_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t\t\tXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\treturn mp->m_sb.sb_inoalignmt;\n\treturn 1;\n}"
  }
]