[
  {
    "function_name": "nilfs_find_uncommitted_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "515-585",
    "snippet": "unsigned long nilfs_find_uncommitted_extent(struct inode *inode,\n\t\t\t\t\t    sector_t start_blk,\n\t\t\t\t\t    sector_t *blkoff)\n{\n\tunsigned int i;\n\tpgoff_t index;\n\tunsigned int nblocks_in_page;\n\tunsigned long length = 0;\n\tsector_t b;\n\tstruct pagevec pvec;\n\tstruct page *page;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn 0;\n\n\tindex = start_blk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tnblocks_in_page = 1U << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\nrepeat:\n\tpvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,\n\t\t\t\t\tpvec.pages);\n\tif (pvec.nr == 0)\n\t\treturn length;\n\n\tif (length > 0 && pvec.pages[0]->index > index)\n\t\tgoto out;\n\n\tb = pvec.pages[0]->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\ti = 0;\n\tdo {\n\t\tpage = pvec.pages[i];\n\n\t\tlock_page(page);\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (b < start_blk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tif (length == 0)\n\t\t\t\t\t\t*blkoff = b;\n\t\t\t\t\tlength++;\n\t\t\t\t} else if (length > 0) {\n\t\t\t\t\tgoto out_locked;\n\t\t\t\t}\n\t\t\t} while (++b, bh = bh->b_this_page, bh != head);\n\t\t} else {\n\t\t\tif (length > 0)\n\t\t\t\tgoto out_locked;\n\n\t\t\tb += nblocks_in_page;\n\t\t}\n\t\tunlock_page(page);\n\n\t} while (++i < pagevec_count(&pvec));\n\n\tindex = page->index + 1;\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n\nout_locked:\n\tunlock_page(page);\nout:\n\tpagevec_release(&pvec);\n\treturn length;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "PAGEVEC_SIZE",
            "pvec.pages"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nunsigned long nilfs_find_uncommitted_extent(struct inode *inode,\n\t\t\t\t\t    sector_t start_blk,\n\t\t\t\t\t    sector_t *blkoff)\n{\n\tunsigned int i;\n\tpgoff_t index;\n\tunsigned int nblocks_in_page;\n\tunsigned long length = 0;\n\tsector_t b;\n\tstruct pagevec pvec;\n\tstruct page *page;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn 0;\n\n\tindex = start_blk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tnblocks_in_page = 1U << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\nrepeat:\n\tpvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,\n\t\t\t\t\tpvec.pages);\n\tif (pvec.nr == 0)\n\t\treturn length;\n\n\tif (length > 0 && pvec.pages[0]->index > index)\n\t\tgoto out;\n\n\tb = pvec.pages[0]->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\ti = 0;\n\tdo {\n\t\tpage = pvec.pages[i];\n\n\t\tlock_page(page);\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (b < start_blk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tif (length == 0)\n\t\t\t\t\t\t*blkoff = b;\n\t\t\t\t\tlength++;\n\t\t\t\t} else if (length > 0) {\n\t\t\t\t\tgoto out_locked;\n\t\t\t\t}\n\t\t\t} while (++b, bh = bh->b_this_page, bh != head);\n\t\t} else {\n\t\t\tif (length > 0)\n\t\t\t\tgoto out_locked;\n\n\t\t\tb += nblocks_in_page;\n\t\t}\n\t\tunlock_page(page);\n\n\t} while (++i < pagevec_count(&pvec));\n\n\tindex = page->index + 1;\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n\nout_locked:\n\tunlock_page(page);\nout:\n\tpagevec_release(&pvec);\n\treturn length;\n}"
  },
  {
    "function_name": "__nilfs_clear_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "484-501",
    "snippet": "int __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestClearPageDirty",
          "args": [
            "page"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&mapping->tree_lock"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&mapping->tree_lock"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&mapping->page_tree",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_dirty",
            "&page->flags"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&mapping->tree_lock"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}"
  },
  {
    "function_name": "nilfs_mapping_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "464-471",
    "snippet": "void nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_NOFS"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}"
  },
  {
    "function_name": "nilfs_page_count_clean_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "447-462",
    "snippet": "unsigned nilfs_page_count_clean_buffers(struct page *page,\n\t\t\t\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tstruct buffer_head *bh, *head;\n\tunsigned nc = 0;\n\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (block_end > from && block_start < to && !buffer_dirty(bh))\n\t\t\tnc++;\n\t}\n\treturn nc;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nunsigned nilfs_page_count_clean_buffers(struct page *page,\n\t\t\t\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tstruct buffer_head *bh, *head;\n\tunsigned nc = 0;\n\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (block_end > from && block_start < to && !buffer_dirty(bh))\n\t\t\tnc++;\n\t}\n\treturn nc;\n}"
  },
  {
    "function_name": "nilfs_clear_dirty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "406-445",
    "snippet": "void nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nilfs_clear_page_dirty",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_clear_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "484-501",
          "snippet": "int __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_redirected",
          "args": [
            "bh"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_checked",
          "args": [
            "bh"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_volatile",
          "args": [
            "bh"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sb",
            "__func__",
            "\"discard block %llu, size %zu\"",
            "(u64)bh->b_blocknr",
            "bh->b_size"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}"
  },
  {
    "function_name": "nilfs_clear_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "379-399",
    "snippet": "void nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_dirty_page",
          "args": [
            "page",
            "silent"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "406-445",
          "snippet": "void nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "PAGEVEC_SIZE"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "nilfs_copy_back_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "312-372",
    "snippet": "void nilfs_copy_back_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i, n;\n\tpgoff_t index = 0;\n\tint err;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tn = pagevec_lookup(&pvec, smap, index, PAGEVEC_SIZE);\n\tif (!n)\n\t\treturn;\n\tindex = pvec.pages[n - 1]->index + 1;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\t\tpgoff_t offset = page->index;\n\n\t\tlock_page(page);\n\t\tdpage = find_lock_page(dmap, offset);\n\t\tif (dpage) {\n\t\t\t/* override existing page on the destination cache */\n\t\t\tWARN_ON(PageDirty(dpage));\n\t\t\tnilfs_copy_page(dpage, page, 0);\n\t\t\tunlock_page(dpage);\n\t\t\tpage_cache_release(dpage);\n\t\t} else {\n\t\t\tstruct page *page2;\n\n\t\t\t/* move the page to the destination cache */\n\t\t\tspin_lock_irq(&smap->tree_lock);\n\t\t\tpage2 = radix_tree_delete(&smap->page_tree, offset);\n\t\t\tWARN_ON(page2 != page);\n\n\t\t\tsmap->nrpages--;\n\t\t\tspin_unlock_irq(&smap->tree_lock);\n\n\t\t\tspin_lock_irq(&dmap->tree_lock);\n\t\t\terr = radix_tree_insert(&dmap->page_tree, offset, page);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\tWARN_ON(err == -EEXIST);\n\t\t\t\tpage->mapping = NULL;\n\t\t\t\tpage_cache_release(page); /* for cache */\n\t\t\t} else {\n\t\t\t\tpage->mapping = dmap;\n\t\t\t\tdmap->nrpages++;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tradix_tree_tag_set(&dmap->page_tree,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\t\t}\n\t\t\tspin_unlock_irq(&dmap->tree_lock);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tgoto repeat;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&dmap->tree_lock"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&dmap->page_tree",
            "offset",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err == -EEXIST"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&dmap->page_tree",
            "offset",
            "page"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&dmap->tree_lock"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&smap->tree_lock"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page2 != page"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&smap->page_tree",
            "offset"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&smap->tree_lock"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dpage"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_copy_page",
          "args": [
            "dpage",
            "page",
            "0"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "213-255",
          "snippet": "static void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nstatic void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(dpage)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "dpage"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "dmap",
            "offset"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "smap",
            "index",
            "PAGEVEC_SIZE"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_copy_back_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i, n;\n\tpgoff_t index = 0;\n\tint err;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tn = pagevec_lookup(&pvec, smap, index, PAGEVEC_SIZE);\n\tif (!n)\n\t\treturn;\n\tindex = pvec.pages[n - 1]->index + 1;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\t\tpgoff_t offset = page->index;\n\n\t\tlock_page(page);\n\t\tdpage = find_lock_page(dmap, offset);\n\t\tif (dpage) {\n\t\t\t/* override existing page on the destination cache */\n\t\t\tWARN_ON(PageDirty(dpage));\n\t\t\tnilfs_copy_page(dpage, page, 0);\n\t\t\tunlock_page(dpage);\n\t\t\tpage_cache_release(dpage);\n\t\t} else {\n\t\t\tstruct page *page2;\n\n\t\t\t/* move the page to the destination cache */\n\t\t\tspin_lock_irq(&smap->tree_lock);\n\t\t\tpage2 = radix_tree_delete(&smap->page_tree, offset);\n\t\t\tWARN_ON(page2 != page);\n\n\t\t\tsmap->nrpages--;\n\t\t\tspin_unlock_irq(&smap->tree_lock);\n\n\t\t\tspin_lock_irq(&dmap->tree_lock);\n\t\t\terr = radix_tree_insert(&dmap->page_tree, offset, page);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\tWARN_ON(err == -EEXIST);\n\t\t\t\tpage->mapping = NULL;\n\t\t\t\tpage_cache_release(page); /* for cache */\n\t\t\t} else {\n\t\t\t\tpage->mapping = dmap;\n\t\t\t\tdmap->nrpages++;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tradix_tree_tag_set(&dmap->page_tree,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\t\t}\n\t\t\tspin_unlock_irq(&dmap->tree_lock);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tgoto repeat;\n}"
  },
  {
    "function_name": "nilfs_copy_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "257-302",
    "snippet": "int nilfs_copy_dirty_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\tint err = 0;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tif (!pagevec_lookup_tag(&pvec, smap, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tPAGEVEC_SIZE))\n\t\treturn 0;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageDirty(page)))\n\t\t\tNILFS_PAGE_BUG(page, \"inconsistent dirty state\");\n\n\t\tdpage = grab_cache_page(dmap, page->index);\n\t\tif (unlikely(!dpage)) {\n\t\t\t/* No empty page is added to the page cache */\n\t\t\terr = -ENOMEM;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\tNILFS_PAGE_BUG(page,\n\t\t\t\t       \"found empty page in dat page cache\");\n\n\t\tnilfs_copy_page(dpage, page, 1);\n\t\t__set_page_dirty_nobuffers(dpage);\n\n\t\tunlock_page(dpage);\n\t\tpage_cache_release(dpage);\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tif (likely(!err))\n\t\tgoto repeat;\n\treturn err;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dpage"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "dpage"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_copy_page",
          "args": [
            "dpage",
            "page",
            "1"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "213-255",
          "snippet": "static void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nstatic void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_PAGE_BUG",
          "args": [
            "page",
            "\"found empty page in dat page cache\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dpage"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "dmap",
            "page->index"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_PAGE_BUG",
          "args": [
            "page",
            "\"inconsistent dirty state\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageDirty(page)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "smap",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "PAGEVEC_SIZE"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_copy_dirty_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\tint err = 0;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tif (!pagevec_lookup_tag(&pvec, smap, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tPAGEVEC_SIZE))\n\t\treturn 0;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageDirty(page)))\n\t\t\tNILFS_PAGE_BUG(page, \"inconsistent dirty state\");\n\n\t\tdpage = grab_cache_page(dmap, page->index);\n\t\tif (unlikely(!dpage)) {\n\t\t\t/* No empty page is added to the page cache */\n\t\t\terr = -ENOMEM;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\tNILFS_PAGE_BUG(page,\n\t\t\t\t       \"found empty page in dat page cache\");\n\n\t\tnilfs_copy_page(dpage, page, 1);\n\t\t__set_page_dirty_nobuffers(dpage);\n\n\t\tunlock_page(dpage);\n\t\tpage_cache_release(dpage);\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tif (likely(!err))\n\t\tgoto repeat;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_copy_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "213-255",
    "snippet": "static void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "dbh"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "dst"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "dst"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "src"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "dst"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "dst"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "src"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "dst"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "dst"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "src"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "dst"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "dst"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "src"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "dst",
            "src"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "dst"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "dst",
            "sbh->b_size",
            "0"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "dst"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(dst)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "dst"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nstatic void nilfs_copy_page(struct page *dst, struct page *src, int copy_dirty)\n{\n\tstruct buffer_head *dbh, *dbufs, *sbh, *sbufs;\n\tunsigned long mask = NILFS_BUFFER_INHERENT_BITS;\n\n\tBUG_ON(PageWriteback(dst));\n\n\tsbh = sbufs = page_buffers(src);\n\tif (!page_has_buffers(dst))\n\t\tcreate_empty_buffers(dst, sbh->b_size, 0);\n\n\tif (copy_dirty)\n\t\tmask |= (1UL << BH_Dirty);\n\n\tdbh = dbufs = page_buffers(dst);\n\tdo {\n\t\tlock_buffer(sbh);\n\t\tlock_buffer(dbh);\n\t\tdbh->b_state = sbh->b_state & mask;\n\t\tdbh->b_blocknr = sbh->b_blocknr;\n\t\tdbh->b_bdev = sbh->b_bdev;\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n\n\tcopy_highpage(dst, src);\n\n\tif (PageUptodate(src) && !PageUptodate(dst))\n\t\tSetPageUptodate(dst);\n\telse if (!PageUptodate(src) && PageUptodate(dst))\n\t\tClearPageUptodate(dst);\n\tif (PageMappedToDisk(src) && !PageMappedToDisk(dst))\n\t\tSetPageMappedToDisk(dst);\n\telse if (!PageMappedToDisk(src) && PageMappedToDisk(dst))\n\t\tClearPageMappedToDisk(dst);\n\n\tdo {\n\t\tunlock_buffer(sbh);\n\t\tunlock_buffer(dbh);\n\t\tsbh = sbh->b_this_page;\n\t\tdbh = dbh->b_this_page;\n\t} while (dbh != dbufs);\n}"
  },
  {
    "function_name": "nilfs_page_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "170-201",
    "snippet": "void nilfs_page_bug(struct page *page)\n{\n\tstruct address_space *m;\n\tunsigned long ino;\n\n\tif (unlikely(!page)) {\n\t\tprintk(KERN_CRIT \"NILFS_PAGE_BUG(NULL)\\n\");\n\t\treturn;\n\t}\n\n\tm = page->mapping;\n\tino = m ? m->host->i_ino : 0;\n\n\tprintk(KERN_CRIT \"NILFS_PAGE_BUG(%p): cnt=%d index#=%llu flags=0x%lx \"\n\t       \"mapping=%p ino=%lu\\n\",\n\t       page, atomic_read(&page->_count),\n\t       (unsigned long long)page->index, page->flags, m, ino);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\t\tint i = 0;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \" BH[%d] %p: cnt=%d block#=%llu state=0x%lx\\n\",\n\t\t\t       i++, bh, atomic_read(&bh->b_count),\n\t\t\t       (unsigned long long)bh->b_blocknr, bh->b_state);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT\n\t\t\t       \" BH[%d] %p: cnt=%d block#=%llu state=0x%lx\\n\"",
            "i++",
            "bh",
            "atomic_read(&bh->b_count)",
            "(unsigned long long)bh->b_blocknr",
            "bh->b_state"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_count"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_page_bug(struct page *page)\n{\n\tstruct address_space *m;\n\tunsigned long ino;\n\n\tif (unlikely(!page)) {\n\t\tprintk(KERN_CRIT \"NILFS_PAGE_BUG(NULL)\\n\");\n\t\treturn;\n\t}\n\n\tm = page->mapping;\n\tino = m ? m->host->i_ino : 0;\n\n\tprintk(KERN_CRIT \"NILFS_PAGE_BUG(%p): cnt=%d index#=%llu flags=0x%lx \"\n\t       \"mapping=%p ino=%lu\\n\",\n\t       page, atomic_read(&page->_count),\n\t       (unsigned long long)page->index, page->flags, m, ino);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\t\tint i = 0;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \" BH[%d] %p: cnt=%d block#=%llu state=0x%lx\\n\",\n\t\t\t       i++, bh, atomic_read(&bh->b_count),\n\t\t\t       (unsigned long long)bh->b_blocknr, bh->b_state);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n}"
  },
  {
    "function_name": "nilfs_page_buffers_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "157-168",
    "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
  },
  {
    "function_name": "nilfs_copy_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "116-148",
    "snippet": "void nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "dpage"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "dpage"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "dpage"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "dpage"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr1"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr1 + bh_offset(dbh)",
            "kaddr0 + bh_offset(sbh)",
            "sbh->b_size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "sbh"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "dbh"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dpage"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "spage"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nvoid nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}"
  },
  {
    "function_name": "nilfs_forget_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "89-109",
    "snippet": "void nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nilfs_clear_page_dirty",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_clear_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "484-501",
          "snippet": "int __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_buffers_clean",
          "args": [
            "page"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_redirected",
          "args": [
            "bh"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_checked",
          "args": [
            "bh"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_volatile",
          "args": [
            "bh"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "nilfs_grab_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "61-82",
    "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nilfs_get_page_block",
          "args": [
            "page",
            "blkoff",
            "index",
            "blkbits",
            "b_state"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_get_page_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "42-59",
          "snippet": "static struct buffer_head *\n__nilfs_get_page_block(struct page *page, unsigned long block, pgoff_t index,\n\t\t       int blkbits, unsigned long b_state)\n\n{\n\tunsigned long first_block;\n\tstruct buffer_head *bh;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, b_state);\n\n\tfirst_block = (unsigned long)index << (PAGE_CACHE_SHIFT - blkbits);\n\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\n\ttouch_buffer(bh);\n\twait_on_buffer(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic struct buffer_head *\n__nilfs_get_page_block(struct page *page, unsigned long block, pgoff_t index,\n\t\t       int blkbits, unsigned long b_state)\n\n{\n\tunsigned long first_block;\n\tstruct buffer_head *bh;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, b_state);\n\n\tfirst_block = (unsigned long)index << (PAGE_CACHE_SHIFT - blkbits);\n\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\n\ttouch_buffer(bh);\n\twait_on_buffer(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
  },
  {
    "function_name": "__nilfs_get_page_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
    "lines": "42-59",
    "snippet": "static struct buffer_head *\n__nilfs_get_page_block(struct page *page, unsigned long block, pgoff_t index,\n\t\t       int blkbits, unsigned long b_state)\n\n{\n\tunsigned long first_block;\n\tstruct buffer_head *bh;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, b_state);\n\n\tfirst_block = (unsigned long)index << (PAGE_CACHE_SHIFT - blkbits);\n\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\n\ttouch_buffer(bh);\n\twait_on_buffer(bh);\n\treturn bh;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/bitops.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_buffer",
          "args": [
            "bh"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "touch_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "57-61",
          "snippet": "inline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\ninline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_get_nth_block",
          "args": [
            "page",
            "block - first_block"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_get_nth_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.h",
          "lines": "69-78",
          "snippet": "static inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << blkbits",
            "b_state"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic struct buffer_head *\n__nilfs_get_page_block(struct page *page, unsigned long block, pgoff_t index,\n\t\t       int blkbits, unsigned long b_state)\n\n{\n\tunsigned long first_block;\n\tstruct buffer_head *bh;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, b_state);\n\n\tfirst_block = (unsigned long)index << (PAGE_CACHE_SHIFT - blkbits);\n\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\n\ttouch_buffer(bh);\n\twait_on_buffer(bh);\n\treturn bh;\n}"
  }
]