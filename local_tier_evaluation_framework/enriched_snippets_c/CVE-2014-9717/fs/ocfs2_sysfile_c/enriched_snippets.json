[
  {
    "function_name": "_ocfs2_get_system_file_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
    "lines": "138-181",
    "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map",
            "ocfs2_system_inodes[type].si_name",
            "&ocfs2_sysfile_cluster_lock_key[type]",
            "0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(inode)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "osb",
            "blkno",
            "OCFS2_FI_FLAG_SYSFILE",
            "type"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "osb->sys_root_inode",
            "namebuf",
            "strlen(namebuf)",
            "&blkno"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namebuf"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sprintf_system_inode_name",
          "args": [
            "namebuf",
            "sizeof(namebuf)",
            "type",
            "slot"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ocfs2_get_system_file_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
    "lines": "103-136",
    "snippet": "struct inode *ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  u32 slot)\n{\n\tstruct inode *inode = NULL;\n\tstruct inode **arr = NULL;\n\n\t/* avoid the lookup if cached in local system file array */\n\tif (is_global_system_inode(type)) {\n\t\tarr = &(osb->global_system_inodes[type]);\n\t} else\n\t\tarr = get_local_system_inode(osb, type, slot);\n\n\tmutex_lock(&osb->system_file_mutex);\n\tif (arr && ((inode = *arr) != NULL)) {\n\t\t/* get a ref in addition to the array ref */\n\t\tinode = igrab(inode);\n\t\tmutex_unlock(&osb->system_file_mutex);\n\t\tBUG_ON(!inode);\n\n\t\treturn inode;\n\t}\n\n\t/* this gets one ref thru iget */\n\tinode = _ocfs2_get_system_file_inode(osb, type, slot);\n\n\t/* add one more if putting into array for first time */\n\tif (arr && inode) {\n\t\t*arr = igrab(inode);\n\t\tBUG_ON(!*arr);\n\t}\n\tmutex_unlock(&osb->system_file_mutex);\n\treturn inode;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->system_file_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!*arr"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "type",
            "slot"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->system_file_mutex"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&osb->system_file_mutex"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_local_system_inode",
          "args": [
            "osb",
            "type",
            "slot"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_system_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "56-101",
          "snippet": "static struct inode **get_local_system_inode(struct ocfs2_super *osb,\n\t\t\t\t\t     int type,\n\t\t\t\t\t     u32 slot)\n{\n\tint index;\n\tstruct inode **local_system_inodes, **free = NULL;\n\n\tBUG_ON(slot == OCFS2_INVALID_SLOT);\n\tBUG_ON(type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE);\n\n\tspin_lock(&osb->osb_lock);\n\tlocal_system_inodes = osb->local_system_inodes;\n\tspin_unlock(&osb->osb_lock);\n\n\tif (unlikely(!local_system_inodes)) {\n\t\tlocal_system_inodes = kzalloc(sizeof(struct inode *) *\n\t\t\t\t\t      NUM_LOCAL_SYSTEM_INODES *\n\t\t\t\t\t      osb->max_slots,\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!local_system_inodes) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\t/*\n\t\t\t * return NULL here so that ocfs2_get_sytem_file_inodes\n\t\t\t * will try to create an inode and use it. We will try\n\t\t\t * to initialize local_system_inodes next time.\n\t\t\t */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->local_system_inodes) {\n\t\t\t/* Someone has initialized it for us. */\n\t\t\tfree = local_system_inodes;\n\t\t\tlocal_system_inodes = osb->local_system_inodes;\n\t\t} else\n\t\t\tosb->local_system_inodes = local_system_inodes;\n\t\tspin_unlock(&osb->osb_lock);\n\t\tkfree(free);\n\t}\n\n\tindex = (slot * NUM_LOCAL_SYSTEM_INODES) +\n\t\t(type - OCFS2_FIRST_LOCAL_SYSTEM_INODE);\n\n\treturn &local_system_inodes[index];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode **get_local_system_inode(struct ocfs2_super *osb,\n\t\t\t\t\t     int type,\n\t\t\t\t\t     u32 slot)\n{\n\tint index;\n\tstruct inode **local_system_inodes, **free = NULL;\n\n\tBUG_ON(slot == OCFS2_INVALID_SLOT);\n\tBUG_ON(type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE);\n\n\tspin_lock(&osb->osb_lock);\n\tlocal_system_inodes = osb->local_system_inodes;\n\tspin_unlock(&osb->osb_lock);\n\n\tif (unlikely(!local_system_inodes)) {\n\t\tlocal_system_inodes = kzalloc(sizeof(struct inode *) *\n\t\t\t\t\t      NUM_LOCAL_SYSTEM_INODES *\n\t\t\t\t\t      osb->max_slots,\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!local_system_inodes) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\t/*\n\t\t\t * return NULL here so that ocfs2_get_sytem_file_inodes\n\t\t\t * will try to create an inode and use it. We will try\n\t\t\t * to initialize local_system_inodes next time.\n\t\t\t */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->local_system_inodes) {\n\t\t\t/* Someone has initialized it for us. */\n\t\t\tfree = local_system_inodes;\n\t\t\tlocal_system_inodes = osb->local_system_inodes;\n\t\t} else\n\t\t\tosb->local_system_inodes = local_system_inodes;\n\t\tspin_unlock(&osb->osb_lock);\n\t\tkfree(free);\n\t}\n\n\tindex = (slot * NUM_LOCAL_SYSTEM_INODES) +\n\t\t(type - OCFS2_FIRST_LOCAL_SYSTEM_INODE);\n\n\treturn &local_system_inodes[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_global_system_inode",
          "args": [
            "type"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "is_global_system_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "50-54",
          "snippet": "static inline int is_global_system_inode(int type)\n{\n\treturn type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&\n\t\ttype <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int is_global_system_inode(int type)\n{\n\treturn type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&\n\t\ttype <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstruct inode *ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  u32 slot)\n{\n\tstruct inode *inode = NULL;\n\tstruct inode **arr = NULL;\n\n\t/* avoid the lookup if cached in local system file array */\n\tif (is_global_system_inode(type)) {\n\t\tarr = &(osb->global_system_inodes[type]);\n\t} else\n\t\tarr = get_local_system_inode(osb, type, slot);\n\n\tmutex_lock(&osb->system_file_mutex);\n\tif (arr && ((inode = *arr) != NULL)) {\n\t\t/* get a ref in addition to the array ref */\n\t\tinode = igrab(inode);\n\t\tmutex_unlock(&osb->system_file_mutex);\n\t\tBUG_ON(!inode);\n\n\t\treturn inode;\n\t}\n\n\t/* this gets one ref thru iget */\n\tinode = _ocfs2_get_system_file_inode(osb, type, slot);\n\n\t/* add one more if putting into array for first time */\n\tif (arr && inode) {\n\t\t*arr = igrab(inode);\n\t\tBUG_ON(!*arr);\n\t}\n\tmutex_unlock(&osb->system_file_mutex);\n\treturn inode;\n}"
  },
  {
    "function_name": "get_local_system_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
    "lines": "56-101",
    "snippet": "static struct inode **get_local_system_inode(struct ocfs2_super *osb,\n\t\t\t\t\t     int type,\n\t\t\t\t\t     u32 slot)\n{\n\tint index;\n\tstruct inode **local_system_inodes, **free = NULL;\n\n\tBUG_ON(slot == OCFS2_INVALID_SLOT);\n\tBUG_ON(type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE);\n\n\tspin_lock(&osb->osb_lock);\n\tlocal_system_inodes = osb->local_system_inodes;\n\tspin_unlock(&osb->osb_lock);\n\n\tif (unlikely(!local_system_inodes)) {\n\t\tlocal_system_inodes = kzalloc(sizeof(struct inode *) *\n\t\t\t\t\t      NUM_LOCAL_SYSTEM_INODES *\n\t\t\t\t\t      osb->max_slots,\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!local_system_inodes) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\t/*\n\t\t\t * return NULL here so that ocfs2_get_sytem_file_inodes\n\t\t\t * will try to create an inode and use it. We will try\n\t\t\t * to initialize local_system_inodes next time.\n\t\t\t */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->local_system_inodes) {\n\t\t\t/* Someone has initialized it for us. */\n\t\t\tfree = local_system_inodes;\n\t\t\tlocal_system_inodes = osb->local_system_inodes;\n\t\t} else\n\t\t\tosb->local_system_inodes = local_system_inodes;\n\t\tspin_unlock(&osb->osb_lock);\n\t\tkfree(free);\n\t}\n\n\tindex = (slot * NUM_LOCAL_SYSTEM_INODES) +\n\t\t(type - OCFS2_FIRST_LOCAL_SYSTEM_INODE);\n\n\treturn &local_system_inodes[index];\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct inode *) *\n\t\t\t\t\t      NUM_LOCAL_SYSTEM_INODES *\n\t\t\t\t\t      osb->max_slots",
            "GFP_NOFS"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!local_system_inodes"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot == OCFS2_INVALID_SLOT"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode **get_local_system_inode(struct ocfs2_super *osb,\n\t\t\t\t\t     int type,\n\t\t\t\t\t     u32 slot)\n{\n\tint index;\n\tstruct inode **local_system_inodes, **free = NULL;\n\n\tBUG_ON(slot == OCFS2_INVALID_SLOT);\n\tBUG_ON(type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE);\n\n\tspin_lock(&osb->osb_lock);\n\tlocal_system_inodes = osb->local_system_inodes;\n\tspin_unlock(&osb->osb_lock);\n\n\tif (unlikely(!local_system_inodes)) {\n\t\tlocal_system_inodes = kzalloc(sizeof(struct inode *) *\n\t\t\t\t\t      NUM_LOCAL_SYSTEM_INODES *\n\t\t\t\t\t      osb->max_slots,\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!local_system_inodes) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\t/*\n\t\t\t * return NULL here so that ocfs2_get_sytem_file_inodes\n\t\t\t * will try to create an inode and use it. We will try\n\t\t\t * to initialize local_system_inodes next time.\n\t\t\t */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->local_system_inodes) {\n\t\t\t/* Someone has initialized it for us. */\n\t\t\tfree = local_system_inodes;\n\t\t\tlocal_system_inodes = osb->local_system_inodes;\n\t\t} else\n\t\t\tosb->local_system_inodes = local_system_inodes;\n\t\tspin_unlock(&osb->osb_lock);\n\t\tkfree(free);\n\t}\n\n\tindex = (slot * NUM_LOCAL_SYSTEM_INODES) +\n\t\t(type - OCFS2_FIRST_LOCAL_SYSTEM_INODE);\n\n\treturn &local_system_inodes[index];\n}"
  },
  {
    "function_name": "is_global_system_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
    "lines": "50-54",
    "snippet": "static inline int is_global_system_inode(int type)\n{\n\treturn type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&\n\t\ttype <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int is_global_system_inode(int type)\n{\n\treturn type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&\n\t\ttype <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;\n}"
  }
]