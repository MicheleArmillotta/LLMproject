[
  {
    "function_name": "ops(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "1266-1321",
    "snippet": "_lprops(struct ubifs_info *c)\n{\n\tint i, err;\n\tstruct ubifs_lp_stats lst;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/*\n\t * As we are going to scan the media, the write buffers have to be\n\t * synchronized.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\n\terr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_check_cb,\n\t\t\t\t    &lst);\n\tif (err && err != -ENOSPC)\n\t\tgoto out;\n\n\tif (lst.empty_lebs != c->lst.empty_lebs ||\n\t    lst.idx_lebs != c->lst.idx_lebs ||\n\t    lst.total_free != c->lst.total_free ||\n\t    lst.total_dirty != c->lst.total_dirty ||\n\t    lst.total_used != c->lst.total_used) {\n\t\tubifs_err(\"bad overall accounting\");\n\t\tubifs_err(\"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.empty_lebs, lst.idx_lebs, lst.total_free,\n\t\t\t  lst.total_dirty, lst.total_used);\n\t\tubifs_err(\"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\n\t\t\t  c->lst.total_dirty, c->lst.total_used);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lst.total_dead != c->lst.total_dead ||\n\t    lst.total_dark != c->lst.total_dark) {\n\t\tubifs_err(\"bad dead/dark space accounting\");\n\t\tubifs_err(\"calculated: total_dead %lld, total_dark %lld\",\n\t\t\t  lst.total_dead, lst.total_dark);\n\t\tubifs_err(\"read from lprops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst.total_dead, c->lst.total_dark);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = dbg_check_cats(c);\nout:\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s(c);\nout:\n\tre",
          "args": [
            "u"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad from l",
          "args": [
            "rops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst",
            "dead, c->lst.tota",
            "dark);\n\t\terr = -E"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lculated:",
          "args": [
            "total_dead %lld, total_dark %lld\",\n\t\t\t  lst.to",
            "d, lst.total_d",
            "k);\n\t\tubifs_er"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d dead/da",
          "args": [
            "k space accounting\");\n\t\tubifs_er"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad from l",
          "args": [
            "rops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst",
            "lebs, c->lst.idx_",
            "bs, c->lst.tota",
            "free,\n\t\t\t  c->lst",
            "dirty, c->lst.tota",
            "used);\n\t\terr = -E"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lculated:",
          "args": [
            "empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.em",
            "s, lst.idx_leb",
            "lst.total_f",
            "e,\n\t\t\t  lst.to",
            "ty, lst.total_u",
            "d);\n\t\tubifs_er"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d overall",
          "args": [
            "accounting\");\n\t\tubifs_er"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_nolock(c, c->main_f",
          "args": [
            "r",
            ", c->leb_cnt",
            "1,\n\t\t\t\t    (ub",
            "an_callback)scan_check_cb,\n\t\t\t\t    &ls",
            "rr &"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, siz",
          "args": [
            "of(s",
            "u",
            "ubifs_lp_stats));\n\terr = ubi"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\t\tif (err)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\n_lprops(struct ubifs_info *c)\n{\n\tint i, err;\n\tstruct ubifs_lp_stats lst;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/*\n\t * As we are going to scan the media, the write buffers have to be\n\t * synchronized.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\n\terr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_check_cb,\n\t\t\t\t    &lst);\n\tif (err && err != -ENOSPC)\n\t\tgoto out;\n\n\tif (lst.empty_lebs != c->lst.empty_lebs ||\n\t    lst.idx_lebs != c->lst.idx_lebs ||\n\t    lst.total_free != c->lst.total_free ||\n\t    lst.total_dirty != c->lst.total_dirty ||\n\t    lst.total_used != c->lst.total_used) {\n\t\tubifs_err(\"bad overall accounting\");\n\t\tubifs_err(\"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.empty_lebs, lst.idx_lebs, lst.total_free,\n\t\t\t  lst.total_dirty, lst.total_used);\n\t\tubifs_err(\"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\n\t\t\t  c->lst.total_dirty, c->lst.total_used);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lst.total_dead != c->lst.total_dead ||\n\t    lst.total_dark != c->lst.total_dark) {\n\t\tubifs_err(\"bad dead/dark space accounting\");\n\t\tubifs_err(\"calculated: total_dead %lld, total_dark %lld\",\n\t\t\t  lst.total_dead, lst.total_dark);\n\t\tubifs_err(\"read from lprops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst.total_dead, c->lst.total_dark);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = dbg_check_cats(c);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "1029-1253",
    "snippet": "an_check_cb(struct ubifs_info *c,\n\t\t\t const struct ubifs_lprops *lp, int in_tree,\n\t\t\t struct ubifs_lp_stats *lst)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint cat, lnum = lp->lnum, is_idx = 0, used = 0, free, dirty, ret;\n\tvoid *buf = NULL;\n\n\tcat = lp->flags & LPROPS_CAT_MASK;\n\tif (cat != LPROPS_UNCAT) {\n\t\tcat = ubifs_categorize_lprops(c, lp);\n\t\tif (cat != (lp->flags & LPROPS_CAT_MASK)) {\n\t\t\tubifs_err(\"bad LEB category %d expected %d\",\n\t\t\t\t  (lp->flags & LPROPS_CAT_MASK), cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check lp is on its category list (if it has one) */\n\tif (in_tree) {\n\t\tstruct list_head *list = NULL;\n\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\t}\n\t\tif (list) {\n\t\t\tstruct ubifs_lprops *lprops;\n\t\t\tint found = 0;\n\n\t\t\tlist_for_each_entry(lprops, list, list) {\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tubifs_err(\"bad LPT list (category %d)\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check lp is on its category heap (if it has one) */\n\tif (in_tree && cat > 0 && cat <= LPROPS_HEAP_CNT) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tif ((lp->hpos != -1 && heap->arr[lp->hpos]->lnum != lnum) ||\n\t\t    lp != heap->arr[lp->hpos]) {\n\t\t\tubifs_err(\"bad LPT heap (category %d)\", cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * After an unclean unmount, empty and freeable LEBs\n\t * may contain garbage - do not scan them.\n\t */\n\tif (lp->free == c->leb_size) {\n\t\tlst->empty_lebs += 1;\n\t\tlst->total_free += c->leb_size;\n\t\tlst->total_dark += ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    !(lp->flags & LPROPS_INDEX)) {\n\t\tlst->total_free  += lp->free;\n\t\tlst->total_dirty += lp->dirty;\n\t\tlst->total_dark  +=  ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tret = PTR_ERR(sleb);\n\t\tif (ret == -EUCLEAN) {\n\t\t\tubifs_dump_lprops(c);\n\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tis_idx = -1;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tint found, level = 0;\n\n\t\tcond_resched();\n\n\t\tif (is_idx == -1)\n\t\t\tis_idx = (snod->type == UBIFS_IDX_NODE) ? 1 : 0;\n\n\t\tif (is_idx && snod->type != UBIFS_IDX_NODE) {\n\t\t\tubifs_err(\"indexing node in data LEB %d:%d\",\n\t\t\t\t  lnum, snod->offs);\n\t\t\tgoto out_destroy;\n\t\t}\n\n\t\tif (snod->type == UBIFS_IDX_NODE) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\tlevel = le16_to_cpu(idx->level);\n\t\t}\n\n\t\tfound = ubifs_tnc_has_node(c, &snod->key, level, lnum,\n\t\t\t\t\t   snod->offs, is_idx);\n\t\tif (found) {\n\t\t\tif (found < 0)\n\t\t\t\tgoto out_destroy;\n\t\t\tused += ALIGN(snod->len, 8);\n\t\t}\n\t}\n\n\tfree = c->leb_size - sleb->endpt;\n\tdirty = sleb->endpt - used;\n\n\tif (free > c->leb_size || free < 0 || dirty > c->leb_size ||\n\t    dirty < 0) {\n\t\tubifs_err(\"bad calculated accounting for LEB %d: free %d, dirty %d\",\n\t\t\t  lnum, free, dirty);\n\t\tgoto out_destroy;\n\t}\n\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    free + dirty == c->leb_size)\n\t\tif ((is_idx && !(lp->flags & LPROPS_INDEX)) ||\n\t\t    (!is_idx && free == c->leb_size) ||\n\t\t    lp->free == c->leb_size) {\n\t\t\t/*\n\t\t\t * Empty or freeable LEBs could contain index\n\t\t\t * nodes from an uncompleted commit due to an\n\t\t\t * unclean unmount. Or they could be empty for\n\t\t\t * the same reason. Or it may simply not have been\n\t\t\t * unmapped.\n\t\t\t */\n\t\t\tfree = lp->free;\n\t\t\tdirty = lp->dirty;\n\t\t\tis_idx = 0;\n\t\t    }\n\n\tif (is_idx && lp->free + lp->dirty == free + dirty &&\n\t    lnum != c->ihead_lnum) {\n\t\t/*\n\t\t * After an unclean unmount, an index LEB could have a different\n\t\t * amount of free space than the value recorded by lprops. That\n\t\t * is because the in-the-gaps method may use free space or\n\t\t * create free space (as a side-effect of using ubi_leb_change\n\t\t * and not writing the whole LEB). The incorrect free space\n\t\t * value is not a problem because the index is only ever\n\t\t * allocated empty LEBs, so there will never be an attempt to\n\t\t * write to the free space at the end of an index LEB - except\n\t\t * by the in-the-gaps method for which it is not a problem.\n\t\t */\n\t\tfree = lp->free;\n\t\tdirty = lp->dirty;\n\t}\n\n\tif (lp->free != free || lp->dirty != dirty)\n\t\tgoto out_print;\n\n\tif (is_idx && !(lp->flags & LPROPS_INDEX)) {\n\t\tif (free == c->leb_size)\n\t\t\t/* Free but not unmapped LEB, it's fine */\n\t\t\tis_idx = 0;\n\t\telse {\n\t\t\tubifs_err(\"indexing node without indexing flag\");\n\t\t\tgoto out_print;\n\t\t}\n\t}\n\n\tif (!is_idx && (lp->flags & LPROPS_INDEX)) {\n\t\tubifs_err(\"data node with indexing flag\");\n\t\tgoto out_print;\n\t}\n\n\tif (free == c->leb_size)\n\t\tlst->empty_lebs += 1;\n\n\tif (is_idx)\n\t\tlst->idx_lebs += 1;\n\n\tif (!(lp->flags & LPROPS_INDEX))\n\t\tlst->total_used += c->leb_size - free - dirty;\n\tlst->total_free += free;\n\tlst->total_dirty += dirty;\n\n\tif (!(lp->flags & LPROPS_INDEX)) {\n\t\tint spc = free + dirty;\n\n\t\tif (spc < c->dead_wm)\n\t\t\tlst->total_dead += spc;\n\t\telse\n\t\t\tlst->total_dark += ubifs_calc_dark(c, spc);\n\t}\n\n\tubifs_scan_destroy(sleb);\n\tvfree(buf);\n\treturn LPT_SCAN_CONTINUE;\n\nout_print:\n\tubifs_err(\"bad accounting of LEB %d: free %d, dirty %d flags %#x, should be free %d, dirty %d\",\n\t\t  lnum, lp->free, lp->dirty, lp->flags, free, dirty);\n\tubifs_dump_leb(c, lnum);\nout_destroy:\n\tubifs_scan_destroy(sleb);\n\tret = -EINVAL;\nout:\n\tvfree(buf);\n\treturn ret;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "re"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tret",
          "args": [
            "-EI"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c, lnum);\nou",
          "args": [
            "_",
            "stro"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d account",
          "args": [
            "ng of LEB %d: free %d, dirty %d flags %#x, should be free %d, dirty %d\",\n\t\t  lnum, l",
            "e, l",
            ">dirty,",
            "->flags,",
            "ee, dirty",
            "ub",
            "s_dum"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tvfre",
          "args": [
            "(buf"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, spc);\n\t}",
          "args": [
            "ifs"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta node w",
          "args": [
            "th indexing flag\");\n\t\tgoto out"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dexing no",
          "args": [
            "e without indexing flag\");\n\t\t\tgoto ou"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d calcula",
          "args": [
            "ed accounting for LEB %d: free %d, dirty %d\",\n\t\t\t  lnum,",
            "irty",
            "g",
            "o out"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, 8",
          "args": [
            ";\n\t\t}\n\t}",
            "f"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, &snod->ke",
          "args": [
            ",",
            "evel, lnum",
            "sno",
            "s_idx);",
            "(foun"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "}\n\n\t\tfou"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_idx",
          "args": [
            "k",
            "(c, idx), &snod->key)",
            "level ="
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, idx), &sn",
          "args": [
            "d",
            "key"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dexing no",
          "args": [
            "e in data LEB %d:%d\",\n\t\t\t\t  lnum,",
            "ffs)",
            "goto ou"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tif (is",
          "args": [],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\ti",
            "fou"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "goto"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c);\n\t\t\tubifs",
          "args": [
            "d"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tif",
          "args": [
            "ret"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\tr",
          "args": [
            "t ="
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, 0,",
          "args": [
            "u",
            "0);",
            "i",
            "(IS",
            "R"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, c->leb_si",
          "args": [
            "e",
            "return L"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, c->leb_si",
          "args": [
            "e",
            "return L"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb_size,",
          "args": [
            "GFP_NOFS, P",
            "E_KERNEL",
            "if (!buf)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d LPT hea",
          "args": [
            "(category %d)\", cat);\n\t\t\tre",
            "rn"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d LPT lis",
          "args": [
            "(category %d)\", cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, list",
          "args": [
            "list)",
            "f (l"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d LEB cat",
          "args": [
            "gory %d expected %d\",\n\t\t\t\t  (lp->",
            "LPROPS_CAT_MASK), cat);\n\t\t\tre",
            "rn"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lp);\n\t\tif",
          "args": [
            "(",
            "t"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nan_check_cb(struct ubifs_info *c,\n\t\t\t const struct ubifs_lprops *lp, int in_tree,\n\t\t\t struct ubifs_lp_stats *lst)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint cat, lnum = lp->lnum, is_idx = 0, used = 0, free, dirty, ret;\n\tvoid *buf = NULL;\n\n\tcat = lp->flags & LPROPS_CAT_MASK;\n\tif (cat != LPROPS_UNCAT) {\n\t\tcat = ubifs_categorize_lprops(c, lp);\n\t\tif (cat != (lp->flags & LPROPS_CAT_MASK)) {\n\t\t\tubifs_err(\"bad LEB category %d expected %d\",\n\t\t\t\t  (lp->flags & LPROPS_CAT_MASK), cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check lp is on its category list (if it has one) */\n\tif (in_tree) {\n\t\tstruct list_head *list = NULL;\n\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\t}\n\t\tif (list) {\n\t\t\tstruct ubifs_lprops *lprops;\n\t\t\tint found = 0;\n\n\t\t\tlist_for_each_entry(lprops, list, list) {\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tubifs_err(\"bad LPT list (category %d)\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check lp is on its category heap (if it has one) */\n\tif (in_tree && cat > 0 && cat <= LPROPS_HEAP_CNT) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tif ((lp->hpos != -1 && heap->arr[lp->hpos]->lnum != lnum) ||\n\t\t    lp != heap->arr[lp->hpos]) {\n\t\t\tubifs_err(\"bad LPT heap (category %d)\", cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * After an unclean unmount, empty and freeable LEBs\n\t * may contain garbage - do not scan them.\n\t */\n\tif (lp->free == c->leb_size) {\n\t\tlst->empty_lebs += 1;\n\t\tlst->total_free += c->leb_size;\n\t\tlst->total_dark += ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    !(lp->flags & LPROPS_INDEX)) {\n\t\tlst->total_free  += lp->free;\n\t\tlst->total_dirty += lp->dirty;\n\t\tlst->total_dark  +=  ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tret = PTR_ERR(sleb);\n\t\tif (ret == -EUCLEAN) {\n\t\t\tubifs_dump_lprops(c);\n\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tis_idx = -1;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tint found, level = 0;\n\n\t\tcond_resched();\n\n\t\tif (is_idx == -1)\n\t\t\tis_idx = (snod->type == UBIFS_IDX_NODE) ? 1 : 0;\n\n\t\tif (is_idx && snod->type != UBIFS_IDX_NODE) {\n\t\t\tubifs_err(\"indexing node in data LEB %d:%d\",\n\t\t\t\t  lnum, snod->offs);\n\t\t\tgoto out_destroy;\n\t\t}\n\n\t\tif (snod->type == UBIFS_IDX_NODE) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\tlevel = le16_to_cpu(idx->level);\n\t\t}\n\n\t\tfound = ubifs_tnc_has_node(c, &snod->key, level, lnum,\n\t\t\t\t\t   snod->offs, is_idx);\n\t\tif (found) {\n\t\t\tif (found < 0)\n\t\t\t\tgoto out_destroy;\n\t\t\tused += ALIGN(snod->len, 8);\n\t\t}\n\t}\n\n\tfree = c->leb_size - sleb->endpt;\n\tdirty = sleb->endpt - used;\n\n\tif (free > c->leb_size || free < 0 || dirty > c->leb_size ||\n\t    dirty < 0) {\n\t\tubifs_err(\"bad calculated accounting for LEB %d: free %d, dirty %d\",\n\t\t\t  lnum, free, dirty);\n\t\tgoto out_destroy;\n\t}\n\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    free + dirty == c->leb_size)\n\t\tif ((is_idx && !(lp->flags & LPROPS_INDEX)) ||\n\t\t    (!is_idx && free == c->leb_size) ||\n\t\t    lp->free == c->leb_size) {\n\t\t\t/*\n\t\t\t * Empty or freeable LEBs could contain index\n\t\t\t * nodes from an uncompleted commit due to an\n\t\t\t * unclean unmount. Or they could be empty for\n\t\t\t * the same reason. Or it may simply not have been\n\t\t\t * unmapped.\n\t\t\t */\n\t\t\tfree = lp->free;\n\t\t\tdirty = lp->dirty;\n\t\t\tis_idx = 0;\n\t\t    }\n\n\tif (is_idx && lp->free + lp->dirty == free + dirty &&\n\t    lnum != c->ihead_lnum) {\n\t\t/*\n\t\t * After an unclean unmount, an index LEB could have a different\n\t\t * amount of free space than the value recorded by lprops. That\n\t\t * is because the in-the-gaps method may use free space or\n\t\t * create free space (as a side-effect of using ubi_leb_change\n\t\t * and not writing the whole LEB). The incorrect free space\n\t\t * value is not a problem because the index is only ever\n\t\t * allocated empty LEBs, so there will never be an attempt to\n\t\t * write to the free space at the end of an index LEB - except\n\t\t * by the in-the-gaps method for which it is not a problem.\n\t\t */\n\t\tfree = lp->free;\n\t\tdirty = lp->dirty;\n\t}\n\n\tif (lp->free != free || lp->dirty != dirty)\n\t\tgoto out_print;\n\n\tif (is_idx && !(lp->flags & LPROPS_INDEX)) {\n\t\tif (free == c->leb_size)\n\t\t\t/* Free but not unmapped LEB, it's fine */\n\t\t\tis_idx = 0;\n\t\telse {\n\t\t\tubifs_err(\"indexing node without indexing flag\");\n\t\t\tgoto out_print;\n\t\t}\n\t}\n\n\tif (!is_idx && (lp->flags & LPROPS_INDEX)) {\n\t\tubifs_err(\"data node with indexing flag\");\n\t\tgoto out_print;\n\t}\n\n\tif (free == c->leb_size)\n\t\tlst->empty_lebs += 1;\n\n\tif (is_idx)\n\t\tlst->idx_lebs += 1;\n\n\tif (!(lp->flags & LPROPS_INDEX))\n\t\tlst->total_used += c->leb_size - free - dirty;\n\tlst->total_free += free;\n\tlst->total_dirty += dirty;\n\n\tif (!(lp->flags & LPROPS_INDEX)) {\n\t\tint spc = free + dirty;\n\n\t\tif (spc < c->dead_wm)\n\t\t\tlst->total_dead += spc;\n\t\telse\n\t\t\tlst->total_dark += ubifs_calc_dark(c, spc);\n\t}\n\n\tubifs_scan_destroy(sleb);\n\tvfree(buf);\n\treturn LPT_SCAN_CONTINUE;\n\nout_print:\n\tubifs_err(\"bad accounting of LEB %d: free %d, dirty %d flags %#x, should be free %d, dirty %d\",\n\t\t  lnum, lp->free, lp->dirty, lp->flags, free, dirty);\n\tubifs_dump_leb(c, lnum);\nout_destroy:\n\tubifs_scan_destroy(sleb);\n\tret = -EINVAL;\nout:\n\tvfree(buf);\n\treturn ret;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "p(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "964-1015",
    "snippet": "k_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat,\n\t\t    int add_pos)\n{\n\tint i = 0, j, err = 0;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn;\n\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\t\tstruct ubifs_lprops *lp;\n\n\t\tif (i != add_pos)\n\t\t\tif ((lprops->flags & LPROPS_CAT_MASK) != cat) {\n\t\t\t\terr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (lprops->hpos != i) {\n\t\t\terr = 2;\n\t\t\tgoto out;\n\t\t}\n\t\tlp = ubifs_lpt_lookup(c, lprops->lnum);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = 3;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lprops != lp) {\n\t\t\tubifs_err(\"lprops %zx lp %zx lprops->lnum %d lp->lnum %d\",\n\t\t\t\t  (size_t)lprops, (size_t)lp, lprops->lnum,\n\t\t\t\t  lp->lnum);\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tlp = heap->arr[j];\n\t\t\tif (lp == lprops) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (lp->lnum == lprops->lnum) {\n\t\t\t\terr = 6;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (err) {\n\t\tubifs_err(\"failed cat %d hpos %d err %d\", cat, i, err);\n\t\tdump_stack();\n\t\tubifs_dump_heap(c, heap, cat);\n\t}\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ap(c, heap, cat",
          "args": [
            ";",
            "}\n}",
            "**"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_d",
          "args": [],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled cat",
          "args": [
            "d hpos %d err %d\", cat, i, err",
            "m",
            "sta"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops %zx",
          "args": [
            "p %zx lprops->lnum %d lp->lnum %d\",\n\t\t\t\t  (size",
            "s, (size_t)lp,",
            "props->lnu",
            "lp->l",
            "err = 4"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er",
          "args": [
            "="
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "torder_next(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "203-219",
          "snippet": "znode *ubifs_tnc_postorder_next(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(znode);\n\tif (unlikely(!znode->parent))\n\t\treturn NULL;\n\n\t/* Switch to the next index in the parent */\n\tzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\n\tif (!zn)\n\t\t/* This is in fact the last child, return parent */\n\t\treturn znode->parent;\n\n\t/* Go to the first znode in this new subtree */\n\treturn ubifs_tnc_postorder_first(zn);\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_tnc_postorder_next(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(znode);\n\tif (unlikely(!znode->parent))\n\t\treturn NULL;\n\n\t/* Switch to the next index in the parent */\n\tzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\n\tif (!zn)\n\t\t/* This is in fact the last child, return parent */\n\t\treturn znode->parent;\n\n\t/* Go to the first znode in this new subtree */\n\treturn ubifs_tnc_postorder_first(zn);\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "kup(c, lprops->l",
          "args": [
            "u",
            ";\n\t\tif (IS_E"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c) && !dbg_i",
          "args": [
            "_"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nk_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat,\n\t\t    int add_pos)\n{\n\tint i = 0, j, err = 0;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn;\n\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\t\tstruct ubifs_lprops *lp;\n\n\t\tif (i != add_pos)\n\t\t\tif ((lprops->flags & LPROPS_CAT_MASK) != cat) {\n\t\t\t\terr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (lprops->hpos != i) {\n\t\t\terr = 2;\n\t\t\tgoto out;\n\t\t}\n\t\tlp = ubifs_lpt_lookup(c, lprops->lnum);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = 3;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lprops != lp) {\n\t\t\tubifs_err(\"lprops %zx lp %zx lprops->lnum %d lp->lnum %d\",\n\t\t\t\t  (size_t)lprops, (size_t)lp, lprops->lnum,\n\t\t\t\t  lp->lnum);\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tlp = heap->arr[j];\n\t\t\tif (lp == lprops) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (lp->lnum == lprops->lnum) {\n\t\t\t\terr = 6;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (err) {\n\t\tubifs_err(\"failed cat %d hpos %d err %d\", cat, i, err);\n\t\tdump_stack();\n\t\tubifs_dump_heap(c, heap, cat);\n\t}\n}\n\n/**\n * scan"
  },
  {
    "function_name": "s(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "865-962",
    "snippet": "_cats(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct list_head *pos;\n\tint i, cat;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tif (lprops->free != c->leb_size) {\n\t\t\tubifs_err(\"non-empty LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(\"non-freeable LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti += 1;\n\t}\n\tif (i != c->freeable_cnt) {\n\t\tubifs_err(\"freeable list count %d expected %d\", i,\n\t\t\t  c->freeable_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tlist_for_each(pos, &c->idx_gc)\n\t\ti += 1;\n\tif (i != c->idx_gc_cnt) {\n\t\tubifs_err(\"idx_gc list count %d expected %d\", i,\n\t\t\t  c->idx_gc_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(\"non-freeable LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\t\tubifs_err(\"non-index LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (cat = 1; cat <= LPROPS_HEAP_CNT; cat++) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tfor (i = 0; i < heap->cnt; i++) {\n\t\t\tlprops = heap->arr[i];\n\t\t\tif (!lprops) {\n\t\t\t\tubifs_err(\"null ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->hpos != i) {\n\t\t\t\tubifs_err(\"bad ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\t\tubifs_err(\"taken LEB in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid dbg_ch",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ken LEB i",
          "args": [
            "LPT heap cat %d\", cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d ptr in",
          "args": [
            "PT heap cat %d\", cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll ptr in",
          "args": [
            "LPT heap cat %d\", cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n-index L",
          "args": [
            "B %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ken LEB %",
          "args": [
            "on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n-freeabl",
          "args": [
            "LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "rdi_id",
            "list, list) {\n\t\ti",
            "(lpr"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_gc list",
          "args": [
            "count %d expected %d\", i,\n\t\t\t  c->",
            "x",
            ");\n\t\treturn -"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(pos, &c->idx",
          "args": [
            "gc)",
            "i += 1;"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeable li",
          "args": [
            "t count %d expected %d\", i,\n\t\t\t  c->",
            "e",
            "nt);\n\t\treturn -"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ken LEB %",
          "args": [
            "on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n-freeabl",
          "args": [
            "LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "reeabl",
            "list, list) {\n\t\ti",
            "(lpr"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ken LEB %",
          "args": [
            "on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n-empty L",
          "args": [
            "B %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprop",
            "lprops->fre",
            "lprops->dir",
            ",\n\t\t\t\t  lprop",
            ");\n\t\t\treturn"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "mpty_l",
            "t, list) {\n\t\ti",
            "(lpr"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c) && !dbg_i",
          "args": [
            "_"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\n_cats(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct list_head *pos;\n\tint i, cat;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tif (lprops->free != c->leb_size) {\n\t\t\tubifs_err(\"non-empty LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(\"non-freeable LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti += 1;\n\t}\n\tif (i != c->freeable_cnt) {\n\t\tubifs_err(\"freeable list count %d expected %d\", i,\n\t\t\t  c->freeable_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tlist_for_each(pos, &c->idx_gc)\n\t\ti += 1;\n\tif (i != c->idx_gc_cnt) {\n\t\tubifs_err(\"idx_gc list count %d expected %d\", i,\n\t\t\t  c->idx_gc_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(\"non-freeable LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(\"taken LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\t\tubifs_err(\"non-index LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (cat = 1; cat <= LPROPS_HEAP_CNT; cat++) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tfor (i = 0; i < heap->cnt; i++) {\n\t\t\tlprops = heap->arr[i];\n\t\t\tif (!lprops) {\n\t\t\t\tubifs_err(\"null ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->hpos != i) {\n\t\t\t\tubifs_err(\"bad ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\t\tubifs_err(\"taken LEB in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid dbg_ch"
  },
  {
    "function_name": "nd_frdi_idx(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "839-853",
    "snippet": "ubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->frdi_idx_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->frdi_idx_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert((lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\treturn lprops;\n}\n\n/*\n * Every",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "+ lprops->dirty == c->leb_size);\n\treturn lp"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(lprops->fla",
          "args": [
            "s & LPROPS_INDEX));\n\tubifs_ass"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">frdi_idx_",
          "args": [
            "ist.next, struct ubif",
            "lprops list);\n\tubi",
            "_ass"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->frdi_idx",
          "args": [
            "list))\n\t\treturn N"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "nd_frdi_idx(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
          "lines": "839-853",
          "snippet": "ubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->frdi_idx_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->frdi_idx_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert((lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\treturn lprops;\n}\n\n/*\n * Every",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->lp_mutex));\n\n\tif (list"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->lp_mutex",
          "args": [
            ");\n\n\tif (lis"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->frdi_idx_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->frdi_idx_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert((lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\treturn lprops;\n}\n\n/*\n * Every"
  },
  {
    "function_name": "nd_freeable(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "815-830",
    "snippet": "ubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->freeable_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->freeable_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(c->freeable_cnt > 0);\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->freeable_",
          "args": [
            "nt > 0);\n\treturn lp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "+ lprops->dirty == c->leb_size);\n\tubifs_ass"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\tubifs_ass"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">freeable_",
          "args": [
            "ist.next, struct ubif",
            "lprops list);\n\tubi",
            "_ass"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->freeable",
          "args": [
            "list))\n\t\treturn N"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "nd_freeable(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
          "lines": "815-830",
          "snippet": "ubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->freeable_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->freeable_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(c->freeable_cnt > 0);\n\treturn lprops;\n}\n\n/**\n * ubif",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->lp_mutex));\n\n\tif (list"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->lp_mutex",
          "args": [
            ");\n\n\tif (lis"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->freeable_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->freeable_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(c->freeable_cnt > 0);\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "nd_empty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "792-806",
    "snippet": "ubifs_lprops *ubifs_fast_find_empty(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->empty_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->empty_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free == c->leb_size);\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "== c->leb_size);\n\treturn lp"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\tubifs_ass"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">empty_lis",
          "args": [
            ".next, struct ubif",
            "lprops list);\n\tubi",
            "_ass"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->empty_li",
          "args": [
            "t))\n\t\treturn N"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->lp_mutex));\n\n\tif (list"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->lp_mutex",
          "args": [
            ");\n\n\tif (lis"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nubifs_lprops *ubifs_fast_find_empty(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->empty_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->empty_list.next, struct ubifs_lprops, list);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(lprops->free == c->leb_size);\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "nd_free(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "768-783",
    "snippet": "ubifs_lprops *ubifs_fast_find_free(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tif (heap->cnt == 0)\n\t\treturn NULL;\n\n\tlprops = heap->arr[0];\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\treturn lp"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->lp_mutex));\n\n\theap = &"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->lp_mutex",
          "args": [
            ");\n\n\theap ="
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nubifs_lprops *ubifs_fast_find_free(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tif (heap->cnt == 0)\n\t\treturn NULL;\n\n\tlprops = heap->arr[0];\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "e_lp(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "739-759",
    "snippet": "d_one_lp(struct ubifs_info *c, int lnum, struct ubifs_lprops *lp)\n{\n\tint err = 0;\n\tconst struct ubifs_lprops *lpp;\n\n\tubifs_get_lprops(c);\n\n\tlpp = ubifs_lpt_lookup(c, lnum);\n\tif (IS_ERR(lpp)) {\n\t\terr = PTR_ERR(lpp);\n\t\tubifs_err(\"cannot read properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\t\tgoto out;\n\t}\n\n\tmemcpy(lp, lpp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, siz",
          "args": [
            "of",
            "tru",
            "ubifs_lprops));\n\nout:\n\tubi"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "properties of LEB %d, error %d\",\n\t\t\t  lnum,",
            "got",
            "out"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubif",
          "args": [
            "_er"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ops(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
          "lines": "1266-1321",
          "snippet": "_lprops(struct ubifs_info *c)\n{\n\tint i, err;\n\tstruct ubifs_lp_stats lst;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/*\n\t * As we are going to scan the media, the write buffers have to be\n\t * synchronized.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\n\terr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_check_cb,\n\t\t\t\t    &lst);\n\tif (err && err != -ENOSPC)\n\t\tgoto out;\n\n\tif (lst.empty_lebs != c->lst.empty_lebs ||\n\t    lst.idx_lebs != c->lst.idx_lebs ||\n\t    lst.total_free != c->lst.total_free ||\n\t    lst.total_dirty != c->lst.total_dirty ||\n\t    lst.total_used != c->lst.total_used) {\n\t\tubifs_err(\"bad overall accounting\");\n\t\tubifs_err(\"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.empty_lebs, lst.idx_lebs, lst.total_free,\n\t\t\t  lst.total_dirty, lst.total_used);\n\t\tubifs_err(\"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\n\t\t\t  c->lst.total_dirty, c->lst.total_used);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lst.total_dead != c->lst.total_dead ||\n\t    lst.total_dark != c->lst.total_dark) {\n\t\tubifs_err(\"bad dead/dark space accounting\");\n\t\tubifs_err(\"calculated: total_dead %lld, total_dark %lld\",\n\t\t\t  lst.total_dead, lst.total_dark);\n\t\tubifs_err(\"read from lprops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst.total_dead, c->lst.total_dark);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = dbg_check_cats(c);\nout:\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * get_h"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\n_lprops(struct ubifs_info *c)\n{\n\tint i, err;\n\tstruct ubifs_lp_stats lst;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/*\n\t * As we are going to scan the media, the write buffers have to be\n\t * synchronized.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\n\terr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_check_cb,\n\t\t\t\t    &lst);\n\tif (err && err != -ENOSPC)\n\t\tgoto out;\n\n\tif (lst.empty_lebs != c->lst.empty_lebs ||\n\t    lst.idx_lebs != c->lst.idx_lebs ||\n\t    lst.total_free != c->lst.total_free ||\n\t    lst.total_dirty != c->lst.total_dirty ||\n\t    lst.total_used != c->lst.total_used) {\n\t\tubifs_err(\"bad overall accounting\");\n\t\tubifs_err(\"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.empty_lebs, lst.idx_lebs, lst.total_free,\n\t\t\t  lst.total_dirty, lst.total_used);\n\t\tubifs_err(\"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\n\t\t\t  c->lst.total_dirty, c->lst.total_used);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lst.total_dead != c->lst.total_dead ||\n\t    lst.total_dark != c->lst.total_dark) {\n\t\tubifs_err(\"bad dead/dark space accounting\");\n\t\tubifs_err(\"calculated: total_dead %lld, total_dark %lld\",\n\t\t\t  lst.total_dead, lst.total_dark);\n\t\tubifs_err(\"read from lprops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst.total_dead, c->lst.total_dark);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = dbg_check_cats(c);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "{\n\t\ter",
          "args": [
            "="
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, lnum);\n\ti",
          "args": [
            "S_ER"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlpp =",
          "args": [
            "b"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nd_one_lp(struct ubifs_info *c, int lnum, struct ubifs_lprops *lp)\n{\n\tint err = 0;\n\tconst struct ubifs_lprops *lpp;\n\n\tubifs_get_lprops(c);\n\n\tlpp = ubifs_lpt_lookup(c, lnum);\n\tif (IS_ERR(lpp)) {\n\t\terr = PTR_ERR(lpp);\n\t\tubifs_err(\"cannot read properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\t\tgoto out;\n\t}\n\n\tmemcpy(lp, lpp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "one_lp(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "702-727",
    "snippet": "ate_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, lp->dirty + dirty, flags, 0);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(\"cannot update properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot upda",
          "args": [
            "e properties of LEB %d, error %d\",\n\t\t\t  lnum,",
            "retu",
            "er"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lprops(c);\n\tif (err",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out:",
          "args": [
            "bi"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_mstimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1557-1566",
          "snippet": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err =",
          "args": [
            "PT"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lp, free,",
          "args": [
            "l",
            ">d",
            "ty +",
            "irty, flags, 0);",
            "f (IS",
            "R"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, lnum);\n\ti",
          "args": [
            "S_ER"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlp = u",
          "args": [
            "i"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nate_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, lp->dirty + dirty, flags, 0);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(\"cannot update properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "one_lp(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "663-688",
    "snippet": "nge_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean, int idx_gc_cnt)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, dirty, flags, idx_gc_cnt);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(\"cannot change properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot chan",
          "args": [
            "e properties of LEB %d, error %d\",\n\t\t\t  lnum,",
            "retu",
            "er"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lprops(c);\n\tif (err",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out:",
          "args": [
            "bi"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_mstimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1557-1566",
          "snippet": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err =",
          "args": [
            "PT"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lp, free,",
          "args": [
            "d",
            "ty",
            "flag",
            "idx_",
            "_cnt)",
            "if (IS_ER"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, lnum);\n\ti",
          "args": [
            "S_ER"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlp = u",
          "args": [
            "i"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nnge_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean, int idx_gc_cnt)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, dirty, flags, idx_gc_cnt);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(\"cannot change properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "stats(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "641-646",
    "snippet": "t_lp_stats(struct ubifs_info *c, struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&c->space_lock);\n\tmemcpy(lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n}\n\n/**\n *"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst",
          "args": [
            "si",
            "of(stru",
            "ubifs_lp_stats));\n\tspin_unlo"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tmemcpy(ls"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nt_lp_stats(struct ubifs_info *c, struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&c->space_lock);\n\tmemcpy(lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "lp(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "534-634",
    "snippet": "ubifs_lprops *ubifs_change_lp(struct ubifs_info *c,\n\t\t\t\t\t   const struct ubifs_lprops *lp,\n\t\t\t\t\t   int free, int dirty, int flags,\n\t\t\t\t\t   int idx_gc_cnt)\n{\n\t/*\n\t * This is the only function that is allowed to change lprops, so we\n\t * discard the \"const\" qualifier.\n\t */\n\tstruct ubifs_lprops *lprops = (struct ubifs_lprops *)lp;\n\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\",\n\t       lprops->lnum, free, dirty, flags);\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\tubifs_assert(c->lst.empty_lebs >= 0 &&\n\t\t     c->lst.empty_lebs <= c->main_lebs);\n\tubifs_assert(c->freeable_cnt >= 0);\n\tubifs_assert(c->freeable_cnt <= c->main_lebs);\n\tubifs_assert(c->lst.taken_empty_lebs >= 0);\n\tubifs_assert(c->lst.taken_empty_lebs <= c->lst.empty_lebs);\n\tubifs_assert(!(c->lst.total_free & 7) && !(c->lst.total_dirty & 7));\n\tubifs_assert(!(c->lst.total_dead & 7) && !(c->lst.total_dark & 7));\n\tubifs_assert(!(c->lst.total_used & 7));\n\tubifs_assert(free == LPROPS_NC || free >= 0);\n\tubifs_assert(dirty == LPROPS_NC || dirty >= 0);\n\n\tif (!is_lprops_dirty(c, lprops)) {\n\t\tlprops = ubifs_lpt_lookup_dirty(c, lprops->lnum);\n\t\tif (IS_ERR(lprops))\n\t\t\treturn lprops;\n\t} else\n\t\tubifs_assert(lprops == ubifs_lpt_lookup_dirty(c, lprops->lnum));\n\n\tubifs_assert(!(lprops->free & 7) && !(lprops->dirty & 7));\n\n\tspin_lock(&c->space_lock);\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs -= 1;\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint old_spc;\n\n\t\told_spc = lprops->free + lprops->dirty;\n\t\tif (old_spc < c->dead_wm)\n\t\t\tc->lst.total_dead -= old_spc;\n\t\telse\n\t\t\tc->lst.total_dark -= ubifs_calc_dark(c, old_spc);\n\n\t\tc->lst.total_used -= c->leb_size - old_spc;\n\t}\n\n\tif (free != LPROPS_NC) {\n\t\tfree = ALIGN(free, 8);\n\t\tc->lst.total_free += free - lprops->free;\n\n\t\t/* Increase or decrease empty LEBs counter if needed */\n\t\tif (free == c->leb_size) {\n\t\t\tif (lprops->free != c->leb_size)\n\t\t\t\tc->lst.empty_lebs += 1;\n\t\t} else if (lprops->free == c->leb_size)\n\t\t\tc->lst.empty_lebs -= 1;\n\t\tlprops->free = free;\n\t}\n\n\tif (dirty != LPROPS_NC) {\n\t\tdirty = ALIGN(dirty, 8);\n\t\tc->lst.total_dirty += dirty - lprops->dirty;\n\t\tlprops->dirty = dirty;\n\t}\n\n\tif (flags != LPROPS_NC) {\n\t\t/* Take care about indexing LEBs counter if needed */\n\t\tif ((lprops->flags & LPROPS_INDEX)) {\n\t\t\tif (!(flags & LPROPS_INDEX))\n\t\t\t\tc->lst.idx_lebs -= 1;\n\t\t} else if (flags & LPROPS_INDEX)\n\t\t\tc->lst.idx_lebs += 1;\n\t\tlprops->flags = flags;\n\t}\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint new_spc;\n\n\t\tnew_spc = lprops->free + lprops->dirty;\n\t\tif (new_spc < c->dead_wm)\n\t\t\tc->lst.total_dead += new_spc;\n\t\telse\n\t\t\tc->lst.total_dark += ubifs_calc_dark(c, new_spc);\n\n\t\tc->lst.total_used += c->leb_size - new_spc;\n\t}\n\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs += 1;\n\n\tchange_category(c, lprops);\n\tc->idx_gc_cnt += idx_gc_cnt;\n\tspin_unlock(&c->space_lock);\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\treturn lp"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ry(c, lprops);",
          "args": [
            "c",
            "idx_gc"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, new_spc);",
          "args": [
            "c->lst."
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "8);",
          "args": [
            "c->ls",
            "t"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "->ls",
            "t"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, old_spc);",
          "args": [
            "c->lst."
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tif ((lpro"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fr",
          "args": [
            "e & 7) && !(lprops->dirty & 7));\n\n\tspin_loc"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops == ub",
          "args": [
            "fs_lpt_lookup_dirty(c, lprops->lnum));\n\n\tubifs_as"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, lprops->l",
          "args": [
            "u",
            ");\n\n\tubifs_a"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))",
          "args": [
            "eturn"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, lprops->l",
          "args": [
            "u",
            ";\n\t\tif (IS_E"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c, lprops))",
          "args": [
            "lprops"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty == LPR",
          "args": [
            "PS_NC || dirty >= 0);\n\n\tif (!is_"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free == LPRO",
          "args": [
            "S_NC || free >= 0);\n\tubifs_ass"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->lst.tot",
          "args": [
            "l_used & 7));\n\tubifs_ass"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->lst.tot",
          "args": [
            "l_dead & 7) && !(c->lst.total_dark & 7));\n\tubifs_ass"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->lst.tot",
          "args": [
            "l_free & 7) && !(c->lst.total_dirty & 7));\n\tubifs_ass"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst.taken",
          "args": [
            "empty_lebs <= c->lst.empty_lebs);\n\tubifs_ass"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst.taken",
          "args": [
            "empty_lebs >= 0);\n\tubifs_ass"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->freeable_",
          "args": [
            "nt <= c->main_lebs);\n\tubifs_ass"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->freeable_",
          "args": [
            "nt >= 0);\n\tubifs_ass"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst.empty",
          "args": [
            "lebs >= 0 &&\n\t\t     c->lst.empty_lebs <= c->main_lebs);\n\tubifs_ass"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->lp_mutex));\n\tubifs_ass"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->lp_mutex",
          "args": [
            ");\n\tubifs_as"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d, fre",
          "args": [
            "%d, dirty %d, flags %d\",\n\t       lpr",
            "free, dirty",
            "flag",
            ";\n\n\tu",
            "fs_as"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nubifs_lprops *ubifs_change_lp(struct ubifs_info *c,\n\t\t\t\t\t   const struct ubifs_lprops *lp,\n\t\t\t\t\t   int free, int dirty, int flags,\n\t\t\t\t\t   int idx_gc_cnt)\n{\n\t/*\n\t * This is the only function that is allowed to change lprops, so we\n\t * discard the \"const\" qualifier.\n\t */\n\tstruct ubifs_lprops *lprops = (struct ubifs_lprops *)lp;\n\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\",\n\t       lprops->lnum, free, dirty, flags);\n\n\tubifs_assert(mutex_is_locked(&c->lp_mutex));\n\tubifs_assert(c->lst.empty_lebs >= 0 &&\n\t\t     c->lst.empty_lebs <= c->main_lebs);\n\tubifs_assert(c->freeable_cnt >= 0);\n\tubifs_assert(c->freeable_cnt <= c->main_lebs);\n\tubifs_assert(c->lst.taken_empty_lebs >= 0);\n\tubifs_assert(c->lst.taken_empty_lebs <= c->lst.empty_lebs);\n\tubifs_assert(!(c->lst.total_free & 7) && !(c->lst.total_dirty & 7));\n\tubifs_assert(!(c->lst.total_dead & 7) && !(c->lst.total_dark & 7));\n\tubifs_assert(!(c->lst.total_used & 7));\n\tubifs_assert(free == LPROPS_NC || free >= 0);\n\tubifs_assert(dirty == LPROPS_NC || dirty >= 0);\n\n\tif (!is_lprops_dirty(c, lprops)) {\n\t\tlprops = ubifs_lpt_lookup_dirty(c, lprops->lnum);\n\t\tif (IS_ERR(lprops))\n\t\t\treturn lprops;\n\t} else\n\t\tubifs_assert(lprops == ubifs_lpt_lookup_dirty(c, lprops->lnum));\n\n\tubifs_assert(!(lprops->free & 7) && !(lprops->dirty & 7));\n\n\tspin_lock(&c->space_lock);\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs -= 1;\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint old_spc;\n\n\t\told_spc = lprops->free + lprops->dirty;\n\t\tif (old_spc < c->dead_wm)\n\t\t\tc->lst.total_dead -= old_spc;\n\t\telse\n\t\t\tc->lst.total_dark -= ubifs_calc_dark(c, old_spc);\n\n\t\tc->lst.total_used -= c->leb_size - old_spc;\n\t}\n\n\tif (free != LPROPS_NC) {\n\t\tfree = ALIGN(free, 8);\n\t\tc->lst.total_free += free - lprops->free;\n\n\t\t/* Increase or decrease empty LEBs counter if needed */\n\t\tif (free == c->leb_size) {\n\t\t\tif (lprops->free != c->leb_size)\n\t\t\t\tc->lst.empty_lebs += 1;\n\t\t} else if (lprops->free == c->leb_size)\n\t\t\tc->lst.empty_lebs -= 1;\n\t\tlprops->free = free;\n\t}\n\n\tif (dirty != LPROPS_NC) {\n\t\tdirty = ALIGN(dirty, 8);\n\t\tc->lst.total_dirty += dirty - lprops->dirty;\n\t\tlprops->dirty = dirty;\n\t}\n\n\tif (flags != LPROPS_NC) {\n\t\t/* Take care about indexing LEBs counter if needed */\n\t\tif ((lprops->flags & LPROPS_INDEX)) {\n\t\t\tif (!(flags & LPROPS_INDEX))\n\t\t\t\tc->lst.idx_lebs -= 1;\n\t\t} else if (flags & LPROPS_INDEX)\n\t\t\tc->lst.idx_lebs += 1;\n\t\tlprops->flags = flags;\n\t}\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint new_spc;\n\n\t\tnew_spc = lprops->free + lprops->dirty;\n\t\tif (new_spc < c->dead_wm)\n\t\t\tc->lst.total_dead += new_spc;\n\t\telse\n\t\t\tc->lst.total_dark += ubifs_calc_dark(c, new_spc);\n\n\t\tc->lst.total_used += c->leb_size - new_spc;\n\t}\n\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs += 1;\n\n\tchange_category(c, lprops);\n\tc->idx_gc_cnt += idx_gc_cnt;\n\tspin_unlock(&c->space_lock);\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "504-515",
    "snippet": "_lprops_dirty(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tstruct ubifs_pnode *pnode;\n\tint pos;\n\n\tpos = (lprops->lnum - c->main_first) & (UBIFS_LPT_FANOUT - 1);\n\tpnode = (struct ubifs_pnode *)container_of(lprops - pos,\n\t\t\t\t\t\t   struct ubifs_pnode,\n\t\t\t\t\t\t   lprops[0]);\n\treturn !test_bit(COW_CNODE, &pnode->flags) &&\n\t       test_bit(DIRTY_CNODE, &pnode->flags);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&pnode->fla",
            ");\n}\n\n/**\n *"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNODE, &",
          "args": [
            "node->fla",
            ") &&"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops - pos",
          "args": [
            "st",
            "pnode,\t\t\t\t\t\t   lp",
            "return !t"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\n_lprops_dirty(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tstruct ubifs_pnode *pnode;\n\tint pos;\n\n\tpos = (lprops->lnum - c->main_first) & (UBIFS_LPT_FANOUT - 1);\n\tpnode = (struct ubifs_pnode *)container_of(lprops - pos,\n\t\t\t\t\t\t   struct ubifs_pnode,\n\t\t\t\t\t\t   lprops[0]);\n\treturn !test_bit(COW_CNODE, &pnode->flags) &&\n\t       test_bit(DIRTY_CNODE, &pnode->flags);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "rk(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "481-497",
    "snippet": "c_dark(const struct ubifs_info *c, int spc)\n{\n\tubifs_assert(!(spc & 7));\n\n\tif (spc < c->dark_wm)\n\t\treturn spc;\n\n\t/*\n\t * If we have slightly more space then the dark space watermark, we can\n\t * anyway safely assume it we'll be able to write a node of the\n\t * smallest size there.\n\t */\n\tif (spc - c->dark_wm < MIN_WRITE_SZ)\n\t\treturn spc - MIN_WRITE_SZ;\n\n\treturn c->dark_wm;\n}\n\n/**\n * is_l",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!(spc & 7));",
          "args": [
            "if (spc"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nc_dark(const struct ubifs_info *c, int spc)\n{\n\tubifs_assert(!(spc & 7));\n\n\tif (spc < c->dark_wm)\n\t\treturn spc;\n\n\t/*\n\t * If we have slightly more space then the dark space watermark, we can\n\t * anyway safely assume it we'll be able to write a node of the\n\t * smallest size there.\n\t */\n\tif (spc - c->dark_wm < MIN_WRITE_SZ)\n\t\treturn spc - MIN_WRITE_SZ;\n\n\treturn c->dark_wm;\n}\n\n/**\n * is_l"
  },
  {
    "function_name": "ry(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "450-467",
    "snippet": "hange_category(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint old_cat = lprops->flags & LPROPS_CAT_MASK;\n\tint new_cat = ubifs_categorize_lprops(c, lprops);\n\n\tif (old_cat == new_cat) {\n\t\tstruct ubifs_lpt_heap *heap;\n\n\t\t/* lprops on a heap now must be moved up or down */\n\t\tif (new_cat < 1 || new_cat > LPROPS_HEAP_CNT)\n\t\t\treturn; /* Not on a heap */\n\t\theap = &c->lpt_heap[new_cat - 1];\n\t\tadjust_lpt_heap(c, heap, lprops, lprops->hpos, new_cat);\n\t} else {\n\t\tubifs_remove_from_cat(c, lprops, old_cat);\n\t\tubifs_add_to_cat(c, lprops, new_cat);\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cat(c, lprops, n",
          "args": [
            "w",
            "at);",
            "}\n\n/**"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_cat(c, lprops, o",
          "args": [
            "d",
            "at);",
            "bifs_ad"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, heap, lpr",
          "args": [
            "p",
            "lpr",
            "s->hpo",
            "new_cat);",
            "else {"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lprops);",
          "args": [
            "(old_"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nhange_category(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint old_cat = lprops->flags & LPROPS_CAT_MASK;\n\tint new_cat = ubifs_categorize_lprops(c, lprops);\n\n\tif (old_cat == new_cat) {\n\t\tstruct ubifs_lpt_heap *heap;\n\n\t\t/* lprops on a heap now must be moved up or down */\n\t\tif (new_cat < 1 || new_cat > LPROPS_HEAP_CNT)\n\t\t\treturn; /* Not on a heap */\n\t\theap = &c->lpt_heap[new_cat - 1];\n\t\tadjust_lpt_heap(c, heap, lprops, lprops->hpos, new_cat);\n\t} else {\n\t\tubifs_remove_from_cat(c, lprops, old_cat);\n\t\tubifs_add_to_cat(c, lprops, new_cat);\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ize_lprops(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "410-440",
    "snippet": "egorize_lprops(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops)\n{\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPROPS_UNCAT;\n\n\tif (lprops->free == c->leb_size) {\n\t\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\t\treturn LPROPS_EMPTY;\n\t}\n\n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\treturn LPROPS_FRDI_IDX;\n\t\telse\n\t\t\treturn LPROPS_FREEABLE;\n\t}\n\n\tif (lprops->flags & LPROPS_INDEX) {\n\t\tif (lprops->dirty + lprops->free >= c->min_idx_node_sz)\n\t\t\treturn LPROPS_DIRTY_IDX;\n\t} else {\n\t\tif (lprops->dirty >= c->dead_wm &&\n\t\t    lprops->dirty > lprops->free)\n\t\t\treturn LPROPS_DIRTY;\n\t\tif (lprops->free > 0)\n\t\t\treturn LPROPS_FREE;\n\t}\n\n\treturn LPROPS_UNCAT;\n}\n\n/**\n * chan",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\t\treturn L"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\negorize_lprops(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops)\n{\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPROPS_UNCAT;\n\n\tif (lprops->free == c->leb_size) {\n\t\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\t\treturn LPROPS_EMPTY;\n\t}\n\n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\treturn LPROPS_FRDI_IDX;\n\t\telse\n\t\t\treturn LPROPS_FREEABLE;\n\t}\n\n\tif (lprops->flags & LPROPS_INDEX) {\n\t\tif (lprops->dirty + lprops->free >= c->min_idx_node_sz)\n\t\t\treturn LPROPS_DIRTY_IDX;\n\t} else {\n\t\tif (lprops->dirty >= c->dead_wm &&\n\t\t    lprops->dirty > lprops->free)\n\t\t\treturn LPROPS_DIRTY;\n\t\tif (lprops->free > 0)\n\t\t\treturn LPROPS_FREE;\n\t}\n\n\treturn LPROPS_UNCAT;\n}\n\n/**\n * chan"
  },
  {
    "function_name": "cat(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "387-398",
    "snippet": "sure_cat(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint cat = lprops->flags & LPROPS_CAT_MASK;\n\n\tif (cat != LPROPS_UNCAT)\n\t\treturn;\n\tcat = ubifs_categorize_lprops(c, lprops);\n\tif (cat == LPROPS_UNCAT)\n\t\treturn;\n\tubifs_remove_from_cat(c, lprops, LPROPS_UNCAT);\n\tubifs_add_to_cat(c, lprops, cat);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cat(c, lprops, c",
          "args": [
            "t",
            "}\n\n/*",
            "*"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_cat(c, lprops, L",
          "args": [
            "R",
            "S_UNCA",
            ";\n\tubifs_add"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lprops);",
          "args": [
            "i",
            "(cat ="
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nsure_cat(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint cat = lprops->flags & LPROPS_CAT_MASK;\n\n\tif (cat != LPROPS_UNCAT)\n\t\treturn;\n\tcat = ubifs_categorize_lprops(c, lprops);\n\tif (cat == LPROPS_UNCAT)\n\t\treturn;\n\tubifs_remove_from_cat(c, lprops, LPROPS_UNCAT);\n\tubifs_add_to_cat(c, lprops, cat);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_cat(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "355-376",
    "snippet": "place_cat(struct ubifs_info *c, struct ubifs_lprops *old_lprops,\n\t\t       struct ubifs_lprops *new_lprops)\n{\n\tint cat;\n\n\tcat = new_lprops->flags & LPROPS_CAT_MASK;\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tlpt_heap_replace(c, old_lprops, new_lprops, cat);\n\t\tbreak;\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FREEABLE:\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_replace(&old_lprops->list, &new_lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "0);\n\t}\n}\n\n/*",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&old_lprops-",
          "args": [
            "list, &new_lprops",
            "list);\n\t\tbreak;"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ace(c, old_lprop",
          "args": [
            ",",
            "ew_lprops,",
            "at);\n\t\tbre",
            ";"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nplace_cat(struct ubifs_info *c, struct ubifs_lprops *old_lprops,\n\t\t       struct ubifs_lprops *new_lprops)\n{\n\tint cat;\n\n\tcat = new_lprops->flags & LPROPS_CAT_MASK;\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tlpt_heap_replace(c, old_lprops, new_lprops, cat);\n\t\tbreak;\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FREEABLE:\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_replace(&old_lprops->list, &new_lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "from_cat(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "318-343",
    "snippet": "bifs_remove_from_cat(struct ubifs_info *c,\n\t\t\t\t  struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tremove_from_lpt_heap(c, lprops, cat);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tc->freeable_cnt -= 1;\n\t\tubifs_assert(c->freeable_cnt >= 0);\n\t\t/* Fall through */\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FRDI_IDX:\n\t\tubifs_assert(!list_empty(&lprops->list));\n\t\tlist_del(&lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n\n\tc->in_a_category_cnt -= 1;\n\tubifs_assert(c->in_a_category_cnt >= 0);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->in_a_cate",
          "args": [
            "ory_cnt >= 0);\n}\n\n/**\n *"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);\n\t}\n\n\tc->",
          "args": [
            "n"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->lis",
          "args": [
            ");\n\t\tbreak;"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!list_empty(",
          "args": [
            "lprops->list));\n\t\tlist_del"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "props->lis",
          "args": [
            "));\n\t\tlist_de"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->freeable_",
          "args": [
            "nt >= 0);\n\t\t/* Fall"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_heap(c, lprops, c",
          "args": [
            "t",
            "bre",
            ";"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nbifs_remove_from_cat(struct ubifs_info *c,\n\t\t\t\t  struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tremove_from_lpt_heap(c, lprops, cat);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tc->freeable_cnt -= 1;\n\t\tubifs_assert(c->freeable_cnt >= 0);\n\t\t/* Fall through */\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FRDI_IDX:\n\t\tubifs_assert(!list_empty(&lprops->list));\n\t\tlist_del(&lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n\n\tc->in_a_category_cnt -= 1;\n\tubifs_assert(c->in_a_category_cnt >= 0);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "cat(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "275-308",
    "snippet": "d_to_cat(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t      int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tif (add_to_lpt_heap(c, lprops, cat))\n\t\t\tbreak;\n\t\t/* No more room on heap so make it un-categorized */\n\t\tcat = LPROPS_UNCAT;\n\t\t/* Fall through */\n\tcase LPROPS_UNCAT:\n\t\tlist_add(&lprops->list, &c->uncat_list);\n\t\tbreak;\n\tcase LPROPS_EMPTY:\n\t\tlist_add(&lprops->list, &c->empty_list);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tlist_add(&lprops->list, &c->freeable_list);\n\t\tc->freeable_cnt += 1;\n\t\tbreak;\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_add(&lprops->list, &c->frdi_idx_list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n\n\tlprops->flags &= ~LPROPS_CAT_MASK;\n\tlprops->flags |= cat;\n\tc->in_a_category_cnt += 1;\n\tubifs_assert(c->in_a_category_cnt <= c->main_lebs);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->in_a_cate",
          "args": [
            "ory_cnt <= c->main_lebs);\n}\n\n/**\n *"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);\n\t}\n\n\tlpr",
          "args": [
            "p"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->lis",
          "args": [
            ", &c->frdi_id",
            "list);\n\t\tbreak;"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->lis",
          "args": [
            ", &c->freeabl",
            "list);\n\t\tc->freea"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->lis",
          "args": [
            ", &c->empty_l",
            "t);\n\t\tbreak;"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->lis",
          "args": [
            ", &c->uncat_l",
            "t);\n\t\tbreak;"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lprops, c",
          "args": [
            "t",
            "br",
            "k;"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nd_to_cat(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t      int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tif (add_to_lpt_heap(c, lprops, cat))\n\t\t\tbreak;\n\t\t/* No more room on heap so make it un-categorized */\n\t\tcat = LPROPS_UNCAT;\n\t\t/* Fall through */\n\tcase LPROPS_UNCAT:\n\t\tlist_add(&lprops->list, &c->uncat_list);\n\t\tbreak;\n\tcase LPROPS_EMPTY:\n\t\tlist_add(&lprops->list, &c->empty_list);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tlist_add(&lprops->list, &c->freeable_list);\n\t\tc->freeable_cnt += 1;\n\t\tbreak;\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_add(&lprops->list, &c->frdi_idx_list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(0);\n\t}\n\n\tlprops->flags &= ~LPROPS_CAT_MASK;\n\tlprops->flags |= cat;\n\tc->in_a_category_cnt += 1;\n\tubifs_assert(c->in_a_category_cnt <= c->main_lebs);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ace(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "256-265",
    "snippet": "pt_heap_replace(struct ubifs_info *c,\n\t\t\t     struct ubifs_lprops *old_lprops,\n\t\t\t     struct ubifs_lprops *new_lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = new_lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\theap->arr[hpos] = new_lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\npt_heap_replace(struct ubifs_info *c,\n\t\t\t     struct ubifs_lprops *old_lprops,\n\t\t\t     struct ubifs_lprops *new_lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = new_lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\theap->arr[hpos] = new_lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "pt_heap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "226-242",
    "snippet": "emove_from_lpt_heap(struct ubifs_info *c,\n\t\t\t\t struct ubifs_lprops *lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\tubifs_assert(hpos >= 0 && hpos < heap->cnt);\n\tubifs_assert(heap->arr[hpos] == lprops);\n\theap->cnt -= 1;\n\tif (hpos < heap->cnt) {\n\t\theap->arr[hpos] = heap->arr[heap->cnt];\n\t\theap->arr[hpos]->hpos = hpos;\n\t\tadjust_lpt_heap(c, heap, heap->arr[hpos], hpos, cat);\n\t}\n\tdbg_check_heap(c, heap, cat, -1);\n}\n\n/**\n * lpt_",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p(c, heap, cat",
          "args": [
            ");\n}",
            "/**",
            "*"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, heap, hea",
          "args": [
            "-",
            "rr[h",
            "s], hpos, cat);",
            "}\n\td",
            "_ch"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap->arr[hp",
          "args": [
            "s] == lprops);\n\theap->cnt"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpos >= 0 &&",
          "args": [
            "hpos < heap->cnt);\n\tubifs_ass"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nemove_from_lpt_heap(struct ubifs_info *c,\n\t\t\t\t struct ubifs_lprops *lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\tubifs_assert(hpos >= 0 && hpos < heap->cnt);\n\tubifs_assert(heap->arr[hpos] == lprops);\n\theap->cnt -= 1;\n\tif (hpos < heap->cnt) {\n\t\theap->arr[hpos] = heap->arr[heap->cnt];\n\t\theap->arr[hpos]->hpos = hpos;\n\t\tadjust_lpt_heap(c, heap, heap->arr[hpos], hpos, cat);\n\t}\n\tdbg_check_heap(c, heap, cat, -1);\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "ap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "178-218",
    "snippet": "d_to_lpt_heap(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t\t   int cat)\n{\n\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\tif (heap->cnt >= heap->max_cnt) {\n\t\tconst int b = LPT_HEAP_SZ / 2 - 1;\n\t\tint cpos, val1, val2;\n\n\t\t/* Compare to some other LEB on the bottom of heap */\n\t\t/* Pick a position kind of randomly */\n\t\tcpos = (((size_t)lprops >> 4) & b) + b;\n\t\tubifs_assert(cpos >= b);\n\t\tubifs_assert(cpos < LPT_HEAP_SZ);\n\t\tubifs_assert(cpos < heap->cnt);\n\n\t\tval1 = get_heap_comp_val(lprops, cat);\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 > val2) {\n\t\t\tstruct ubifs_lprops *lp;\n\n\t\t\tlp = heap->arr[cpos];\n\t\t\tlp->flags &= ~LPROPS_CAT_MASK;\n\t\t\tlp->flags |= LPROPS_UNCAT;\n\t\t\tlist_add(&lp->list, &c->uncat_list);\n\t\t\tlprops->hpos = cpos;\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\t\treturn 1; /* Added to heap */\n\t\t}\n\t\tdbg_check_heap(c, heap, cat, -1);\n\t\treturn 0; /* Not added to heap */\n\t} else {\n\t\tlprops->hpos = heap->cnt++;\n\t\theap->arr[lprops->hpos] = lprops;\n\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\treturn 1; /* Added to heap */\n\t}\n}\n\n/**\n * remo",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p(c, heap, cat",
          "args": [
            "rops",
            "hpo",
            ";\n\t\treturn 1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap(c, heap, lpr",
          "args": [
            "p",
            "cat",
            "dbg",
            "hec"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p(c, heap, cat",
          "args": [
            ");",
            "etu",
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p(c, heap, cat",
          "args": [
            "rops",
            "hpo",
            ";\n\t\t\treturn"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap(c, heap, lpr",
          "args": [
            "p",
            "cat",
            "db",
            "che"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">list, &",
          "args": [
            "->uncat_l",
            "t);\n\t\t\tlprops-"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(heap->arr[cp",
          "args": [
            "s], cat);\n\t\tif",
            "al1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(lprops, cat)",
          "args": [
            "val",
            "= g"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpos < heap-",
          "args": [
            "cnt);\n\n\t\tval1 ="
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpos < LPT_H",
          "args": [
            "AP_SZ);\n\t\tubifs_as"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpos >= b);",
          "args": [
            "ubifs_as"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nd_to_lpt_heap(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t\t   int cat)\n{\n\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\tif (heap->cnt >= heap->max_cnt) {\n\t\tconst int b = LPT_HEAP_SZ / 2 - 1;\n\t\tint cpos, val1, val2;\n\n\t\t/* Compare to some other LEB on the bottom of heap */\n\t\t/* Pick a position kind of randomly */\n\t\tcpos = (((size_t)lprops >> 4) & b) + b;\n\t\tubifs_assert(cpos >= b);\n\t\tubifs_assert(cpos < LPT_HEAP_SZ);\n\t\tubifs_assert(cpos < heap->cnt);\n\n\t\tval1 = get_heap_comp_val(lprops, cat);\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 > val2) {\n\t\t\tstruct ubifs_lprops *lp;\n\n\t\t\tlp = heap->arr[cpos];\n\t\t\tlp->flags &= ~LPROPS_CAT_MASK;\n\t\t\tlp->flags |= LPROPS_UNCAT;\n\t\t\tlist_add(&lp->list, &c->uncat_list);\n\t\t\tlprops->hpos = cpos;\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\t\treturn 1; /* Added to heap */\n\t\t}\n\t\tdbg_check_heap(c, heap, cat, -1);\n\t\treturn 0; /* Not added to heap */\n\t} else {\n\t\tlprops->hpos = heap->cnt++;\n\t\theap->arr[lprops->hpos] = lprops;\n\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\treturn 1; /* Added to heap */\n\t}\n}\n\n/**\n * remo"
  },
  {
    "function_name": "ap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "99-167",
    "snippet": "djust_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t    struct ubifs_lprops *lprops, int hpos, int cat)\n{\n\tint val1, val2, val3, cpos;\n\n\tval1 = get_heap_comp_val(lprops, cat);\n\t/* Compare to parent and, if greater than parent, move up the heap */\n\tif (hpos) {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val1 > val2) {\n\t\t\t/* Greater than parent so move up */\n\t\t\twhile (1) {\n\t\t\t\theap->arr[ppos]->hpos = hpos;\n\t\t\t\theap->arr[hpos] = heap->arr[ppos];\n\t\t\t\theap->arr[ppos] = lprops;\n\t\t\t\tlprops->hpos = ppos;\n\t\t\t\thpos = ppos;\n\t\t\t\tif (!hpos)\n\t\t\t\t\treturn;\n\t\t\t\tppos = (hpos - 1) / 2;\n\t\t\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\t\t\tif (val1 <= val2)\n\t\t\t\t\treturn;\n\t\t\t\t/* Still greater than parent so keep going */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not greater than parent, so compare to children */\n\twhile (1) {\n\t\t/* Compare to left child */\n\t\tcpos = hpos * 2 + 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val2) {\n\t\t\t/* Less than left child, so promote biggest child */\n\t\t\tif (cpos + 1 < heap->cnt) {\n\t\t\t\tval3 = get_heap_comp_val(heap->arr[cpos + 1],\n\t\t\t\t\t\t\t cat);\n\t\t\t\tif (val3 > val2)\n\t\t\t\t\tcpos += 1; /* Right child is bigger */\n\t\t\t}\n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Compare to right child */\n\t\tcpos += 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval3 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val3) {\n\t\t\t/* Less than right child, so promote right child */\n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\treturn;\n\t}\n}\n\n/**\n * add_",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_val(heap->arr[cp",
          "args": [
            "s], cat);\n\t\tif",
            "al1"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(heap->arr[cp",
          "args": [
            "s + 1],\n\t\t\t\t\t\t\t cat",
            "(va"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(heap->arr[cp",
          "args": [
            "s], cat);\n\t\tif",
            "al1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(heap->arr[pp",
          "args": [
            "s], cat);\n\t\t\t\ti",
            "(va"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(heap->arr[pp",
          "args": [
            "s], cat);\n\t\tif",
            "al1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(lprops, cat)",
          "args": [
            "/* C",
            "par"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\ndjust_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t    struct ubifs_lprops *lprops, int hpos, int cat)\n{\n\tint val1, val2, val3, cpos;\n\n\tval1 = get_heap_comp_val(lprops, cat);\n\t/* Compare to parent and, if greater than parent, move up the heap */\n\tif (hpos) {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val1 > val2) {\n\t\t\t/* Greater than parent so move up */\n\t\t\twhile (1) {\n\t\t\t\theap->arr[ppos]->hpos = hpos;\n\t\t\t\theap->arr[hpos] = heap->arr[ppos];\n\t\t\t\theap->arr[ppos] = lprops;\n\t\t\t\tlprops->hpos = ppos;\n\t\t\t\thpos = ppos;\n\t\t\t\tif (!hpos)\n\t\t\t\t\treturn;\n\t\t\t\tppos = (hpos - 1) / 2;\n\t\t\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\t\t\tif (val1 <= val2)\n\t\t\t\t\treturn;\n\t\t\t\t/* Still greater than parent so keep going */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not greater than parent, so compare to children */\n\twhile (1) {\n\t\t/* Compare to left child */\n\t\tcpos = hpos * 2 + 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val2) {\n\t\t\t/* Less than left child, so promote biggest child */\n\t\t\tif (cpos + 1 < heap->cnt) {\n\t\t\t\tval3 = get_heap_comp_val(heap->arr[cpos + 1],\n\t\t\t\t\t\t\t cat);\n\t\t\t\tif (val3 > val2)\n\t\t\t\t\tcpos += 1; /* Right child is bigger */\n\t\t\t}\n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Compare to right child */\n\t\tcpos += 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval3 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val3) {\n\t\t\t/* Less than right child, so promote right child */\n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\treturn;\n\t}\n}\n\n/**\n * add_"
  },
  {
    "function_name": "eap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "62-85",
    "snippet": "ove_up_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t     struct ubifs_lprops *lprops, int cat)\n{\n\tint val1, val2, hpos;\n\n\thpos = lprops->hpos;\n\tif (!hpos)\n\t\treturn; /* Already top of the heap */\n\tval1 = get_heap_comp_val(lprops, cat);\n\t/* Compare to parent and, if greater, move up the heap */\n\tdo {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val2 >= val1)\n\t\t\treturn;\n\t\t/* Greater than parent so move up */\n\t\theap->arr[ppos]->hpos = hpos;\n\t\theap->arr[hpos] = heap->arr[ppos];\n\t\theap->arr[ppos] = lprops;\n\t\tlprops->hpos = ppos;\n\t\thpos = ppos;\n\t} while (hpos);\n}\n\n/**\n * adju",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_val(heap->arr[pp",
          "args": [
            "s], cat);\n\t\tif",
            "al2"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_val(lprops, cat)",
          "args": [
            "/* C",
            "par"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nove_up_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t     struct ubifs_lprops *lprops, int cat)\n{\n\tint val1, val2, hpos;\n\n\thpos = lprops->hpos;\n\tif (!hpos)\n\t\treturn; /* Already top of the heap */\n\tval1 = get_heap_comp_val(lprops, cat);\n\t/* Compare to parent and, if greater, move up the heap */\n\tdo {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val2 >= val1)\n\t\t\treturn;\n\t\t/* Greater than parent so move up */\n\t\theap->arr[ppos]->hpos = hpos;\n\t\theap->arr[hpos] = heap->arr[ppos];\n\t\theap->arr[ppos] = lprops;\n\t\tlprops->hpos = ppos;\n\t\thpos = ppos;\n\t} while (hpos);\n}\n\n/**\n * adju"
  },
  {
    "function_name": "_val(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lprops.c",
    "lines": "38-48",
    "snippet": "t_heap_comp_val(struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_FREE:\n\t\treturn lprops->free;\n\tcase LPROPS_DIRTY_IDX:\n\t\treturn lprops->free + lprops->dirty;\n\tdefault:\n\t\treturn lprops->dirty;\n\t}\n}\n\n/**\n * move",
    "includes": [
      "fs.h\"\n\n/**\n * get_h"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * get_h\n\nt_heap_comp_val(struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_FREE:\n\t\treturn lprops->free;\n\tcase LPROPS_DIRTY_IDX:\n\t\treturn lprops->free + lprops->dirty;\n\tdefault:\n\t\treturn lprops->dirty;\n\t}\n}\n\n/**\n * move"
  }
]