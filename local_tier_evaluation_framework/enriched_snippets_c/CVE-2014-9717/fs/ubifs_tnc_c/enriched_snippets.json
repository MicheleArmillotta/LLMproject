[
  {
    "function_name": "de_size(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "3274-3327",
    "snippet": "_inode_size(struct ubifs_info *c, const struct inode *inode,\n\t\t\t loff_t size)\n{\n\tint err, n;\n\tunion ubifs_key from_key, to_key, *key;\n\tstruct ubifs_znode *znode;\n\tunsigned int block;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tblock = (size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tdata_key_init(c, &from_key, inode->i_ino, block);\n\thighest_data_key(c, &to_key, inode->i_ino);\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, &from_key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tkey = &from_key;\n\t\tgoto out_dump;\n\t}\n\n\terr = tnc_next(c, &znode, &n);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tubifs_assert(err == 0);\n\tkey = &znode->zbranch[n].key;\n\tif (!key_in_range(c, key, &from_key, &to_key))\n\t\tgoto out_unlock;\n\nout_dump:\n\tblock = key_block(c, key);\n\tubifs_err(\"inode %lu has size %lld, but there are data at offset %lld\",\n\t\t  (unsigned long)inode->i_ino, size,\n\t\t  ((loff_t)block) << UBIFS_BLOCK_SHIFT);\n\tmutex_unlock(&c->tnc_mutex);\n\tubifs_dump_inode(c, inode);\n\tdump_stack();\n\treturn -EINVAL;\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return -",
          "args": [],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, inode);",
          "args": [
            "u",
            "_stac"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\tubifs_dum"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu h",
          "args": [
            "s size %lld, but there are data at offset %lld\",\n\t\t  (unsign",
            "g)inode->i_ino, size,\n\t\t  (",
            "off_",
            "k) << UBIFS_BLOCK_SHIFT);\n\tmutex_unl"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key);\n\tub",
          "args": [
            "f",
            "err"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, key, &fro",
          "args": [
            "_",
            "y,",
            "o_key))",
            "oto out"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err == 0);",
          "args": [
            "ey = &zn"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if (e",
            "="
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, &from_key",
          "args": [
            "node, &n)",
            "if (e",
            "<"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\terr = ubi"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &to_key,",
          "args": [
            "n",
            "e->i_in",
            ";\n\n\tmutex_lo"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &from_key",
          "args": [
            "ode->i_in",
            "block);\n\thi",
            "est_d"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "))\n\t\treturn 0"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_inode_size(struct ubifs_info *c, const struct inode *inode,\n\t\t\t loff_t size)\n{\n\tint err, n;\n\tunion ubifs_key from_key, to_key, *key;\n\tstruct ubifs_znode *znode;\n\tunsigned int block;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tblock = (size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tdata_key_init(c, &from_key, inode->i_ino, block);\n\thighest_data_key(c, &to_key, inode->i_ino);\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, &from_key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tkey = &from_key;\n\t\tgoto out_dump;\n\t}\n\n\terr = tnc_next(c, &znode, &n);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tubifs_assert(err == 0);\n\tkey = &znode->zbranch[n].key;\n\tif (!key_in_range(c, key, &from_key, &to_key))\n\t\tgoto out_unlock;\n\nout_dump:\n\tblock = key_block(c, key);\n\tubifs_err(\"inode %lu has size %lld, but there are data at offset %lld\",\n\t\t  (unsigned long)inode->i_ino, size,\n\t\t  ((loff_t)block) << UBIFS_BLOCK_SHIFT);\n\tmutex_unlock(&c->tnc_mutex);\n\tubifs_dump_inode(c, inode);\n\tdump_stack();\n\treturn -EINVAL;\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "dx_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "3238-3261",
    "snippet": "ty_idx_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t\t int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint err = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\tgoto out_unlock;\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\tznode = dirty_cow_bottom_up(c, znode);\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "f",
            "IS_ER"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, key, leve",
          "args": [
            ",",
            "num",
            "offs)",
            "if",
            "znod"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tznode = l"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nty_idx_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t\t int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint err = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\tgoto out_unlock;\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\tznode = dirty_cow_bottom_up(c, znode);\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "3198-3222",
    "snippet": "_has_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs, int is_idx)\n{\n\tint err;\n\n\tmutex_lock(&c->tnc_mutex);\n\tif (is_idx) {\n\t\terr = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err == 1)\n\t\t\t/* The index node was found but it was dirty */\n\t\t\terr = 0;\n\t\telse if (err == 2)\n\t\t\t/* The index node was found and it was clean */\n\t\t\terr = 1;\n\t\telse\n\t\t\tBUG_ON(err != 0);\n\t} else\n\t\terr = is_leaf_node_in_tnc(c, key, lnum, offs);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_tnc(c, key, lnum",
          "args": [
            "fs)",
            "out",
            "nloc"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);",
          "args": [
            "else"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_tnc(c, key, leve",
          "args": [
            ",",
            "num",
            "offs)",
            "if",
            "err"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tif (is_id"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_has_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs, int is_idx)\n{\n\tint err;\n\n\tmutex_lock(&c->tnc_mutex);\n\tif (is_idx) {\n\t\terr = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err == 1)\n\t\t\t/* The index node was found but it was dirty */\n\t\t\terr = 0;\n\t\telse if (err == 2)\n\t\t\t/* The index node was found and it was clean */\n\t\t\terr = 1;\n\t\telse\n\t\t\tBUG_ON(err != 0);\n\t} else\n\t\terr = is_leaf_node_in_tnc(c, key, lnum, offs);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "in_tnc(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "3128-3182",
    "snippet": "_leaf_node_in_tnc(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t       int lnum, int offs)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *zn;\n\tint n, found, err, nn;\n\tconst int unique = !is_hash_key(c, key);\n\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (found < 0)\n\t\treturn found; /* Error code */\n\tif (!found)\n\t\treturn 0;\n\tzbr = &znode->zbranch[n];\n\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\treturn 1; /* Found it */\n\tif (unique)\n\t\treturn 0;\n\t/*\n\t * Because the key is not unique, we have to look left\n\t * and right as well\n\t */\n\tzn = znode;\n\tnn = n;\n\t/* Look left */\n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &n);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1; /* Found it */\n\t}\n\t/* Look right */\n\tznode = zn;\n\tn = nn;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1; /* Found it */\n\t}\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ey, &zno",
          "args": [
            "e",
            "zbr",
            "ch[n].key))\n\t\t\tbreak;"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if (",
            "r)"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zno",
          "args": [
            "e",
            "zbr",
            "ch[n].key))\n\t\t\tbreak;"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if (",
            "r"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (f",
            "nd"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key);\n\n\tf",
          "args": [
            "u",
            "="
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_leaf_node_in_tnc(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t       int lnum, int offs)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *zn;\n\tint n, found, err, nn;\n\tconst int unique = !is_hash_key(c, key);\n\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (found < 0)\n\t\treturn found; /* Error code */\n\tif (!found)\n\t\treturn 0;\n\tzbr = &znode->zbranch[n];\n\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\treturn 1; /* Found it */\n\tif (unique)\n\t\treturn 0;\n\t/*\n\t * Because the key is not unique, we have to look left\n\t * and right as well\n\t */\n\tzn = znode;\n\tnn = n;\n\t/* Look left */\n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &n);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1; /* Found it */\n\t}\n\t/* Look right */\n\tznode = zn;\n\tn = nn;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1; /* Found it */\n\t}\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "n_tnc(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "3101-3113",
    "snippet": "de_in_tnc(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\treturn 0;\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\treturn ubifs_zn_dirty(znode) ? 1 : 2;\n}\n\n/**\n * is_l",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y(znode) ? 1 :",
          "args": [
            "2;\n}"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\tre",
          "args": [
            "urn u"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn P"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, key, leve",
          "args": [
            ",",
            "num",
            "offs)",
            "if",
            "znod"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nde_in_tnc(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\treturn 0;\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\treturn ubifs_zn_dirty(znode) ? 1 : 2;\n}\n\n/**\n * is_l"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2972-3082",
    "snippet": "ubifs_znode *lookup_znode(struct ubifs_info *c,\n\t\t\t\t\tunion ubifs_key *key, int level,\n\t\t\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_znode *znode, *zn;\n\tint n, nn;\n\n\tubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\n\n\t/*\n\t * The arguments have probably been read off flash, so don't assume\n\t * they are valid.\n\t */\n\tif (level < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Get the root znode */\n\tznode = c->zroot.znode;\n\tif (!znode) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t/* Check if it is the one we are looking for */\n\tif (c->zroot.lnum == lnum && c->zroot.offs == offs)\n\t\treturn znode;\n\t/* Descend to the parent level i.e. (level + 1) */\n\tif (level >= znode->level)\n\t\treturn NULL;\n\twhile (1) {\n\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\tif (n < 0) {\n\t\t\t/*\n\t\t\t * We reached a znode where the leftmost key is greater\n\t\t\t * than the key we are searching for. This is the same\n\t\t\t * situation as the one described in a huge comment at\n\t\t\t * the end of the 'ubifs_lookup_level0()' function. And\n\t\t\t * for exactly the same reasons we have to try to look\n\t\t\t * left before giving up.\n\t\t\t */\n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\treturn NULL;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\t\tubifs_assert(n >= 0);\n\t\t}\n\t\tif (znode->level == level + 1)\n\t\t\tbreak;\n\t\tznode = get_znode(c, znode, n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t/* Check if the child is the one we are looking for */\n\tif (znode->zbranch[n].lnum == lnum && znode->zbranch[n].offs == offs)\n\t\treturn get_znode(c, znode, n);\n\t/* If the key is unique, there is nowhere else to look */\n\tif (!is_hash_key(c, key))\n\t\treturn NULL;\n\t/*\n\t * The key is not unique and so may be also in the znodes to either\n\t * side.\n\t */\n\tzn = znode;\n\tnn = n;\n\t/* Look left */\n\twhile (1) {\n\t\t/* Move one branch to the left */\n\t\tif (n)\n\t\t\tn -= 1;\n\t\telse {\n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = znode->child_cnt - 1;\n\t\t}\n\t\t/* Check it */\n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t/* Stop if the key is less than the one we are looking for */\n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) < 0)\n\t\t\tbreak;\n\t}\n\t/* Back to the middle */\n\tznode = zn;\n\tn = nn;\n\t/* Look right */\n\twhile (1) {\n\t\t/* Move one branch to the right */\n\t\tif (++n >= znode->child_cnt) {\n\t\t\tznode = right_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = 0;\n\t\t}\n\t\t/* Check it */\n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t/* Stop if the key is greater than the one we are looking for */\n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) > 0)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n/**\n * is_i",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[n].key, key) > 0)",
            "bre"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "/* St"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "eturn"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": ", znode);",
          "args": [
            "(!zn"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[n].key, key) < 0)",
            "bre"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "/* St"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);",
          "args": [
            "(!zn"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key))\n\t\tr",
          "args": [
            "t",
            "n N"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "* If",
            "e"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "if (I",
            "E"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n >= 0);\n\t\t}",
          "args": [
            "if ("
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbranch(c, znode, ke",
          "args": [
            ",",
            "n);",
            "ubi",
            "_a"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);",
          "args": [
            "(!zn"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbranch(c, znode, ke",
          "args": [
            ",",
            "n);",
            "f (",
            "<"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, &c->zroot",
          "args": [
            "LL, 0);",
            "f (I",
            "E"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "* Get t"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "ey) < UBIFS_INVALID_KEY);\n\n\t/*\n\t * T"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) < UB",
          "args": [
            "F",
            "INV"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *lookup_znode(struct ubifs_info *c,\n\t\t\t\t\tunion ubifs_key *key, int level,\n\t\t\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_znode *znode, *zn;\n\tint n, nn;\n\n\tubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\n\n\t/*\n\t * The arguments have probably been read off flash, so don't assume\n\t * they are valid.\n\t */\n\tif (level < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Get the root znode */\n\tznode = c->zroot.znode;\n\tif (!znode) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t/* Check if it is the one we are looking for */\n\tif (c->zroot.lnum == lnum && c->zroot.offs == offs)\n\t\treturn znode;\n\t/* Descend to the parent level i.e. (level + 1) */\n\tif (level >= znode->level)\n\t\treturn NULL;\n\twhile (1) {\n\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\tif (n < 0) {\n\t\t\t/*\n\t\t\t * We reached a znode where the leftmost key is greater\n\t\t\t * than the key we are searching for. This is the same\n\t\t\t * situation as the one described in a huge comment at\n\t\t\t * the end of the 'ubifs_lookup_level0()' function. And\n\t\t\t * for exactly the same reasons we have to try to look\n\t\t\t * left before giving up.\n\t\t\t */\n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\treturn NULL;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\t\tubifs_assert(n >= 0);\n\t\t}\n\t\tif (znode->level == level + 1)\n\t\t\tbreak;\n\t\tznode = get_znode(c, znode, n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t/* Check if the child is the one we are looking for */\n\tif (znode->zbranch[n].lnum == lnum && znode->zbranch[n].offs == offs)\n\t\treturn get_znode(c, znode, n);\n\t/* If the key is unique, there is nowhere else to look */\n\tif (!is_hash_key(c, key))\n\t\treturn NULL;\n\t/*\n\t * The key is not unique and so may be also in the znodes to either\n\t * side.\n\t */\n\tzn = znode;\n\tnn = n;\n\t/* Look left */\n\twhile (1) {\n\t\t/* Move one branch to the left */\n\t\tif (n)\n\t\t\tn -= 1;\n\t\telse {\n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = znode->child_cnt - 1;\n\t\t}\n\t\t/* Check it */\n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t/* Stop if the key is less than the one we are looking for */\n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) < 0)\n\t\t\tbreak;\n\t}\n\t/* Back to the middle */\n\tznode = zn;\n\tn = nn;\n\t/* Look right */\n\twhile (1) {\n\t\t/* Move one branch to the right */\n\t\tif (++n >= znode->child_cnt) {\n\t\t\tznode = right_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = 0;\n\t\t}\n\t\t/* Check it */\n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t/* Stop if the key is greater than the one we are looking for */\n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) > 0)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n/**\n * is_i"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2919-2945",
    "snippet": "ubifs_znode *right_znode(struct ubifs_info *c,\n\t\t\t\t       struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip + 1;\n\n\t\t/* Go up until we can go right */\n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n < znode->child_cnt) {\n\t\t\t/* Now go down the leftmost branch to 'level' */\n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n/**\n * look",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ")",
          "args": [
            "retur"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "znode, 0)",
          "args": [
            "if",
            "S"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "if (",
            "_"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *right_znode(struct ubifs_info *c,\n\t\t\t\t       struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip + 1;\n\n\t\t/* Go up until we can go right */\n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n < znode->child_cnt) {\n\t\t\t/* Now go down the leftmost branch to 'level' */\n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n/**\n * look"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2882-2909",
    "snippet": "ubifs_znode *left_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip - 1;\n\n\t\t/* Go up until we can go left */\n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n >= 0) {\n\t\t\t/* Now go down the rightmost branch to 'level' */\n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, n);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n/**\n * righ",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ")",
          "args": [
            "retur"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "if",
            "S"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "if (",
            "_"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *left_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip - 1;\n\n\t\t/* Go up until we can go left */\n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n >= 0) {\n\t\t\t/* Now go down the rightmost branch to 'level' */\n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, n);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n/**\n * righ"
  },
  {
    "function_name": "se(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2858-2872",
    "snippet": "c_close(struct ubifs_info *c)\n{\n\ttnc_destroy_cnext(c);\n\tif (c->zroot.znode) {\n\t\tlong n, freed;\n\n\t\tn = atomic_long_read(&c->clean_zn_cnt);\n\t\tfreed = ubifs_destroy_tnc_subtree(c->zroot.znode);\n\t\tubifs_assert(freed == n);\n\t\tatomic_long_sub(n, &ubifs_clean_zn_cnt);\n\t}\n\tkfree(c->gap_lebs);\n\tkfree(c->ilebs);\n\tdestroy_old_idx(c);\n}\n\n/**\n * left",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx(c);\n}\n\n/**",
          "args": [],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "estroy_o"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lebs)",
          "args": [
            "kfree(c->"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ub(n, &ubifs_cl",
          "args": [
            "a",
            "zn_cnt);\n\t}\n\tkfree("
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freed == n);",
          "args": [
            "atomic_l"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_tnc_subtree(c->zroot.zno",
          "args": [
            "e);\n\t\tubifs_as"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt);\n\t\tfreed ="
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next(c);\n\tif (c->",
          "args": [
            "r"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_close(struct ubifs_info *c)\n{\n\ttnc_destroy_cnext(c);\n\tif (c->zroot.znode) {\n\t\tlong n, freed;\n\n\t\tn = atomic_long_read(&c->clean_zn_cnt);\n\t\tfreed = ubifs_destroy_tnc_subtree(c->zroot.znode);\n\t\tubifs_assert(freed == n);\n\t\tatomic_long_sub(n, &ubifs_clean_zn_cnt);\n\t}\n\tkfree(c->gap_lebs);\n\tkfree(c->ilebs);\n\tdestroy_old_idx(c);\n}\n\n/**\n * left"
  },
  {
    "function_name": "next(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2837-2852",
    "snippet": "nc_destroy_cnext(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *cnext;\n\n\tif (!c->cnext)\n\t\treturn;\n\tubifs_assert(c->cmt_state == COMMIT_BROKEN);\n\tcnext = c->cnext;\n\tdo {\n\t\tstruct ubifs_znode *znode = cnext;\n\n\t\tcnext = cnext->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t} while (cnext && cnext != c->cnext);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "} w",
          "args": [
            "ile ("
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lete(znode))\n\t\t\tk",
          "args": [
            "ree(z"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cmt_state",
          "args": [
            "== COMMIT_BROKEN);\n\tcnext = c"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nnc_destroy_cnext(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *cnext;\n\n\tif (!c->cnext)\n\t\treturn;\n\tubifs_assert(c->cmt_state == COMMIT_BROKEN);\n\tcnext = c->cnext;\n\tdo {\n\t\tstruct ubifs_znode *znode = cnext;\n\n\t\tcnext = cnext->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t} while (cnext && cnext != c->cnext);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "t_ent(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2749-2829",
    "snippet": "dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,\n\t\t\t\t\t   union ubifs_key *key,\n\t\t\t\t\t   const struct qstr *nm)\n{\n\tint n, err, type = key_type(c, key);\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_zbranch *zbr;\n\tunion ubifs_key *dkey;\n\n\tdbg_tnck(key, \"%s \", nm->name ? (char *)nm->name : \"(lowest)\");\n\tubifs_assert(is_hash_key(c, key));\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\n\tif (nm->name) {\n\t\tif (err) {\n\t\t\t/* Handle collisions */\n\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\",\n\t\t\t\terr, znode, n);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Now find next entry */\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (unlikely(err))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t/*\n\t\t * The full name of the entry was not given, in which case the\n\t\t * behavior of this function is a little different and it\n\t\t * returns current entry, not the next one.\n\t\t */\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * However, the given key does not exist in the TNC\n\t\t\t * tree and @znode/@n variables contain the closest\n\t\t\t * \"preceding\" element. Switch to the next one.\n\t\t\t */\n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tdent = kmalloc(zbr->len, GFP_NOFS);\n\tif (unlikely(!dent)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * The above 'tnc_next()' call could lead us to the next inode, check\n\t * this.\n\t */\n\tdkey = &zbr->key;\n\tif (key_inum(c, dkey) != key_inum(c, key) ||\n\t    key_type(c, dkey) != type) {\n\t\terr = -ENOENT;\n\t\tgoto out_free;\n\t}\n\n\terr = tnc_read_node_nm(c, zbr, dent);\n\tif (unlikely(err))\n\t\tgoto out_free;\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn dent;\n\nout_free:\n\tkfree(dent);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn ERR_PTR(err);\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/**",
          "args": [
            "*"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn ER"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_u",
          "args": [
            "lock"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "__objlayout_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "595-639",
          "snippet": "static int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";\n\nstatic int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn de"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tgoto",
          "args": [
            "out"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, zbr, dent",
          "args": [
            ";",
            "if",
            "nlik"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key) !=",
          "args": [
            "y",
            ") {"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) ||",
          "args": [
            "key"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key) !=",
          "args": [
            "e",
            "inum"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t)) {",
          "args": [
            "rr ="
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "f (unlik"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if",
            "rr"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tgot",
          "args": [
            "ou"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if (",
            "li"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "goto o"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturned",
          "args": [
            "%d, znode %p, n %d\",\n\t\t\t\terr, zn",
            ");",
            "if (",
            "l"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sion(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "m);",
            "bg",
            "nc"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "oto out"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (u",
            "ik"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\terr = ubi"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hash_key(",
          "args": [
            ", key));\n\n\tmutex_lo"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key));",
          "args": [
            "u",
            "x_l"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"%s \",",
          "args": [
            "m->",
            "me ?",
            "har *)nm->name : \"(lowest)\");\n\tubifs_ass"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey);\n\tst",
          "args": [
            "u",
            "ub"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ndent_node *ubifs_tnc_next_ent(struct ubifs_info *c,\n\t\t\t\t\t   union ubifs_key *key,\n\t\t\t\t\t   const struct qstr *nm)\n{\n\tint n, err, type = key_type(c, key);\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_zbranch *zbr;\n\tunion ubifs_key *dkey;\n\n\tdbg_tnck(key, \"%s \", nm->name ? (char *)nm->name : \"(lowest)\");\n\tubifs_assert(is_hash_key(c, key));\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\n\tif (nm->name) {\n\t\tif (err) {\n\t\t\t/* Handle collisions */\n\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\",\n\t\t\t\terr, znode, n);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Now find next entry */\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (unlikely(err))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t/*\n\t\t * The full name of the entry was not given, in which case the\n\t\t * behavior of this function is a little different and it\n\t\t * returns current entry, not the next one.\n\t\t */\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * However, the given key does not exist in the TNC\n\t\t\t * tree and @znode/@n variables contain the closest\n\t\t\t * \"preceding\" element. Switch to the next one.\n\t\t\t */\n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tdent = kmalloc(zbr->len, GFP_NOFS);\n\tif (unlikely(!dent)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * The above 'tnc_next()' call could lead us to the next inode, check\n\t * this.\n\t */\n\tdkey = &zbr->key;\n\tif (key_inum(c, dkey) != key_inum(c, key) ||\n\t    key_type(c, dkey) != type) {\n\t\terr = -ENOENT;\n\t\tgoto out_free;\n\t}\n\n\terr = tnc_read_node_nm(c, zbr, dent);\n\tif (unlikely(err))\n\t\tgoto out_free;\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn dent;\n\nout_free:\n\tkfree(dent);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn ERR_PTR(err);\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "ove_ino(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2669-2724",
    "snippet": "_remove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tunion ubifs_key key1, key2;\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tstruct qstr nm = { .name = NULL };\n\n\tdbg_tnc(\"ino %lu\", (unsigned long)inum);\n\n\t/*\n\t * Walk all extended attribute entries and remove them together with\n\t * corresponding extended attribute inodes.\n\t */\n\tlowest_xent_key(c, &key1, inum);\n\twhile (1) {\n\t\tino_t xattr_inum;\n\t\tint err;\n\n\t\txent = ubifs_tnc_next_ent(c, &key1, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\treturn err;\n\t\t}\n\n\t\txattr_inum = le64_to_cpu(xent->inum);\n\t\tdbg_tnc(\"xent '%s', ino %lu\", xent->name,\n\t\t\t(unsigned long)xattr_inum);\n\n\t\tnm.name = xent->name;\n\t\tnm.len = le16_to_cpu(xent->nlen);\n\t\terr = ubifs_tnc_remove_nm(c, &key1, &nm);\n\t\tif (err) {\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tlowest_ino_key(c, &key1, xattr_inum);\n\t\thighest_ino_key(c, &key2, xattr_inum);\n\t\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\t\tif (err) {\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key1);\n\t}\n\n\tkfree(pxent);\n\tlowest_ino_key(c, &key1, inum);\n\thighest_ino_key(c, &key2, inum);\n\n\treturn ubifs_tnc_remove_range(c, &key1, &key2);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ove_range(c, &key1, &k",
          "args": [
            "y",
            ";\n}",
            "*\n *"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key2, in",
          "args": [
            "m",
            "re",
            "rn u"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(c, &key1, in",
          "args": [
            "m",
            "hig",
            "st_i"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low",
          "args": [
            "st_in"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "f_delown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "126-129",
          "snippet": "void f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_PID, 1);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_PID, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xent->ke",
          "args": [
            ",",
            "key1);\n\t}",
            "kfree"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "px",
          "args": [
            "nt ="
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re",
          "args": [
            "urn"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "_tnc_subtree(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "228-257",
          "snippet": "stroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nstroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read"
        }
      },
      {
        "call_info": {
          "callee": "ove_range(c, &key1, &k",
          "args": [
            "y",
            ";\n\t\ti",
            "(err)"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key2, xa",
          "args": [
            "t",
            "inum)",
            "err = ub"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(c, &key1, xa",
          "args": [
            "t",
            "inum)",
            "highest_"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, &key1, &n",
          "args": [
            ")",
            "if",
            "rr)"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "err = ub"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%s',",
          "args": [
            "no %lu\", xent->name,",
            "(unsigne",
            "g)xattr_inum);\n\n\t\tnm.name"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum);",
          "args": [
            "dbg_tnc("
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tif",
          "args": [
            "(err"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "rr ="
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key1, &n",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key1, in",
          "args": [
            "m",
            "whi",
            "(1)"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu\", (",
          "args": [
            "nsigned l",
            "g)inum);\n\n\t/*\n\t * W"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_remove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tunion ubifs_key key1, key2;\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tstruct qstr nm = { .name = NULL };\n\n\tdbg_tnc(\"ino %lu\", (unsigned long)inum);\n\n\t/*\n\t * Walk all extended attribute entries and remove them together with\n\t * corresponding extended attribute inodes.\n\t */\n\tlowest_xent_key(c, &key1, inum);\n\twhile (1) {\n\t\tino_t xattr_inum;\n\t\tint err;\n\n\t\txent = ubifs_tnc_next_ent(c, &key1, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\treturn err;\n\t\t}\n\n\t\txattr_inum = le64_to_cpu(xent->inum);\n\t\tdbg_tnc(\"xent '%s', ino %lu\", xent->name,\n\t\t\t(unsigned long)xattr_inum);\n\n\t\tnm.name = xent->name;\n\t\tnm.len = le16_to_cpu(xent->nlen);\n\t\terr = ubifs_tnc_remove_nm(c, &key1, &nm);\n\t\tif (err) {\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tlowest_ino_key(c, &key1, xattr_inum);\n\t\thighest_ino_key(c, &key2, xattr_inum);\n\t\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\t\tif (err) {\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key1);\n\t}\n\n\tkfree(pxent);\n\tlowest_ino_key(c, &key1, inum);\n\thighest_ino_key(c, &key2, inum);\n\n\treturn ubifs_tnc_remove_range(c, &key1, &key2);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ove_range(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2587-2658",
    "snippet": "_remove_range(struct ubifs_info *c, union ubifs_key *from_key,\n\t\t\t   union ubifs_key *to_key)\n{\n\tint i, n, k, err = 0;\n\tstruct ubifs_znode *znode;\n\tunion ubifs_key *key;\n\n\tmutex_lock(&c->tnc_mutex);\n\twhile (1) {\n\t\t/* Find first level 0 znode that contains keys to remove */\n\t\terr = ubifs_lookup_level0(c, from_key, &znode, &n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (err)\n\t\t\tkey = from_key;\n\t\telse {\n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tkey = &znode->zbranch[n].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key)) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* Ensure the znode is dirtied */\n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* Remove all keys in range except the first */\n\t\tfor (i = n + 1, k = 0; i < znode->child_cnt; i++, k++) {\n\t\t\tkey = &znode->zbranch[i].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key))\n\t\t\t\tbreak;\n\t\t\tlnc_free(&znode->zbranch[i]);\n\t\t\terr = ubifs_add_dirt(c, znode->zbranch[i].lnum,\n\t\t\t\t\t     znode->zbranch[i].len);\n\t\t\tif (err) {\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tdbg_tnck(key, \"removing key \");\n\t\t}\n\t\tif (k) {\n\t\t\tfor (i = n + 1 + k; i < znode->child_cnt; i++)\n\t\t\t\tznode->zbranch[i - k] = znode->zbranch[i];\n\t\t\tznode->child_cnt -= k;\n\t\t}\n\n\t\t/* Now delete the first */\n\t\terr = tnc_delete(c, znode, n);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\tmute",
          "args": [
            "_",
            "l"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "if (e",
            ")"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"removi",
          "args": [
            "g k",
            "\");\n\t\t}\n\t\tif ("
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "oto o"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, znode->zb",
          "args": [
            "a",
            "h[i].lnum,\n\t\t\t\t\t     z",
            "h[i].len);\n\t\t\tif (err"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de->zbra",
          "args": [
            "ch[i]);\n\t\t\terr = u"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, key, from",
          "args": [
            "k",
            ", t",
            "key))",
            "break;"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "oto o"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "(IS_"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "znode"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, key, from",
          "args": [
            "k",
            ", t",
            "key)) {",
            "err"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if",
            "rr"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, from_key,",
          "args": [
            "&",
            "ode, &n)",
            "if (",
            "r"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\twhile (1)"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_remove_range(struct ubifs_info *c, union ubifs_key *from_key,\n\t\t\t   union ubifs_key *to_key)\n{\n\tint i, n, k, err = 0;\n\tstruct ubifs_znode *znode;\n\tunion ubifs_key *key;\n\n\tmutex_lock(&c->tnc_mutex);\n\twhile (1) {\n\t\t/* Find first level 0 znode that contains keys to remove */\n\t\terr = ubifs_lookup_level0(c, from_key, &znode, &n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (err)\n\t\t\tkey = from_key;\n\t\telse {\n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tkey = &znode->zbranch[n].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key)) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* Ensure the znode is dirtied */\n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* Remove all keys in range except the first */\n\t\tfor (i = n + 1, k = 0; i < znode->child_cnt; i++, k++) {\n\t\t\tkey = &znode->zbranch[i].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key))\n\t\t\t\tbreak;\n\t\t\tlnc_free(&znode->zbranch[i]);\n\t\t\terr = ubifs_add_dirt(c, znode->zbranch[i].lnum,\n\t\t\t\t\t     znode->zbranch[i].len);\n\t\t\tif (err) {\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tdbg_tnck(key, \"removing key \");\n\t\t}\n\t\tif (k) {\n\t\t\tfor (i = n + 1 + k; i < znode->child_cnt; i++)\n\t\t\t\tznode->zbranch[i - k] = znode->zbranch[i];\n\t\t\tznode->child_cnt -= k;\n\t\t}\n\n\t\t/* Now delete the first */\n\t\terr = tnc_delete(c, znode, n);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2567-2575",
    "snippet": "y_in_range(struct ubifs_info *c, union ubifs_key *key,\n\t\t\tunion ubifs_key *from_key, union ubifs_key *to_key)\n{\n\tif (keys_cmp(c, key, from_key) < 0)\n\t\treturn 0;\n\tif (keys_cmp(c, key, to_key) > 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ey, to_k",
          "args": [
            "y",
            "> 0",
            "retu"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, from",
          "args": [
            "k",
            ") <",
            ")\n\t\tretu"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ny_in_range(struct ubifs_info *c, union ubifs_key *key,\n\t\t\tunion ubifs_key *from_key, union ubifs_key *to_key)\n{\n\tif (keys_cmp(c, key, from_key) < 0)\n\t\treturn 0;\n\tif (keys_cmp(c, key, to_key) > 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ove_nm(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2517-2556",
    "snippet": "_remove_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tconst struct qstr *nm)\n{\n\tint n, err;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"%.*s, key \", nm->len, nm->name);\n\terr = lookup_level0_dirty(c, key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tif (c->replaying)\n\t\t\terr = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t nm, 0);\n\t\telse\n\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err) {\n\t\t\t/* Ensure the znode is dirtied */\n\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = tnc_delete(c, znode, n);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * key_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\tmute",
          "args": [
            "_",
            "l"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "}\n\t}",
            "u"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "goto"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "f (IS"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "znod"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturned",
          "args": [
            "%d, znode %p, n %d\", err, znode,",
            ");",
            "if (e"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sion(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "m);",
            "g_",
            "c("
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lve_collision(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "m,",
            "e"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (e",
            "<"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"%.*s,",
          "args": [
            "ey",
            "nm->len, nm",
            "name);",
            "rr = loo"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tdbg_tnck("
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_remove_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tconst struct qstr *nm)\n{\n\tint n, err;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"%.*s, key \", nm->len, nm->name);\n\terr = lookup_level0_dirty(c, key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tif (c->replaying)\n\t\t\terr = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t nm, 0);\n\t\telse\n\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err) {\n\t\t\t/* Ensure the znode is dirtied */\n\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = tnc_delete(c, znode, n);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * key_"
  },
  {
    "function_name": "ove(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2487-2507",
    "snippet": "_remove(struct ubifs_info *c, const union ubifs_key *key)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"key \");\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\tif (found == 1)\n\t\terr = tnc_delete(c, znode, n);\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\nout_",
          "args": [
            "n",
            "c"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n)",
          "args": [
            "f (!e",
            ")"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (f",
            "nd"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"key \")",
          "args": [
            "f",
            "nd = l"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tdbg_tnck("
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_remove(struct ubifs_info *c, const union ubifs_key *key)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"key \");\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\tif (found == 1)\n\t\terr = tnc_delete(c, znode, n);\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2374-2478",
    "snippet": "c_delete(struct ubifs_info *c, struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *zp;\n\tint i, err;\n\n\t/* Delete without merge for now */\n\tubifs_assert(znode->level == 0);\n\tubifs_assert(n >= 0 && n < c->fanout);\n\tdbg_tnck(&znode->zbranch[n].key, \"deleting key \");\n\n\tzbr = &znode->zbranch[n];\n\tlnc_free(zbr);\n\n\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\tif (err) {\n\t\tubifs_dump_znode(c, znode);\n\t\treturn err;\n\t}\n\n\t/* We do not \"gap\" zbranch slots */\n\tfor (i = n; i < znode->child_cnt - 1; i++)\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\tznode->child_cnt -= 1;\n\n\tif (znode->child_cnt > 0)\n\t\treturn 0;\n\n\t/*\n\t * This was the last zbranch, we have to delete this znode from the\n\t * parent.\n\t */\n\n\tdo {\n\t\tubifs_assert(!ubifs_zn_obsolete(znode));\n\t\tubifs_assert(ubifs_zn_dirty(znode));\n\n\t\tzp = znode->parent;\n\t\tn = znode->iip;\n\n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\terr = insert_old_idx_znode(c, znode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (znode->cnext) {\n\t\t\t__set_bit(OBSOLETE_ZNODE, &znode->flags);\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t} else\n\t\t\tkfree(znode);\n\t\tznode = zp;\n\t} while (znode->child_cnt == 1); /* while removing last child */\n\n\t/* Remove from znode, entry n - 1 */\n\tznode->child_cnt -= 1;\n\tubifs_assert(znode->level != 0);\n\tfor (i = n; i < znode->child_cnt; i++) {\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\t\tif (znode->zbranch[i].znode)\n\t\t\tznode->zbranch[i].znode->iip = i;\n\t}\n\n\t/*\n\t * If this is the root and it has only 1 child then\n\t * collapse the tree.\n\t */\n\tif (!znode->parent) {\n\t\twhile (znode->child_cnt == 1 && znode->level != 0) {\n\t\t\tzp = znode;\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tznode = get_znode(c, znode, 0);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode->parent = NULL;\n\t\t\tznode->iip = 0;\n\t\t\tif (c->zroot.len) {\n\t\t\t\terr = insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t\t     c->zroot.offs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tc->zroot.lnum = zbr->lnum;\n\t\t\tc->zroot.offs = zbr->offs;\n\t\t\tc->zroot.len = zbr->len;\n\t\t\tc->zroot.znode = znode;\n\t\t\tubifs_assert(!ubifs_zn_obsolete(zp));\n\t\t\tubifs_assert(ubifs_zn_dirty(zp));\n\t\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t\tif (zp->cnext) {\n\t\t\t\t__set_bit(OBSOLETE_ZNODE, &zp->flags);\n\t\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t\t} else\n\t\t\t\tkfree(zp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\t}",
          "args": [
            "r"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&ubifs_clean",
          "args": [
            "zn_cnt);\n\t\t\t} else"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->clean_zn",
          "args": [
            "cnt);\n\t\t\t\tatomic"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OLETE_ZNO",
          "args": [
            "E, &zp->flags)",
            "atomic"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_zn",
          "args": [
            "cnt);\n\n\t\t\tif (zp"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_dir",
          "args": [
            "y(zp));\n\t\t\tatomic_"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(zp));\n\t\t\tato",
          "args": [
            "ic"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ubifs_zn_ob",
          "args": [
            "olete(zp));\n\t\t\tubifs_a"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lete(zp));\n\t\t\tubi",
          "args": [
            "s_"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, c->zroot.",
          "args": [
            "n",
            ",",
            ");\n\t\t\t\tif (er"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tz",
          "args": [
            "ode->"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "eturn"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "de(c, zbr);",
          "args": [
            "f",
            "IS_"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tz",
          "args": [
            "ode ="
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, 0)",
          "args": [
            "if (",
            "_"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->level",
          "args": [
            "!= 0);\n\tfor (i ="
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zn",
          "args": [
            "de ="
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "_znodes(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
          "lines": "992-1008",
          "snippet": "ree_obsolete_znodes(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\n\tcnext = c->cnext;\n\tdo {\n\t\tznode = cnext;\n\t\tcnext = znode->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse {\n\t\t\tznode->cnext = NULL;\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext != c->cnext);\n}\n\n/**\n * retu",
          "includes": [
            "fs.h\"\n\n/**\n * make_",
            "ux/random.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nree_obsolete_znodes(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\n\tcnext = c->cnext;\n\tdo {\n\t\tznode = cnext;\n\t\tcnext = znode->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse {\n\t\t\tznode->cnext = NULL;\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext != c->cnext);\n}\n\n/**\n * retu"
        }
      },
      {
        "call_info": {
          "callee": "nc(&ubifs_clean",
          "args": [
            "zn_cnt);\n\t\t} else"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->clean_zn",
          "args": [
            "cnt);\n\t\t\tatomic_"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OLETE_ZNO",
          "args": [
            "E, &znode->fla",
            ");\n\t\t\tatomic_"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_znode(c, znode);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_zn",
          "args": [
            "cnt);\n\n\t\terr = i"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_dir",
          "args": [
            "y(znode));\n\n\t\tzp = zn"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode));",
          "args": [
            "p = z"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ubifs_zn_ob",
          "args": [
            "olete(znode));\n\t\tubifs_as"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lete(znode));\n\t\tu",
          "args": [
            "ifs_a"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "r",
            "urn e"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, zbr->lnum",
          "args": [
            "r->len);",
            "f (err)"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\terr",
          "args": [
            "ub"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de->zbra",
          "args": [
            "ch[n].key, \"deleting k",
            "\");\n\n\tzbr = &z"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n >= 0 && n",
          "args": [
            "c->fanout);\n\tdbg_tnck("
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->level",
          "args": [
            "== 0);\n\tubifs_ass"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_delete(struct ubifs_info *c, struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *zp;\n\tint i, err;\n\n\t/* Delete without merge for now */\n\tubifs_assert(znode->level == 0);\n\tubifs_assert(n >= 0 && n < c->fanout);\n\tdbg_tnck(&znode->zbranch[n].key, \"deleting key \");\n\n\tzbr = &znode->zbranch[n];\n\tlnc_free(zbr);\n\n\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\tif (err) {\n\t\tubifs_dump_znode(c, znode);\n\t\treturn err;\n\t}\n\n\t/* We do not \"gap\" zbranch slots */\n\tfor (i = n; i < znode->child_cnt - 1; i++)\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\tznode->child_cnt -= 1;\n\n\tif (znode->child_cnt > 0)\n\t\treturn 0;\n\n\t/*\n\t * This was the last zbranch, we have to delete this znode from the\n\t * parent.\n\t */\n\n\tdo {\n\t\tubifs_assert(!ubifs_zn_obsolete(znode));\n\t\tubifs_assert(ubifs_zn_dirty(znode));\n\n\t\tzp = znode->parent;\n\t\tn = znode->iip;\n\n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\terr = insert_old_idx_znode(c, znode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (znode->cnext) {\n\t\t\t__set_bit(OBSOLETE_ZNODE, &znode->flags);\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t} else\n\t\t\tkfree(znode);\n\t\tznode = zp;\n\t} while (znode->child_cnt == 1); /* while removing last child */\n\n\t/* Remove from znode, entry n - 1 */\n\tznode->child_cnt -= 1;\n\tubifs_assert(znode->level != 0);\n\tfor (i = n; i < znode->child_cnt; i++) {\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\t\tif (znode->zbranch[i].znode)\n\t\t\tznode->zbranch[i].znode->iip = i;\n\t}\n\n\t/*\n\t * If this is the root and it has only 1 child then\n\t * collapse the tree.\n\t */\n\tif (!znode->parent) {\n\t\twhile (znode->child_cnt == 1 && znode->level != 0) {\n\t\t\tzp = znode;\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tznode = get_znode(c, znode, 0);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode->parent = NULL;\n\t\t\tznode->iip = 0;\n\t\t\tif (c->zroot.len) {\n\t\t\t\terr = insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t\t     c->zroot.offs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tc->zroot.lnum = zbr->lnum;\n\t\t\tc->zroot.offs = zbr->offs;\n\t\t\tc->zroot.len = zbr->len;\n\t\t\tc->zroot.znode = znode;\n\t\t\tubifs_assert(!ubifs_zn_obsolete(zp));\n\t\t\tubifs_assert(ubifs_zn_dirty(zp));\n\t\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t\tif (zp->cnext) {\n\t\t\t\t__set_bit(OBSOLETE_ZNODE, &zp->flags);\n\t\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t\t} else\n\t\t\t\tkfree(zp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_nm(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2282-2363",
    "snippet": "_add_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     int lnum, int offs, int len, const struct qstr *nm)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"LEB %d:%d, name '%.*s', key \",\n\t\t lnum, offs, nm->len, nm->name);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tif (c->replaying)\n\t\t\tfound = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t   nm, 1);\n\t\telse\n\t\t\tfound = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", found, znode, n);\n\t\tif (found < 0) {\n\t\t\terr = found;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Ensure the znode is dirtied */\n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tif (found == 1) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tif (c->replaying) {\n\t\t\t/*\n\t\t\t * We did not find it in the index so there may be a\n\t\t\t * dangling branch still in the index. So we remove it\n\t\t\t * by passing 'ubifs_tnc_remove_nm()' the same key but\n\t\t\t * an unmatchable name.\n\t\t\t */\n\t\t\tstruct qstr noname = { .name = \"\" };\n\n\t\t\terr = dbg_check_tnc(c, 0);\n\t\t\tmutex_unlock(&c->tnc_mutex);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn ubifs_tnc_remove_nm(c, key, &noname);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\tmute",
          "args": [
            "_",
            "l"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, key, &non",
          "args": [
            "m",
            ";",
            "}\n\nou"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\t\t\tif (err"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\t\t\tmu",
          "args": [
            "e",
            "u"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &z",
          "args": [
            "r",
            "n + 1",
            "i",
            "(err)"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "k",
            ");",
            "err = tn"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, zbr->lnum",
          "args": [
            "r->len);",
            "zbr->ln"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\terr",
          "args": [
            "= u"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "oto o"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "(IS_"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "znode"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturned",
          "args": [
            "%d, znode %p, n %d\", found, znod",
            "n);",
            "if (f",
            "n"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sion(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "m);",
            "g_",
            "c("
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lve_collision(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "n",
            "e"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (f",
            "nd"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"LEB %d",
          "args": [
            "%d,",
            "ame '%.*s', key \",\n\t\t lnum, of",
            "m->l",
            ", nm",
            "name);",
            "ound = l"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tdbg_tnck("
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_add_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     int lnum, int offs, int len, const struct qstr *nm)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"LEB %d:%d, name '%.*s', key \",\n\t\t lnum, offs, nm->len, nm->name);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tif (c->replaying)\n\t\t\tfound = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t   nm, 1);\n\t\telse\n\t\t\tfound = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", found, znode, n);\n\t\tif (found < 0) {\n\t\t\terr = found;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Ensure the znode is dirtied */\n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tif (found == 1) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tif (c->replaying) {\n\t\t\t/*\n\t\t\t * We did not find it in the index so there may be a\n\t\t\t * dangling branch still in the index. So we remove it\n\t\t\t * by passing 'ubifs_tnc_remove_nm()' the same key but\n\t\t\t * an unmatchable name.\n\t\t\t */\n\t\t\tstruct qstr noname = { .name = \"\" };\n\n\t\t\terr = dbg_check_tnc(c, 0);\n\t\t\tmutex_unlock(&c->tnc_mutex);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn ubifs_tnc_remove_nm(c, key, &noname);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "lace(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2199-2268",
    "snippet": "_replace(struct ubifs_info *c, const union ubifs_key *key,\n\t\t      int old_lnum, int old_offs, int lnum, int offs, int len)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"old LEB %d:%d, new LEB %d:%d, len %d, key \", old_lnum,\n\t\t old_offs, lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tfound = 0;\n\t\tif (zbr->lnum == old_lnum && zbr->offs == old_offs) {\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tfound = 1;\n\t\t} else if (is_hash_key(c, key)) {\n\t\t\tfound = resolve_collision_directly(c, key, &znode, &n,\n\t\t\t\t\t\t\t   old_lnum, old_offs);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d, LEB %d:%d\",\n\t\t\t\tfound, znode, n, old_lnum, old_offs);\n\t\t\tif (found < 0) {\n\t\t\t\terr = found;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\t/* Ensure the znode is dirtied */\n\t\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzbr = &znode->zbranch[n];\n\t\t\t\tlnc_free(zbr);\n\t\t\t\terr = ubifs_add_dirt(c, zbr->lnum,\n\t\t\t\t\t\t     zbr->len);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tzbr->lnum = lnum;\n\t\t\t\tzbr->offs = offs;\n\t\t\t\tzbr->len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)\n\t\terr = ubifs_add_dirt(c, lnum, len);\n\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\nout_",
          "args": [
            "n",
            "c"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, len",
          "args": [
            ";",
            "if",
            "err"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, zbr->lnum",
          "args": [
            "if (er"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\t\ter",
          "args": [
            "="
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "goto"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "er"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "if (I"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "zno"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturned",
          "args": [
            "%d, znode %p, n %d, LEB %d:%d\",\n\t\t\t\tfound,",
            "n, o",
            "_lnum",
            "o",
            "_offs);",
            "if (fou"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sion_directly(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "o",
            "_offs);",
            "dbg_tnc"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key)) {",
          "args": [
            "und"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, zbr->lnum",
          "args": [
            "r->len);",
            "if (err"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\terr",
          "args": [
            "= u"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (f",
            "nd"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"old LE",
          "args": [
            "%d",
            "d, new LEB %d:%d, len %d, key \", old_lnum,",
            "old_offs",
            "m, offs,",
            "en);",
            "foun",
            "= l"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tdbg_tnck("
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_replace(struct ubifs_info *c, const union ubifs_key *key,\n\t\t      int old_lnum, int old_offs, int lnum, int offs, int len)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"old LEB %d:%d, new LEB %d:%d, len %d, key \", old_lnum,\n\t\t old_offs, lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tfound = 0;\n\t\tif (zbr->lnum == old_lnum && zbr->offs == old_offs) {\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tfound = 1;\n\t\t} else if (is_hash_key(c, key)) {\n\t\t\tfound = resolve_collision_directly(c, key, &znode, &n,\n\t\t\t\t\t\t\t   old_lnum, old_offs);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d, LEB %d:%d\",\n\t\t\t\tfound, znode, n, old_lnum, old_offs);\n\t\t\tif (found < 0) {\n\t\t\t\terr = found;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\t/* Ensure the znode is dirtied */\n\t\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzbr = &znode->zbranch[n];\n\t\t\t\tlnc_free(zbr);\n\t\t\t\terr = ubifs_add_dirt(c, zbr->lnum,\n\t\t\t\t\t\t     zbr->len);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tzbr->lnum = lnum;\n\t\t\t\tzbr->offs = offs;\n\t\t\t\tzbr->len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)\n\t\terr = ubifs_add_dirt(c, lnum, len);\n\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "2150-2183",
    "snippet": "_add(struct ubifs_info *c, const union ubifs_key *key, int lnum,\n\t\t  int offs, int len)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"%d:%d, len %d, key \", lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t} else if (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tlnc_free(zbr);\n\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t} else\n\t\terr = found;\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\n\treturn e"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 0);\n\tmute",
          "args": [
            "_",
            "l"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, zbr->lnum",
          "args": [
            "r->len);",
            "zbr->lnu"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\terr",
          "args": [
            "ub"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &z",
          "args": [
            "r",
            "n + 1",
            "}",
            "se if"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "k",
            ");",
            "err = tn"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (!",
            "un"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"%d:%d,",
          "args": [
            "len",
            "d, key \", lnum, offs,",
            "en);",
            "foun",
            "= l"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tdbg_tnck("
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_add(struct ubifs_info *c, const union ubifs_key *key, int lnum,\n\t\t  int offs, int len)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"%d:%d, len %d, key \", lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t} else if (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tlnc_free(zbr);\n\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t} else\n\t\terr = found;\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1958-2136",
    "snippet": "c_insert(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      struct ubifs_zbranch *zbr, int n)\n{\n\tstruct ubifs_znode *zn, *zi, *zp;\n\tint i, keep, move, appending = 0;\n\tunion ubifs_key *key = &zbr->key, *key1;\n\n\tubifs_assert(n >= 0 && n <= c->fanout);\n\n\t/* Implement naive insert for now */\nagain:\n\tzp = znode->parent;\n\tif (znode->child_cnt < c->fanout) {\n\t\tubifs_assert(n != c->fanout);\n\t\tdbg_tnck(key, \"inserted at %d level %d, key \", n, znode->level);\n\n\t\tinsert_zbranch(znode, zbr, n);\n\n\t\t/* Ensure parent's key is correct */\n\t\tif (n == 0 && zp && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Unfortunately, @znode does not have more empty slots and we have to\n\t * split it.\n\t */\n\tdbg_tnck(key, \"splitting level %d, key \", znode->level);\n\n\tif (znode->alt)\n\t\t/*\n\t\t * We can no longer be sure of finding this znode by key, so we\n\t\t * record it in the old_idx tree.\n\t\t */\n\t\tins_clr_old_idx_znode(c, znode);\n\n\tzn = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zn)\n\t\treturn -ENOMEM;\n\tzn->parent = zp;\n\tzn->level = znode->level;\n\n\t/* Decide where to split */\n\tif (znode->level == 0 && key_type(c, key) == UBIFS_DATA_KEY) {\n\t\t/* Try not to split consecutive data keys */\n\t\tif (n == c->fanout) {\n\t\t\tkey1 = &znode->zbranch[n - 1].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY)\n\t\t\t\tappending = 1;\n\t\t} else\n\t\t\tgoto check_split;\n\t} else if (appending && n != c->fanout) {\n\t\t/* Try not to split consecutive data keys */\n\t\tappending = 0;\ncheck_split:\n\t\tif (n >= (c->fanout + 1) / 2) {\n\t\t\tkey1 = &znode->zbranch[0].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY) {\n\t\t\t\tkey1 = &znode->zbranch[n].key;\n\t\t\t\tif (key_inum(c, key1) != key_inum(c, key) ||\n\t\t\t\t    key_type(c, key1) != UBIFS_DATA_KEY) {\n\t\t\t\t\tkeep = n;\n\t\t\t\t\tmove = c->fanout - keep;\n\t\t\t\t\tzi = znode;\n\t\t\t\t\tgoto do_split;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (appending) {\n\t\tkeep = c->fanout;\n\t\tmove = 0;\n\t} else {\n\t\tkeep = (c->fanout + 1) / 2;\n\t\tmove = c->fanout - keep;\n\t}\n\n\t/*\n\t * Although we don't at present, we could look at the neighbors and see\n\t * if we can move some zbranches there.\n\t */\n\n\tif (n < keep) {\n\t\t/* Insert into existing znode */\n\t\tzi = znode;\n\t\tmove += 1;\n\t\tkeep -= 1;\n\t} else {\n\t\t/* Insert into new znode */\n\t\tzi = zn;\n\t\tn -= keep;\n\t\t/* Re-parent */\n\t\tif (zn->level != 0)\n\t\t\tzbr->znode->parent = zn;\n\t}\n\ndo_split:\n\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzn->child_cnt = move;\n\tznode->child_cnt = keep;\n\n\tdbg_tnc(\"moving %d, keeping %d\", move, keep);\n\n\t/* Move zbranch */\n\tfor (i = 0; i < move; i++) {\n\t\tzn->zbranch[i] = znode->zbranch[keep + i];\n\t\t/* Re-parent */\n\t\tif (zn->level != 0)\n\t\t\tif (zn->zbranch[i].znode) {\n\t\t\t\tzn->zbranch[i].znode->parent = zn;\n\t\t\t\tzn->zbranch[i].znode->iip = i;\n\t\t\t}\n\t}\n\n\t/* Insert new key and branch */\n\tdbg_tnck(key, \"inserting at %d level %d, key \", n, zn->level);\n\n\tinsert_zbranch(zi, zbr, n);\n\n\t/* Insert new znode (produced by spitting) into the parent */\n\tif (zp) {\n\t\tif (n == 0 && zi == znode && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\t/* Locate insertion point */\n\t\tn = znode->iip + 1;\n\n\t\t/* Tail recursion */\n\t\tzbr->key = zn->zbranch[0].key;\n\t\tzbr->znode = zn;\n\t\tzbr->lnum = 0;\n\t\tzbr->offs = 0;\n\t\tzbr->len = 0;\n\t\tznode = zp;\n\n\t\tgoto again;\n\t}\n\n\t/* We have to split root znode */\n\tdbg_tnc(\"creating new zroot at level %d\", znode->level + 1);\n\n\tzi = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zi)\n\t\treturn -ENOMEM;\n\n\tzi->child_cnt = 2;\n\tzi->level = znode->level + 1;\n\n\t__set_bit(DIRTY_ZNODE, &zi->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzi->zbranch[0].key = znode->zbranch[0].key;\n\tzi->zbranch[0].znode = znode;\n\tzi->zbranch[0].lnum = c->zroot.lnum;\n\tzi->zbranch[0].offs = c->zroot.offs;\n\tzi->zbranch[0].len = c->zroot.len;\n\tzi->zbranch[1].key = zn->zbranch[0].key;\n\tzi->zbranch[1].znode = zn;\n\n\tc->zroot.lnum = 0;\n\tc->zroot.offs = 0;\n\tc->zroot.len = 0;\n\tc->zroot.znode = zi;\n\n\tzn->parent = zi;\n\tzn->iip = 1;\n\tznode->parent = zi;\n\tznode->iip = 0;\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc(&c->dirty_zn",
          "args": [
            "cnt);\n\n\tzi->zbra"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_ZNODE,",
          "args": [
            "&zi->flags)",
            "atomic_lo"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_znode",
          "args": [
            "sz, GFP_NOFS);",
            "f (!zi)"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "dx_znode(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "140-167",
          "snippet": "s_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ns_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest"
        }
      },
      {
        "call_info": {
          "callee": "ting ne",
          "args": [
            "zroot at level %d\", znode->leve",
            "+ 1);\n\n\tzi = kza"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_keys(c, znode);",
          "args": [
            "Loca"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(zi, zbr, n);",
          "args": [
            "In",
            "r"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"insert",
          "args": [
            "ng",
            "%d level %d, key \", n, zn->leve",
            ";",
            "insert_z"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng %d,",
          "args": [
            "eeping %d\", move, keep)",
            "/*",
            "ove"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->dirty_zn",
          "args": [
            "cnt);\n\n\tzn->chil"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_ZNODE,",
          "args": [
            "&zn->flags)",
            "atomic_lo"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) !=",
          "args": [
            "B",
            "S_DA"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) ||",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) !=",
          "args": [
            "e",
            "inum"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) ==",
          "args": [
            "B",
            "S_DA"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) &&",
          "args": [
            "k"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) ==",
          "args": [
            "e",
            "inum"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) ==",
          "args": [
            "B",
            "S_DA"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) &&",
          "args": [
            "k"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1) ==",
          "args": [
            "e",
            "inum"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) == U",
          "args": [
            "I",
            "_DA"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_znode(c, znode);",
          "args": [
            "z",
            "= kza"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"splitt",
          "args": [
            "ng",
            "vel %d, key \", znode->leve",
            ";\n\n\tif (znod"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_keys(c, znode);",
          "args": [
            "turn"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(znode, zbr,",
          "args": [
            ");",
            "* E",
            "u"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"insert",
          "args": [
            "d a",
            "%d level %d, key \", n, znode->l",
            "e",
            ";\n\n\t\tinsert_"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n != c->fano",
          "args": [
            "t);\n\t\tdbg_tnck"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n >= 0 && n",
          "args": [
            "= c->fanout);\n\n\t/* Imple"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_insert(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      struct ubifs_zbranch *zbr, int n)\n{\n\tstruct ubifs_znode *zn, *zi, *zp;\n\tint i, keep, move, appending = 0;\n\tunion ubifs_key *key = &zbr->key, *key1;\n\n\tubifs_assert(n >= 0 && n <= c->fanout);\n\n\t/* Implement naive insert for now */\nagain:\n\tzp = znode->parent;\n\tif (znode->child_cnt < c->fanout) {\n\t\tubifs_assert(n != c->fanout);\n\t\tdbg_tnck(key, \"inserted at %d level %d, key \", n, znode->level);\n\n\t\tinsert_zbranch(znode, zbr, n);\n\n\t\t/* Ensure parent's key is correct */\n\t\tif (n == 0 && zp && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Unfortunately, @znode does not have more empty slots and we have to\n\t * split it.\n\t */\n\tdbg_tnck(key, \"splitting level %d, key \", znode->level);\n\n\tif (znode->alt)\n\t\t/*\n\t\t * We can no longer be sure of finding this znode by key, so we\n\t\t * record it in the old_idx tree.\n\t\t */\n\t\tins_clr_old_idx_znode(c, znode);\n\n\tzn = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zn)\n\t\treturn -ENOMEM;\n\tzn->parent = zp;\n\tzn->level = znode->level;\n\n\t/* Decide where to split */\n\tif (znode->level == 0 && key_type(c, key) == UBIFS_DATA_KEY) {\n\t\t/* Try not to split consecutive data keys */\n\t\tif (n == c->fanout) {\n\t\t\tkey1 = &znode->zbranch[n - 1].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY)\n\t\t\t\tappending = 1;\n\t\t} else\n\t\t\tgoto check_split;\n\t} else if (appending && n != c->fanout) {\n\t\t/* Try not to split consecutive data keys */\n\t\tappending = 0;\ncheck_split:\n\t\tif (n >= (c->fanout + 1) / 2) {\n\t\t\tkey1 = &znode->zbranch[0].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY) {\n\t\t\t\tkey1 = &znode->zbranch[n].key;\n\t\t\t\tif (key_inum(c, key1) != key_inum(c, key) ||\n\t\t\t\t    key_type(c, key1) != UBIFS_DATA_KEY) {\n\t\t\t\t\tkeep = n;\n\t\t\t\t\tmove = c->fanout - keep;\n\t\t\t\t\tzi = znode;\n\t\t\t\t\tgoto do_split;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (appending) {\n\t\tkeep = c->fanout;\n\t\tmove = 0;\n\t} else {\n\t\tkeep = (c->fanout + 1) / 2;\n\t\tmove = c->fanout - keep;\n\t}\n\n\t/*\n\t * Although we don't at present, we could look at the neighbors and see\n\t * if we can move some zbranches there.\n\t */\n\n\tif (n < keep) {\n\t\t/* Insert into existing znode */\n\t\tzi = znode;\n\t\tmove += 1;\n\t\tkeep -= 1;\n\t} else {\n\t\t/* Insert into new znode */\n\t\tzi = zn;\n\t\tn -= keep;\n\t\t/* Re-parent */\n\t\tif (zn->level != 0)\n\t\t\tzbr->znode->parent = zn;\n\t}\n\ndo_split:\n\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzn->child_cnt = move;\n\tznode->child_cnt = keep;\n\n\tdbg_tnc(\"moving %d, keeping %d\", move, keep);\n\n\t/* Move zbranch */\n\tfor (i = 0; i < move; i++) {\n\t\tzn->zbranch[i] = znode->zbranch[keep + i];\n\t\t/* Re-parent */\n\t\tif (zn->level != 0)\n\t\t\tif (zn->zbranch[i].znode) {\n\t\t\t\tzn->zbranch[i].znode->parent = zn;\n\t\t\t\tzn->zbranch[i].znode->iip = i;\n\t\t\t}\n\t}\n\n\t/* Insert new key and branch */\n\tdbg_tnck(key, \"inserting at %d level %d, key \", n, zn->level);\n\n\tinsert_zbranch(zi, zbr, n);\n\n\t/* Insert new znode (produced by spitting) into the parent */\n\tif (zp) {\n\t\tif (n == 0 && zi == znode && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\t/* Locate insertion point */\n\t\tn = znode->iip + 1;\n\n\t\t/* Tail recursion */\n\t\tzbr->key = zn->zbranch[0].key;\n\t\tzbr->znode = zn;\n\t\tzbr->lnum = 0;\n\t\tzbr->offs = 0;\n\t\tzbr->len = 0;\n\t\tznode = zp;\n\n\t\tgoto again;\n\t}\n\n\t/* We have to split root znode */\n\tdbg_tnc(\"creating new zroot at level %d\", znode->level + 1);\n\n\tzi = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zi)\n\t\treturn -ENOMEM;\n\n\tzi->child_cnt = 2;\n\tzi->level = znode->level + 1;\n\n\t__set_bit(DIRTY_ZNODE, &zi->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzi->zbranch[0].key = znode->zbranch[0].key;\n\tzi->zbranch[0].znode = znode;\n\tzi->zbranch[0].lnum = c->zroot.lnum;\n\tzi->zbranch[0].offs = c->zroot.offs;\n\tzi->zbranch[0].len = c->zroot.len;\n\tzi->zbranch[1].key = zn->zbranch[0].key;\n\tzi->zbranch[1].znode = zn;\n\n\tc->zroot.lnum = 0;\n\tc->zroot.offs = 0;\n\tc->zroot.len = 0;\n\tc->zroot.znode = zi;\n\n\tzn->parent = zi;\n\tzn->iip = 1;\n\tznode->parent = zi;\n\tznode->iip = 0;\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "h(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1906-1944",
    "snippet": "nsert_zbranch(struct ubifs_znode *znode,\n\t\t\t   const struct ubifs_zbranch *zbr, int n)\n{\n\tint i;\n\n\tubifs_assert(ubifs_zn_dirty(znode));\n\n\tif (znode->level) {\n\t\tfor (i = znode->child_cnt; i > n; i--) {\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\t\t\tif (znode->zbranch[i].znode)\n\t\t\t\tznode->zbranch[i].znode->iip = i;\n\t\t}\n\t\tif (zbr->znode)\n\t\t\tzbr->znode->iip = n;\n\t} else\n\t\tfor (i = znode->child_cnt; i > n; i--)\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\n\tznode->zbranch[n] = *zbr;\n\tznode->child_cnt += 1;\n\n\t/*\n\t * After inserting at slot zero, the lower bound of the key range of\n\t * this znode may have changed. If this znode is subsequently split\n\t * then the upper bound of the key range may change, and furthermore\n\t * it could change to be lower than the original lower bound. If that\n\t * happens, then it will no longer be possible to find this znode in the\n\t * TNC using the key from the index node on flash. That is bad because\n\t * if it is not found, we will assume it is obsolete and may overwrite\n\t * it. Then if there is an unclean unmount, we will start using the\n\t * old index which will be broken.\n\t *\n\t * So we first mark znodes that have insertions at slot zero, and then\n\t * if they are split we add their lnum/offs to the old_idx tree.\n\t */\n\tif (n == 0)\n\t\tznode->alt = 1;\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_zn_dir",
          "args": [
            "y(znode));\n\n\tif (znod"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode));\n\n\ti",
          "args": [
            "(zno"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nnsert_zbranch(struct ubifs_znode *znode,\n\t\t\t   const struct ubifs_zbranch *zbr, int n)\n{\n\tint i;\n\n\tubifs_assert(ubifs_zn_dirty(znode));\n\n\tif (znode->level) {\n\t\tfor (i = znode->child_cnt; i > n; i--) {\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\t\t\tif (znode->zbranch[i].znode)\n\t\t\t\tznode->zbranch[i].znode->iip = i;\n\t\t}\n\t\tif (zbr->znode)\n\t\t\tzbr->znode->iip = n;\n\t} else\n\t\tfor (i = znode->child_cnt; i > n; i--)\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\n\tznode->zbranch[n] = *zbr;\n\tznode->child_cnt += 1;\n\n\t/*\n\t * After inserting at slot zero, the lower bound of the key range of\n\t * this znode may have changed. If this znode is subsequently split\n\t * then the upper bound of the key range may change, and furthermore\n\t * it could change to be lower than the original lower bound. If that\n\t * happens, then it will no longer be possible to find this znode in the\n\t * TNC using the key from the index node on flash. That is bad because\n\t * if it is not found, we will assume it is obsolete and may overwrite\n\t * it. Then if there is an unclean unmount, we will start using the\n\t * old index which will be broken.\n\t *\n\t * So we first mark znodes that have insertions at slot zero, and then\n\t * if they are split we add their lnum/offs to the old_idx tree.\n\t */\n\tif (n == 0)\n\t\tznode->alt = 1;\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "t_keys(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1874-1893",
    "snippet": "orrect_parent_keys(const struct ubifs_info *c,\n\t\t\t\tstruct ubifs_znode *znode)\n{\n\tunion ubifs_key *key, *key1;\n\n\tubifs_assert(znode->parent);\n\tubifs_assert(znode->iip == 0);\n\n\tkey = &znode->zbranch[0].key;\n\tkey1 = &znode->parent->zbranch[0].key;\n\n\twhile (keys_cmp(c, key, key1) < 0) {\n\t\tkey_copy(c, key, key1);\n\t\tznode = znode->parent;\n\t\tznode->alt = 1;\n\t\tif (!znode->parent || znode->iip)\n\t\t\tbreak;\n\t\tkey1 = &znode->parent->zbranch[0].key;\n\t}\n}\n\n/**\n * inse",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ey, key1",
          "args": [
            ";",
            "zn",
            "e ="
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, key1",
          "args": [
            "0)",
            "ke"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->iip =",
          "args": [
            "0);\n\n\tkey = &z"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->paren",
          "args": [
            ");\n\tubifs_ass"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\norrect_parent_keys(const struct ubifs_info *c,\n\t\t\t\tstruct ubifs_znode *znode)\n{\n\tunion ubifs_key *key, *key1;\n\n\tubifs_assert(znode->parent);\n\tubifs_assert(znode->iip == 0);\n\n\tkey = &znode->zbranch[0].key;\n\tkey1 = &znode->parent->zbranch[0].key;\n\n\twhile (keys_cmp(c, key, key1) < 0) {\n\t\tkey_copy(c, key, key1);\n\t\tznode = znode->parent;\n\t\tznode->alt = 1;\n\t\tif (!znode->parent || znode->iip)\n\t\t\tbreak;\n\t\tkey1 = &znode->parent->zbranch[0].key;\n\t}\n}\n\n/**\n * inse"
  },
  {
    "function_name": "kup_nm(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1840-1863",
    "snippet": "_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct qstr *nm)\n{\n\tint err, len;\n\tconst struct ubifs_dent_node *dent = node;\n\n\t/*\n\t * We assume that in most of the cases there are no name collisions and\n\t * 'ubifs_tnc_lookup()' returns us the right direntry.\n\t */\n\terr = ubifs_tnc_lookup(c, key, node);\n\tif (err)\n\t\treturn err;\n\n\tlen = le16_to_cpu(dent->nlen);\n\tif (nm->len == len && !memcmp(dent->name, nm->name, len))\n\t\treturn 0;\n\n\t/*\n\t * Unluckily, there are hash collisions and we have to iterate over\n\t * them look at each direntry with colliding name hash sequentially.\n\t */\n\treturn do_lookup_nm(c, key, node, nm);\n}\n\n/**\n * corr",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c, key, node",
          "args": [
            ");",
            "/**",
            "*"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, l",
            "))\n\t\tret",
            "n 0"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "if (nm->l"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, key, node",
          "args": [
            ";",
            "if",
            "rr)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct qstr *nm)\n{\n\tint err, len;\n\tconst struct ubifs_dent_node *dent = node;\n\n\t/*\n\t * We assume that in most of the cases there are no name collisions and\n\t * 'ubifs_tnc_lookup()' returns us the right direntry.\n\t */\n\terr = ubifs_tnc_lookup(c, key, node);\n\tif (err)\n\t\treturn err;\n\n\tlen = le16_to_cpu(dent->nlen);\n\tif (nm->len == len && !memcmp(dent->name, nm->name, len))\n\t\treturn 0;\n\n\t/*\n\t * Unluckily, there are hash collisions and we have to iterate over\n\t * them look at each direntry with colliding name hash sequentially.\n\t */\n\treturn do_lookup_nm(c, key, node, nm);\n}\n\n/**\n * corr"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1792-1825",
    "snippet": "_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct qstr *nm)\n{\n\tint found, n, err;\n\tstruct ubifs_znode *znode;\n\n\tdbg_tnck(key, \"name '%.*s' key \", nm->len, nm->name);\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tubifs_assert(n >= 0);\n\n\terr = resolve_collision(c, key, &znode, &n, nm);\n\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\tif (err == 0) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\terr = tnc_read_node_nm(c, &znode->zbranch[n], node);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, &znode->z",
          "args": [
            "r",
            "ch[n], node);\n\nout",
            "nloc"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "oto out"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturned",
          "args": [
            "%d, znode %p, n %d\", err, znode,",
            ");",
            "f (un",
            "k"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sion(c, key, &zno",
          "args": [
            "e",
            "&n,",
            "m);\n\td",
            "_t",
            "(\""
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n >= 0);\n\n\te",
          "args": [
            "r = re"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (!",
            "un"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tfound = u"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"name '",
          "args": [
            ".*s",
            "key \", nm->len, nm",
            "name);",
            "utex_loc"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct qstr *nm)\n{\n\tint found, n, err;\n\tstruct ubifs_znode *znode;\n\n\tdbg_tnck(key, \"name '%.*s' key \", nm->len, nm->name);\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tubifs_assert(n >= 0);\n\n\terr = resolve_collision(c, key, &znode, &n, nm);\n\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\tif (err == 0) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\terr = tnc_read_node_nm(c, &znode->zbranch[n], node);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "k_read(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1735-1777",
    "snippet": "_bulk_read(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\n\tstruct ubifs_wbuf *wbuf;\n\tvoid *buf;\n\n\tlen = bu->zbranch[bu->cnt - 1].offs;\n\tlen += bu->zbranch[bu->cnt - 1].len - offs;\n\tif (len > bu->buf_len) {\n\t\tubifs_err(\"buffer too small %d vs %d\", bu->buf_len, len);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do the read */\n\twbuf = ubifs_get_wbuf(c, lnum);\n\tif (wbuf)\n\t\terr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\n\telse\n\t\terr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\n\n\t/* Check for a race with GC */\n\tif (maybe_leb_gced(c, lnum, bu->gc_seq))\n\t\treturn -EAGAIN;\n\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"failed to read from LEB %d:%d, error %d\",\n\t\t\t  lnum, offs, err);\n\t\tdump_stack();\n\t\tdbg_tnck(&bu->key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Validate the nodes read */\n\tbuf = bu->buf;\n\tfor (i = 0; i < bu->cnt; i++) {\n\t\terr = validate_data_node(c, buf, &bu->zbranch[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf = buf + ALIGN(bu->zbranch[i].len, 8);\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_l",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anch[",
          "args": [
            "].len, 8);\n\t}\n\n\tre",
            "r"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, buf, &bu-",
          "args": [
            "z",
            "anc",
            "i]);\n\t\tif (err)"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">key, \"k",
          "args": [
            "y \");",
            "turn e"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_tnc",
          "args": [],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled to r",
          "args": [
            "ad from LEB %d:%d, error %d\",\n\t\t\t  lnum,",
            "rr);",
            "dum",
            "sta"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, bu-",
          "args": [
            "g",
            "seq)",
            "return -"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, bu-",
          "args": [
            "b",
            ", of",
            ", len,",
            ";",
            "Ch",
            "k"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, bu->bu",
          "args": [
            ", le",
            "lnum,",
            "fs)",
            "els",
            "er"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(c, lnum);\n\ti",
          "args": [
            "buf)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffer too",
          "args": [
            "mall %d vs %d\", bu->buf_len",
            "len);\n\t\tret",
            "n -"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_bulk_read(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\n\tstruct ubifs_wbuf *wbuf;\n\tvoid *buf;\n\n\tlen = bu->zbranch[bu->cnt - 1].offs;\n\tlen += bu->zbranch[bu->cnt - 1].len - offs;\n\tif (len > bu->buf_len) {\n\t\tubifs_err(\"buffer too small %d vs %d\", bu->buf_len, len);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do the read */\n\twbuf = ubifs_get_wbuf(c, lnum);\n\tif (wbuf)\n\t\terr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\n\telse\n\t\terr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\n\n\t/* Check for a race with GC */\n\tif (maybe_leb_gced(c, lnum, bu->gc_seq))\n\t\treturn -EAGAIN;\n\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"failed to read from LEB %d:%d, error %d\",\n\t\t\t  lnum, offs, err);\n\t\tdump_stack();\n\t\tdbg_tnck(&bu->key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Validate the nodes read */\n\tbuf = bu->buf;\n\tfor (i = 0; i < bu->cnt; i++) {\n\t\terr = validate_data_node(c, buf, &bu->zbranch[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf = buf + ALIGN(bu->zbranch[i].len, 8);\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_l"
  },
  {
    "function_name": "_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1679-1723",
    "snippet": "lidate_data_node(struct ubifs_info *c, void *buf,\n\t\t\t      struct ubifs_zbranch *zbr)\n{\n\tunion ubifs_key key1;\n\tstruct ubifs_ch *ch = buf;\n\tint err, len;\n\n\tif (ch->node_type != UBIFS_DATA_NODE) {\n\t\tubifs_err(\"bad node type (%d but expected %d)\",\n\t\t\t  ch->node_type, UBIFS_DATA_NODE);\n\t\tgoto out_err;\n\t}\n\n\terr = ubifs_check_node(c, buf, zbr->lnum, zbr->offs, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"expected node type %d\", UBIFS_DATA_NODE);\n\t\tgoto out;\n\t}\n\n\tlen = le32_to_cpu(ch->len);\n\tif (len != zbr->len) {\n\t\tubifs_err(\"bad node length %d, expected %d\", len, zbr->len);\n\t\tgoto out_err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, buf + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, &zbr->key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(&zbr->key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"found node's key \");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout:\n\tubifs_err(\"bad node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return e",
          "args": [],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf);\n\tdu",
          "args": [
            "p",
            "tac"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node at",
          "args": [
            "LEB %d:%d\", zbr->lnum,",
            "r->offs);",
            "ubifs_dum"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1, \"foun",
          "args": [
            "node",
            "key \");\n\t\tgoto out"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->key, \"",
          "args": [
            "ooked for",
            "ey \");\n\t\tdbg_tnck"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d key in",
          "args": [
            "ode at LEB %d:%d\",\n\t\t\t  zbr->l",
            "r->offs);",
            "dbg_tnck"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key",
          "args": [
            "ey1)) {",
            "bifs_"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf + UBI",
          "args": [
            "S",
            "EY_OFFSET, &key1);\n\tif",
            "!keys"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node le",
          "args": [
            "gth %d, expected %d\", len, zbr->l",
            ");",
            "goto out"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ti",
          "args": [
            "(len !"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pected no",
          "args": [
            "e type %d\", UBIFS_DATA_",
            "DE);\n\t\tgoto out"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf, zbr-",
          "args": [
            "l",
            "m,",
            "r->offs,",
            "0);\n\tif",
            "r"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e (%d but expected %d)\",\n\t\t\t  ch->no",
            ", UBIFS_DATA_",
            "DE);\n\t\tgoto out"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nlidate_data_node(struct ubifs_info *c, void *buf,\n\t\t\t      struct ubifs_zbranch *zbr)\n{\n\tunion ubifs_key key1;\n\tstruct ubifs_ch *ch = buf;\n\tint err, len;\n\n\tif (ch->node_type != UBIFS_DATA_NODE) {\n\t\tubifs_err(\"bad node type (%d but expected %d)\",\n\t\t\t  ch->node_type, UBIFS_DATA_NODE);\n\t\tgoto out_err;\n\t}\n\n\terr = ubifs_check_node(c, buf, zbr->lnum, zbr->offs, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"expected node type %d\", UBIFS_DATA_NODE);\n\t\tgoto out;\n\t}\n\n\tlen = le32_to_cpu(ch->len);\n\tif (len != zbr->len) {\n\t\tubifs_err(\"bad node length %d, expected %d\", len, zbr->len);\n\t\tgoto out_err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, buf + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, &zbr->key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(&zbr->key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"found node's key \");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout:\n\tubifs_err(\"bad node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1636-1669",
    "snippet": "ad_wbuf(struct ubifs_wbuf *wbuf, void *buf, int len, int lnum,\n\t\t     int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\tint rlen, overlap;\n\n\tdbg_io(\"LEB %d:%d, length %d\", lnum, offs, len);\n\tubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(offs + len <= c->leb_size);\n\n\tspin_lock(&wbuf->lock);\n\toverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\n\tif (!overlap) {\n\t\t/* We may safely unlock the write-buffer and read the data */\n\t\tspin_unlock(&wbuf->lock);\n\t\treturn ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\t}\n\n\t/* Don't read under wbuf */\n\trlen = wbuf->offs - offs;\n\tif (rlen < 0)\n\t\trlen = 0;\n\n\t/* Copy the rest from the write-buffer */\n\tmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\n\tspin_unlock(&wbuf->lock);\n\n\tif (rlen > 0)\n\t\t/* Read everything that goes before write-buffer */\n\t\treturn ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\n\n\treturn 0;\n}\n\n/**\n * vali",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "en,",
            ");",
            "etur",
            "0"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "if (rlen"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlen,",
          "args": [
            "buf->buf +",
            "ffs + rlen - wbuf->offs, len - rlen)",
            "spin_unlo"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "n,",
            ";\n\t}",
            "/*",
            "o"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "return u"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "overlap ="
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs + len <",
          "args": [
            "c->leb_size);\n\n\tspin_loc"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(offs & 7)",
          "args": [
            "& offs < c->leb_size);\n\tubifs_ass"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf && lnum",
          "args": [
            ">= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_ass"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "ength %d\", lnum, offs,",
            "en);",
            "ubif",
            "ass"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nad_wbuf(struct ubifs_wbuf *wbuf, void *buf, int len, int lnum,\n\t\t     int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\tint rlen, overlap;\n\n\tdbg_io(\"LEB %d:%d, length %d\", lnum, offs, len);\n\tubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(offs + len <= c->leb_size);\n\n\tspin_lock(&wbuf->lock);\n\toverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\n\tif (!overlap) {\n\t\t/* We may safely unlock the write-buffer and read the data */\n\t\tspin_unlock(&wbuf->lock);\n\t\treturn ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\t}\n\n\t/* Don't read under wbuf */\n\trlen = wbuf->offs - offs;\n\tif (rlen < 0)\n\t\trlen = 0;\n\n\t/* Copy the rest from the write-buffer */\n\tmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\n\tspin_unlock(&wbuf->lock);\n\n\tif (rlen > 0)\n\t\t/* Read everything that goes before write-buffer */\n\t\treturn ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\n\n\treturn 0;\n}\n\n/**\n * vali"
  },
  {
    "function_name": "_bu_keys(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1504-1624",
    "snippet": "_get_bu_keys(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint n, err = 0, lnum = -1, uninitialized_var(offs);\n\tint uninitialized_var(len);\n\tunsigned int block = key_block(c, &bu->key);\n\tstruct ubifs_znode *znode;\n\n\tbu->cnt = 0;\n\tbu->blk_cnt = 0;\n\tbu->eof = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\t/* Find first key */\n\terr = ubifs_lookup_level0(c, &bu->key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out;\n\tif (err) {\n\t\t/* Key found */\n\t\tlen = znode->zbranch[n].len;\n\t\t/* The buffer must be big enough for at least 1 node */\n\t\tif (len > bu->buf_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Add this key */\n\t\tbu->zbranch[bu->cnt++] = znode->zbranch[n];\n\t\tbu->blk_cnt += 1;\n\t\tlnum = znode->zbranch[n].lnum;\n\t\toffs = ALIGN(znode->zbranch[n].offs + len, 8);\n\t}\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\t\tunion ubifs_key *key;\n\t\tunsigned int next_block;\n\n\t\t/* Find next key */\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzbr = &znode->zbranch[n];\n\t\tkey = &zbr->key;\n\t\t/* See if there is another data key for this file */\n\t\tif (key_inum(c, key) != key_inum(c, &bu->key) ||\n\t\t    key_type(c, key) != UBIFS_DATA_KEY) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum < 0) {\n\t\t\t/* First key found */\n\t\t\tlnum = zbr->lnum;\n\t\t\toffs = ALIGN(zbr->offs + zbr->len, 8);\n\t\t\tlen = zbr->len;\n\t\t\tif (len > bu->buf_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data nodes must be in consecutive positions in\n\t\t\t * the same LEB.\n\t\t\t */\n\t\t\tif (zbr->lnum != lnum || zbr->offs != offs)\n\t\t\t\tgoto out;\n\t\t\toffs += ALIGN(zbr->len, 8);\n\t\t\tlen = ALIGN(len, 8) + zbr->len;\n\t\t\t/* Must not exceed buffer length */\n\t\t\tif (len > bu->buf_len)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/* Allow for holes */\n\t\tnext_block = key_block(c, key);\n\t\tbu->blk_cnt += (next_block - block - 1);\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tblock = next_block;\n\t\t/* Add this key */\n\t\tbu->zbranch[bu->cnt++] = *zbr;\n\t\tbu->blk_cnt += 1;\n\t\t/* See if we have room for more */\n\t\tif (bu->cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t}\nout:\n\tif (err == -ENOENT) {\n\t\tbu->eof = 1;\n\t\terr = 0;\n\t}\n\tbu->gc_seq = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\tif (err)\n\t\treturn err;\n\t/*\n\t * An enormous hole could cause bulk-read to encompass too many\n\t * page cache pages, so limit the number here.\n\t */\n\tif (bu->blk_cnt > UBIFS_MAX_BULK_READ)\n\t\tbu->blk_cnt = UBIFS_MAX_BULK_READ;\n\t/*\n\t * Ensure that bulk-read covers a whole number of page cache\n\t * pages.\n\t */\n\tif (UBIFS_BLOCKS_PER_PAGE == 1 ||\n\t    !(bu->blk_cnt & (UBIFS_BLOCKS_PER_PAGE - 1)))\n\t\treturn 0;\n\tif (bu->eof) {\n\t\t/* At the end of file we can round up */\n\t\tbu->blk_cnt += UBIFS_BLOCKS_PER_PAGE - 1;\n\t\treturn 0;\n\t}\n\t/* Exclude data nodes that do not make up a whole page cache page */\n\tblock = key_block(c, &bu->key) + bu->blk_cnt;\n\tblock &= ~(UBIFS_BLOCKS_PER_PAGE - 1);\n\twhile (bu->cnt) {\n\t\tif (key_block(c, &bu->zbranch[bu->cnt - 1].key) < block)\n\t\t\tbreak;\n\t\tbu->cnt -= 1;\n\t}\n\treturn 0;\n}\n\n/**\n * read",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&bu->zbra",
          "args": [
            "c",
            "bu->cnt - 1].key) < block)"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bu->key)",
          "args": [
            "+",
            "u->blk_c"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\tif (err)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key);\n\t\tb",
          "args": [
            "-",
            "lk_"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ zb",
          "args": [
            "->l",
            ";"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, 8)",
          "args": [
            "len",
            "A"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs +",
          "args": [
            "br->len, 8);\n\t\t\tlen",
            "z"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) != U",
          "args": [
            "I",
            "_DA"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bu->key)",
          "args": [
            "|",
            "ke"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) != k",
          "args": [
            "y",
            "num"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            ")",
            "if (",
            "r)"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbran",
          "args": [
            "h[n].offs + len, 8);\n\t}\n\twhi"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, &bu->key,",
          "args": [
            "&",
            "ode, &n)",
            "if (e",
            "<"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\t/* Find f"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bu->key)",
          "args": [
            "truct ub"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_get_bu_keys(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint n, err = 0, lnum = -1, uninitialized_var(offs);\n\tint uninitialized_var(len);\n\tunsigned int block = key_block(c, &bu->key);\n\tstruct ubifs_znode *znode;\n\n\tbu->cnt = 0;\n\tbu->blk_cnt = 0;\n\tbu->eof = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\t/* Find first key */\n\terr = ubifs_lookup_level0(c, &bu->key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out;\n\tif (err) {\n\t\t/* Key found */\n\t\tlen = znode->zbranch[n].len;\n\t\t/* The buffer must be big enough for at least 1 node */\n\t\tif (len > bu->buf_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Add this key */\n\t\tbu->zbranch[bu->cnt++] = znode->zbranch[n];\n\t\tbu->blk_cnt += 1;\n\t\tlnum = znode->zbranch[n].lnum;\n\t\toffs = ALIGN(znode->zbranch[n].offs + len, 8);\n\t}\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\t\tunion ubifs_key *key;\n\t\tunsigned int next_block;\n\n\t\t/* Find next key */\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzbr = &znode->zbranch[n];\n\t\tkey = &zbr->key;\n\t\t/* See if there is another data key for this file */\n\t\tif (key_inum(c, key) != key_inum(c, &bu->key) ||\n\t\t    key_type(c, key) != UBIFS_DATA_KEY) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum < 0) {\n\t\t\t/* First key found */\n\t\t\tlnum = zbr->lnum;\n\t\t\toffs = ALIGN(zbr->offs + zbr->len, 8);\n\t\t\tlen = zbr->len;\n\t\t\tif (len > bu->buf_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data nodes must be in consecutive positions in\n\t\t\t * the same LEB.\n\t\t\t */\n\t\t\tif (zbr->lnum != lnum || zbr->offs != offs)\n\t\t\t\tgoto out;\n\t\t\toffs += ALIGN(zbr->len, 8);\n\t\t\tlen = ALIGN(len, 8) + zbr->len;\n\t\t\t/* Must not exceed buffer length */\n\t\t\tif (len > bu->buf_len)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/* Allow for holes */\n\t\tnext_block = key_block(c, key);\n\t\tbu->blk_cnt += (next_block - block - 1);\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tblock = next_block;\n\t\t/* Add this key */\n\t\tbu->zbranch[bu->cnt++] = *zbr;\n\t\tbu->blk_cnt += 1;\n\t\t/* See if we have room for more */\n\t\tif (bu->cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t}\nout:\n\tif (err == -ENOENT) {\n\t\tbu->eof = 1;\n\t\terr = 0;\n\t}\n\tbu->gc_seq = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\tif (err)\n\t\treturn err;\n\t/*\n\t * An enormous hole could cause bulk-read to encompass too many\n\t * page cache pages, so limit the number here.\n\t */\n\tif (bu->blk_cnt > UBIFS_MAX_BULK_READ)\n\t\tbu->blk_cnt = UBIFS_MAX_BULK_READ;\n\t/*\n\t * Ensure that bulk-read covers a whole number of page cache\n\t * pages.\n\t */\n\tif (UBIFS_BLOCKS_PER_PAGE == 1 ||\n\t    !(bu->blk_cnt & (UBIFS_BLOCKS_PER_PAGE - 1)))\n\t\treturn 0;\n\tif (bu->eof) {\n\t\t/* At the end of file we can round up */\n\t\tbu->blk_cnt += UBIFS_BLOCKS_PER_PAGE - 1;\n\t\treturn 0;\n\t}\n\t/* Exclude data nodes that do not make up a whole page cache page */\n\tblock = key_block(c, &bu->key) + bu->blk_cnt;\n\tblock &= ~(UBIFS_BLOCKS_PER_PAGE - 1);\n\twhile (bu->cnt) {\n\t\tif (key_block(c, &bu->zbranch[bu->cnt - 1].key) < block)\n\t\t\tbreak;\n\t\tbu->cnt -= 1;\n\t}\n\treturn 0;\n}\n\n/**\n * read"
  },
  {
    "function_name": "ate(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1430-1489",
    "snippet": "_locate(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     void *node, int *lnum, int *offs)\n{\n\tint found, n, err, safely = 0, gc_seq1;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch zbr, *zt;\n\nagain:\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out;\n\t}\n\tzt = &znode->zbranch[n];\n\tif (lnum) {\n\t\t*lnum = zt->lnum;\n\t\t*offs = zt->offs;\n\t}\n\tif (is_hash_key(c, key)) {\n\t\t/*\n\t\t * In this case the leaf node cache gets used, so we pass the\n\t\t * address of the zbranch and keep the mutex locked\n\t\t */\n\t\terr = tnc_read_node_nm(c, zt, node);\n\t\tgoto out;\n\t}\n\tif (safely) {\n\t\terr = ubifs_tnc_read_node(c, zt, node);\n\t\tgoto out;\n\t}\n\t/* Drop the TNC mutex prematurely and race with garbage collection */\n\tzbr = znode->zbranch[n];\n\tgc_seq1 = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\n\tif (ubifs_get_wbuf(c, zbr.lnum)) {\n\t\t/* We do not GC journal heads */\n\t\terr = ubifs_tnc_read_node(c, &zbr, node);\n\t\treturn err;\n\t}\n\n\terr = fallible_read_node(c, key, &zbr, node);\n\tif (err <= 0 || maybe_leb_gced(c, zbr.lnum, gc_seq1)) {\n\t\t/*\n\t\t * The node may have been GC'ed out from under us so try again\n\t\t * while keeping the TNC mutex locked.\n\t\t */\n\t\tsafely = 1;\n\t\tgoto again;\n\t}\n\treturn 0;\n\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, zbr.lnum,",
          "args": [
            "g",
            "seq1)) {",
            "/*"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, key, &zbr",
          "args": [
            "de)",
            "if",
            "rr <"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, &zbr, nod",
          "args": [
            ")",
            "re",
            "rn e"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(c, zbr.lnum)",
          "args": [
            "/* We"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\n\tif (ubif"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zt, node)",
          "args": [
            "go",
            "out"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, zt, node)",
          "args": [
            "go",
            "out"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key)) {",
          "args": [
            "/"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, key, &zno",
          "args": [
            "e",
            "&n)",
            "if (!",
            "un"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\tfound = u"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_locate(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     void *node, int *lnum, int *offs)\n{\n\tint found, n, err, safely = 0, gc_seq1;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch zbr, *zt;\n\nagain:\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out;\n\t}\n\tzt = &znode->zbranch[n];\n\tif (lnum) {\n\t\t*lnum = zt->lnum;\n\t\t*offs = zt->offs;\n\t}\n\tif (is_hash_key(c, key)) {\n\t\t/*\n\t\t * In this case the leaf node cache gets used, so we pass the\n\t\t * address of the zbranch and keep the mutex locked\n\t\t */\n\t\terr = tnc_read_node_nm(c, zt, node);\n\t\tgoto out;\n\t}\n\tif (safely) {\n\t\terr = ubifs_tnc_read_node(c, zt, node);\n\t\tgoto out;\n\t}\n\t/* Drop the TNC mutex prematurely and race with garbage collection */\n\tzbr = znode->zbranch[n];\n\tgc_seq1 = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\n\tif (ubifs_get_wbuf(c, zbr.lnum)) {\n\t\t/* We do not GC journal heads */\n\t\terr = ubifs_tnc_read_node(c, &zbr, node);\n\t\treturn err;\n\t}\n\n\terr = fallible_read_node(c, key, &zbr, node);\n\tif (err <= 0 || maybe_leb_gced(c, zbr.lnum, gc_seq1)) {\n\t\t/*\n\t\t * The node may have been GC'ed out from under us so try again\n\t\t * while keeping the TNC mutex locked.\n\t\t */\n\t\tsafely = 1;\n\t\tgoto again;\n\t}\n\treturn 0;\n\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "d(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1391-1415",
    "snippet": "ybe_leb_gced(struct ubifs_info *c, int lnum, int gc_seq1)\n{\n\tint gc_seq2, gced_lnum;\n\n\tgced_lnum = c->gced_lnum;\n\tsmp_rmb();\n\tgc_seq2 = c->gc_seq;\n\t/* Same seq means no GC */\n\tif (gc_seq1 == gc_seq2)\n\t\treturn 0;\n\t/* Different by more than 1 means we don't know */\n\tif (gc_seq1 + 1 != gc_seq2)\n\t\treturn 1;\n\t/*\n\t * We have seen the sequence number has increased by 1. Now we need to\n\t * be sure we read the right LEB number, so read it again.\n\t */\n\tsmp_rmb();\n\tif (gced_lnum != c->gced_lnum)\n\t\treturn 1;\n\t/* Finally we can check lnum */\n\tif (gced_lnum == lnum)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f (gced",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_seq2",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nybe_leb_gced(struct ubifs_info *c, int lnum, int gc_seq1)\n{\n\tint gc_seq2, gced_lnum;\n\n\tgced_lnum = c->gced_lnum;\n\tsmp_rmb();\n\tgc_seq2 = c->gc_seq;\n\t/* Same seq means no GC */\n\tif (gc_seq1 == gc_seq2)\n\t\treturn 0;\n\t/* Different by more than 1 means we don't know */\n\tif (gc_seq1 + 1 != gc_seq2)\n\t\treturn 1;\n\t/*\n\t * We have seen the sequence number has increased by 1. Now we need to\n\t * be sure we read the right LEB number, so read it again.\n\t */\n\tsmp_rmb();\n\tif (gced_lnum != c->gced_lnum)\n\t\treturn 1;\n\t/* Finally we can check lnum */\n\tif (gced_lnum == lnum)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1295-1379",
    "snippet": "okup_level0_dirty(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t       struct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\tunsigned long time = get_seconds();\n\n\tdbg_tnck(key, \"search and dirty key \");\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode = dirty_cow_znode(c, &c->zroot);\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* znode is not in TNC cache, load it from the media */\n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t\tznode = dirty_cow_znode(c, zbr);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t/*\n\t * See huge comment at 'lookup_level0_dirty()' what is the rest of the\n\t * code.\n\t */\n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\n\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n/**\n * mayb",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d 1, lv",
          "args": [
            "%d, n %d\", znode->leve",
            "*n);\n\t*zn =",
            "no"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "dbg_t"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom_up(c, znode);",
          "args": [
            "i",
            "(IS_E"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "node"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d 0, lv",
          "args": [
            "%d, n -1\", znode->leve",
            ";\n\t\treturn 0"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zno",
          "args": [
            "e",
            "zbr",
            "ch[*n].key)) {\n\t\t*n = -"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "eturn e"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d 0, lv",
          "args": [
            "%d, n -1\", znode->leve",
            ";\n\t\treturn 0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n",
          "args": [
            ";",
            "if (er",
            "="
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d %d, l",
          "args": [
            "l %d, n %d\", exact, znod",
            ">leve",
            "*n);\n\t\tretu",
            "e"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key) || *",
          "args": [
            "-1"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "*zn ="
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, zbr);\n\t\ti",
          "args": [
            "S_E"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tzn",
          "args": [
            "de ="
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            "n);",
            "if (",
            "_E"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tc",
          "args": [
            "ntinu"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "eturn"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "de(c, zbr);",
          "args": [
            "f",
            "IS_"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbranch(c, znode, ke",
          "args": [
            ",",
            ");",
            "f (",
            "o"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\tzn",
          "args": [
            "de->t"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn P"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, &c->zroot",
          "args": [
            ";",
            "if (IS_ER"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "znode"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, &c->zroot",
          "args": [
            "LL, 0);",
            "f (I",
            "E"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de)) {",
          "args": [
            "znode"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"search",
          "args": [
            "and",
            "irty key \");\n\n\tznode ="
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tdbg_tnc",
          "args": [],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nokup_level0_dirty(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t       struct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\tunsigned long time = get_seconds();\n\n\tdbg_tnck(key, \"search and dirty key \");\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode = dirty_cow_znode(c, &c->zroot);\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* znode is not in TNC cache, load it from the media */\n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t\tznode = dirty_cow_znode(c, zbr);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t/*\n\t * See huge comment at 'lookup_level0_dirty()' what is the rest of the\n\t * code.\n\t */\n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\n\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n/**\n * mayb"
  },
  {
    "function_name": "level0(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1159-1268",
    "snippet": "kup_level0(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tstruct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\tunsigned long time = get_seconds();\n\n\tdbg_tnck(key, \"search key \");\n\tubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = zbr->znode;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* znode is not in TNC cache, load it from the media */\n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t/*\n\t * Here is a tricky place. We have not found the key and this is a\n\t * \"hashed\" key, which may collide. The rest of the code deals with\n\t * situations like this:\n\t *\n\t *                  | 3 | 5 |\n\t *                  /       \\\n\t *          | 3 | 5 |      | 6 | 7 | (x)\n\t *\n\t * Or more a complex example:\n\t *\n\t *                | 1 | 5 |\n\t *                /       \\\n\t *       | 1 | 3 |         | 5 | 8 |\n\t *              \\           /\n\t *          | 5 | 5 |   | 6 | 7 | (x)\n\t *\n\t * In the examples, if we are looking for key \"5\", we may reach nodes\n\t * marked with \"(x)\". In this case what we have do is to look at the\n\t * left and see if there is \"5\" key there. If there is, we have to\n\t * return it.\n\t *\n\t * Note, this whole situation is possible because we allow to have\n\t * elements which are equivalent to the next key in the parent in the\n\t * children of current znode. For example, this happens if we split a\n\t * znode like this: | 3 | 5 | 5 | 6 | 7 |, which results in something\n\t * like this:\n\t *                      | 3 | 5 |\n\t *                       /     \\\n\t *                | 3 | 5 |   | 5 | 6 | 7 |\n\t *                              ^\n\t * And this becomes what is at the first \"picture\" after key \"5\" marked\n\t * with \"^\" is removed. What could be done is we could prohibit\n\t * splitting in the middle of the colliding sequence. Also, when\n\t * removing the leftmost key, we would have to correct the key of the\n\t * parent node, which would introduce additional complications. Namely,\n\t * if we changed the leftmost key of the parent znode, the garbage\n\t * collector would be unable to find it (GC is doing this when GC'ing\n\t * indexing LEBs). Although we already have an additional RB-tree where\n\t * we save such changed znodes (see 'ins_clr_old_idx_znode()') until\n\t * after the commit. But anyway, this does not look easy to implement\n\t * so we did not try this.\n\t */\n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n/**\n * look",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d 1, lv",
          "args": [
            "%d, n %d\", znode->leve",
            "*n);\n\t*zn =",
            "no"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d 0, lv",
          "args": [
            "%d, n -1\", znode->leve",
            ";\n\t\t*n = -1;"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zno",
          "args": [
            "e",
            "zbr",
            "ch[*n].key)) {\n\t\tdbg_tn"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "eturn e"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d 0, lv",
          "args": [
            "%d, n -1\", znode->leve",
            ";\n\t\t*n = -1;"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, n",
          "args": [
            ";",
            "if (er",
            "="
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d %d, l",
          "args": [
            "l %d, n %d\", exact, znod",
            ">leve",
            "*n);\n\t\tretu",
            "e"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key) || *",
          "args": [
            "-1"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "*zn ="
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            "n);",
            "if (",
            "_E"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbranch(c, znode, ke",
          "args": [
            ",",
            ");",
            "f (",
            "o"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "znode"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, &c->zroot",
          "args": [
            "LL, 0);",
            "f (I",
            "E"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de)) {",
          "args": [
            "znode"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "ey) < UBIFS_INVALID_KEY);\n\n\tznode ="
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) < UB",
          "args": [
            "F",
            "INV"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"search",
          "args": [
            "key",
            ");\n\tubifs_ass"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tdbg_tnc",
          "args": [],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nkup_level0(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tstruct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\tunsigned long time = get_seconds();\n\n\tdbg_tnck(key, \"search key \");\n\tubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = zbr->znode;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* znode is not in TNC cache, load it from the media */\n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t/*\n\t * Here is a tricky place. We have not found the key and this is a\n\t * \"hashed\" key, which may collide. The rest of the code deals with\n\t * situations like this:\n\t *\n\t *                  | 3 | 5 |\n\t *                  /       \\\n\t *          | 3 | 5 |      | 6 | 7 | (x)\n\t *\n\t * Or more a complex example:\n\t *\n\t *                | 1 | 5 |\n\t *                /       \\\n\t *       | 1 | 3 |         | 5 | 8 |\n\t *              \\           /\n\t *          | 5 | 5 |   | 6 | 7 | (x)\n\t *\n\t * In the examples, if we are looking for key \"5\", we may reach nodes\n\t * marked with \"(x)\". In this case what we have do is to look at the\n\t * left and see if there is \"5\" key there. If there is, we have to\n\t * return it.\n\t *\n\t * Note, this whole situation is possible because we allow to have\n\t * elements which are equivalent to the next key in the parent in the\n\t * children of current znode. For example, this happens if we split a\n\t * znode like this: | 3 | 5 | 5 | 6 | 7 |, which results in something\n\t * like this:\n\t *                      | 3 | 5 |\n\t *                       /     \\\n\t *                | 3 | 5 |   | 5 | 6 | 7 |\n\t *                              ^\n\t * And this becomes what is at the first \"picture\" after key \"5\" marked\n\t * with \"^\" is removed. What could be done is we could prohibit\n\t * splitting in the middle of the colliding sequence. Also, when\n\t * removing the leftmost key, we would have to correct the key of the\n\t * parent node, which would introduce additional complications. Namely,\n\t * if we changed the leftmost key of the parent znode, the garbage\n\t * collector would be unable to find it (GC is doing this when GC'ing\n\t * indexing LEBs). Although we already have an additional RB-tree where\n\t * we save such changed znodes (see 'ins_clr_old_idx_znode()') until\n\t * after the commit. But anyway, this does not look easy to implement\n\t * so we did not try this.\n\t */\n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n/**\n * look"
  },
  {
    "function_name": "tom_up(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1080-1135",
    "snippet": "ubifs_znode *dirty_cow_bottom_up(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zp;\n\tint *path = c->bottom_up_buf, p = 0;\n\n\tubifs_assert(c->zroot.znode);\n\tubifs_assert(znode);\n\tif (c->zroot.znode->level > BOTTOM_UP_HEIGHT) {\n\t\tkfree(c->bottom_up_buf);\n\t\tc->bottom_up_buf = kmalloc(c->zroot.znode->level * sizeof(int),\n\t\t\t\t\t   GFP_NOFS);\n\t\tif (!c->bottom_up_buf)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath = c->bottom_up_buf;\n\t}\n\tif (c->zroot.znode->level) {\n\t\t/* Go up until parent is dirty */\n\t\twhile (1) {\n\t\t\tint n;\n\n\t\t\tzp = znode->parent;\n\t\t\tif (!zp)\n\t\t\t\tbreak;\n\t\t\tn = znode->iip;\n\t\t\tubifs_assert(p < c->zroot.znode->level);\n\t\t\tpath[p++] = n;\n\t\t\tif (!zp->cnext && ubifs_zn_dirty(znode))\n\t\t\t\tbreak;\n\t\t\tznode = zp;\n\t\t}\n\t}\n\n\t/* Come back down, dirtying as we go */\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tubifs_assert(path[p - 1] >= 0);\n\t\t\tubifs_assert(path[p - 1] < zp->child_cnt);\n\t\t\tzbr = &zp->zbranch[path[--p]];\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t} else {\n\t\t\tubifs_assert(znode == c->zroot.znode);\n\t\t\tznode = dirty_cow_znode(c, &c->zroot);\n\t\t}\n\t\tif (IS_ERR(znode) || !p)\n\t\t\tbreak;\n\t\tubifs_assert(path[p - 1] >= 0);\n\t\tubifs_assert(path[p - 1] < znode->child_cnt);\n\t\tznode = znode->zbranch[path[p - 1]].znode;\n\t}\n\n\treturn znode;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path[p - 1]",
          "args": [
            "znode->child_cnt);\n\t\tznode ="
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path[p - 1]",
          "args": [
            "= 0);\n\t\tubifs_as"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "|| !p",
          "args": [
            "b"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, &c->zroot",
          "args": [
            ";",
            "}\n\t\tif ("
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode == c->",
          "args": [
            "root.znode);\n\t\t\tznode ="
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, zbr);\n\t\t}",
          "args": [
            "e",
            "e {"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path[p - 1]",
          "args": [
            "zp->child_cnt);\n\t\t\tzbr = &"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path[p - 1]",
          "args": [
            "= 0);\n\t\t\tubifs_a"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode))",
          "args": [
            "reak;"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p < c->zroot",
          "args": [
            "znode->level);\n\t\t\tpath[p+"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "ath = c"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot.zno",
          "args": [
            "e->level * sizeof(int),\n\t\t\t\t\t   GFP",
            "if (!c->"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_up",
          "args": [
            "buf);\n\t\tc->botto"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);\n\tif",
          "args": [
            "c->zr"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->zroot.zno",
          "args": [
            "e);\n\tubifs_ass"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *dirty_cow_bottom_up(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zp;\n\tint *path = c->bottom_up_buf, p = 0;\n\n\tubifs_assert(c->zroot.znode);\n\tubifs_assert(znode);\n\tif (c->zroot.znode->level > BOTTOM_UP_HEIGHT) {\n\t\tkfree(c->bottom_up_buf);\n\t\tc->bottom_up_buf = kmalloc(c->zroot.znode->level * sizeof(int),\n\t\t\t\t\t   GFP_NOFS);\n\t\tif (!c->bottom_up_buf)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath = c->bottom_up_buf;\n\t}\n\tif (c->zroot.znode->level) {\n\t\t/* Go up until parent is dirty */\n\t\twhile (1) {\n\t\t\tint n;\n\n\t\t\tzp = znode->parent;\n\t\t\tif (!zp)\n\t\t\t\tbreak;\n\t\t\tn = znode->iip;\n\t\t\tubifs_assert(p < c->zroot.znode->level);\n\t\t\tpath[p++] = n;\n\t\t\tif (!zp->cnext && ubifs_zn_dirty(znode))\n\t\t\t\tbreak;\n\t\t\tznode = zp;\n\t\t}\n\t}\n\n\t/* Come back down, dirtying as we go */\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tubifs_assert(path[p - 1] >= 0);\n\t\t\tubifs_assert(path[p - 1] < zp->child_cnt);\n\t\t\tzbr = &zp->zbranch[path[--p]];\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t} else {\n\t\t\tubifs_assert(znode == c->zroot.znode);\n\t\t\tznode = dirty_cow_znode(c, &c->zroot);\n\t\t}\n\t\tif (IS_ERR(znode) || !p)\n\t\t\tbreak;\n\t\tubifs_assert(path[p - 1] >= 0);\n\t\tubifs_assert(path[p - 1] < znode->child_cnt);\n\t\tznode = znode->zbranch[path[p - 1]].znode;\n\t}\n\n\treturn znode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "sion_directly(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "1023-1068",
    "snippet": "solve_collision_directly(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint nn, err;\n\n\tznode = *zn;\n\tnn = *n;\n\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\treturn 1;\n\n\t/* Look left */\n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\tbreak;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs)) {\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Look right */\n\tznode = *zn;\n\tnn = *n;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\treturn 0;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\treturn 0;\n\t\t*zn = znode;\n\t\t*n = nn;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\t\treturn 1;\n\t}\n}\n\n/**\n * dirt",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ion(&znode->zbra",
          "args": [
            "ch[nn], lnum, offs)",
            "r",
            "urn"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[nn].key, key))\n\t\t\tre",
            "rn"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            "n",
            "if",
            "rr"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(&znode->zbra",
          "args": [
            "ch[nn], lnum, offs)",
            "{",
            "zn ="
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[nn].key, key))\n\t\t\tbr",
            "k;"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            "n",
            "if",
            "rr"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(&znode->zbra",
          "args": [
            "ch[nn], lnum, offs)",
            "re",
            "rn 1"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nsolve_collision_directly(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint nn, err;\n\n\tznode = *zn;\n\tnn = *n;\n\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\treturn 1;\n\n\t/* Look left */\n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\tbreak;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs)) {\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Look right */\n\tznode = *zn;\n\tnn = *n;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\treturn 0;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\treturn 0;\n\t\t*zn = znode;\n\t\t*n = nn;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\t\treturn 1;\n\t}\n}\n\n/**\n * dirt"
  },
  {
    "function_name": "ion(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "998-1004",
    "snippet": "tches_position(struct ubifs_zbranch *zbr, int lnum, int offs)\n{\n\tif (zbr->lnum == lnum && zbr->offs == offs)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * reso",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ntches_position(struct ubifs_zbranch *zbr, int lnum, int offs)\n{\n\tif (zbr->lnum == lnum && zbr->offs == offs)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * reso"
  },
  {
    "function_name": "lve_collision(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "879-988",
    "snippet": "llible_resolve_collision(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      const struct qstr *nm, int adding)\n{\n\tstruct ubifs_znode *o_znode = NULL, *znode = *zn;\n\tint uninitialized_var(o_n), err, cmp, unsure = 0, nn = *n;\n\n\tcmp = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\tif (unlikely(cmp < 0))\n\t\treturn cmp;\n\tif (cmp == NAME_MATCHES)\n\t\treturn 1;\n\tif (cmp == NOT_ON_MEDIA) {\n\t\to_znode = znode;\n\t\to_n = nn;\n\t\t/*\n\t\t * We are unlucky and hit a dangling branch straight away.\n\t\t * Now we do not really know where to go to find the needed\n\t\t * branch - to the left or to the right. Well, let's try left.\n\t\t */\n\t\tunsure = 1;\n\t} else if (!adding)\n\t\tunsure = 1; /* Remove a dangling branch wherever it is */\n\n\tif (cmp == NAME_GREATER || unsure) {\n\t\t/* Look left */\n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t/* See comments in 'resolve_collision()' */\n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t/* Should be impossible */\n\t\t\t\t\t\tubifs_assert(0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = fallible_matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = *zn;\n\t\t\t\to_n = *n;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!adding)\n\t\t\t\tcontinue;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tunsure = 0;\n\t\t}\n\t}\n\n\tif (cmp == NAME_LESS || unsure) {\n\t\t/* Look right */\n\t\t*zn = znode;\n\t\t*n = nn;\n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\tbreak;\n\t\t\terr = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\tbreak;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = znode;\n\t\t\t\to_n = nn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Never match a dangling branch when adding */\n\tif (adding || !o_znode)\n\t\treturn 0;\n\n\tdbg_mntk(key, \"dangling match LEB %d:%d len %d key \",\n\t\to_znode->zbranch[o_n].lnum, o_znode->zbranch[o_n].offs,\n\t\to_znode->zbranch[o_n].len);\n\t*zn = o_znode;\n\t*n = o_n;\n\treturn 1;\n}\n\n/**\n * matc",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"dangli",
          "args": [
            "g m",
            "ch LEB %d:%d len %d key \",\n\t\to_znode->",
            "nch[o_n].lnum, o_znode->zb",
            "nch[o_n].offs,\n\t\to_znode->",
            "nch[o_n].len);\n\t*zn = o_z"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hes_name(c, &znode->z",
          "args": [
            "r",
            "ch[nn], nm);\n\t\t\tif",
            "rr"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[nn].key, key))\n\t\t\t\tb",
            "ak;"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            "n",
            "if",
            "err"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hes_name(c, &(*zn)->z",
          "args": [
            "r",
            "ch[*n], nm);\n\t\t\tif",
            "rr"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n == 0);",
          "args": [
            "*n ="
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);\n\t\t\t\t\t\tif",
          "args": [
            "("
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, n);",
          "args": [
            "if",
            "e"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(*zn)->z",
          "args": [
            "r",
            "ch[*n].key, key)) {",
            "* S"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n == 0);",
          "args": [
            "*n = -"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, n);",
          "args": [
            "(",
            "r"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "eturn c"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hes_name(c, &znode->z",
          "args": [
            "r",
            "ch[nn], nm);\n\tif (u",
            "ik"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nllible_resolve_collision(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      const struct qstr *nm, int adding)\n{\n\tstruct ubifs_znode *o_znode = NULL, *znode = *zn;\n\tint uninitialized_var(o_n), err, cmp, unsure = 0, nn = *n;\n\n\tcmp = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\tif (unlikely(cmp < 0))\n\t\treturn cmp;\n\tif (cmp == NAME_MATCHES)\n\t\treturn 1;\n\tif (cmp == NOT_ON_MEDIA) {\n\t\to_znode = znode;\n\t\to_n = nn;\n\t\t/*\n\t\t * We are unlucky and hit a dangling branch straight away.\n\t\t * Now we do not really know where to go to find the needed\n\t\t * branch - to the left or to the right. Well, let's try left.\n\t\t */\n\t\tunsure = 1;\n\t} else if (!adding)\n\t\tunsure = 1; /* Remove a dangling branch wherever it is */\n\n\tif (cmp == NAME_GREATER || unsure) {\n\t\t/* Look left */\n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t/* See comments in 'resolve_collision()' */\n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t/* Should be impossible */\n\t\t\t\t\t\tubifs_assert(0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = fallible_matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = *zn;\n\t\t\t\to_n = *n;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!adding)\n\t\t\t\tcontinue;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tunsure = 0;\n\t\t}\n\t}\n\n\tif (cmp == NAME_LESS || unsure) {\n\t\t/* Look right */\n\t\t*zn = znode;\n\t\t*n = nn;\n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\tbreak;\n\t\t\terr = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\tbreak;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = znode;\n\t\t\t\to_n = nn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Never match a dangling branch when adding */\n\tif (adding || !o_znode)\n\t\treturn 0;\n\n\tdbg_mntk(key, \"dangling match LEB %d:%d len %d key \",\n\t\to_znode->zbranch[o_n].lnum, o_znode->zbranch[o_n].offs,\n\t\to_znode->zbranch[o_n].len);\n\t*zn = o_znode;\n\t*n = o_n;\n\treturn 1;\n}\n\n/**\n * matc"
  },
  {
    "function_name": "hes_name(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "809-855",
    "snippet": "llible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, m",
            "_t(int,",
            "en, nm->len));\n\tif (err ="
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, n",
          "args": [
            "->l",
            "));",
            "f (err"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "err = mem"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tly(c, zbr, dent",
          "args": [
            ";",
            "if",
            "err)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err == 1);",
          "args": [
            "err = l"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, &zbr->key",
          "args": [
            "r, dent);",
            "if",
            "err"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "if (!den"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nllible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall"
  },
  {
    "function_name": "sion(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "691-792",
    "snippet": "solve_collision(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t     struct ubifs_znode **zn, int *n,\n\t\t\t     const struct qstr *nm)\n{\n\tint err;\n\n\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (err == NAME_MATCHES)\n\t\treturn 1;\n\n\tif (err == NAME_GREATER) {\n\t\t/* Look left */\n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t/*\n\t\t\t\t * We have found the branch after which we would\n\t\t\t\t * like to insert, but inserting in this znode\n\t\t\t\t * may still be wrong. Consider the following 3\n\t\t\t\t * znodes, in the case where we are resolving a\n\t\t\t\t * collision with Key2.\n\t\t\t\t *\n\t\t\t\t *                  znode zp\n\t\t\t\t *            ----------------------\n\t\t\t\t * level 1     |  Key0  |  Key1  |\n\t\t\t\t *            -----------------------\n\t\t\t\t *                 |            |\n\t\t\t\t *       znode za  |            |  znode zb\n\t\t\t\t *          ------------      ------------\n\t\t\t\t * level 0  |  Key0  |        |  Key2  |\n\t\t\t\t *          ------------      ------------\n\t\t\t\t *\n\t\t\t\t * The lookup finds Key2 in znode zb. Lets say\n\t\t\t\t * there is no match and the name is greater so\n\t\t\t\t * we look left. When we find Key0, we end up\n\t\t\t\t * here. If we return now, we will insert into\n\t\t\t\t * znode za at slot n = 1.  But that is invalid\n\t\t\t\t * according to the parent's keys.  Key2 must\n\t\t\t\t * be inserted into znode zb.\n\t\t\t\t *\n\t\t\t\t * Note, this problem is not relevant for the\n\t\t\t\t * case when we go right, because\n\t\t\t\t * 'tnc_insert()' would correct the parent key.\n\t\t\t\t */\n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t/* Should be impossible */\n\t\t\t\t\t\tubifs_assert(0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\treturn 0;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(err == NAME_GREATER);\n\t\t}\n\t} else {\n\t\tint nn = *n;\n\t\tstruct ubifs_znode *znode = *zn;\n\n\t\t/* Look right */\n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\treturn 0;\n\t\t\terr = matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\treturn 0;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(err == NAME_LESS);\n\t\t}\n\t}\n}\n\n/**\n * fall",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err == NAME_",
          "args": [
            "ESS);\n\t\t}\n\t}\n}"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &znode->z",
          "args": [
            "r",
            "ch[nn], nm);\n\t\t\tif",
            "rr"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[nn].key, key))\n\t\t\t\tr",
            "urn"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, &",
          "args": [
            "n",
            "if",
            "err"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err == NAME_",
          "args": [
            "REATER);\n\t\t}\n\t} els"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &(*zn)->z",
          "args": [
            "r",
            "ch[*n], nm);\n\t\t\tif",
            "rr"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n == 0);",
          "args": [
            "*n ="
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);\n\t\t\t\t\t\tif",
          "args": [
            "("
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, n);",
          "args": [
            "if",
            "e"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(*zn)->z",
          "args": [
            "r",
            "ch[*n].key, key)) {",
            "*"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n == 0);",
          "args": [
            "*n = -"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, n);",
          "args": [
            "(",
            "r"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "eturn e"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &(*zn)->z",
          "args": [
            "r",
            "ch[*n], nm);\n\tif (u",
            "ik"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nsolve_collision(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t     struct ubifs_znode **zn, int *n,\n\t\t\t     const struct qstr *nm)\n{\n\tint err;\n\n\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (err == NAME_MATCHES)\n\t\treturn 1;\n\n\tif (err == NAME_GREATER) {\n\t\t/* Look left */\n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t/*\n\t\t\t\t * We have found the branch after which we would\n\t\t\t\t * like to insert, but inserting in this znode\n\t\t\t\t * may still be wrong. Consider the following 3\n\t\t\t\t * znodes, in the case where we are resolving a\n\t\t\t\t * collision with Key2.\n\t\t\t\t *\n\t\t\t\t *                  znode zp\n\t\t\t\t *            ----------------------\n\t\t\t\t * level 1     |  Key0  |  Key1  |\n\t\t\t\t *            -----------------------\n\t\t\t\t *                 |            |\n\t\t\t\t *       znode za  |            |  znode zb\n\t\t\t\t *          ------------      ------------\n\t\t\t\t * level 0  |  Key0  |        |  Key2  |\n\t\t\t\t *          ------------      ------------\n\t\t\t\t *\n\t\t\t\t * The lookup finds Key2 in znode zb. Lets say\n\t\t\t\t * there is no match and the name is greater so\n\t\t\t\t * we look left. When we find Key0, we end up\n\t\t\t\t * here. If we return now, we will insert into\n\t\t\t\t * znode za at slot n = 1.  But that is invalid\n\t\t\t\t * according to the parent's keys.  Key2 must\n\t\t\t\t * be inserted into znode zb.\n\t\t\t\t *\n\t\t\t\t * Note, this problem is not relevant for the\n\t\t\t\t * case when we go right, because\n\t\t\t\t * 'tnc_insert()' would correct the parent key.\n\t\t\t\t */\n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t/* Should be impossible */\n\t\t\t\t\t\tubifs_assert(0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(*n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\treturn 0;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(err == NAME_GREATER);\n\t\t}\n\t} else {\n\t\tint nn = *n;\n\t\tstruct ubifs_znode *znode = *zn;\n\n\t\t/* Look right */\n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\treturn 0;\n\t\t\terr = matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\treturn 0;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(err == NAME_LESS);\n\t\t}\n\t}\n}\n\n/**\n * fall"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "639-673",
    "snippet": "c_prev(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tif (nn > 0) {\n\t\t*n = nn - 1;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip - 1;\n\t\tznode = zp;\n\t\tif (nn >= 0) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tnn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, nn);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = znode->child_cnt - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n/**\n * reso",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\t\t\t}",
          "args": [
            "nn"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "retur"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "znode, nn",
          "args": [
            ";",
            "if",
            "IS"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tw",
          "args": [
            "ile ("
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, nn",
          "args": [
            ";",
            "if",
            "S_"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_prev(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tif (nn > 0) {\n\t\t*n = nn - 1;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip - 1;\n\t\tznode = zp;\n\t\tif (nn >= 0) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tnn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, nn);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = znode->child_cnt - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n/**\n * reso"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "594-628",
    "snippet": "c_next(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tnn += 1;\n\tif (nn < znode->child_cnt) {\n\t\t*n = nn;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip + 1;\n\t\tznode = zp;\n\t\tif (nn < znode->child_cnt) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\t\t\t}",
          "args": [
            "nn"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "retur"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "znode, 0)",
          "args": [
            "if",
            "S"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tw",
          "args": [
            "ile ("
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode, nn",
          "args": [
            ";",
            "if",
            "S_"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_next(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tnn += 1;\n\tif (nn < znode->child_cnt) {\n\t\t*n = nn;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip + 1;\n\t\tznode = zp;\n\t\tif (nn < znode->child_cnt) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "572-583",
    "snippet": "ubifs_znode *get_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->znode)\n\t\tznode = zbr->znode;\n\telse\n\t\tznode = ubifs_load_znode(c, zbr, znode, n);\n\treturn znode;\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            ");",
            "eturn",
            "n"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *get_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->znode)\n\t\tznode = zbr->znode;\n\telse\n\t\tznode = ubifs_load_znode(c, zbr, znode, n);\n\treturn znode;\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "522-562",
    "snippet": "tches_name(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tconst struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ubifs_tnc_read_node(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\t/* Add the node to the leaf node cache */\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, m",
            "_t(int,",
            "en, nm->len));\n\tif (err ="
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, n",
          "args": [
            "->l",
            "));",
            "f (err"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "err = mem"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tly(c, zbr, dent",
          "args": [
            ";",
            "if",
            "err)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr, dent",
          "args": [
            ";",
            "if",
            "err)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "if (!den"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ntches_name(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tconst struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ubifs_tnc_read_node(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\t/* Add the node to the leaf node cache */\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "487-509",
    "snippet": "llible_read_node(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t      struct ubifs_zbranch *zbr, void *node)\n{\n\tint ret;\n\n\tdbg_tnck(key, \"LEB %d:%d, key \", zbr->lnum, zbr->offs);\n\n\tret = try_read_node(c, node, key_type(c, key), zbr->len, zbr->lnum,\n\t\t\t    zbr->offs);\n\tif (ret == 1) {\n\t\tunion ubifs_key node_key;\n\t\tstruct ubifs_dent_node *dent = node;\n\n\t\t/* All nodes have key in the same place */\n\t\tkey_read(c, &dent->key, &node_key);\n\t\tif (keys_cmp(c, key, &node_key) != 0)\n\t\t\tret = 0;\n\t}\n\tif (ret == 0 && c->replaying)\n\t\tdbg_mntk(key, \"dangling branch LEB %d:%d len %d, key \",\n\t\t\tzbr->lnum, zbr->offs, zbr->len);\n\treturn ret;\n}\n\n/**\n * matc",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"dangli",
          "args": [
            "g b",
            "nch LEB %d:%d len %d, key \",\n\t\t\tzbr->lnu",
            "r->offs,",
            "r->len);",
            "eturn re"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &nod",
          "args": [
            "_",
            "y)",
            "0)\n\t\t\tre"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->ke",
          "args": [
            ",",
            "node_key);",
            "if (keys"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, node, key",
          "args": [
            "t",
            "e(c,",
            "ey), zbr->len, z",
            "->lnum,",
            "zbr-",
            "if (ret ="
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey), zbr",
          "args": [
            ">",
            "n,"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"LEB %d",
          "args": [
            "%d,",
            "ey \", zbr->lnum,",
            "r->offs);",
            "ret = tr"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nllible_read_node(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t      struct ubifs_zbranch *zbr, void *node)\n{\n\tint ret;\n\n\tdbg_tnck(key, \"LEB %d:%d, key \", zbr->lnum, zbr->offs);\n\n\tret = try_read_node(c, node, key_type(c, key), zbr->len, zbr->lnum,\n\t\t\t    zbr->offs);\n\tif (ret == 1) {\n\t\tunion ubifs_key node_key;\n\t\tstruct ubifs_dent_node *dent = node;\n\n\t\t/* All nodes have key in the same place */\n\t\tkey_read(c, &dent->key, &node_key);\n\t\tif (keys_cmp(c, key, &node_key) != 0)\n\t\t\tret = 0;\n\t}\n\tif (ret == 0 && c->replaying)\n\t\tdbg_mntk(key, \"dangling branch LEB %d:%d len %d, key \",\n\t\t\tzbr->lnum, zbr->offs, zbr->len);\n\treturn ret;\n}\n\n/**\n * matc"
  },
  {
    "function_name": "(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "439-475",
    "snippet": "y_read_node(const struct ubifs_info *c, void *buf, int type,\n\t\t\t int len, int lnum, int offs)\n{\n\tint err, node_len;\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t crc, node_crc;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d\", lnum, offs, dbg_ntype(type), len);\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 1);\n\tif (err) {\n\t\tubifs_err(\"cannot read node type %d from LEB %d:%d, error %d\",\n\t\t\t  type, lnum, offs, err);\n\t\treturn err;\n\t}\n\n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\treturn 0;\n\n\tif (ch->node_type != type)\n\t\treturn 0;\n\n\tnode_len = le32_to_cpu(ch->len);\n\tif (node_len != len)\n\t\treturn 0;\n\n\tif (type == UBIFS_DATA_NODE && c->no_chk_data_crc && !c->mounting &&\n\t    !c->remounting_rw)\n\t\treturn 1;\n\n\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\n\tnode_crc = le32_to_cpu(ch->crc);\n\tif (crc != node_crc)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * fall",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "h->crc);\n\ti",
          "args": [
            "(crc !"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, buf + 8, no",
            "_len -",
            ";\n\tnode_crc"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ti",
          "args": [
            "(node_"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->magic) !",
          "args": [
            "UBIFS_NO"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "node type %d from LEB %d:%d, error %d\",\n\t\t\t  type,",
            "ffs,",
            "rr);",
            "ret",
            "n e"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "n,",
            ";\n\ti",
            "(er"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "s, length %d\", lnum, offs,",
            "bg_n",
            "pe(t",
            "e), len);\n\n\terr",
            "ub"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e), len);",
          "args": [
            "er"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ny_read_node(const struct ubifs_info *c, void *buf, int type,\n\t\t\t int len, int lnum, int offs)\n{\n\tint err, node_len;\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t crc, node_crc;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d\", lnum, offs, dbg_ntype(type), len);\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 1);\n\tif (err) {\n\t\tubifs_err(\"cannot read node type %d from LEB %d:%d, error %d\",\n\t\t\t  type, lnum, offs, err);\n\t\treturn err;\n\t}\n\n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\treturn 0;\n\n\tif (ch->node_type != type)\n\t\treturn 0;\n\n\tnode_len = le32_to_cpu(ch->len);\n\tif (node_len != len)\n\t\treturn 0;\n\n\tif (type == UBIFS_DATA_NODE && c->no_chk_data_crc && !c->mounting &&\n\t    !c->remounting_rw)\n\t\treturn 1;\n\n\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\n\tnode_crc = le32_to_cpu(ch->crc);\n\tif (crc != node_crc)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * fall"
  },
  {
    "function_name": "_nm(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "392-413",
    "snippet": "c_read_node_nm(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *node)\n{\n\tint err;\n\n\tubifs_assert(is_hash_key(c, &zbr->key));\n\n\tif (zbr->leaf) {\n\t\t/* Read from the leaf node cache */\n\t\tubifs_assert(zbr->len != 0);\n\t\tmemcpy(node, zbr->leaf, zbr->len);\n\t\treturn 0;\n\t}\n\n\terr = ubifs_tnc_read_node(c, zbr, node);\n\tif (err)\n\t\treturn err;\n\n\t/* Add the node to the leaf node cache */\n\terr = lnc_add(c, zbr, node);\n\treturn err;\n}\n\n/**\n * try_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r, node",
          "args": [
            ";",
            "ret",
            "n er"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr, node",
          "args": [
            ";",
            "if",
            "rr)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->l",
          "args": [
            "af,",
            "r->len);",
            "return 0"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->len !=",
          "args": [
            ");\n\t\tmemcpy(n"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hash_key(",
          "args": [
            ", &zbr->key));\n\n\tif (zbr-"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &zbr->key",
          "args": [
            ")",
            "if (zbr"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_read_node_nm(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *node)\n{\n\tint err;\n\n\tubifs_assert(is_hash_key(c, &zbr->key));\n\n\tif (zbr->leaf) {\n\t\t/* Read from the leaf node cache */\n\t\tubifs_assert(zbr->len != 0);\n\t\tmemcpy(node, zbr->leaf, zbr->len);\n\t\treturn 0;\n\t}\n\n\terr = ubifs_tnc_read_node(c, zbr, node);\n\tif (err)\n\t\treturn err;\n\n\t/* Add the node to the leaf node cache */\n\terr = lnc_add(c, zbr, node);\n\treturn err;\n}\n\n/**\n * try_"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "373-379",
    "snippet": "nc_free(struct ubifs_zbranch *zbr)\n{\n\tif (!zbr->leaf)\n\t\treturn;\n\tkfree(zbr->leaf);\n\tzbr->leaf = NULL;\n}\n\n/**\n * tnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "af);",
          "args": [
            "zbr->leaf"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nnc_free(struct ubifs_zbranch *zbr)\n{\n\tif (!zbr->leaf)\n\t\treturn;\n\tkfree(zbr->leaf);\n\tzbr->leaf = NULL;\n}\n\n/**\n * tnc_"
  },
  {
    "function_name": "tly(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "349-366",
    "snippet": "c_add_directly(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *node)\n{\n\tint err;\n\n\tubifs_assert(!zbr->leaf);\n\tubifs_assert(zbr->len != 0);\n\n\terr = ubifs_validate_entry(c, node);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, node);\n\t\treturn err;\n\t}\n\n\tzbr->leaf = node;\n\treturn 0;\n}\n\n/**\n * lnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, node);",
          "args": [
            "e",
            "rn e"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_d",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, node);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->len !=",
          "args": [
            ");\n\n\terr = ub"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!zbr->leaf);",
          "args": [
            "ubifs_ass"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_add_directly(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *node)\n{\n\tint err;\n\n\tubifs_assert(!zbr->leaf);\n\tubifs_assert(zbr->len != 0);\n\n\terr = ubifs_validate_entry(c, node);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, node);\n\t\treturn err;\n\t}\n\n\tzbr->leaf = node;\n\treturn 0;\n}\n\n/**\n * lnc_"
  },
  {
    "function_name": "t ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "313-338",
    "snippet": "c_add(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t   const void *node)\n{\n\tint err;\n\tvoid *lnc_node;\n\tconst struct ubifs_dent_node *dent = node;\n\n\tubifs_assert(!zbr->leaf);\n\tubifs_assert(zbr->len != 0);\n\tubifs_assert(is_hash_key(c, &zbr->key));\n\n\terr = ubifs_validate_entry(c, dent);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, dent);\n\t\treturn err;\n\t}\n\n\tlnc_node = kmemdup(node, zbr->len, GFP_NOFS);\n\tif (!lnc_node)\n\t\t/* We don't have to have the cache, so no error */\n\t\treturn 0;\n\n\tzbr->leaf = lnc_node;\n\treturn 0;\n}\n\n /**\n * lnc",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbr->l",
          "args": [
            "n, G",
            "_NOFS);",
            "f (!lnc_"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dent);",
          "args": [
            "e",
            "rn e"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_d",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, dent);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hash_key(",
          "args": [
            ", &zbr->key));\n\n\terr = ub"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &zbr->key",
          "args": [
            ")",
            "err = u"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->len !=",
          "args": [
            ");\n\tubifs_ass"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!zbr->leaf);",
          "args": [
            "ubifs_ass"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_add(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t   const void *node)\n{\n\tint err;\n\tvoid *lnc_node;\n\tconst struct ubifs_dent_node *dent = node;\n\n\tubifs_assert(!zbr->leaf);\n\tubifs_assert(zbr->len != 0);\n\tubifs_assert(is_hash_key(c, &zbr->key));\n\n\terr = ubifs_validate_entry(c, dent);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, dent);\n\t\treturn err;\n\t}\n\n\tlnc_node = kmemdup(node, zbr->len, GFP_NOFS);\n\tif (!lnc_node)\n\t\t/* We don't have to have the cache, so no error */\n\t\treturn 0;\n\n\tzbr->leaf = lnc_node;\n\treturn 0;\n}\n\n /**\n * lnc"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "251-291",
    "snippet": "ubifs_znode *dirty_cow_znode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zn;\n\tint err;\n\n\tif (!ubifs_zn_cow(znode)) {\n\t\t/* znode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_ZNODE, &znode->flags)) {\n\t\t\tatomic_long_inc(&c->dirty_zn_cnt);\n\t\t\tatomic_long_dec(&c->clean_zn_cnt);\n\t\t\tatomic_long_dec(&ubifs_clean_zn_cnt);\n\t\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (unlikely(err))\n\t\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\treturn znode;\n\t}\n\n\tzn = copy_znode(c, znode);\n\tif (IS_ERR(zn))\n\t\treturn zn;\n\n\tif (zbr->len) {\n\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\tif (unlikely(err))\n\t\t\treturn ERR_PTR(err);\n\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t} else\n\t\terr = 0;\n\n\tzbr->znode = zn;\n\tzbr->lnum = 0;\n\tzbr->offs = 0;\n\tzbr->len = 0;\n\n\tif (unlikely(err))\n\t\treturn ERR_PTR(err);\n\treturn zn;\n}\n\n/**\n * lnc_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "zn"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": ")\n\t\tretu",
          "args": [
            "n E"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, zbr->lnum",
          "args": [
            "r->len);",
            "else"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "ad"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tret",
          "args": [
            "rn"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, zbr->lnum",
          "args": [
            "r->offs);",
            "if (unli"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);",
          "args": [
            "f",
            "IS_ER"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "etu"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\t\tre",
          "args": [
            "urn"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, zbr->lnum",
          "args": [
            "r->len);",
            "if (unl"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&ubifs_clean",
          "args": [
            "zn_cnt);\n\t\t\terr = a"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->clean_zn",
          "args": [
            "cnt);\n\t\t\tatomic_"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->dirty_zn",
          "args": [
            "cnt);\n\t\t\tatomic_"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_ZNODE,",
          "args": [
            "&znode->fla",
            ")) {\n\t\t\tatomi"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode)) {",
          "args": [
            "* zno"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *dirty_cow_znode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zn;\n\tint err;\n\n\tif (!ubifs_zn_cow(znode)) {\n\t\t/* znode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_ZNODE, &znode->flags)) {\n\t\t\tatomic_long_inc(&c->dirty_zn_cnt);\n\t\t\tatomic_long_dec(&c->clean_zn_cnt);\n\t\t\tatomic_long_dec(&ubifs_clean_zn_cnt);\n\t\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (unlikely(err))\n\t\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\treturn znode;\n\t}\n\n\tzn = copy_znode(c, znode);\n\tif (IS_ERR(zn))\n\t\treturn zn;\n\n\tif (zbr->len) {\n\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\tif (unlikely(err))\n\t\t\treturn ERR_PTR(err);\n\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t} else\n\t\terr = 0;\n\n\tzbr->znode = zn;\n\tzbr->lnum = 0;\n\tzbr->offs = 0;\n\tzbr->len = 0;\n\n\tif (unlikely(err))\n\t\treturn ERR_PTR(err);\n\treturn zn;\n}\n\n/**\n * lnc_"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "238-242",
    "snippet": "d_idx_dirt(struct ubifs_info *c, int lnum, int dirt)\n{\n\tc->calc_idx_sz -= ALIGN(dirt, 8);\n\treturn ubifs_add_dirt(c, lnum, dirt);\n}\n\n/**\n * dirt",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t(c, lnum, dir",
          "args": [
            ")",
            "}\n\n/",
            "*"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tr",
          "args": [
            "turn",
            "b"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd_idx_dirt(struct ubifs_info *c, int lnum, int dirt)\n{\n\tc->calc_idx_sz -= ALIGN(dirt, 8);\n\treturn ubifs_add_dirt(c, lnum, dirt);\n}\n\n/**\n * dirt"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "196-228",
    "snippet": "ubifs_znode *copy_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tzn = kmalloc(c->max_znode_sz, GFP_NOFS);\n\tif (unlikely(!zn))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(zn, znode, c->max_znode_sz);\n\tzn->cnext = NULL;\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\t__clear_bit(COW_ZNODE, &zn->flags);\n\n\tubifs_assert(!ubifs_zn_obsolete(znode));\n\t__set_bit(OBSOLETE_ZNODE, &znode->flags);\n\n\tif (znode->level != 0) {\n\t\tint i;\n\t\tconst int n = zn->child_cnt;\n\n\t\t/* The children now have new parent */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tstruct ubifs_zbranch *zbr = &zn->zbranch[i];\n\n\t\t\tif (zbr->znode)\n\t\t\t\tzbr->znode->parent = zn;\n\t\t}\n\t}\n\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\treturn zn;\n}\n\n/**\n * add_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc(&c->dirty_zn",
          "args": [
            "cnt);\n\treturn zn"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OLETE_ZNO",
          "args": [
            "E, &znode->fla",
            ");\n\n\tif (znod"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ubifs_zn_ob",
          "args": [
            "olete(znode));\n\t__set_bit"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lete(znode));\n\t__",
          "args": [
            "et_bi"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OW_ZNODE, &",
          "args": [
            "n->flags)",
            "ubifs_as"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_ZNODE,",
          "args": [
            "&zn->flags)",
            "__clear_b"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode, c",
          "args": [
            ">m",
            "_znod",
            "sz);\n\tzn->cnext"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "emcpy(z"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tretu",
          "args": [
            "n E"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_znode",
          "args": [
            "sz, GFP_NOFS);",
            "f (unlik"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "dx_znode(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "140-167",
          "snippet": "s_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ns_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nubifs_znode *copy_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tzn = kmalloc(c->max_znode_sz, GFP_NOFS);\n\tif (unlikely(!zn))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(zn, znode, c->max_znode_sz);\n\tzn->cnext = NULL;\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\t__clear_bit(COW_ZNODE, &zn->flags);\n\n\tubifs_assert(!ubifs_zn_obsolete(znode));\n\t__set_bit(OBSOLETE_ZNODE, &znode->flags);\n\n\tif (znode->level != 0) {\n\t\tint i;\n\t\tconst int n = zn->child_cnt;\n\n\t\t/* The children now have new parent */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tstruct ubifs_zbranch *zbr = &zn->zbranch[i];\n\n\t\t\tif (zbr->znode)\n\t\t\t\tzbr->znode->parent = zn;\n\t\t}\n\t}\n\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\treturn zn;\n}\n\n/**\n * add_"
  },
  {
    "function_name": "dx(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "179-187",
    "snippet": "old_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_old_idx *old_idx, *n;\n\n\trbtree_postorder_for_each_entry_safe(old_idx, n, &c->old_idx, rb)\n\t\tkfree(old_idx);\n\n\tc->old_idx = RB_ROOT;\n}\n\n/**\n * copy",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");",
          "args": [
            "->old_i"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "der_for_each_entry_safe(old_idx, n,",
          "args": [
            "c->old_",
            "x",
            "rb)\n\t\tkfree",
            "ld"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nold_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_old_idx *old_idx, *n;\n\n\trbtree_postorder_for_each_entry_safe(old_idx, n, &c->old_idx, rb)\n\t\tkfree(old_idx);\n\n\tc->old_idx = RB_ROOT;\n}\n\n/**\n * copy"
  },
  {
    "function_name": "dx_znode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "140-167",
    "snippet": "s_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x(c, c->zroot.",
          "args": [
            "n",
            ", c->zroot.of",
            ");\n\t\t\tif (err"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, zbr->lnum",
          "args": [
            "r->offs);",
            "if (err"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ns_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest"
  },
  {
    "function_name": "x_znode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "118-131",
    "snippet": "d_idx_znode(struct ubifs_info *c, struct ubifs_znode *znode)\n{\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len)\n\t\t\treturn insert_old_idx(c, zbr->lnum, zbr->offs);\n\t} else\n\t\tif (c->zroot.len)\n\t\t\treturn insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t      c->zroot.offs);\n\treturn 0;\n}\n\n/**\n * ins_",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x(c, c->zroot.",
          "args": [
            "n",
            ",",
            ");\n\treturn 0;"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, zbr->lnum",
          "args": [
            "r->offs);",
            "} else"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd_idx_znode(struct ubifs_info *c, struct ubifs_znode *znode)\n{\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len)\n\t\t\treturn insert_old_idx(c, zbr->lnum, zbr->offs);\n\t} else\n\t\tif (c->zroot.len)\n\t\t\treturn insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t      c->zroot.offs);\n\treturn 0;\n}\n\n/**\n * ins_"
  },
  {
    "function_name": "x(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
    "lines": "77-109",
    "snippet": "sert_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *old_idx, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\told_idx = kmalloc(sizeof(struct ubifs_old_idx), GFP_NOFS);\n\tif (unlikely(!old_idx))\n\t\treturn -ENOMEM;\n\told_idx->lnum = lnum;\n\told_idx->offs = offs;\n\n\tp = &c->old_idx.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_old_idx, rb);\n\t\tif (lnum < o->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (lnum > o->lnum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (offs < o->offs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offs > o->offs)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(\"old idx added twice!\");\n\t\t\tkfree(old_idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&old_idx->rb, parent, p);\n\trb_insert_color(&old_idx->rb, &c->old_idx);\n\treturn 0;\n}\n\n/**\n * inse",
    "includes": [
      "fs.h\"\n\n/*\n * Return",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "or(&old_idx->rb",
          "args": [
            "&c->old_idx",
            "return 0;"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&old_idx->rb",
          "args": [
            "parent, p);",
            "rb_ins",
            "t"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "return"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d idx add",
          "args": [
            "d twice!\");\n\t\t\tkfree(o"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt, stru",
          "args": [
            "t ubif",
            "old_id, rb);\n\t\tif (",
            "um"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx))",
          "args": [
            "return -"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_old_idx), GFP_NOFS);",
            "f (unlik"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nsert_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *old_idx, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\told_idx = kmalloc(sizeof(struct ubifs_old_idx), GFP_NOFS);\n\tif (unlikely(!old_idx))\n\t\treturn -ENOMEM;\n\told_idx->lnum = lnum;\n\told_idx->offs = offs;\n\n\tp = &c->old_idx.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_old_idx, rb);\n\t\tif (lnum < o->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (lnum > o->lnum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (offs < o->offs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offs > o->offs)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(\"old idx added twice!\");\n\t\t\tkfree(old_idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&old_idx->rb, parent, p);\n\trb_insert_color(&old_idx->rb, &c->old_idx);\n\treturn 0;\n}\n\n/**\n * inse"
  }
]