[
  {
    "function_name": "ext4_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "583-606",
    "snippet": "loff_t ext4_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes;\n\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\telse\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\t\treturn ext4_seek_data(file, offset, maxbytes);\n\tcase SEEK_HOLE:\n\t\treturn ext4_seek_hole(file, offset, maxbytes);\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_seek_hole",
          "args": [
            "file",
            "offset",
            "maxbytes"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_seek_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "505-576",
          "snippet": "static loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t holeoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tholeoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tlast += ret;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * we will skip this extent.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tlast = es.es_lblk + es.es_len;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_HOLE,\n\t\t\t\t\t\t\t      &map, &holeoff);\n\t\t\tif (!unwritten) {\n\t\t\t\tlast += ret;\n\t\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* find a hole */\n\t\tbreak;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (holeoff > isize)\n\t\tholeoff = isize;\n\n\treturn vfs_setpos(file, holeoff, maxsize);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t holeoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tholeoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tlast += ret;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * we will skip this extent.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tlast = es.es_lblk + es.es_len;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_HOLE,\n\t\t\t\t\t\t\t      &map, &holeoff);\n\t\t\tif (!unwritten) {\n\t\t\t\tlast += ret;\n\t\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* find a hole */\n\t\tbreak;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (holeoff > isize)\n\t\tholeoff = isize;\n\n\treturn vfs_setpos(file, holeoff, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_seek_data",
          "args": [
            "file",
            "offset",
            "maxbytes"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_seek_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "432-500",
          "snippet": "static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t dataoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tdataoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * it will be as a data.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_DATA,\n\t\t\t\t\t\t\t      &map, &dataoff);\n\t\t\tif (unwritten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlast++;\n\t\tdataoff = (loff_t)last << blkbits;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (dataoff > isize)\n\t\treturn -ENXIO;\n\n\treturn vfs_setpos(file, dataoff, maxsize);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t dataoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tdataoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * it will be as a data.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_DATA,\n\t\t\t\t\t\t\t      &map, &dataoff);\n\t\t\tif (unwritten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlast++;\n\t\tdataoff = (loff_t)last << blkbits;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (dataoff > isize)\n\t\treturn -ENXIO;\n\n\treturn vfs_setpos(file, dataoff, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "maxbytes",
            "i_size_read(inode)"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nloff_t ext4_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes;\n\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\telse\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\t\treturn ext4_seek_data(file, offset, maxbytes);\n\tcase SEEK_HOLE:\n\t\treturn ext4_seek_hole(file, offset, maxbytes);\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ext4_seek_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "505-576",
    "snippet": "static loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t holeoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tholeoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tlast += ret;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * we will skip this extent.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tlast = es.es_lblk + es.es_len;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_HOLE,\n\t\t\t\t\t\t\t      &map, &holeoff);\n\t\t\tif (!unwritten) {\n\t\t\t\tlast += ret;\n\t\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* find a hole */\n\t\tbreak;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (holeoff > isize)\n\t\tholeoff = isize;\n\n\treturn vfs_setpos(file, holeoff, maxsize);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "holeoff",
            "maxsize"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_unwritten_pgoff",
          "args": [
            "inode",
            "SEEK_HOLE",
            "&map",
            "&holeoff"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_unwritten_pgoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "300-427",
          "snippet": "static int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "last",
            "es.es_lblk",
            "es.es_len"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_find_delayed_extent_range",
          "args": [
            "inode",
            "last",
            "last",
            "&es"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_find_delayed_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "246-298",
          "snippet": "void ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nvoid ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "NULL",
            "inode",
            "&map",
            "0"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t holeoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tholeoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tlast += ret;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * we will skip this extent.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tlast = es.es_lblk + es.es_len;\n\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_HOLE,\n\t\t\t\t\t\t\t      &map, &holeoff);\n\t\t\tif (!unwritten) {\n\t\t\t\tlast += ret;\n\t\t\t\tholeoff = (loff_t)last << blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* find a hole */\n\t\tbreak;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (holeoff > isize)\n\t\tholeoff = isize;\n\n\treturn vfs_setpos(file, holeoff, maxsize);\n}"
  },
  {
    "function_name": "ext4_seek_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "432-500",
    "snippet": "static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t dataoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tdataoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * it will be as a data.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_DATA,\n\t\t\t\t\t\t\t      &map, &dataoff);\n\t\t\tif (unwritten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlast++;\n\t\tdataoff = (loff_t)last << blkbits;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (dataoff > isize)\n\t\treturn -ENXIO;\n\n\treturn vfs_setpos(file, dataoff, maxsize);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "dataoff",
            "maxsize"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_unwritten_pgoff",
          "args": [
            "inode",
            "SEEK_DATA",
            "&map",
            "&dataoff"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_unwritten_pgoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "300-427",
          "snippet": "static int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "last",
            "es.es_lblk",
            "es.es_len"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_find_delayed_extent_range",
          "args": [
            "inode",
            "last",
            "last",
            "&es"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_find_delayed_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "246-298",
          "snippet": "void ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nvoid ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "NULL",
            "inode",
            "&map",
            "0"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es;\n\text4_lblk_t start, last, end;\n\tloff_t dataoff, isize;\n\tint blkbits;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstart = offset >> blkbits;\n\tlast = start;\n\tend = isize >> blkbits;\n\tdataoff = offset;\n\n\tdo {\n\t\tmap.m_lblk = last;\n\t\tmap.m_len = end - last + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret > 0 && !(map.m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a delay extent at this offset,\n\t\t * it will be as a data.\n\t\t */\n\t\text4_es_find_delayed_extent_range(inode, last, last, &es);\n\t\tif (es.es_len != 0 && in_range(last, es.es_lblk, es.es_len)) {\n\t\t\tif (last != start)\n\t\t\t\tdataoff = (loff_t)last << blkbits;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is a unwritten extent at this offset,\n\t\t * it will be as a data or a hole according to page\n\t\t * cache that has data or not.\n\t\t */\n\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\t\tint unwritten;\n\t\t\tunwritten = ext4_find_unwritten_pgoff(inode, SEEK_DATA,\n\t\t\t\t\t\t\t      &map, &dataoff);\n\t\t\tif (unwritten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlast++;\n\t\tdataoff = (loff_t)last << blkbits;\n\t} while (last <= end);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (dataoff > isize)\n\t\treturn -ENXIO;\n\n\treturn vfs_setpos(file, dataoff, maxsize);\n}"
  },
  {
    "function_name": "ext4_find_unwritten_pgoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "300-427",
    "snippet": "static int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "loff_t",
            "startoff",
            "lastoff"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pvec.pages[0]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "whence != SEEK_HOLE"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "inode->i_mapping",
            "index",
            "(pgoff_t)num"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "pgoff_t",
            "end - index",
            "PAGEVEC_SIZE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "map->m_lblk + map->m_len"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}"
  },
  {
    "function_name": "ext4_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "232-282",
    "snippet": "static int ext4_file_open(struct inode * inode, struct file * filp)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct vfsmount *mnt = filp->f_path.mnt;\n\tstruct path path;\n\tchar buf[64], *cp;\n\n\tif (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&\n\t\t     !(sb->s_flags & MS_RDONLY))) {\n\t\tsbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;\n\t\t/*\n\t\t * Sample where the filesystem has been mounted and\n\t\t * store it in the superblock for sysadmin convenience\n\t\t * when trying to sort through large numbers of block\n\t\t * devices or filesystem images.\n\t\t */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tpath.mnt = mnt;\n\t\tpath.dentry = mnt->mnt_root;\n\t\tcp = d_path(&path, buf, sizeof(buf));\n\t\tif (!IS_ERR(cp)) {\n\t\t\thandle_t *handle;\n\t\t\tint err;\n\n\t\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\t\t\tif (IS_ERR(handle))\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\t\tif (err) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstrlcpy(sbi->s_es->s_last_mounted, cp,\n\t\t\t\tsizeof(sbi->s_es->s_last_mounted));\n\t\t\text4_handle_dirty_super(handle, sb);\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\t/*\n\t * Set up the jbd2_inode if we are opening the inode for\n\t * writing and the journal is present\n\t */\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tint ret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn dquot_file_open(inode, filp);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_file_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1985-1993",
          "snippet": "int dquot_file_open(struct inode *inode, struct file *file)\n{\n\tint error;\n\n\terror = generic_file_open(inode, file);\n\tif (!error && (file->f_mode & FMODE_WRITE))\n\t\tdquot_initialize(inode);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_file_open(struct inode *inode, struct file *file)\n{\n\tint error;\n\n\terror = generic_file_open(inode, file);\n\tif (!error && (file->f_mode & FMODE_WRITE))\n\t\tdquot_initialize(inode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_attach_jinode",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_attach_jinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3524-3547",
          "snippet": "int ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sbi->s_es->s_last_mounted",
            "cp",
            "sizeof(sbi->s_es->s_last_mounted)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_MISC",
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cp"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&path",
            "buf",
            "sizeof(buf)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3047-3076",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&\n\t\t     !(sb->s_flags & MS_RDONLY)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_file_open(struct inode * inode, struct file * filp)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct vfsmount *mnt = filp->f_path.mnt;\n\tstruct path path;\n\tchar buf[64], *cp;\n\n\tif (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&\n\t\t     !(sb->s_flags & MS_RDONLY))) {\n\t\tsbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;\n\t\t/*\n\t\t * Sample where the filesystem has been mounted and\n\t\t * store it in the superblock for sysadmin convenience\n\t\t * when trying to sort through large numbers of block\n\t\t * devices or filesystem images.\n\t\t */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tpath.mnt = mnt;\n\t\tpath.dentry = mnt->mnt_root;\n\t\tcp = d_path(&path, buf, sizeof(buf));\n\t\tif (!IS_ERR(cp)) {\n\t\t\thandle_t *handle;\n\t\t\tint err;\n\n\t\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\t\t\tif (IS_ERR(handle))\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\t\tif (err) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstrlcpy(sbi->s_es->s_last_mounted, cp,\n\t\t\t\tsizeof(sbi->s_es->s_last_mounted));\n\t\t\text4_handle_dirty_super(handle, sb);\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\t/*\n\t * Set up the jbd2_inode if we are opening the inode for\n\t * writing and the journal is present\n\t */\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tint ret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn dquot_file_open(inode, filp);\n}"
  },
  {
    "function_name": "ext4_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "220-230",
    "snippet": "static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tif (IS_DAX(file_inode(file))) {\n\t\tvma->vm_ops = &ext4_dax_vm_ops;\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t} else {\n\t\tvma->vm_ops = &ext4_file_vm_ops;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define ext4_dax_vm_ops\text4_file_vm_ops"
    ],
    "globals_used": [
      "static const struct vm_operations_struct ext4_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite   = ext4_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "file_inode(file)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define ext4_dax_vm_ops\text4_file_vm_ops\n\nstatic const struct vm_operations_struct ext4_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite   = ext4_page_mkwrite,\n};\n\nstatic int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tif (IS_DAX(file_inode(file))) {\n\t\tvma->vm_ops = &ext4_dax_vm_ops;\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t} else {\n\t\tvma->vm_ops = &ext4_file_vm_ops;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_dax_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "201-204",
    "snippet": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_mkwrite",
          "args": [
            "vma",
            "vmf",
            "ext4_get_block"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block);\n}"
  },
  {
    "function_name": "ext4_dax_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "195-199",
    "snippet": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_fault(vma, vmf, ext4_get_block);\n\t\t\t\t\t/* Is this the right get_block? */\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_fault",
          "args": [
            "vma",
            "vmf",
            "ext4_get_block"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "dax_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "448-463",
          "snippet": "int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tint result;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t}\n\tresult = do_dax_fault(vma, vmf, get_block);\n\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\tsb_end_pagefault(sb);\n\n\treturn result;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tint result;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t}\n\tresult = do_dax_fault(vma, vmf, get_block);\n\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\tsb_end_pagefault(sb);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_fault(vma, vmf, ext4_get_block);\n\t\t\t\t\t/* Is this the right get_block? */\n}"
  },
  {
    "function_name": "ext4_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "91-192",
    "snippet": "static ssize_t\next4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct mutex *aio_mutex = NULL;\n\tstruct blk_plug plug;\n\tint o_direct = io_is_direct(file);\n\tint overwrite = 0;\n\tsize_t length = iov_iter_count(from);\n\tssize_t ret;\n\tloff_t pos = iocb->ki_pos;\n\n\t/*\n\t * Unaligned direct AIO must be serialized; see comment above\n\t * In the case of O_APPEND, assume that we must always serialize\n\t */\n\tif (o_direct &&\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&\n\t    !is_sync_kiocb(iocb) &&\n\t    (file->f_flags & O_APPEND ||\n\t     ext4_unaligned_aio(inode, from, pos))) {\n\t\taio_mutex = ext4_aio_mutex(inode);\n\t\tmutex_lock(aio_mutex);\n\t\text4_unwritten_wait(inode);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tiocb->ki_pos = pos = i_size_read(inode);\n\n\t/*\n\t * If we have encountered a bitmap-format file, the size limit\n\t * is smaller than s_maxbytes, which is for extent-mapped files.\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\tif ((pos > sbi->s_bitmap_maxbytes) ||\n\t\t    (pos == sbi->s_bitmap_maxbytes && length > 0)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EFBIG;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (pos + length > sbi->s_bitmap_maxbytes)\n\t\t\tiov_iter_truncate(from, sbi->s_bitmap_maxbytes - pos);\n\t}\n\n\tiocb->private = &overwrite;\n\tif (o_direct) {\n\t\tblk_start_plug(&plug);\n\n\n\t\t/* check whether we do a DIO overwrite or not */\n\t\tif (ext4_should_dioread_nolock(inode) && !aio_mutex &&\n\t\t    !file->f_mapping->nrpages && pos + length <= i_size_read(inode)) {\n\t\t\tstruct ext4_map_blocks map;\n\t\t\tunsigned int blkbits = inode->i_blkbits;\n\t\t\tint err, len;\n\n\t\t\tmap.m_lblk = pos >> blkbits;\n\t\t\tmap.m_len = (EXT4_BLOCK_ALIGN(pos + length, blkbits) >> blkbits)\n\t\t\t\t- map.m_lblk;\n\t\t\tlen = map.m_len;\n\n\t\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\t\t/*\n\t\t\t * 'err==len' means that all of blocks has\n\t\t\t * been preallocated no matter they are\n\t\t\t * initialized or not.  For excluding\n\t\t\t * unwritten extents, we need to check\n\t\t\t * m_flags.  There are two conditions that\n\t\t\t * indicate for initialized extents.  1) If we\n\t\t\t * hit extent cache, EXT4_MAP_MAPPED flag is\n\t\t\t * returned; 2) If we do a real lookup,\n\t\t\t * non-flags are returned.  So we should check\n\t\t\t * these two conditions.\n\t\t\t */\n\t\t\tif (err == len && (map.m_flags & EXT4_MAP_MAPPED))\n\t\t\t\toverwrite = 1;\n\t\t}\n\t}\n\n\tret = __generic_file_write_iter(iocb, from);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (ret > 0) {\n\t\tssize_t err;\n\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\tif (o_direct)\n\t\tblk_finish_plug(&plug);\n\nerrout:\n\tif (aio_mutex)\n\t\tmutex_unlock(aio_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "aio_mutex"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - ret",
            "ret"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "NULL",
            "inode",
            "&map",
            "0"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_ALIGN",
          "args": [
            "pos + length",
            "blkbits"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "sbi->s_bitmap_maxbytes - pos"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unwritten_wait",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unwritten_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "60-65",
          "snippet": "static void ext4_unwritten_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = ext4_ioend_wq(inode);\n\n\twait_event(*wq, (atomic_read(&EXT4_I(inode)->i_unwritten) == 0));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void ext4_unwritten_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = ext4_ioend_wq(inode);\n\n\twait_event(*wq, (atomic_read(&EXT4_I(inode)->i_unwritten) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "aio_mutex"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_aio_mutex",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unaligned_aio",
          "args": [
            "inode",
            "from",
            "pos"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unaligned_aio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "76-89",
          "snippet": "static int\next4_unaligned_aio(struct inode *inode, struct iov_iter *from, loff_t pos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint blockmask = sb->s_blocksize - 1;\n\n\tif (pos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif ((pos | iov_iter_alignment(from)) & blockmask)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int\next4_unaligned_aio(struct inode *inode, struct iov_iter *from, loff_t pos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint blockmask = sb->s_blocksize - 1;\n\n\tif (pos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif ((pos | iov_iter_alignment(from)) & blockmask)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_is_direct",
          "args": [
            "file"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic ssize_t\next4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct mutex *aio_mutex = NULL;\n\tstruct blk_plug plug;\n\tint o_direct = io_is_direct(file);\n\tint overwrite = 0;\n\tsize_t length = iov_iter_count(from);\n\tssize_t ret;\n\tloff_t pos = iocb->ki_pos;\n\n\t/*\n\t * Unaligned direct AIO must be serialized; see comment above\n\t * In the case of O_APPEND, assume that we must always serialize\n\t */\n\tif (o_direct &&\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&\n\t    !is_sync_kiocb(iocb) &&\n\t    (file->f_flags & O_APPEND ||\n\t     ext4_unaligned_aio(inode, from, pos))) {\n\t\taio_mutex = ext4_aio_mutex(inode);\n\t\tmutex_lock(aio_mutex);\n\t\text4_unwritten_wait(inode);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tiocb->ki_pos = pos = i_size_read(inode);\n\n\t/*\n\t * If we have encountered a bitmap-format file, the size limit\n\t * is smaller than s_maxbytes, which is for extent-mapped files.\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\tif ((pos > sbi->s_bitmap_maxbytes) ||\n\t\t    (pos == sbi->s_bitmap_maxbytes && length > 0)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EFBIG;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (pos + length > sbi->s_bitmap_maxbytes)\n\t\t\tiov_iter_truncate(from, sbi->s_bitmap_maxbytes - pos);\n\t}\n\n\tiocb->private = &overwrite;\n\tif (o_direct) {\n\t\tblk_start_plug(&plug);\n\n\n\t\t/* check whether we do a DIO overwrite or not */\n\t\tif (ext4_should_dioread_nolock(inode) && !aio_mutex &&\n\t\t    !file->f_mapping->nrpages && pos + length <= i_size_read(inode)) {\n\t\t\tstruct ext4_map_blocks map;\n\t\t\tunsigned int blkbits = inode->i_blkbits;\n\t\t\tint err, len;\n\n\t\t\tmap.m_lblk = pos >> blkbits;\n\t\t\tmap.m_len = (EXT4_BLOCK_ALIGN(pos + length, blkbits) >> blkbits)\n\t\t\t\t- map.m_lblk;\n\t\t\tlen = map.m_len;\n\n\t\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\t\t/*\n\t\t\t * 'err==len' means that all of blocks has\n\t\t\t * been preallocated no matter they are\n\t\t\t * initialized or not.  For excluding\n\t\t\t * unwritten extents, we need to check\n\t\t\t * m_flags.  There are two conditions that\n\t\t\t * indicate for initialized extents.  1) If we\n\t\t\t * hit extent cache, EXT4_MAP_MAPPED flag is\n\t\t\t * returned; 2) If we do a real lookup,\n\t\t\t * non-flags are returned.  So we should check\n\t\t\t * these two conditions.\n\t\t\t */\n\t\t\tif (err == len && (map.m_flags & EXT4_MAP_MAPPED))\n\t\t\t\toverwrite = 1;\n\t\t}\n\t}\n\n\tret = __generic_file_write_iter(iocb, from);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (ret > 0) {\n\t\tssize_t err;\n\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\tif (o_direct)\n\t\tblk_finish_plug(&plug);\n\nerrout:\n\tif (aio_mutex)\n\t\tmutex_unlock(aio_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_unaligned_aio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "76-89",
    "snippet": "static int\next4_unaligned_aio(struct inode *inode, struct iov_iter *from, loff_t pos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint blockmask = sb->s_blocksize - 1;\n\n\tif (pos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif ((pos | iov_iter_alignment(from)) & blockmask)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_alignment",
          "args": [
            "from"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int\next4_unaligned_aio(struct inode *inode, struct iov_iter *from, loff_t pos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint blockmask = sb->s_blocksize - 1;\n\n\tif (pos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif ((pos | iov_iter_alignment(from)) & blockmask)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_unwritten_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "60-65",
    "snippet": "static void ext4_unwritten_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = ext4_ioend_wq(inode);\n\n\twait_event(*wq, (atomic_read(&EXT4_I(inode)->i_unwritten) == 0));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "*wq",
            "(atomic_read(&EXT4_I(inode)->i_unwritten) == 0)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&EXT4_I(inode)->i_unwritten"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ioend_wq",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void ext4_unwritten_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = ext4_ioend_wq(inode);\n\n\twait_event(*wq, (atomic_read(&EXT4_I(inode)->i_unwritten) == 0));\n}"
  },
  {
    "function_name": "ext4_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
    "lines": "39-58",
    "snippet": "static int ext4_release_file(struct inode *inode, struct file *filp)\n{\n\tif (ext4_test_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE)) {\n\t\text4_alloc_da_blocks(inode);\n\t\text4_clear_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\t}\n\t/* if we are the last writer on the inode, drop the block reservation */\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t\t\t(atomic_read(&inode->i_writecount) == 1) &&\n\t\t        !EXT4_I(inode)->i_reserved_data_blocks)\n\t{\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_discard_preallocations(inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t}\n\tif (is_dx(inode) && filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/aio.h>",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_htree_free_dir_info",
          "args": [
            "filp->private_data"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_free_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "379-383",
          "snippet": "void ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nvoid ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DA_ALLOC_CLOSE"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_alloc_da_blocks",
          "args": [
            "inode"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_da_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2704-2743",
          "snippet": "int ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DA_ALLOC_CLOSE"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ext4_release_file(struct inode *inode, struct file *filp)\n{\n\tif (ext4_test_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE)) {\n\t\text4_alloc_da_blocks(inode);\n\t\text4_clear_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\t}\n\t/* if we are the last writer on the inode, drop the block reservation */\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t\t\t(atomic_read(&inode->i_writecount) == 1) &&\n\t\t        !EXT4_I(inode)->i_reserved_data_blocks)\n\t{\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_discard_preallocations(inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t}\n\tif (is_dx(inode) && filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}"
  }
]