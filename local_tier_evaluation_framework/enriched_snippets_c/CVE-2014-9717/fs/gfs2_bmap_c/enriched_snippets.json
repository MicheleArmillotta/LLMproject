[
  {
    "function_name": "gfs2_write_alloc_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1455-1494",
    "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&bh"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "&ip->i_inode",
            "lblock",
            "&bh",
            "0"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gfs2_is_dir(ip)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_dir",
          "args": [
            "ip"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "45-48",
          "snippet": "static inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_map_journal_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1401-1444",
    "snippet": "int gfs2_map_journal_extents(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tu64 lblock = 0;\n\tu64 lblock_stop;\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 size;\n\tint rc;\n\n\tlblock_stop = i_size_read(jd->jd_inode) >> shift;\n\tsize = (lblock_stop - lblock) << shift;\n\tjd->nr_extents = 0;\n\tWARN_ON(!list_empty(&jd->extent_list));\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_blocknr = 0;\n\t\tbh.b_size = size;\n\t\trc = gfs2_block_map(jd->jd_inode, lblock, &bh, 0);\n\t\tif (rc || !buffer_mapped(&bh))\n\t\t\tgoto fail;\n\t\trc = gfs2_add_jextent(jd, lblock, bh.b_blocknr, bh.b_size >> shift);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\tfs_info(sdp, \"journal %d mapped with %u extents\\n\", jd->jd_jid,\n\t\tjd->nr_extents);\n\treturn 0;\n\nfail:\n\tfs_warn(sdp, \"error %d mapping journal %u at offset %llu (extent %u)\\n\",\n\t\trc, jd->jd_jid,\n\t\t(unsigned long long)(i_size_read(jd->jd_inode) - size),\n\t\tjd->nr_extents);\n\tfs_warn(sdp, \"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\",\n\t\trc, (unsigned long long)lblock, (unsigned long long)bh.b_blocknr,\n\t\tbh.b_state, (unsigned long long)bh.b_size);\n\tgfs2_free_journal_extents(jd);\n\treturn rc;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_free_journal_extents",
          "args": [
            "jd"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_journal_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1337-1346",
          "snippet": "void gfs2_free_journal_extents(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\twhile(!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.next, struct gfs2_journal_extent, list);\n\t\tlist_del(&jext->list);\n\t\tkfree(jext);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_free_journal_extents(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\twhile(!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.next, struct gfs2_journal_extent, list);\n\t\tlist_del(&jext->list);\n\t\tkfree(jext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\"",
            "rc",
            "(unsigned long long)lblock",
            "(unsigned long long)bh.b_blocknr",
            "bh.b_state",
            "(unsigned long long)bh.b_size"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "jd->jd_inode"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"journal %d mapped with %u extents\\n\"",
            "jd->jd_jid",
            "jd->nr_extents"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_jextent",
          "args": [
            "jd",
            "lblock",
            "bh.b_blocknr",
            "bh.b_size >> shift"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_jextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1358-1379",
          "snippet": "static int gfs2_add_jextent(struct gfs2_jdesc *jd, u64 lblock, u64 dblock, u64 blocks)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\tif (!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.prev, struct gfs2_journal_extent, list);\n\t\tif ((jext->dblock + jext->blocks) == dblock) {\n\t\t\tjext->blocks += blocks;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjext = kzalloc(sizeof(struct gfs2_journal_extent), GFP_NOFS);\n\tif (jext == NULL)\n\t\treturn -ENOMEM;\n\tjext->dblock = dblock;\n\tjext->lblock = lblock;\n\tjext->blocks = blocks;\n\tlist_add_tail(&jext->list, &jd->extent_list);\n\tjd->nr_extents++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_add_jextent(struct gfs2_jdesc *jd, u64 lblock, u64 dblock, u64 blocks)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\tif (!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.prev, struct gfs2_journal_extent, list);\n\t\tif ((jext->dblock + jext->blocks) == dblock) {\n\t\t\tjext->blocks += blocks;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjext = kzalloc(sizeof(struct gfs2_journal_extent), GFP_NOFS);\n\tif (jext == NULL)\n\t\treturn -ENOMEM;\n\tjext->dblock = dblock;\n\tjext->lblock = lblock;\n\tjext->blocks = blocks;\n\tlist_add_tail(&jext->list, &jd->extent_list);\n\tjd->nr_extents++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&bh"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "jd->jd_inode",
            "lblock",
            "&bh",
            "0"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&jd->extent_list)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jd->extent_list"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "jd->jd_inode"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_map_journal_extents(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tu64 lblock = 0;\n\tu64 lblock_stop;\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 size;\n\tint rc;\n\n\tlblock_stop = i_size_read(jd->jd_inode) >> shift;\n\tsize = (lblock_stop - lblock) << shift;\n\tjd->nr_extents = 0;\n\tWARN_ON(!list_empty(&jd->extent_list));\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_blocknr = 0;\n\t\tbh.b_size = size;\n\t\trc = gfs2_block_map(jd->jd_inode, lblock, &bh, 0);\n\t\tif (rc || !buffer_mapped(&bh))\n\t\t\tgoto fail;\n\t\trc = gfs2_add_jextent(jd, lblock, bh.b_blocknr, bh.b_size >> shift);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\tfs_info(sdp, \"journal %d mapped with %u extents\\n\", jd->jd_jid,\n\t\tjd->nr_extents);\n\treturn 0;\n\nfail:\n\tfs_warn(sdp, \"error %d mapping journal %u at offset %llu (extent %u)\\n\",\n\t\trc, jd->jd_jid,\n\t\t(unsigned long long)(i_size_read(jd->jd_inode) - size),\n\t\tjd->nr_extents);\n\tfs_warn(sdp, \"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\",\n\t\trc, (unsigned long long)lblock, (unsigned long long)bh.b_blocknr,\n\t\tbh.b_state, (unsigned long long)bh.b_size);\n\tgfs2_free_journal_extents(jd);\n\treturn rc;\n}"
  },
  {
    "function_name": "gfs2_add_jextent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1358-1379",
    "snippet": "static int gfs2_add_jextent(struct gfs2_jdesc *jd, u64 lblock, u64 dblock, u64 blocks)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\tif (!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.prev, struct gfs2_journal_extent, list);\n\t\tif ((jext->dblock + jext->blocks) == dblock) {\n\t\t\tjext->blocks += blocks;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjext = kzalloc(sizeof(struct gfs2_journal_extent), GFP_NOFS);\n\tif (jext == NULL)\n\t\treturn -ENOMEM;\n\tjext->dblock = dblock;\n\tjext->lblock = lblock;\n\tjext->blocks = blocks;\n\tlist_add_tail(&jext->list, &jd->extent_list);\n\tjd->nr_extents++;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jext->list",
            "&jd->extent_list"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gfs2_journal_extent)",
            "GFP_NOFS"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "jd->extent_list.prev",
            "structgfs2_journal_extent",
            "list"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jd->extent_list"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_add_jextent(struct gfs2_jdesc *jd, u64 lblock, u64 dblock, u64 blocks)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\tif (!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.prev, struct gfs2_journal_extent, list);\n\t\tif ((jext->dblock + jext->blocks) == dblock) {\n\t\t\tjext->blocks += blocks;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjext = kzalloc(sizeof(struct gfs2_journal_extent), GFP_NOFS);\n\tif (jext == NULL)\n\t\treturn -ENOMEM;\n\tjext->dblock = dblock;\n\tjext->lblock = lblock;\n\tjext->blocks = blocks;\n\tlist_add_tail(&jext->list, &jd->extent_list);\n\tjd->nr_extents++;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_free_journal_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1337-1346",
    "snippet": "void gfs2_free_journal_extents(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\twhile(!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.next, struct gfs2_journal_extent, list);\n\t\tlist_del(&jext->list);\n\t\tkfree(jext);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jext"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&jext->list"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "jd->extent_list.next",
            "structgfs2_journal_extent",
            "list"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jd->extent_list"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_free_journal_extents(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\twhile(!list_empty(&jd->extent_list)) {\n\t\tjext = list_entry(jd->extent_list.next, struct gfs2_journal_extent, list);\n\t\tlist_del(&jext->list);\n\t\tkfree(jext);\n\t}\n}"
  },
  {
    "function_name": "gfs2_file_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1326-1329",
    "snippet": "int gfs2_file_dealloc(struct gfs2_inode *ip)\n{\n\treturn trunc_dealloc(ip, 0);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trunc_dealloc",
          "args": [
            "ip",
            "0"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1085-1120",
          "snippet": "static int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_file_dealloc(struct gfs2_inode *ip)\n{\n\treturn trunc_dealloc(ip, 0);\n}"
  },
  {
    "function_name": "gfs2_truncatei_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1317-1324",
    "snippet": "int gfs2_truncatei_resume(struct gfs2_inode *ip)\n{\n\tint error;\n\terror = trunc_dealloc(ip, i_size_read(&ip->i_inode));\n\tif (!error)\n\t\terror = trunc_end(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trunc_end",
          "args": [
            "ip"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1122-1155",
          "snippet": "static int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trunc_dealloc",
          "args": [
            "ip",
            "i_size_read(&ip->i_inode)"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1085-1120",
          "snippet": "static int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_truncatei_resume(struct gfs2_inode *ip)\n{\n\tint error;\n\terror = trunc_dealloc(ip, i_size_read(&ip->i_inode));\n\tif (!error)\n\t\terror = trunc_end(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_setattr_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1282-1315",
    "snippet": "int gfs2_setattr_size(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret;\n\tu64 oldsize;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_dio_wait(inode);\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out;\n\n\toldsize = inode->i_size;\n\tif (newsize >= oldsize) {\n\t\tret = do_grow(inode, newsize);\n\t\tgoto out;\n\t}\n\n\tgfs2_rs_deltree(ip->i_res);\n\tret = do_shrink(inode, oldsize, newsize);\nout:\n\tput_write_access(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_shrink",
          "args": [
            "inode",
            "oldsize",
            "newsize"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "do_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1169-1185",
          "snippet": "static int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_deltree",
          "args": [
            "ip->i_res"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "668-678",
          "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_grow",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "do_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1216-1268",
          "snippet": "static int do_grow(struct inode *inode, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .target = 1, };\n\tstruct buffer_head *dibh;\n\tint error;\n\tint unstuff = 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    (size > (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)))) {\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto do_grow_qunlock;\n\t\tunstuff = 1;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA), 0);\n\tif (error)\n\t\tgoto do_grow_release;\n\n\tif (unstuff) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\tgoto do_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto do_end_trans;\n\n\ti_size_write(inode, size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\ndo_end_trans:\n\tgfs2_trans_end(sdp);\ndo_grow_release:\n\tif (unstuff) {\n\t\tgfs2_inplace_release(ip);\ndo_grow_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_grow(struct inode *inode, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .target = 1, };\n\tstruct buffer_head *dibh;\n\tint error;\n\tint unstuff = 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    (size > (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)))) {\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto do_grow_qunlock;\n\t\tunstuff = 1;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA), 0);\n\tif (error)\n\t\tgoto do_grow_release;\n\n\tif (unstuff) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\tgoto do_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto do_end_trans;\n\n\ti_size_write(inode, size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\ndo_end_trans:\n\tgfs2_trans_end(sdp);\ndo_grow_release:\n\tif (unstuff) {\n\t\tgfs2_inplace_release(ip);\ndo_grow_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISREG(inode->i_mode)"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_setattr_size(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret;\n\tu64 oldsize;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_dio_wait(inode);\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out;\n\n\toldsize = inode->i_size;\n\tif (newsize >= oldsize) {\n\t\tret = do_grow(inode, newsize);\n\t\tgoto out;\n\t}\n\n\tgfs2_rs_deltree(ip->i_res);\n\tret = do_shrink(inode, oldsize, newsize);\nout:\n\tput_write_access(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_grow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1216-1268",
    "snippet": "static int do_grow(struct inode *inode, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .target = 1, };\n\tstruct buffer_head *dibh;\n\tint error;\n\tint unstuff = 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    (size > (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)))) {\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto do_grow_qunlock;\n\t\tunstuff = 1;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA), 0);\n\tif (error)\n\t\tgoto do_grow_release;\n\n\tif (unstuff) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\tgoto do_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto do_end_trans;\n\n\ti_size_write(inode, size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\ndo_end_trans:\n\tgfs2_trans_end(sdp);\ndo_grow_release:\n\tif (unstuff) {\n\t\tgfs2_inplace_release(ip);\ndo_grow_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "NULL"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA)",
            "0"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_grow(struct inode *inode, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .target = 1, };\n\tstruct buffer_head *dibh;\n\tint error;\n\tint unstuff = 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    (size > (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)))) {\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto do_grow_qunlock;\n\t\tunstuff = 1;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA), 0);\n\tif (error)\n\t\tgoto do_grow_release;\n\n\tif (unstuff) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\tgoto do_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto do_end_trans;\n\n\ti_size_write(inode, size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\ndo_end_trans:\n\tgfs2_trans_end(sdp);\ndo_grow_release:\n\tif (unstuff) {\n\t\tgfs2_inplace_release(ip);\ndo_grow_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_trim_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1187-1194",
    "snippet": "void gfs2_trim_blocks(struct inode *inode)\n{\n\tu64 size = inode->i_size;\n\tint ret;\n\n\tret = do_shrink(inode, size, size);\n\tWARN_ON(ret != 0);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret != 0"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_shrink",
          "args": [
            "inode",
            "size",
            "size"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "do_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1169-1185",
          "snippet": "static int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_trim_blocks(struct inode *inode)\n{\n\tu64 size = inode->i_size;\n\tint ret;\n\n\tret = do_shrink(inode, size, size);\n\tWARN_ON(ret != 0);\n}"
  },
  {
    "function_name": "do_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1169-1185",
    "snippet": "static int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trunc_end",
          "args": [
            "ip"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1122-1155",
          "snippet": "static int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trunc_dealloc",
          "args": [
            "ip",
            "newsize"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1085-1120",
          "snippet": "static int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trunc_start",
          "args": [
            "inode",
            "oldsize",
            "newsize"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "trunc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1031-1083",
          "snippet": "static int trunc_start(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct buffer_head *dibh;\n\tint journaled = gfs2_is_jdata(ip);\n\tint error;\n\n\tif (journaled)\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_JDATA, GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);\n\t} else {\n\t\tif (newsize & (u64)(sdp->sd_sb.sb_bsize - 1)) {\n\t\t\terror = gfs2_block_truncate_page(mapping, newsize);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t\tip->i_diskflags |= GFS2_DIF_TRUNC_IN_PROG;\n\t}\n\n\ti_size_write(inode, newsize);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tif (journaled)\n\t\terror = gfs2_journaled_truncate(inode, oldsize, newsize);\n\telse\n\t\ttruncate_pagecache(inode, newsize);\n\n\tif (error) {\n\t\tbrelse(dibh);\n\t\treturn error;\n\t}\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define GFS2_JTRUNC_REVOKES 8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\n#define GFS2_JTRUNC_REVOKES 8192\n\nstatic int trunc_start(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct buffer_head *dibh;\n\tint journaled = gfs2_is_jdata(ip);\n\tint error;\n\n\tif (journaled)\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_JDATA, GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);\n\t} else {\n\t\tif (newsize & (u64)(sdp->sd_sb.sb_bsize - 1)) {\n\t\t\terror = gfs2_block_truncate_page(mapping, newsize);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t\tip->i_diskflags |= GFS2_DIF_TRUNC_IN_PROG;\n\t}\n\n\ti_size_write(inode, newsize);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tif (journaled)\n\t\terror = gfs2_journaled_truncate(inode, oldsize, newsize);\n\telse\n\t\ttruncate_pagecache(inode, newsize);\n\n\tif (error) {\n\t\tbrelse(dibh);\n\t\treturn error;\n\t}\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_shrink(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, oldsize, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = trunc_dealloc(ip, newsize);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}"
  },
  {
    "function_name": "trunc_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1122-1155",
    "snippet": "static int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ordered_del_inode",
          "args": [
            "ip"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ordered_del_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "568-576",
          "snippet": "void gfs2_ordered_del_inode(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tspin_lock(&sdp->sd_ordered_lock);\n\tif (test_and_clear_bit(GIF_ORDERED, &ip->i_flags))\n\t\tlist_del(&ip->i_ordered);\n\tspin_unlock(&sdp->sd_ordered_lock);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_ordered_del_inode(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tspin_lock(&sdp->sd_ordered_lock);\n\tif (test_and_clear_bit(GIF_ORDERED, &ip->i_flags))\n\t\tlist_del(&ip->i_ordered);\n\tspin_unlock(&sdp->sd_ordered_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE",
            "0"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
  },
  {
    "function_name": "trunc_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1085-1120",
    "snippet": "static int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursive_scan",
          "args": [
            "ip",
            "NULL",
            "&mp",
            "0",
            "0",
            "1",
            "&sm"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "recursive_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "870-923",
          "snippet": "static int recursive_scan(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t  struct metapath *mp, unsigned int height,\n\t\t\t  u64 block, int first, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh = NULL;\n\t__be64 *top, *bottom;\n\tu64 bn;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (!height) {\n\t\terror = gfs2_meta_inode_buffer(ip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdibh = bh;\n\n\t\ttop = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + mp->mp_list[0];\n\t\tbottom = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + sdp->sd_diptrs;\n\t} else {\n\t\terror = gfs2_meta_indirect_buffer(ip, height, block, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttop = (__be64 *)(bh->b_data + mh_size) +\n\t\t\t\t  (first ? mp->mp_list[height] : 0);\n\n\t\tbottom = (__be64 *)(bh->b_data + mh_size) + sdp->sd_inptrs;\n\t}\n\n\terror = do_strip(ip, dibh, bh, top, bottom, height, sm);\n\tif (error)\n\t\tgoto out;\n\n\tif (height < ip->i_height - 1) {\n\n\t\tgfs2_metapath_ra(ip->i_gl, bh, top);\n\n\t\tfor (; top < bottom; top++, first = 0) {\n\t\t\tif (!*top)\n\t\t\t\tcontinue;\n\n\t\t\tbn = be64_to_cpu(*top);\n\n\t\t\terror = recursive_scan(ip, dibh, mp, height + 1, bn,\n\t\t\t\t\t       first, sm);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int recursive_scan(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t  struct metapath *mp, unsigned int height,\n\t\t\t  u64 block, int first, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh = NULL;\n\t__be64 *top, *bottom;\n\tu64 bn;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (!height) {\n\t\terror = gfs2_meta_inode_buffer(ip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdibh = bh;\n\n\t\ttop = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + mp->mp_list[0];\n\t\tbottom = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + sdp->sd_diptrs;\n\t} else {\n\t\terror = gfs2_meta_indirect_buffer(ip, height, block, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttop = (__be64 *)(bh->b_data + mh_size) +\n\t\t\t\t  (first ? mp->mp_list[height] : 0);\n\n\t\tbottom = (__be64 *)(bh->b_data + mh_size) + sdp->sd_inptrs;\n\t}\n\n\terror = do_strip(ip, dibh, bh, top, bottom, height, sm);\n\tif (error)\n\t\tgoto out;\n\n\tif (height < ip->i_height - 1) {\n\n\t\tgfs2_metapath_ra(ip->i_gl, bh, top);\n\n\t\tfor (; top < bottom; top++, first = 0) {\n\t\t\tif (!*top)\n\t\t\t\tcontinue;\n\n\t\t\tbn = be64_to_cpu(*top);\n\n\t\t\terror = recursive_scan(ip, dibh, mp, height + 1, bn,\n\t\t\t\t\t       first, sm);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_hold",
          "args": [
            "ip",
            "NO_UID_QUOTA_CHANGE",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "530-585",
          "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_metapath",
          "args": [
            "sdp",
            "lblock",
            "&mp",
            "ip->i_height"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "find_metapath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "238-246",
          "snippet": "static void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int trunc_dealloc(struct gfs2_inode *ip, u64 size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int height = ip->i_height;\n\tu64 lblock;\n\tstruct metapath mp;\n\tint error;\n\n\tif (!size)\n\t\tlblock = 0;\n\telse\n\t\tlblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\twhile (height--) {\n\t\tstruct strip_mine sm;\n\t\tsm.sm_first = !!size;\n\t\tsm.sm_height = height;\n\n\t\terror = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tgfs2_quota_unhold(ip);\n\n\treturn error;\n}"
  },
  {
    "function_name": "trunc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1031-1083",
    "snippet": "static int trunc_start(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct buffer_head *dibh;\n\tint journaled = gfs2_is_jdata(ip);\n\tint error;\n\n\tif (journaled)\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_JDATA, GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);\n\t} else {\n\t\tif (newsize & (u64)(sdp->sd_sb.sb_bsize - 1)) {\n\t\t\terror = gfs2_block_truncate_page(mapping, newsize);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t\tip->i_diskflags |= GFS2_DIF_TRUNC_IN_PROG;\n\t}\n\n\ti_size_write(inode, newsize);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tif (journaled)\n\t\terror = gfs2_journaled_truncate(inode, oldsize, newsize);\n\telse\n\t\ttruncate_pagecache(inode, newsize);\n\n\tif (error) {\n\t\tbrelse(dibh);\n\t\treturn error;\n\t}\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define GFS2_JTRUNC_REVOKES 8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_journaled_truncate",
          "args": [
            "inode",
            "oldsize",
            "newsize"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_journaled_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1009-1029",
          "snippet": "static int gfs2_journaled_truncate(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tu64 chunk;\n\tint error;\n\n\twhile (oldsize != newsize) {\n\t\tchunk = oldsize - newsize;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\t\ttruncate_pagecache(inode, oldsize - chunk);\n\t\toldsize -= chunk;\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define GFS2_JTRUNC_REVOKES 8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\n#define GFS2_JTRUNC_REVOKES 8192\n\nstatic int gfs2_journaled_truncate(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tu64 chunk;\n\tint error;\n\n\twhile (oldsize != newsize) {\n\t\tchunk = oldsize - newsize;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\t\ttruncate_pagecache(inode, oldsize - chunk);\n\t\toldsize -= chunk;\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_block_truncate_page",
          "args": [
            "mapping",
            "newsize"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "931-994",
          "snippet": "static int gfs2_block_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned long index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err;\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn 0;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\terr = 0;\n\t}\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_block_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned long index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err;\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn 0;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\terr = 0;\n\t}\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sdp->sd_sb.sb_bsize - 1"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode) + newsize"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE",
            "0"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\n#define GFS2_JTRUNC_REVOKES 8192\n\nstatic int trunc_start(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct buffer_head *dibh;\n\tint journaled = gfs2_is_jdata(ip);\n\tint error;\n\n\tif (journaled)\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_JDATA, GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);\n\t} else {\n\t\tif (newsize & (u64)(sdp->sd_sb.sb_bsize - 1)) {\n\t\t\terror = gfs2_block_truncate_page(mapping, newsize);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t\tip->i_diskflags |= GFS2_DIF_TRUNC_IN_PROG;\n\t}\n\n\ti_size_write(inode, newsize);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tif (journaled)\n\t\terror = gfs2_journaled_truncate(inode, oldsize, newsize);\n\telse\n\t\ttruncate_pagecache(inode, newsize);\n\n\tif (error) {\n\t\tbrelse(dibh);\n\t\treturn error;\n\t}\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_journaled_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "1009-1029",
    "snippet": "static int gfs2_journaled_truncate(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tu64 chunk;\n\tint error;\n\n\twhile (oldsize != newsize) {\n\t\tchunk = oldsize - newsize;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\t\ttruncate_pagecache(inode, oldsize - chunk);\n\t\toldsize -= chunk;\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define GFS2_JTRUNC_REVOKES 8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE",
            "GFS2_JTRUNC_REVOKES"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "oldsize - chunk"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\n#define GFS2_JTRUNC_REVOKES 8192\n\nstatic int gfs2_journaled_truncate(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tu64 chunk;\n\tint error;\n\n\twhile (oldsize != newsize) {\n\t\tchunk = oldsize - newsize;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\t\ttruncate_pagecache(inode, oldsize - chunk);\n\t\toldsize -= chunk;\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "931-994",
    "snippet": "static int gfs2_block_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned long index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err;\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn 0;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\terr = 0;\n\t}\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_data",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "158-193",
          "snippet": "void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_writeback",
          "args": [
            "ip"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "33-37",
          "snippet": "static inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_block_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned long index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err;\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn 0;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\terr = 0;\n\t}\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "recursive_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "870-923",
    "snippet": "static int recursive_scan(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t  struct metapath *mp, unsigned int height,\n\t\t\t  u64 block, int first, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh = NULL;\n\t__be64 *top, *bottom;\n\tu64 bn;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (!height) {\n\t\terror = gfs2_meta_inode_buffer(ip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdibh = bh;\n\n\t\ttop = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + mp->mp_list[0];\n\t\tbottom = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + sdp->sd_diptrs;\n\t} else {\n\t\terror = gfs2_meta_indirect_buffer(ip, height, block, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttop = (__be64 *)(bh->b_data + mh_size) +\n\t\t\t\t  (first ? mp->mp_list[height] : 0);\n\n\t\tbottom = (__be64 *)(bh->b_data + mh_size) + sdp->sd_inptrs;\n\t}\n\n\terror = do_strip(ip, dibh, bh, top, bottom, height, sm);\n\tif (error)\n\t\tgoto out;\n\n\tif (height < ip->i_height - 1) {\n\n\t\tgfs2_metapath_ra(ip->i_gl, bh, top);\n\n\t\tfor (; top < bottom; top++, first = 0) {\n\t\t\tif (!*top)\n\t\t\t\tcontinue;\n\n\t\t\tbn = be64_to_cpu(*top);\n\n\t\t\terror = recursive_scan(ip, dibh, mp, height + 1, bn,\n\t\t\t\t\t       first, sm);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursive_scan",
          "args": [
            "ip",
            "dibh",
            "mp",
            "height + 1",
            "bn",
            "first",
            "sm"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "recursive_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "870-923",
          "snippet": "static int recursive_scan(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t  struct metapath *mp, unsigned int height,\n\t\t\t  u64 block, int first, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh = NULL;\n\t__be64 *top, *bottom;\n\tu64 bn;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (!height) {\n\t\terror = gfs2_meta_inode_buffer(ip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdibh = bh;\n\n\t\ttop = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + mp->mp_list[0];\n\t\tbottom = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + sdp->sd_diptrs;\n\t} else {\n\t\terror = gfs2_meta_indirect_buffer(ip, height, block, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttop = (__be64 *)(bh->b_data + mh_size) +\n\t\t\t\t  (first ? mp->mp_list[height] : 0);\n\n\t\tbottom = (__be64 *)(bh->b_data + mh_size) + sdp->sd_inptrs;\n\t}\n\n\terror = do_strip(ip, dibh, bh, top, bottom, height, sm);\n\tif (error)\n\t\tgoto out;\n\n\tif (height < ip->i_height - 1) {\n\n\t\tgfs2_metapath_ra(ip->i_gl, bh, top);\n\n\t\tfor (; top < bottom; top++, first = 0) {\n\t\t\tif (!*top)\n\t\t\t\tcontinue;\n\n\t\t\tbn = be64_to_cpu(*top);\n\n\t\t\terror = recursive_scan(ip, dibh, mp, height + 1, bn,\n\t\t\t\t\t       first, sm);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*top"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metapath_ra",
          "args": [
            "ip->i_gl",
            "bh",
            "top"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metapath_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "273-295",
          "snippet": "static void gfs2_metapath_ra(struct gfs2_glock *gl,\n\t\t\t     const struct buffer_head *bh, const __be64 *pos)\n{\n\tstruct buffer_head *rabh;\n\tconst __be64 *endp = (const __be64 *)(bh->b_data + bh->b_size);\n\tconst __be64 *t;\n\n\tfor (t = pos; t < endp; t++) {\n\t\tif (!*t)\n\t\t\tcontinue;\n\n\t\trabh = gfs2_getbuf(gl, be64_to_cpu(*t), CREATE);\n\t\tif (trylock_buffer(rabh)) {\n\t\t\tif (!buffer_uptodate(rabh)) {\n\t\t\t\trabh->b_end_io = end_buffer_read_sync;\n\t\t\t\tsubmit_bh(READA | REQ_META, rabh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_buffer(rabh);\n\t\t}\n\t\tbrelse(rabh);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_metapath_ra(struct gfs2_glock *gl,\n\t\t\t     const struct buffer_head *bh, const __be64 *pos)\n{\n\tstruct buffer_head *rabh;\n\tconst __be64 *endp = (const __be64 *)(bh->b_data + bh->b_size);\n\tconst __be64 *t;\n\n\tfor (t = pos; t < endp; t++) {\n\t\tif (!*t)\n\t\t\tcontinue;\n\n\t\trabh = gfs2_getbuf(gl, be64_to_cpu(*t), CREATE);\n\t\tif (trylock_buffer(rabh)) {\n\t\t\tif (!buffer_uptodate(rabh)) {\n\t\t\t\trabh->b_end_io = end_buffer_read_sync;\n\t\t\t\tsubmit_bh(READA | REQ_META, rabh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_buffer(rabh);\n\t\t}\n\t\tbrelse(rabh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_strip",
          "args": [
            "ip",
            "dibh",
            "bh",
            "top",
            "bottom",
            "height",
            "sm"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "do_strip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "716-852",
          "snippet": "static int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t    struct buffer_head *bh, __be64 *top, __be64 *bottom,\n\t\t    unsigned int height, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tu64 bn, bstart;\n\tu32 blen, btotal;\n\t__be64 *p;\n\tunsigned int rg_blocks = 0;\n\tint metadata;\n\tunsigned int revokes = 0;\n\tint x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (!*top)\n\t\tsm->sm_first = 0;\n\n\tif (height != sm->sm_height)\n\t\treturn 0;\n\n\tif (sm->sm_first) {\n\t\ttop++;\n\t\tsm->sm_first = 0;\n\t}\n\n\tmetadata = (height != ip->i_height - 1);\n\tif (metadata)\n\t\trevokes = (height) ? sdp->sd_inptrs : sdp->sd_diptrs;\n\telse if (ip->i_depth)\n\t\trevokes = sdp->sd_inptrs;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t}\n\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out; /* Nothing to do */\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\tif (gfs2_rs_active(ip->i_res)) /* needs to be done with the rgrp glock held */\n\t\tgfs2_rs_deltree(ip->i_res);\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE +\n\t\t\t\t RES_INDIRECT + RES_STATFS + RES_QUOTA,\n\t\t\t\t revokes);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tbstart = 0;\n\tblen = 0;\n\tbtotal = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart) {\n\t\t\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\t\t\tbtotal += blen;\n\t\t\t}\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*p = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart) {\n\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\tbtotal += blen;\n\t}\n\n\tgfs2_statfs_change(sdp, 0, +btotal, 0);\n\tgfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,\n\t\t\t  ip->i_inode.i_gid);\n\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tup_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_end(sdp);\n\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t    struct buffer_head *bh, __be64 *top, __be64 *bottom,\n\t\t    unsigned int height, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tu64 bn, bstart;\n\tu32 blen, btotal;\n\t__be64 *p;\n\tunsigned int rg_blocks = 0;\n\tint metadata;\n\tunsigned int revokes = 0;\n\tint x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (!*top)\n\t\tsm->sm_first = 0;\n\n\tif (height != sm->sm_height)\n\t\treturn 0;\n\n\tif (sm->sm_first) {\n\t\ttop++;\n\t\tsm->sm_first = 0;\n\t}\n\n\tmetadata = (height != ip->i_height - 1);\n\tif (metadata)\n\t\trevokes = (height) ? sdp->sd_inptrs : sdp->sd_diptrs;\n\telse if (ip->i_depth)\n\t\trevokes = sdp->sd_inptrs;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t}\n\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out; /* Nothing to do */\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\tif (gfs2_rs_active(ip->i_res)) /* needs to be done with the rgrp glock held */\n\t\tgfs2_rs_deltree(ip->i_res);\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE +\n\t\t\t\t RES_INDIRECT + RES_STATFS + RES_QUOTA,\n\t\t\t\t revokes);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tbstart = 0;\n\tblen = 0;\n\tbtotal = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart) {\n\t\t\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\t\t\tbtotal += blen;\n\t\t\t}\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*p = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart) {\n\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\tbtotal += blen;\n\t}\n\n\tgfs2_statfs_change(sdp, 0, +btotal, 0);\n\tgfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,\n\t\t\t  ip->i_inode.i_gid);\n\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tup_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_end(sdp);\n\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_indirect_buffer",
          "args": [
            "ip",
            "height",
            "block",
            "&bh"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_indirect_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "336-352",
          "snippet": "int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\n\t\t\t      struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\n\n\tret = gfs2_meta_read(gl, num, DIO_WAIT, &bh);\n\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\n\t\tbrelse(bh);\n\t\tret = -EIO;\n\t}\n\t*bhp = bh;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\n\t\t\t      struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\n\n\tret = gfs2_meta_read(gl, num, DIO_WAIT, &bh);\n\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\n\t\tbrelse(bh);\n\t\tret = -EIO;\n\t}\n\t*bhp = bh;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&bh"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int recursive_scan(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t  struct metapath *mp, unsigned int height,\n\t\t\t  u64 block, int first, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh = NULL;\n\t__be64 *top, *bottom;\n\tu64 bn;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (!height) {\n\t\terror = gfs2_meta_inode_buffer(ip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdibh = bh;\n\n\t\ttop = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + mp->mp_list[0];\n\t\tbottom = (__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)) + sdp->sd_diptrs;\n\t} else {\n\t\terror = gfs2_meta_indirect_buffer(ip, height, block, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttop = (__be64 *)(bh->b_data + mh_size) +\n\t\t\t\t  (first ? mp->mp_list[height] : 0);\n\n\t\tbottom = (__be64 *)(bh->b_data + mh_size) + sdp->sd_inptrs;\n\t}\n\n\terror = do_strip(ip, dibh, bh, top, bottom, height, sm);\n\tif (error)\n\t\tgoto out;\n\n\tif (height < ip->i_height - 1) {\n\n\t\tgfs2_metapath_ra(ip->i_gl, bh, top);\n\n\t\tfor (; top < bottom; top++, first = 0) {\n\t\t\tif (!*top)\n\t\t\t\tcontinue;\n\n\t\t\tbn = be64_to_cpu(*top);\n\n\t\t\terror = recursive_scan(ip, dibh, mp, height + 1, bn,\n\t\t\t\t\t       first, sm);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "do_strip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "716-852",
    "snippet": "static int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t    struct buffer_head *bh, __be64 *top, __be64 *bottom,\n\t\t    unsigned int height, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tu64 bn, bstart;\n\tu32 blen, btotal;\n\t__be64 *p;\n\tunsigned int rg_blocks = 0;\n\tint metadata;\n\tunsigned int revokes = 0;\n\tint x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (!*top)\n\t\tsm->sm_first = 0;\n\n\tif (height != sm->sm_height)\n\t\treturn 0;\n\n\tif (sm->sm_first) {\n\t\ttop++;\n\t\tsm->sm_first = 0;\n\t}\n\n\tmetadata = (height != ip->i_height - 1);\n\tif (metadata)\n\t\trevokes = (height) ? sdp->sd_inptrs : sdp->sd_diptrs;\n\telse if (ip->i_depth)\n\t\trevokes = sdp->sd_inptrs;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t}\n\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out; /* Nothing to do */\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\tif (gfs2_rs_active(ip->i_res)) /* needs to be done with the rgrp glock held */\n\t\tgfs2_rs_deltree(ip->i_res);\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE +\n\t\t\t\t RES_INDIRECT + RES_STATFS + RES_QUOTA,\n\t\t\t\t revokes);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tbstart = 0;\n\tblen = 0;\n\tbtotal = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart) {\n\t\t\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\t\t\tbtotal += blen;\n\t\t\t}\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*p = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart) {\n\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\tbtotal += blen;\n\t}\n\n\tgfs2_statfs_change(sdp, 0, +btotal, 0);\n\tgfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,\n\t\t\t  ip->i_inode.i_gid);\n\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tup_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_end(sdp);\n\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rlist_free",
          "args": [
            "&rlist"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2600-2612",
          "snippet": "void gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1245-1249",
          "snippet": "void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_change",
          "args": [
            "ip",
            "-(s64)btotal",
            "ip->i_inode.i_uid",
            "ip->i_inode.i_gid"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1145-1164",
          "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_change",
          "args": [
            "sdp",
            "0",
            "+btotal",
            "0"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "515-548",
          "snippet": "void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_free_blocks",
          "args": [
            "ip",
            "bstart",
            "blen",
            "metadata"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2396-2414",
          "snippet": "void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "-1"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*p"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rg_blocks + RES_DINODE +\n\t\t\t\t RES_INDIRECT + RES_STATFS + RES_QUOTA",
            "revokes"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_deltree",
          "args": [
            "ip->i_res"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "668-678",
          "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "ip->i_res"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1210-1236",
          "snippet": "int gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_alloc",
          "args": [
            "&rlist",
            "LM_ST_EXCLUSIVE"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2582-2592",
          "snippet": "void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_add",
          "args": [
            "ip",
            "&rlist",
            "bstart"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2527-2570",
          "snippet": "void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*p"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rlist",
            "0",
            "sizeof(struct gfs2_rgrp_list)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t    struct buffer_head *bh, __be64 *top, __be64 *bottom,\n\t\t    unsigned int height, struct strip_mine *sm)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tu64 bn, bstart;\n\tu32 blen, btotal;\n\t__be64 *p;\n\tunsigned int rg_blocks = 0;\n\tint metadata;\n\tunsigned int revokes = 0;\n\tint x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (!*top)\n\t\tsm->sm_first = 0;\n\n\tif (height != sm->sm_height)\n\t\treturn 0;\n\n\tif (sm->sm_first) {\n\t\ttop++;\n\t\tsm->sm_first = 0;\n\t}\n\n\tmetadata = (height != ip->i_height - 1);\n\tif (metadata)\n\t\trevokes = (height) ? sdp->sd_inptrs : sdp->sd_diptrs;\n\telse if (ip->i_depth)\n\t\trevokes = sdp->sd_inptrs;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t}\n\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out; /* Nothing to do */\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\tif (gfs2_rs_active(ip->i_res)) /* needs to be done with the rgrp glock held */\n\t\tgfs2_rs_deltree(ip->i_res);\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE +\n\t\t\t\t RES_INDIRECT + RES_STATFS + RES_QUOTA,\n\t\t\t\t revokes);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tbstart = 0;\n\tblen = 0;\n\tbtotal = 0;\n\n\tfor (p = top; p < bottom; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart) {\n\t\t\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\t\t\tbtotal += blen;\n\t\t\t}\n\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*p = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart) {\n\t\t__gfs2_free_blocks(ip, bstart, blen, metadata);\n\t\tbtotal += blen;\n\t}\n\n\tgfs2_statfs_change(sdp, 0, +btotal, 0);\n\tgfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,\n\t\t\t  ip->i_inode.i_gid);\n\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tup_write(&ip->i_rw_mutex);\n\n\tgfs2_trans_end(sdp);\n\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "682-701",
    "snippet": "int gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&bh"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "lblock",
            "&bh",
            "create"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!new"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dblock"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!extlen"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "603-677",
    "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_bmap_alloc",
          "args": [
            "inode",
            "lblock",
            "bh_map",
            "&mp",
            "ret",
            "height",
            "maxlen"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_bmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "448-587",
          "snippet": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const size_t maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, (size_t)(ptrs_per_blk -\n\t\t\t\t\t     mp->mp_list[end_of_metadata]));\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const size_t maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, (size_t)(ptrs_per_blk -\n\t\t\t\t\t     mp->mp_list[end_of_metadata]));\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gfs2_is_stuffed(ip)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap_unlock",
          "args": [
            "ip",
            "create"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "391-397",
          "snippet": "static inline void bmap_unlock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tup_write(&ip->i_rw_mutex);\n\telse\n\t\tup_read(&ip->i_rw_mutex);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void bmap_unlock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tup_write(&ip->i_rw_mutex);\n\telse\n\t\tup_read(&ip->i_rw_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_bmap",
          "args": [
            "ip",
            "bh_map",
            "lblock",
            "create",
            "ret"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapath",
          "args": [
            "&mp"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "336-345",
          "snippet": "static inline void release_metapath(struct metapath *mp)\n{\n\tint i;\n\n\tfor (i = 0; i < GFS2_MAX_META_HEIGHT; i++) {\n\t\tif (mp->mp_bh[i] == NULL)\n\t\t\tbreak;\n\t\tbrelse(mp->mp_bh[i]);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void release_metapath(struct metapath *mp)\n{\n\tint i;\n\n\tfor (i = 0; i < GFS2_MAX_META_HEIGHT; i++) {\n\t\tif (mp->mp_bh[i] == NULL)\n\t\t\tbreak;\n\t\tbrelse(mp->mp_bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_boundary",
          "args": [
            "bh_map"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_extent_length",
          "args": [
            "bh->b_data",
            "bh->b_size",
            "ptr",
            "maxlen",
            "&eob"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "362-381",
          "snippet": "static inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_map",
            "inode->i_sb",
            "be64_to_cpu(*ptr)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapointer",
          "args": [
            "ip->i_height - 1",
            "&mp"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "metapointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "265-271",
          "snippet": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_metapath",
          "args": [
            "ip",
            "&mp"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_metapath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "314-334",
          "snippet": "static int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)\n{\n\tunsigned int end_of_metadata = ip->i_height - 1;\n\tunsigned int x;\n\t__be64 *ptr;\n\tu64 dblock;\n\tint ret;\n\n\tfor (x = 0; x < end_of_metadata; x++) {\n\t\tptr = metapointer(x, mp);\n\t\tdblock = be64_to_cpu(*ptr);\n\t\tif (!dblock)\n\t\t\treturn x + 1;\n\n\t\tret = gfs2_meta_indirect_buffer(ip, x+1, dblock, &mp->mp_bh[x+1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ip->i_height;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)\n{\n\tunsigned int end_of_metadata = ip->i_height - 1;\n\tunsigned int x;\n\t__be64 *ptr;\n\tu64 dblock;\n\tint ret;\n\n\tfor (x = 0; x < end_of_metadata; x++) {\n\t\tptr = metapointer(x, mp);\n\t\tdblock = be64_to_cpu(*ptr);\n\t\tif (!dblock)\n\t\t\treturn x + 1;\n\n\t\tret = gfs2_meta_indirect_buffer(ip, x+1, dblock, &mp->mp_bh[x+1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_metapath",
          "args": [
            "sdp",
            "lblock",
            "&mp",
            "height"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "find_metapath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "238-246",
          "snippet": "static void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&mp.mp_bh[0]"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_dir",
          "args": [
            "ip"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "45-48",
          "snippet": "static inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_bmap",
          "args": [
            "ip",
            "bh_map",
            "lblock",
            "create",
            "1"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_boundary",
          "args": [
            "bh_map"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh_map"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh_map"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap_lock",
          "args": [
            "ip",
            "create"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "383-389",
          "snippet": "static inline void bmap_lock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tdown_write(&ip->i_rw_mutex);\n\telse\n\t\tdown_read(&ip->i_rw_mutex);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void bmap_lock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tdown_write(&ip->i_rw_mutex);\n\telse\n\t\tdown_read(&ip->i_rw_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mp.mp_bh",
            "0",
            "sizeof(mp.mp_bh)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "maxlen == 0"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
  },
  {
    "function_name": "gfs2_bmap_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "448-587",
    "snippet": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const size_t maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, (size_t)(ptrs_per_blk -\n\t\t\t\t\t     mp->mp_list[end_of_metadata]));\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_map"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_map",
            "inode->i_sb",
            "dblock"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "mp->mp_bh[0]->b_data"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "alloced"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_zeronew",
          "args": [
            "bh_map"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"Failed to zero data buffers\\n\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_issue_zeroout",
          "args": [
            "sb",
            "dblock",
            "dblks",
            "GFP_NOFS"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_zeronew",
          "args": [
            "bh_map"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bn++"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapointer",
          "args": [
            "end_of_metadata",
            "mp"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "metapointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "265-271",
          "snippet": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "mp->mp_bh[end_of_metadata]"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mp->mp_bh[end_of_metadata] == NULL"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "n > dblks"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_indirect_init",
          "args": [
            "mp",
            "ip->i_gl",
            "i",
            "mp->mp_list[i-1]",
            "bn++"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_indirect_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "399-415",
          "snippet": "static inline __be64 *gfs2_indirect_init(struct metapath *mp,\n\t\t\t\t\t struct gfs2_glock *gl, unsigned int i,\n\t\t\t\t\t unsigned offset, u64 bn)\n{\n\t__be64 *ptr = (__be64 *)(mp->mp_bh[i - 1]->b_data +\n\t\t       ((i > 1) ? sizeof(struct gfs2_meta_header) :\n\t\t\t\t sizeof(struct gfs2_dinode)));\n\tBUG_ON(i < 1);\n\tBUG_ON(mp->mp_bh[i] != NULL);\n\tmp->mp_bh[i] = gfs2_meta_new(gl, bn);\n\tgfs2_trans_add_meta(gl, mp->mp_bh[i]);\n\tgfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\tgfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));\n\tptr += offset;\n\t*ptr = cpu_to_be64(bn);\n\treturn ptr;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *gfs2_indirect_init(struct metapath *mp,\n\t\t\t\t\t struct gfs2_glock *gl, unsigned int i,\n\t\t\t\t\t unsigned offset, u64 bn)\n{\n\t__be64 *ptr = (__be64 *)(mp->mp_bh[i - 1]->b_data +\n\t\t       ((i > 1) ? sizeof(struct gfs2_meta_header) :\n\t\t\t\t sizeof(struct gfs2_dinode)));\n\tBUG_ON(i < 1);\n\tBUG_ON(mp->mp_bh[i] != NULL);\n\tmp->mp_bh[i] = gfs2_meta_new(gl, bn);\n\tgfs2_trans_add_meta(gl, mp->mp_bh[i]);\n\tgfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\tgfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));\n\tptr += offset;\n\t*ptr = cpu_to_be64(bn);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "mp->mp_bh[i]"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64)"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_copy_tail",
          "args": [
            "mp->mp_bh[i]",
            "sizeof(struct gfs2_meta_header)",
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_copy_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "28-38",
          "snippet": "static inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "sdp",
            "bn",
            "n"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&bn",
            "&n",
            "0",
            "NULL"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapath_branch_start",
          "args": [
            "mp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "metapath_branch_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "248-253",
          "snippet": "static inline unsigned int metapath_branch_start(const struct metapath *mp)\n{\n\tif (mp->mp_list[0] == 0)\n\t\treturn 2;\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int metapath_branch_start(const struct metapath *mp)\n{\n\tif (mp->mp_list[0] == 0)\n\t\treturn 2;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "maxlen",
            "(size_t)(ptrs_per_blk -\n\t\t\t\t\t     mp->mp_list[end_of_metadata])"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dblks < 1"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_extent_length",
          "args": [
            "bh->b_data",
            "bh->b_size",
            "ptr",
            "maxlen",
            "&eob"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "362-381",
          "snippet": "static inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dibh == NULL"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sheight < 1"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const size_t maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, (size_t)(ptrs_per_blk -\n\t\t\t\t\t     mp->mp_list[end_of_metadata]));\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_indirect_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "399-415",
    "snippet": "static inline __be64 *gfs2_indirect_init(struct metapath *mp,\n\t\t\t\t\t struct gfs2_glock *gl, unsigned int i,\n\t\t\t\t\t unsigned offset, u64 bn)\n{\n\t__be64 *ptr = (__be64 *)(mp->mp_bh[i - 1]->b_data +\n\t\t       ((i > 1) ? sizeof(struct gfs2_meta_header) :\n\t\t\t\t sizeof(struct gfs2_dinode)));\n\tBUG_ON(i < 1);\n\tBUG_ON(mp->mp_bh[i] != NULL);\n\tmp->mp_bh[i] = gfs2_meta_new(gl, bn);\n\tgfs2_trans_add_meta(gl, mp->mp_bh[i]);\n\tgfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\tgfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));\n\tptr += offset;\n\t*ptr = cpu_to_be64(bn);\n\treturn ptr;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bn"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "mp->mp_bh[i]",
            "sizeof(struct gfs2_meta_header)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "mp->mp_bh[i]",
            "GFS2_METATYPE_IN",
            "GFS2_FORMAT_IN"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "gl",
            "mp->mp_bh[i]"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "gl",
            "bn"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mp->mp_bh[i] != NULL"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i < 1"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *gfs2_indirect_init(struct metapath *mp,\n\t\t\t\t\t struct gfs2_glock *gl, unsigned int i,\n\t\t\t\t\t unsigned offset, u64 bn)\n{\n\t__be64 *ptr = (__be64 *)(mp->mp_bh[i - 1]->b_data +\n\t\t       ((i > 1) ? sizeof(struct gfs2_meta_header) :\n\t\t\t\t sizeof(struct gfs2_dinode)));\n\tBUG_ON(i < 1);\n\tBUG_ON(mp->mp_bh[i] != NULL);\n\tmp->mp_bh[i] = gfs2_meta_new(gl, bn);\n\tgfs2_trans_add_meta(gl, mp->mp_bh[i]);\n\tgfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\tgfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));\n\tptr += offset;\n\t*ptr = cpu_to_be64(bn);\n\treturn ptr;\n}"
  },
  {
    "function_name": "bmap_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "391-397",
    "snippet": "static inline void bmap_unlock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tup_write(&ip->i_rw_mutex);\n\telse\n\t\tup_read(&ip->i_rw_mutex);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void bmap_unlock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tup_write(&ip->i_rw_mutex);\n\telse\n\t\tup_read(&ip->i_rw_mutex);\n}"
  },
  {
    "function_name": "bmap_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "383-389",
    "snippet": "static inline void bmap_lock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tdown_write(&ip->i_rw_mutex);\n\telse\n\t\tdown_read(&ip->i_rw_mutex);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void bmap_lock(struct gfs2_inode *ip, int create)\n{\n\tif (create)\n\t\tdown_write(&ip->i_rw_mutex);\n\telse\n\t\tdown_read(&ip->i_rw_mutex);\n}"
  },
  {
    "function_name": "gfs2_extent_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "362-381",
    "snippet": "static inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int gfs2_extent_length(void *start, unsigned int len, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (start + len);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\tif (limit && --limit == 0)\n\t\t\tbreak;\n\t\tif (d)\n\t\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn (ptr - first);\n}"
  },
  {
    "function_name": "release_metapath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "336-345",
    "snippet": "static inline void release_metapath(struct metapath *mp)\n{\n\tint i;\n\n\tfor (i = 0; i < GFS2_MAX_META_HEIGHT; i++) {\n\t\tif (mp->mp_bh[i] == NULL)\n\t\t\tbreak;\n\t\tbrelse(mp->mp_bh[i]);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "mp->mp_bh[i]"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline void release_metapath(struct metapath *mp)\n{\n\tint i;\n\n\tfor (i = 0; i < GFS2_MAX_META_HEIGHT; i++) {\n\t\tif (mp->mp_bh[i] == NULL)\n\t\t\tbreak;\n\t\tbrelse(mp->mp_bh[i]);\n\t}\n}"
  },
  {
    "function_name": "lookup_metapath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "314-334",
    "snippet": "static int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)\n{\n\tunsigned int end_of_metadata = ip->i_height - 1;\n\tunsigned int x;\n\t__be64 *ptr;\n\tu64 dblock;\n\tint ret;\n\n\tfor (x = 0; x < end_of_metadata; x++) {\n\t\tptr = metapointer(x, mp);\n\t\tdblock = be64_to_cpu(*ptr);\n\t\tif (!dblock)\n\t\t\treturn x + 1;\n\n\t\tret = gfs2_meta_indirect_buffer(ip, x+1, dblock, &mp->mp_bh[x+1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ip->i_height;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_meta_indirect_buffer",
          "args": [
            "ip",
            "x+1",
            "dblock",
            "&mp->mp_bh[x+1]"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_indirect_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "336-352",
          "snippet": "int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\n\t\t\t      struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\n\n\tret = gfs2_meta_read(gl, num, DIO_WAIT, &bh);\n\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\n\t\tbrelse(bh);\n\t\tret = -EIO;\n\t}\n\t*bhp = bh;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\n\t\t\t      struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\n\n\tret = gfs2_meta_read(gl, num, DIO_WAIT, &bh);\n\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\n\t\tbrelse(bh);\n\t\tret = -EIO;\n\t}\n\t*bhp = bh;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapointer",
          "args": [
            "x",
            "mp"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "metapointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "265-271",
          "snippet": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)\n{\n\tunsigned int end_of_metadata = ip->i_height - 1;\n\tunsigned int x;\n\t__be64 *ptr;\n\tu64 dblock;\n\tint ret;\n\n\tfor (x = 0; x < end_of_metadata; x++) {\n\t\tptr = metapointer(x, mp);\n\t\tdblock = be64_to_cpu(*ptr);\n\t\tif (!dblock)\n\t\t\treturn x + 1;\n\n\t\tret = gfs2_meta_indirect_buffer(ip, x+1, dblock, &mp->mp_bh[x+1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ip->i_height;\n}"
  },
  {
    "function_name": "gfs2_metapath_ra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "273-295",
    "snippet": "static void gfs2_metapath_ra(struct gfs2_glock *gl,\n\t\t\t     const struct buffer_head *bh, const __be64 *pos)\n{\n\tstruct buffer_head *rabh;\n\tconst __be64 *endp = (const __be64 *)(bh->b_data + bh->b_size);\n\tconst __be64 *t;\n\n\tfor (t = pos; t < endp; t++) {\n\t\tif (!*t)\n\t\t\tcontinue;\n\n\t\trabh = gfs2_getbuf(gl, be64_to_cpu(*t), CREATE);\n\t\tif (trylock_buffer(rabh)) {\n\t\t\tif (!buffer_uptodate(rabh)) {\n\t\t\t\trabh->b_end_io = end_buffer_read_sync;\n\t\t\t\tsubmit_bh(READA | REQ_META, rabh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_buffer(rabh);\n\t\t}\n\t\tbrelse(rabh);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "rabh"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "rabh"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READA | REQ_META",
            "rabh"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "rabh"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "rabh"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_getbuf",
          "args": [
            "gl",
            "be64_to_cpu(*t)",
            "CREATE"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_getbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "114-160",
          "snippet": "struct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\n{\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift;\n\tunsigned long index;\n\tunsigned int bufnum;\n\n\tif (mapping == NULL)\n\t\tmapping = &sdp->sd_aspace;\n\n\tshift = PAGE_CACHE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tindex = blkno >> shift;             /* convert block to page */\n\tbufnum = blkno - (index << shift);  /* block buf index within page */\n\n\tif (create) {\n\t\tfor (;;) {\n\t\t\tpage = grab_cache_page(mapping, index);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tyield();\n\t\t}\n\t} else {\n\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\tFGP_LOCK|FGP_ACCESSED);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\n\n\t/* Locate header for our buffer within our page */\n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t/* Do nothing */;\n\tget_bh(bh);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, sdp->sd_vfs, blkno);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\n{\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift;\n\tunsigned long index;\n\tunsigned int bufnum;\n\n\tif (mapping == NULL)\n\t\tmapping = &sdp->sd_aspace;\n\n\tshift = PAGE_CACHE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tindex = blkno >> shift;             /* convert block to page */\n\tbufnum = blkno - (index << shift);  /* block buf index within page */\n\n\tif (create) {\n\t\tfor (;;) {\n\t\t\tpage = grab_cache_page(mapping, index);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tyield();\n\t\t}\n\t} else {\n\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\tFGP_LOCK|FGP_ACCESSED);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\n\n\t/* Locate header for our buffer within our page */\n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t/* Do nothing */;\n\tget_bh(bh);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, sdp->sd_vfs, blkno);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*t"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_metapath_ra(struct gfs2_glock *gl,\n\t\t\t     const struct buffer_head *bh, const __be64 *pos)\n{\n\tstruct buffer_head *rabh;\n\tconst __be64 *endp = (const __be64 *)(bh->b_data + bh->b_size);\n\tconst __be64 *t;\n\n\tfor (t = pos; t < endp; t++) {\n\t\tif (!*t)\n\t\t\tcontinue;\n\n\t\trabh = gfs2_getbuf(gl, be64_to_cpu(*t), CREATE);\n\t\tif (trylock_buffer(rabh)) {\n\t\t\tif (!buffer_uptodate(rabh)) {\n\t\t\t\trabh->b_end_io = end_buffer_read_sync;\n\t\t\t\tsubmit_bh(READA | REQ_META, rabh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_buffer(rabh);\n\t\t}\n\t\tbrelse(rabh);\n\t}\n}"
  },
  {
    "function_name": "metapointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "265-271",
    "snippet": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}"
  },
  {
    "function_name": "metapath_branch_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "248-253",
    "snippet": "static inline unsigned int metapath_branch_start(const struct metapath *mp)\n{\n\tif (mp->mp_list[0] == 0)\n\t\treturn 2;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int metapath_branch_start(const struct metapath *mp)\n{\n\tif (mp->mp_list[0] == 0)\n\t\treturn 2;\n\treturn 1;\n}"
  },
  {
    "function_name": "find_metapath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "238-246",
    "snippet": "static void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "block",
            "sdp->sd_inptrs"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n\n}"
  },
  {
    "function_name": "gfs2_unstuff_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "118-175",
    "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "gfs2_get_inode_blocks(&ip->i_inode)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_get_inode_blocks",
          "args": [
            "&ip->i_inode"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_get_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "56-60",
          "snippet": "static inline u64 gfs2_get_inode_blocks(const struct inode *inode)\n{\n\treturn inode->i_blocks >>\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_get_inode_blocks(const struct inode *inode)\n{\n\treturn inode->i_blocks >>\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "1"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "block"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unstuffer_page",
          "args": [
            "ip",
            "dibh",
            "block",
            "page"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "56-105",
          "snippet": "static int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t       u64 block, struct page *page)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct buffer_head *bh;\n\tint release = 0;\n\n\tif (!page || page->index) {\n\t\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trelease = 1;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tvoid *kaddr = kmap(page);\n\t\tu64 dsize = i_size_read(inode);\n \n\t\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\t\tdsize = dibh->b_size - sizeof(struct gfs2_dinode);\n\n\t\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\t\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\t\tkunmap(page);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits,\n\t\t\t\t     (1 << BH_Uptodate));\n\n\tbh = page_buffers(page);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, inode->i_sb, block);\n\n\tset_buffer_uptodate(bh);\n\tif (!gfs2_is_jdata(ip))\n\t\tmark_buffer_dirty(bh);\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tif (release) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t       u64 block, struct page *page)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct buffer_head *bh;\n\tint release = 0;\n\n\tif (!page || page->index) {\n\t\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trelease = 1;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tvoid *kaddr = kmap(page);\n\t\tu64 dsize = i_size_read(inode);\n \n\t\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\t\tdsize = dibh->b_size - sizeof(struct gfs2_dinode);\n\n\t\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\t\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\t\tkunmap(page);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits,\n\t\t\t\t     (1 << BH_Uptodate));\n\n\tbh = page_buffers(page);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, inode->i_sb, block);\n\n\tset_buffer_uptodate(bh);\n\tif (!gfs2_is_jdata(ip))\n\t\tmark_buffer_dirty(bh);\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tif (release) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_copy_tail",
          "args": [
            "bh",
            "sizeof(struct gfs2_meta_header)",
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_copy_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "28-38",
          "snippet": "static inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_new_buffer",
          "args": [
            "ip",
            "block",
            "&bh"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_new_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "92-103",
          "snippet": "int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "block",
            "1"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&block",
            "&n",
            "0",
            "NULL"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_dir",
          "args": [
            "ip"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "45-48",
          "snippet": "static inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_dir(const struct gfs2_inode *ip)\n{\n\treturn S_ISDIR(ip->i_inode.i_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_unstuffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
    "lines": "56-105",
    "snippet": "static int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t       u64 block, struct page *page)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct buffer_head *bh;\n\tint release = 0;\n\n\tif (!page || page->index) {\n\t\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trelease = 1;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tvoid *kaddr = kmap(page);\n\t\tu64 dsize = i_size_read(inode);\n \n\t\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\t\tdsize = dibh->b_size - sizeof(struct gfs2_dinode);\n\n\t\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\t\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\t\tkunmap(page);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits,\n\t\t\t\t     (1 << BH_Uptodate));\n\n\tbh = page_buffers(page);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, inode->i_sb, block);\n\n\tset_buffer_uptodate(bh);\n\tif (!gfs2_is_jdata(ip))\n\t\tmark_buffer_dirty(bh);\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tif (release) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"log.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_data",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "158-193",
          "snippet": "void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_writeback",
          "args": [
            "ip"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "33-37",
          "snippet": "static inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "block"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << inode->i_blkbits",
            "(1 << BH_Uptodate)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + dsize",
            "0",
            "PAGE_CACHE_SIZE - dsize"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "dibh->b_data + sizeof(struct gfs2_dinode)",
            "dsize"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "0",
            "GFP_NOFS"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t       u64 block, struct page *page)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct buffer_head *bh;\n\tint release = 0;\n\n\tif (!page || page->index) {\n\t\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trelease = 1;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tvoid *kaddr = kmap(page);\n\t\tu64 dsize = i_size_read(inode);\n \n\t\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\t\tdsize = dibh->b_size - sizeof(struct gfs2_dinode);\n\n\t\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\t\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\t\tkunmap(page);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits,\n\t\t\t\t     (1 << BH_Uptodate));\n\n\tbh = page_buffers(page);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, inode->i_sb, block);\n\n\tset_buffer_uptodate(bh);\n\tif (!gfs2_is_jdata(ip))\n\t\tmark_buffer_dirty(bh);\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tif (release) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn 0;\n}"
  }
]