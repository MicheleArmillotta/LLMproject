[
  {
    "function_name": "dlmunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "587-696",
    "snippet": "enum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"returning status=%d!\\n\"",
            "status"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"kicking the thread\\n\""
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data",
            "status"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->ast_wq",
            "dlm_lock_basts_flushed(dlm, lock)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_basts_flushed",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_basts_flushed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2715-2724",
          "snippet": "int dlm_lock_basts_flushed(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tint ret;\n\tspin_lock(&dlm->ast_lock);\n\tspin_lock(&lock->spinlock);\n\tret = (list_empty(&lock->bast_list) && !lock->bast_pending);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&dlm->ast_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_lock_basts_flushed(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tint ret;\n\tspin_lock(&dlm->ast_lock);\n\tspin_lock(&lock->spinlock);\n\tret = (list_empty(&lock->bast_list) && !lock->bast_pending);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&dlm->ast_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"calling unlockast(%p, %d)\\n\"",
            "data",
            "status"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "50"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmunlock_remote",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "&call_ast"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "293-300",
          "snippet": "static inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags, int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags, int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmunlock_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "&call_ast"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "283-291",
          "snippet": "static inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nenum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_get_unlock_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "560-581",
    "snippet": "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\t/* unlock request */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tstatus = DLM_DENIED;\n\t\tdlm_error(status);\n\t\t*actions = 0;\n\t} else {\n\t\t/* unlock granted lock */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_FREE_LOCK |\n\t\t\t    DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
      "#define DLM_UNLOCK_CALL_AST            0x00000002",
      "#define DLM_UNLOCK_FREE_LOCK           0x00000001"
    ],
    "globals_used": [
      "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
      "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_on_list",
          "args": [
            "&res->granted",
            "lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_on_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1082-1092",
          "snippet": "static inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\n\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\t/* unlock request */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tstatus = DLM_DENIED;\n\t\tdlm_error(status);\n\t\t*actions = 0;\n\t} else {\n\t\t/* unlock granted lock */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_FREE_LOCK |\n\t\t\t    DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_get_cancel_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "528-558",
    "snippet": "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\tif (dlm_lock_on_list(&res->blocked, lock)) {\n\t\t/* cancel this outright */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t} else if (dlm_lock_on_list(&res->converting, lock)) {\n\t\t/* cancel the request, put back on granted */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK |\n\t\t\t    DLM_UNLOCK_REGRANT_LOCK |\n\t\t\t    DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t} else if (dlm_lock_on_list(&res->granted, lock)) {\n\t\t/* too late, already granted. */\n\t\tstatus = DLM_CANCELGRANT;\n\t\t*actions = DLM_UNLOCK_CALL_AST;\n\t} else {\n\t\tmlog(ML_ERROR, \"lock to cancel is not on any list!\\n\");\n\t\tstatus = DLM_IVLOCKID;\n\t\t*actions = 0;\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010",
      "#define DLM_UNLOCK_REGRANT_LOCK        0x00000008",
      "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
      "#define DLM_UNLOCK_CALL_AST            0x00000002"
    ],
    "globals_used": [
      "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
      "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lock to cancel is not on any list!\\n\""
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_on_list",
          "args": [
            "&res->granted",
            "lock"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_on_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1082-1092",
          "snippet": "static inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\tif (dlm_lock_on_list(&res->blocked, lock)) {\n\t\t/* cancel this outright */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t} else if (dlm_lock_on_list(&res->converting, lock)) {\n\t\t/* cancel the request, put back on granted */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK |\n\t\t\t    DLM_UNLOCK_REGRANT_LOCK |\n\t\t\t    DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t} else if (dlm_lock_on_list(&res->granted, lock)) {\n\t\t/* too late, already granted. */\n\t\tstatus = DLM_CANCELGRANT;\n\t\t*actions = DLM_UNLOCK_CALL_AST;\n\t} else {\n\t\tmlog(ML_ERROR, \"lock to cancel is not on any list!\\n\");\n\t\tstatus = DLM_IVLOCKID;\n\t\t*actions = 0;\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_unlock_lock_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "391-525",
    "snippet": "int dlm_unlock_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_unlock_lock *unlock = (struct dlm_unlock_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tenum dlm_status status = DLM_NORMAL;\n\tint found = 0, i;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ignore;\n\tu32 flags;\n\tstruct list_head *queue;\n\n\tflags = be32_to_cpu(unlock->flags);\n\n\tif (flags & LKM_GET_LVB) {\n\t\tmlog(ML_ERROR, \"bad args!  GET_LVB specified on unlock!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_CANCEL)) == (LKM_PUT_LVB|LKM_CANCEL)) {\n\t\tmlog(ML_ERROR, \"bad args!  cannot modify lvb on a CANCEL \"\n\t\t     \"request!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (unlock->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length in unlock handler!\\n\");\n\t\treturn DLM_IVBUFLEN;\n\t}\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_REJECTED;\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" : \"none\");\n\n\tres = dlm_lookup_lockres(dlm, unlock->name, unlock->namelen);\n\tif (!res) {\n\t\t/* We assume here that a no lock resource simply means\n\t\t * it was migrated away and destroyed before the other\n\t\t * node could detect it. */\n\t\tmlog(0, \"returning DLM_FORWARD -- res no longer exists\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto not_found;\n\t}\n\n\tqueue=&res->granted;\n\tfound = 0;\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_RECOVERING\\n\");\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_MIGRATING\\n\");\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\tif (res->owner != dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_FORWARD -- not master\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto leave;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == unlock->cookie &&\n\t\t    \t    lock->ml.node == unlock->node_idx) {\n\t\t\t\tdlm_lock_get(lock);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t\t/* scan granted -> converting -> blocked queues */\n\t\tqueue++;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!found) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tgoto not_found;\n\t}\n\n\t/* lock was found on queue */\n\tlksb = lock->lksb;\n\tif (flags & (LKM_VALBLK|LKM_PUT_LVB) &&\n\t    lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~(LKM_VALBLK|LKM_PUT_LVB);\n\n\t/* unlockast only called on originating node */\n\tif (flags & LKM_PUT_LVB) {\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &unlock->lvb[0], DLM_LVB_LEN);\n\t}\n\n\t/* if this is in-progress, propagate the DLM_FORWARD\n\t * all the way back out */\n\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags, &ignore);\n\tif (status == DLM_FORWARD)\n\t\tmlog(0, \"lockres is in progress\\n\");\n\n\tif (flags & LKM_PUT_LVB)\n\t\tlksb->flags &= ~DLM_LKSB_PUT_LVB;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_kick_thread(dlm, res);\n\nnot_found:\n\tif (!found)\n\t\tmlog(ML_ERROR, \"failed to find lock to unlock! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(unlock->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(unlock->cookie)));\n\telse\n\t\tdlm_lock_put(lock);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to find lock to unlock! \"\n\t\t\t       \"cookie=%u:%llu\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(unlock->cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(unlock->cookie))"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(unlock->cookie)"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "unlock->cookie"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(unlock->cookie)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "unlock->cookie"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lockres is in progress\\n\""
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmunlock_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "&ignore"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "283-291",
          "snippet": "static inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lksb->lvb[0]",
            "&unlock->lvb[0]",
            "DLM_LVB_LEN"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "unlock->name",
            "unlock->namelen"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lvb: %s\\n\"",
            "flags & LKM_PUT_LVB ? \"put lvb\" : \"none\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!dlm_domain_fully_joined(dlm)",
            "\"Domain %s not fully joined!\\n\"",
            "dlm->name"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "unlock->flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nint dlm_unlock_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_unlock_lock *unlock = (struct dlm_unlock_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tenum dlm_status status = DLM_NORMAL;\n\tint found = 0, i;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ignore;\n\tu32 flags;\n\tstruct list_head *queue;\n\n\tflags = be32_to_cpu(unlock->flags);\n\n\tif (flags & LKM_GET_LVB) {\n\t\tmlog(ML_ERROR, \"bad args!  GET_LVB specified on unlock!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_CANCEL)) == (LKM_PUT_LVB|LKM_CANCEL)) {\n\t\tmlog(ML_ERROR, \"bad args!  cannot modify lvb on a CANCEL \"\n\t\t     \"request!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (unlock->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length in unlock handler!\\n\");\n\t\treturn DLM_IVBUFLEN;\n\t}\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_REJECTED;\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" : \"none\");\n\n\tres = dlm_lookup_lockres(dlm, unlock->name, unlock->namelen);\n\tif (!res) {\n\t\t/* We assume here that a no lock resource simply means\n\t\t * it was migrated away and destroyed before the other\n\t\t * node could detect it. */\n\t\tmlog(0, \"returning DLM_FORWARD -- res no longer exists\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto not_found;\n\t}\n\n\tqueue=&res->granted;\n\tfound = 0;\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_RECOVERING\\n\");\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_MIGRATING\\n\");\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\tif (res->owner != dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_FORWARD -- not master\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto leave;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == unlock->cookie &&\n\t\t    \t    lock->ml.node == unlock->node_idx) {\n\t\t\t\tdlm_lock_get(lock);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t\t/* scan granted -> converting -> blocked queues */\n\t\tqueue++;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!found) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tgoto not_found;\n\t}\n\n\t/* lock was found on queue */\n\tlksb = lock->lksb;\n\tif (flags & (LKM_VALBLK|LKM_PUT_LVB) &&\n\t    lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~(LKM_VALBLK|LKM_PUT_LVB);\n\n\t/* unlockast only called on originating node */\n\tif (flags & LKM_PUT_LVB) {\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &unlock->lvb[0], DLM_LVB_LEN);\n\t}\n\n\t/* if this is in-progress, propagate the DLM_FORWARD\n\t * all the way back out */\n\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags, &ignore);\n\tif (status == DLM_FORWARD)\n\t\tmlog(0, \"lockres is in progress\\n\");\n\n\tif (flags & LKM_PUT_LVB)\n\t\tlksb->flags &= ~DLM_LKSB_PUT_LVB;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_kick_thread(dlm, res);\n\nnot_found:\n\tif (!found)\n\t\tmlog(ML_ERROR, \"failed to find lock to unlock! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(unlock->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(unlock->cookie)));\n\telse\n\t\tdlm_lock_put(lock);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_remote_unlock_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "309-381",
    "snippet": "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner)\n{\n\tstruct dlm_unlock_lock unlock;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tif (owner == dlm->node_num) {\n\t\t/* ended up trying to contact ourself.  this means\n\t\t * that the lockres had been remote but became local\n\t\t * via a migration.  just retry it, now as local */\n\t\tmlog(0, \"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name);\n\t\treturn DLM_FORWARD;\n\t}\n\n\tmemset(&unlock, 0, sizeof(unlock));\n\tunlock.node_idx = dlm->node_num;\n\tunlock.flags = cpu_to_be32(flags);\n\tunlock.cookie = lock->ml.cookie;\n\tunlock.namelen = res->lockname.len;\n\tmemcpy(unlock.name, res->lockname.name, unlock.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_unlock_lock);\n\tvec[0].iov_base = &unlock;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tif (status == DLM_FORWARD)\n\t\t\tmlog(0, \"master was in-progress.  retry\\n\");\n\t\tret = status;\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* NOTE: this seems strange, but it is what we want.\n\t\t\t * when the master goes down during a cancel or\n\t\t\t * unlock, the recovery code completes the operation\n\t\t\t * as if the master had not died, then passes the\n\t\t\t * updated state to the recovery master.  this thread\n\t\t\t * just needs to finish out the operation and call\n\t\t\t * the unlockast. */\n\t\t\tif (dlm_is_node_dead(dlm, owner))\n\t\t\t\tret = DLM_NORMAL;\n\t\t\telse\n\t\t\t\tret = DLM_NOLOCKMGR;\n\t\t} else {\n\t\t\t/* something bad.  this will BUG in ocfs2 */\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_err_to_dlm_status",
          "args": [
            "tmpret"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_err_to_dlm_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1095-1109",
          "snippet": "static inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_node_dead",
          "args": [
            "dlm",
            "owner"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_node_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "341-348",
          "snippet": "int dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "tmpret"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\"",
            "tmpret",
            "DLM_UNLOCK_LOCK_MSG",
            "dlm->key",
            "owner"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"master was in-progress.  retry\\n\""
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_send_message_vec",
          "args": [
            "DLM_UNLOCK_LOCK_MSG",
            "dlm->key",
            "vec",
            "veclen",
            "owner",
            "&status"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1029-1144",
          "snippet": "int o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "unlock.name",
            "res->lockname.name",
            "unlock.namelen"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "flags"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&unlock",
            "0",
            "sizeof(unlock)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner)\n{\n\tstruct dlm_unlock_lock unlock;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tif (owner == dlm->node_num) {\n\t\t/* ended up trying to contact ourself.  this means\n\t\t * that the lockres had been remote but became local\n\t\t * via a migration.  just retry it, now as local */\n\t\tmlog(0, \"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name);\n\t\treturn DLM_FORWARD;\n\t}\n\n\tmemset(&unlock, 0, sizeof(unlock));\n\tunlock.node_idx = dlm->node_num;\n\tunlock.flags = cpu_to_be32(flags);\n\tunlock.cookie = lock->ml.cookie;\n\tunlock.namelen = res->lockname.len;\n\tmemcpy(unlock.name, res->lockname.name, unlock.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_unlock_lock);\n\tvec[0].iov_base = &unlock;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tif (status == DLM_FORWARD)\n\t\t\tmlog(0, \"master was in-progress.  retry\\n\");\n\t\tret = status;\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* NOTE: this seems strange, but it is what we want.\n\t\t\t * when the master goes down during a cancel or\n\t\t\t * unlock, the recovery code completes the operation\n\t\t\t * as if the master had not died, then passes the\n\t\t\t * updated state to the recovery master.  this thread\n\t\t\t * just needs to finish out the operation and call\n\t\t\t * the unlockast. */\n\t\t\tif (dlm_is_node_dead(dlm, owner))\n\t\t\t\tret = DLM_NORMAL;\n\t\t\telse\n\t\t\t\tret = DLM_NOLOCKMGR;\n\t\t} else {\n\t\t\t/* something bad.  this will BUG in ocfs2 */\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlmunlock_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "293-300",
    "snippet": "static inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags, int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlmunlock_common",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "call_ast",
            "0"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "98-265",
          "snippet": "static enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010",
            "#define DLM_UNLOCK_REGRANT_LOCK        0x00000008",
            "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
            "#define DLM_UNLOCK_CALL_AST            0x00000002",
            "#define DLM_UNLOCK_FREE_LOCK           0x00000001"
          ],
          "globals_used": [
            "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nstatic enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags, int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\n}"
  },
  {
    "function_name": "dlmunlock_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "283-291",
    "snippet": "static inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlmunlock_common",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "call_ast",
            "1"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "98-265",
          "snippet": "static enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010",
            "#define DLM_UNLOCK_REGRANT_LOCK        0x00000008",
            "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
            "#define DLM_UNLOCK_CALL_AST            0x00000002",
            "#define DLM_UNLOCK_FREE_LOCK           0x00000001"
          ],
          "globals_used": [
            "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nstatic enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}"
  },
  {
    "function_name": "dlm_commit_pending_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "275-280",
    "snippet": "void dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n}"
  },
  {
    "function_name": "dlm_commit_pending_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "267-273",
    "snippet": "void dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\t/* leave DLM_LKSB_PUT_LVB on the lksb so any final\n\t * update of the lvb will be sent to the new master */\n\tlist_del_init(&lock->list);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\t/* leave DLM_LKSB_PUT_LVB on the lksb so any final\n\t * update of the lvb will be sent to the new master */\n\tlist_del_init(&lock->list);\n}"
  },
  {
    "function_name": "dlmunlock_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
    "lines": "98-265",
    "snippet": "static enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010",
      "#define DLM_UNLOCK_REGRANT_LOCK        0x00000008",
      "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
      "#define DLM_UNLOCK_CALL_AST            0x00000002",
      "#define DLM_UNLOCK_FREE_LOCK           0x00000001"
    ],
    "globals_used": [
      "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
      "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
      "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock %u:%llu should be gone now! refs=%d\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "atomic_read(&lock->lock_refs.refcount)-1"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lock->lock_refs.refcount"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(actions & DLM_UNLOCK_REMOVE_LOCK)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.convert_type == LKM_IVMODE"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.convert_type != LKM_IVMODE"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_on_list",
          "args": [
            "&res->converting",
            "lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_on_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1082-1092",
          "snippet": "static inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"clearing convert_type at %smaster node\\n\"",
            "master_node ? \"\" : \"non-\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: clearing actions, %s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\"))"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_remote_unlock_request",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "flags",
            "owner"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_remote_unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "309-381",
          "snippet": "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner)\n{\n\tstruct dlm_unlock_lock unlock;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tif (owner == dlm->node_num) {\n\t\t/* ended up trying to contact ourself.  this means\n\t\t * that the lockres had been remote but became local\n\t\t * via a migration.  just retry it, now as local */\n\t\tmlog(0, \"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name);\n\t\treturn DLM_FORWARD;\n\t}\n\n\tmemset(&unlock, 0, sizeof(unlock));\n\tunlock.node_idx = dlm->node_num;\n\tunlock.flags = cpu_to_be32(flags);\n\tunlock.cookie = lock->ml.cookie;\n\tunlock.namelen = res->lockname.len;\n\tmemcpy(unlock.name, res->lockname.name, unlock.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_unlock_lock);\n\tvec[0].iov_base = &unlock;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tif (status == DLM_FORWARD)\n\t\t\tmlog(0, \"master was in-progress.  retry\\n\");\n\t\tret = status;\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* NOTE: this seems strange, but it is what we want.\n\t\t\t * when the master goes down during a cancel or\n\t\t\t * unlock, the recovery code completes the operation\n\t\t\t * as if the master had not died, then passes the\n\t\t\t * updated state to the recovery master.  this thread\n\t\t\t * just needs to finish out the operation and call\n\t\t\t * the unlockast. */\n\t\t\tif (dlm_is_node_dead(dlm, owner))\n\t\t\t\tret = DLM_NORMAL;\n\t\t\telse\n\t\t\t\tret = DLM_NOLOCKMGR;\n\t\t} else {\n\t\t\t/* something bad.  this will BUG in ocfs2 */\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner)\n{\n\tstruct dlm_unlock_lock unlock;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tif (owner == dlm->node_num) {\n\t\t/* ended up trying to contact ourself.  this means\n\t\t * that the lockres had been remote but became local\n\t\t * via a migration.  just retry it, now as local */\n\t\tmlog(0, \"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name);\n\t\treturn DLM_FORWARD;\n\t}\n\n\tmemset(&unlock, 0, sizeof(unlock));\n\tunlock.node_idx = dlm->node_num;\n\tunlock.flags = cpu_to_be32(flags);\n\tunlock.cookie = lock->ml.cookie;\n\tunlock.namelen = res->lockname.len;\n\tmemcpy(unlock.name, res->lockname.name, unlock.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_unlock_lock);\n\tvec[0].iov_base = &unlock;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tif (status == DLM_FORWARD)\n\t\t\tmlog(0, \"master was in-progress.  retry\\n\");\n\t\tret = status;\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* NOTE: this seems strange, but it is what we want.\n\t\t\t * when the master goes down during a cancel or\n\t\t\t * unlock, the recovery code completes the operation\n\t\t\t * as if the master had not died, then passes the\n\t\t\t * updated state to the recovery master.  this thread\n\t\t\t * just needs to finish out the operation and call\n\t\t\t * the unlockast. */\n\t\t\tif (dlm_is_node_dead(dlm, owner))\n\t\t\t\tret = DLM_NORMAL;\n\t\t\telse\n\t\t\t\tret = DLM_NOLOCKMGR;\n\t\t} else {\n\t\t\t/* something bad.  this will BUG in ocfs2 */\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res->lvb",
            "lksb->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_unlock_actions",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "&actions"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_unlock_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "560-581",
          "snippet": "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\t/* unlock request */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tstatus = DLM_DENIED;\n\t\tdlm_error(status);\n\t\t*actions = 0;\n\t} else {\n\t\t/* unlock granted lock */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_FREE_LOCK |\n\t\t\t    DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
            "#define DLM_UNLOCK_CALL_AST            0x00000002",
            "#define DLM_UNLOCK_FREE_LOCK           0x00000001"
          ],
          "globals_used": [
            "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\n\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\t/* unlock request */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tstatus = DLM_DENIED;\n\t\tdlm_error(status);\n\t\t*actions = 0;\n\t} else {\n\t\t/* unlock granted lock */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_FREE_LOCK |\n\t\t\t    DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_cancel_actions",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksb",
            "&actions"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_cancel_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "528-558",
          "snippet": "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\tif (dlm_lock_on_list(&res->blocked, lock)) {\n\t\t/* cancel this outright */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t} else if (dlm_lock_on_list(&res->converting, lock)) {\n\t\t/* cancel the request, put back on granted */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK |\n\t\t\t    DLM_UNLOCK_REGRANT_LOCK |\n\t\t\t    DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t} else if (dlm_lock_on_list(&res->granted, lock)) {\n\t\t/* too late, already granted. */\n\t\tstatus = DLM_CANCELGRANT;\n\t\t*actions = DLM_UNLOCK_CALL_AST;\n\t} else {\n\t\tmlog(ML_ERROR, \"lock to cancel is not on any list!\\n\");\n\t\tstatus = DLM_IVLOCKID;\n\t\t*actions = 0;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010",
            "#define DLM_UNLOCK_REGRANT_LOCK        0x00000008",
            "#define DLM_UNLOCK_REMOVE_LOCK         0x00000004",
            "#define DLM_UNLOCK_CALL_AST            0x00000002"
          ],
          "globals_used": [
            "static enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);",
            "static enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\tif (dlm_lock_on_list(&res->blocked, lock)) {\n\t\t/* cancel this outright */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t} else if (dlm_lock_on_list(&res->converting, lock)) {\n\t\t/* cancel the request, put back on granted */\n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK |\n\t\t\t    DLM_UNLOCK_REGRANT_LOCK |\n\t\t\t    DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t} else if (dlm_lock_on_list(&res->granted, lock)) {\n\t\t/* too late, already granted. */\n\t\tstatus = DLM_CANCELGRANT;\n\t\t*actions = DLM_UNLOCK_CALL_AST;\n\t} else {\n\t\tmlog(ML_ERROR, \"lock to cancel is not on any list!\\n\");\n\t\tstatus = DLM_IVLOCKID;\n\t\t*actions = 0;\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "res"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres in progress!\\n\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->ast_list"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner == dlm->node_num"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner != dlm->node_num"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nstatic enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n        u8 owner;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t/* We want to be sure that we're not freeing a lock\n\t * that still has AST's pending... */\n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t/* ok for this to sleep if not in a network handler */\n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t/* see above for what the spec says about\n\t * LKM_CANCEL and the lock queue state */\n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t/* By now this has been masked out of cancel requests. */\n\tif (flags & LKM_VALBLK) {\n\t\t/* make the final update to the lvb */\n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB; /* let the send function\n\t\t\t\t\t       * handle it. */\n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t/* drop locks and send message */\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t/* if the master told us the lock was already granted,\n\t\t * let the ast handle all of these actions */\n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t/* must clear the actions because this unlock\n\t\t\t * is about to be retried.  cannot free or do\n\t\t\t * any list manipulation. */\n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse\n\t\t\tlock->unlock_pending = 0;\n\n\t}\n\n\t/* get an extra ref on lock.  if we are just switching\n\t * lists here, we dont want the lock to go away. */\n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t/* remove the extra ref on lock */\n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* let the caller's final dlm_lock_put handle the actual kfree */\n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t/* this should always be coupled with list removal */\n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     atomic_read(&lock->lock_refs.refcount)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t/* if cancel or unlock succeeded, lvb work is done */\n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}"
  }
]