[
  {
    "function_name": "jfs_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/ioctl.c",
    "lines": "170-188",
    "snippet": "long jfs_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\t/* While these ioctl numbers defined with 'long' and have different\n\t * numbers than the 64bit ABI,\n\t * the actual implementation only deals with ints and is compatible.\n\t */\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS32:\n\t\tcmd = JFS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase JFS_IOC_SETFLAGS32:\n\t\tcmd = JFS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase FITRIM:\n\t\tcmd = FITRIM;\n\t\tbreak;\n\t}\n\treturn jfs_ioctl(filp, cmd, arg);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_incore.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_filsys.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/current.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/capability.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/ioctl.c",
          "lines": "59-167",
          "snippet": "long jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(inode);\n\tunsigned int flags;\n\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS:\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\tflags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;\n\t\tflags = jfs_map_ext2(flags, 0);\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase JFS_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\t\tint err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = jfs_map_ext2(flags, 1);\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~JFS_DIRSYNC_FL;\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\t/* Lock against other parallel changes of flags */\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\toldflags = jfs_inode->mode2;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((oldflags & JFS_IMMUTABLE_FL) ||\n\t\t\t((flags ^ oldflags) &\n\t\t\t(JFS_APPEND_FL | JFS_IMMUTABLE_FL))) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & JFS_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~JFS_FL_USER_MODIFIABLE;\n\t\tjfs_inode->mode2 = flags;\n\n\t\tjfs_set_inode_flags(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\ts64 ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\tjfs_warn(\"FITRIM not supported on device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\tq->limits.discard_granularity);\n\n\t\tret = jfs_ioc_trim(inode, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_incore.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_filsys.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/capability.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nlong jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(inode);\n\tunsigned int flags;\n\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS:\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\tflags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;\n\t\tflags = jfs_map_ext2(flags, 0);\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase JFS_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\t\tint err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = jfs_map_ext2(flags, 1);\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~JFS_DIRSYNC_FL;\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\t/* Lock against other parallel changes of flags */\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\toldflags = jfs_inode->mode2;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((oldflags & JFS_IMMUTABLE_FL) ||\n\t\t\t((flags ^ oldflags) &\n\t\t\t(JFS_APPEND_FL | JFS_IMMUTABLE_FL))) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & JFS_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~JFS_FL_USER_MODIFIABLE;\n\t\tjfs_inode->mode2 = flags;\n\n\t\tjfs_set_inode_flags(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\ts64 ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\tjfs_warn(\"FITRIM not supported on device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\tq->limits.discard_granularity);\n\n\t\tret = jfs_ioc_trim(inode, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nlong jfs_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\t/* While these ioctl numbers defined with 'long' and have different\n\t * numbers than the 64bit ABI,\n\t * the actual implementation only deals with ints and is compatible.\n\t */\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS32:\n\t\tcmd = JFS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase JFS_IOC_SETFLAGS32:\n\t\tcmd = JFS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase FITRIM:\n\t\tcmd = FITRIM;\n\t\tbreak;\n\t}\n\treturn jfs_ioctl(filp, cmd, arg);\n}"
  },
  {
    "function_name": "jfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/ioctl.c",
    "lines": "59-167",
    "snippet": "long jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(inode);\n\tunsigned int flags;\n\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS:\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\tflags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;\n\t\tflags = jfs_map_ext2(flags, 0);\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase JFS_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\t\tint err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = jfs_map_ext2(flags, 1);\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~JFS_DIRSYNC_FL;\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\t/* Lock against other parallel changes of flags */\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\toldflags = jfs_inode->mode2;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((oldflags & JFS_IMMUTABLE_FL) ||\n\t\t\t((flags ^ oldflags) &\n\t\t\t(JFS_APPEND_FL | JFS_IMMUTABLE_FL))) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & JFS_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~JFS_FL_USER_MODIFIABLE;\n\t\tjfs_inode->mode2 = flags;\n\n\t\tjfs_set_inode_flags(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\ts64 ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\tjfs_warn(\"FITRIM not supported on device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\tq->limits.discard_granularity);\n\n\t\tret = jfs_ioc_trim(inode, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_incore.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_filsys.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/current.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/capability.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(struct fstrim_range __user *)arg",
            "&range",
            "sizeof(range)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_ioc_trim",
          "args": [
            "inode",
            "&range"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_ioc_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_discard.c",
          "lines": "80-121",
          "snippet": "int jfs_ioc_trim(struct inode *ip, struct fstrim_range *range)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tint agno, agno_end;\n\tu64 start, end, minlen;\n\tu64 trimmed = 0;\n\n\t/**\n\t * convert byte values to block size of filesystem:\n\t * start:\tFirst Byte to trim\n\t * len:\t\tnumber of Bytes to trim from start\n\t * minlen:\tminimum extent length in Bytes\n\t */\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\tif (minlen == 0)\n\t\tminlen = 1;\n\n\tif (minlen > bmp->db_agsize ||\n\t    start >= bmp->db_mapsize ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tif (end >= bmp->db_mapsize)\n\t\tend = bmp->db_mapsize - 1;\n\n\t/**\n\t * we trim all ag's within the range\n\t */\n\tagno = BLKTOAG(start, JFS_SBI(ip->i_sb));\n\tagno_end = BLKTOAG(end, JFS_SBI(ip->i_sb));\n\twhile (agno <= agno_end) {\n\t\ttrimmed += dbDiscardAG(ip, agno, minlen);\n\t\tagno++;\n\t}\n\trange->len = trimmed << sb->s_blocksize_bits;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_discard.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint jfs_ioc_trim(struct inode *ip, struct fstrim_range *range)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tint agno, agno_end;\n\tu64 start, end, minlen;\n\tu64 trimmed = 0;\n\n\t/**\n\t * convert byte values to block size of filesystem:\n\t * start:\tFirst Byte to trim\n\t * len:\t\tnumber of Bytes to trim from start\n\t * minlen:\tminimum extent length in Bytes\n\t */\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\tif (minlen == 0)\n\t\tminlen = 1;\n\n\tif (minlen > bmp->db_agsize ||\n\t    start >= bmp->db_mapsize ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tif (end >= bmp->db_mapsize)\n\t\tend = bmp->db_mapsize - 1;\n\n\t/**\n\t * we trim all ag's within the range\n\t */\n\tagno = BLKTOAG(start, JFS_SBI(ip->i_sb));\n\tagno_end = BLKTOAG(end, JFS_SBI(ip->i_sb));\n\twhile (agno <= agno_end) {\n\t\ttrimmed += dbDiscardAG(ip, agno, minlen);\n\t\tagno++;\n\t}\n\trange->len = trimmed << sb->s_blocksize_bits;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "range.minlen",
            "q->limits.discard_granularity"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "(struct fstrim_range __user *)arg",
            "sizeof(range)"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"FITRIM not supported on device\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "29-46",
          "snippet": "void jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_get_inode_flags",
          "args": [
            "jfs_inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "48-64",
          "snippet": "void jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_map_ext2",
          "args": [
            "flags",
            "1"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_map_ext2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/ioctl.c",
          "lines": "40-56",
          "snippet": "static long jfs_map_ext2(unsigned long flags, int from)\n{\n\tint index=0;\n\tlong mapped=0;\n\n\twhile (jfs_map[index].jfs_flag) {\n\t\tif (from) {\n\t\t\tif (jfs_map[index].ext2_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].jfs_flag;\n\t\t} else {\n\t\t\tif (jfs_map[index].jfs_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].ext2_flag;\n\t\t}\n\t\tindex++;\n\t}\n\treturn mapped;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_incore.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_filsys.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/capability.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tlong jfs_flag;\n\tlong ext2_flag;\n} jfs_map[] = {\n\t{JFS_NOATIME_FL,\tFS_NOATIME_FL},\n\t{JFS_DIRSYNC_FL,\tFS_DIRSYNC_FL},\n\t{JFS_SYNC_FL,\t\tFS_SYNC_FL},\n\t{JFS_SECRM_FL,\t\tFS_SECRM_FL},\n\t{JFS_UNRM_FL,\t\tFS_UNRM_FL},\n\t{JFS_APPEND_FL,\t\tFS_APPEND_FL},\n\t{JFS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL},\n\t{0, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tlong jfs_flag;\n\tlong ext2_flag;\n} jfs_map[] = {\n\t{JFS_NOATIME_FL,\tFS_NOATIME_FL},\n\t{JFS_DIRSYNC_FL,\tFS_DIRSYNC_FL},\n\t{JFS_SYNC_FL,\t\tFS_SYNC_FL},\n\t{JFS_SECRM_FL,\t\tFS_SECRM_FL},\n\t{JFS_UNRM_FL,\t\tFS_UNRM_FL},\n\t{JFS_APPEND_FL,\t\tFS_APPEND_FL},\n\t{JFS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL},\n\t{0, 0},\n};\n\nstatic long jfs_map_ext2(unsigned long flags, int from)\n{\n\tint index=0;\n\tlong mapped=0;\n\n\twhile (jfs_map[index].jfs_flag) {\n\t\tif (from) {\n\t\t\tif (jfs_map[index].ext2_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].jfs_flag;\n\t\t} else {\n\t\t\tif (jfs_map[index].jfs_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].ext2_flag;\n\t\t}\n\t\tindex++;\n\t}\n\treturn mapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nlong jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(inode);\n\tunsigned int flags;\n\n\tswitch (cmd) {\n\tcase JFS_IOC_GETFLAGS:\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\tflags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;\n\t\tflags = jfs_map_ext2(flags, 0);\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase JFS_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\t\tint err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = jfs_map_ext2(flags, 1);\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~JFS_DIRSYNC_FL;\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\t/* Lock against other parallel changes of flags */\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\tjfs_get_inode_flags(jfs_inode);\n\t\toldflags = jfs_inode->mode2;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((oldflags & JFS_IMMUTABLE_FL) ||\n\t\t\t((flags ^ oldflags) &\n\t\t\t(JFS_APPEND_FL | JFS_IMMUTABLE_FL))) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & JFS_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~JFS_FL_USER_MODIFIABLE;\n\t\tjfs_inode->mode2 = flags;\n\n\t\tjfs_set_inode_flags(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\ts64 ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\tjfs_warn(\"FITRIM not supported on device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\tq->limits.discard_granularity);\n\n\t\tret = jfs_ioc_trim(inode, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "jfs_map_ext2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/ioctl.c",
    "lines": "40-56",
    "snippet": "static long jfs_map_ext2(unsigned long flags, int from)\n{\n\tint index=0;\n\tlong mapped=0;\n\n\twhile (jfs_map[index].jfs_flag) {\n\t\tif (from) {\n\t\t\tif (jfs_map[index].ext2_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].jfs_flag;\n\t\t} else {\n\t\t\tif (jfs_map[index].jfs_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].ext2_flag;\n\t\t}\n\t\tindex++;\n\t}\n\treturn mapped;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_incore.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_filsys.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/current.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/capability.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tlong jfs_flag;\n\tlong ext2_flag;\n} jfs_map[] = {\n\t{JFS_NOATIME_FL,\tFS_NOATIME_FL},\n\t{JFS_DIRSYNC_FL,\tFS_DIRSYNC_FL},\n\t{JFS_SYNC_FL,\t\tFS_SYNC_FL},\n\t{JFS_SECRM_FL,\t\tFS_SECRM_FL},\n\t{JFS_UNRM_FL,\t\tFS_UNRM_FL},\n\t{JFS_APPEND_FL,\t\tFS_APPEND_FL},\n\t{JFS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL},\n\t{0, 0},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tlong jfs_flag;\n\tlong ext2_flag;\n} jfs_map[] = {\n\t{JFS_NOATIME_FL,\tFS_NOATIME_FL},\n\t{JFS_DIRSYNC_FL,\tFS_DIRSYNC_FL},\n\t{JFS_SYNC_FL,\t\tFS_SYNC_FL},\n\t{JFS_SECRM_FL,\t\tFS_SECRM_FL},\n\t{JFS_UNRM_FL,\t\tFS_UNRM_FL},\n\t{JFS_APPEND_FL,\t\tFS_APPEND_FL},\n\t{JFS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL},\n\t{0, 0},\n};\n\nstatic long jfs_map_ext2(unsigned long flags, int from)\n{\n\tint index=0;\n\tlong mapped=0;\n\n\twhile (jfs_map[index].jfs_flag) {\n\t\tif (from) {\n\t\t\tif (jfs_map[index].ext2_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].jfs_flag;\n\t\t} else {\n\t\t\tif (jfs_map[index].jfs_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].ext2_flag;\n\t\t}\n\t\tindex++;\n\t}\n\treturn mapped;\n}"
  }
]