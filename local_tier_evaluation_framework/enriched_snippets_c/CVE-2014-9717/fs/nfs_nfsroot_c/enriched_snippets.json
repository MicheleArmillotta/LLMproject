[
  {
    "function_name": "fs_root_data(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "295-309",
    "snippet": "nt __init nfs_root_data(char **root_device, char **root_data)\n{\n\tservaddr = root_server_addr;\n\tif (servaddr == htonl(INADDR_NONE)) {\n\t\tprintk(KERN_ERR \"Root-NFS: no NFS server address\\n\");\n\t\treturn -1;\n\t}\n\n\tif (root_nfs_data(nfs_root_parms) < 0)\n\t\treturn -1;\n\n\t*root_device = nfs_root_device;\n\t*root_data = nfs_root_options;\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char nfs_root_parms[256]",
      "tatic char nfs_root_options[256]",
      "tatic char nfs_root_device[NFS_MAXPATHLEN + 1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "oot_nfs_data(",
          "args": [
            "fs_root_parms)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "oot_nfs_data(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
          "lines": "217-285",
          "snippet": "tatic int __init root_nfs_data(char *cmdline)\n{\n\tchar mand_options[sizeof(\"nolock,addr=\") + INET_ADDRSTRLEN + 1];\n\tint len, retval = -1;\n\tchar *tmp = NULL;\n\tconst size_t tmplen = sizeof(nfs_export_path);\n\n\ttmp = kzalloc(tmplen, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\tgoto out_nomem;\n\tstrcpy(tmp, NFS_ROOT);\n\n\tif (root_server_path[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: DHCPv4 option 17: %s\\n\",\n\t\t\troot_server_path);\n\t\tif (root_nfs_parse_options(root_server_path, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\tif (cmdline[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: nfsroot=%s\\n\", cmdline);\n\t\tif (root_nfs_parse_options(cmdline, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\t/*\n\t * Append mandatory options for nfsroot so they override\n\t * what has come before\n\t */\n\tsnprintf(mand_options, sizeof(mand_options), \"nolock,addr=%pI4\",\n\t\t\t&servaddr);\n\tif (root_nfs_cat(nfs_root_options, mand_options,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\tgoto out_optionstoolong;\n\n\t/*\n\t * Set up nfs_root_device.  For NFS mounts, this looks like\n\t *\n\t *\tserver:/path\n\t *\n\t * At this point, utsname()->nodename contains our local\n\t * IP address or hostname, set by ipconfig.  If \"%s\" exists\n\t * in tmp, substitute the nodename, then shovel the whole\n\t * mess into nfs_root_device.\n\t */\n\tlen = snprintf(nfs_export_path, sizeof(nfs_export_path),\n\t\t\t\ttmp, utsname()->nodename);\n\tif (len >= (int)sizeof(nfs_export_path))\n\t\tgoto out_devnametoolong;\n\tlen = snprintf(nfs_root_device, sizeof(nfs_root_device),\n\t\t\t\t\"%pI4:%s\", &servaddr, nfs_export_path);\n\tif (len >= (int)sizeof(nfs_root_device))\n\t\tgoto out_devnametoolong;\n\n\tretval = 0;\n\nout:\n\tkfree(tmp);\n\treturn retval;\nout_nomem:\n\tprintk(KERN_ERR \"Root-NFS: could not allocate memory\\n\");\n\tgoto out;\nout_optionstoolong:\n\tprintk(KERN_ERR \"Root-NFS: mount options string too long\\n\");\n\tgoto out;\nout_devnametoolong:\n\tprintk(KERN_ERR \"Root-NFS: root device name too long.\\n\");\n\tgoto out;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <net/ipconfig.h>",
            "include <linux/root_dev.h>\n#",
            "include <linux/utsname.h>\n#",
            "include <linux/nfs_fs.h>\n#",
            "include <linux/nfs.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/string.h>\n#",
            "include <linux/types.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char nfs_root_options[256]",
            "tatic char nfs_export_path[NFS_MAXPATHLEN + 1]",
            "tatic char nfs_root_device[NFS_MAXPATHLEN + 1]"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_options[256];\ntatic char nfs_export_path[NFS_MAXPATHLEN + 1];\ntatic char nfs_root_device[NFS_MAXPATHLEN + 1];\n\ntatic int __init root_nfs_data(char *cmdline)\n{\n\tchar mand_options[sizeof(\"nolock,addr=\") + INET_ADDRSTRLEN + 1];\n\tint len, retval = -1;\n\tchar *tmp = NULL;\n\tconst size_t tmplen = sizeof(nfs_export_path);\n\n\ttmp = kzalloc(tmplen, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\tgoto out_nomem;\n\tstrcpy(tmp, NFS_ROOT);\n\n\tif (root_server_path[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: DHCPv4 option 17: %s\\n\",\n\t\t\troot_server_path);\n\t\tif (root_nfs_parse_options(root_server_path, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\tif (cmdline[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: nfsroot=%s\\n\", cmdline);\n\t\tif (root_nfs_parse_options(cmdline, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\t/*\n\t * Append mandatory options for nfsroot so they override\n\t * what has come before\n\t */\n\tsnprintf(mand_options, sizeof(mand_options), \"nolock,addr=%pI4\",\n\t\t\t&servaddr);\n\tif (root_nfs_cat(nfs_root_options, mand_options,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\tgoto out_optionstoolong;\n\n\t/*\n\t * Set up nfs_root_device.  For NFS mounts, this looks like\n\t *\n\t *\tserver:/path\n\t *\n\t * At this point, utsname()->nodename contains our local\n\t * IP address or hostname, set by ipconfig.  If \"%s\" exists\n\t * in tmp, substitute the nodename, then shovel the whole\n\t * mess into nfs_root_device.\n\t */\n\tlen = snprintf(nfs_export_path, sizeof(nfs_export_path),\n\t\t\t\ttmp, utsname()->nodename);\n\tif (len >= (int)sizeof(nfs_export_path))\n\t\tgoto out_devnametoolong;\n\tlen = snprintf(nfs_root_device, sizeof(nfs_root_device),\n\t\t\t\t\"%pI4:%s\", &servaddr, nfs_export_path);\n\tif (len >= (int)sizeof(nfs_root_device))\n\t\tgoto out_devnametoolong;\n\n\tretval = 0;\n\nout:\n\tkfree(tmp);\n\treturn retval;\nout_nomem:\n\tprintk(KERN_ERR \"Root-NFS: could not allocate memory\\n\");\n\tgoto out;\nout_optionstoolong:\n\tprintk(KERN_ERR \"Root-NFS: mount options string too long\\n\");\n\tgoto out;\nout_devnametoolong:\n\tprintk(KERN_ERR \"Root-NFS: root device name too long.\\n\");\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"Root-NFS: no NFS server address\\n\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tonl(",
          "args": [
            "NADDR_NONE)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_parms[256];\ntatic char nfs_root_options[256];\ntatic char nfs_root_device[NFS_MAXPATHLEN + 1];\n\nnt __init nfs_root_data(char **root_device, char **root_data)\n{\n\tservaddr = root_server_addr;\n\tif (servaddr == htonl(INADDR_NONE)) {\n\t\tprintk(KERN_ERR \"Root-NFS: no NFS server address\\n\");\n\t\treturn -1;\n\t}\n\n\tif (root_nfs_data(nfs_root_parms) < 0)\n\t\treturn -1;\n\n\t*root_device = nfs_root_device;\n\t*root_data = nfs_root_options;\n\treturn 0;\n}"
  },
  {
    "function_name": "oot_nfs_data(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "217-285",
    "snippet": "tatic int __init root_nfs_data(char *cmdline)\n{\n\tchar mand_options[sizeof(\"nolock,addr=\") + INET_ADDRSTRLEN + 1];\n\tint len, retval = -1;\n\tchar *tmp = NULL;\n\tconst size_t tmplen = sizeof(nfs_export_path);\n\n\ttmp = kzalloc(tmplen, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\tgoto out_nomem;\n\tstrcpy(tmp, NFS_ROOT);\n\n\tif (root_server_path[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: DHCPv4 option 17: %s\\n\",\n\t\t\troot_server_path);\n\t\tif (root_nfs_parse_options(root_server_path, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\tif (cmdline[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: nfsroot=%s\\n\", cmdline);\n\t\tif (root_nfs_parse_options(cmdline, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\t/*\n\t * Append mandatory options for nfsroot so they override\n\t * what has come before\n\t */\n\tsnprintf(mand_options, sizeof(mand_options), \"nolock,addr=%pI4\",\n\t\t\t&servaddr);\n\tif (root_nfs_cat(nfs_root_options, mand_options,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\tgoto out_optionstoolong;\n\n\t/*\n\t * Set up nfs_root_device.  For NFS mounts, this looks like\n\t *\n\t *\tserver:/path\n\t *\n\t * At this point, utsname()->nodename contains our local\n\t * IP address or hostname, set by ipconfig.  If \"%s\" exists\n\t * in tmp, substitute the nodename, then shovel the whole\n\t * mess into nfs_root_device.\n\t */\n\tlen = snprintf(nfs_export_path, sizeof(nfs_export_path),\n\t\t\t\ttmp, utsname()->nodename);\n\tif (len >= (int)sizeof(nfs_export_path))\n\t\tgoto out_devnametoolong;\n\tlen = snprintf(nfs_root_device, sizeof(nfs_root_device),\n\t\t\t\t\"%pI4:%s\", &servaddr, nfs_export_path);\n\tif (len >= (int)sizeof(nfs_root_device))\n\t\tgoto out_devnametoolong;\n\n\tretval = 0;\n\nout:\n\tkfree(tmp);\n\treturn retval;\nout_nomem:\n\tprintk(KERN_ERR \"Root-NFS: could not allocate memory\\n\");\n\tgoto out;\nout_optionstoolong:\n\tprintk(KERN_ERR \"Root-NFS: mount options string too long\\n\");\n\tgoto out;\nout_devnametoolong:\n\tprintk(KERN_ERR \"Root-NFS: root device name too long.\\n\");\n\tgoto out;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char nfs_root_options[256]",
      "tatic char nfs_export_path[NFS_MAXPATHLEN + 1]",
      "tatic char nfs_root_device[NFS_MAXPATHLEN + 1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"Root-NFS: root device name too long.\\n\")"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"Root-NFS: mount options string too long\\n\")"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"Root-NFS: could not allocate memory\\n\")"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "mp)"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nprintf(",
          "args": [
            "fs_root_device,",
            "izeof(nfs_root_device),",
            "%pI4:%s\",",
            "servaddr,",
            "fs_export_path)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nprintf(",
          "args": [
            "fs_export_path,",
            "izeof(nfs_export_path),",
            "mp,",
            "tsname()->nodename)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsname(",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot_nfs_cat(",
          "args": [
            "fs_root_options,",
            "and_options,",
            "izeof(nfs_root_options))"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "oot_nfs_cat(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
          "lines": "165-177",
          "snippet": "tatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <net/ipconfig.h>",
            "include <linux/root_dev.h>\n#",
            "include <linux/utsname.h>\n#",
            "include <linux/nfs_fs.h>\n#",
            "include <linux/nfs.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/string.h>\n#",
            "include <linux/types.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nprintf(",
          "args": [
            "and_options,",
            "izeof(mand_options),",
            "nolock,addr=%pI4\",",
            "servaddr)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot_nfs_parse_options(",
          "args": [
            "mdline,",
            "mp,",
            "mplen)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "oot_nfs_parse_options(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
          "lines": "185-207",
          "snippet": "tatic int __init root_nfs_parse_options(char *incoming, char *exppath,\n\t\t\t\t\t const size_t exppathlen)\n{\n\tchar *p;\n\n\t/*\n\t * Set the NFS remote path\n\t */\n\tp = strsep(&incoming, \",\");\n\tif (*p != '\\0' && strcmp(p, \"default\") != 0)\n\t\tif (root_nfs_copy(exppath, p, exppathlen))\n\t\t\treturn -1;\n\n\t/*\n\t * @incoming now points to the rest of the string; if it\n\t * contains something, append it to our root options buffer\n\t */\n\tif (incoming != NULL && *incoming != '\\0')\n\t\tif (root_nfs_cat(nfs_root_options, incoming,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <net/ipconfig.h>",
            "include <linux/root_dev.h>\n#",
            "include <linux/utsname.h>\n#",
            "include <linux/nfs_fs.h>\n#",
            "include <linux/nfs.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/string.h>\n#",
            "include <linux/types.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char nfs_root_options[256]"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_options[256];\n\ntatic int __init root_nfs_parse_options(char *incoming, char *exppath,\n\t\t\t\t\t const size_t exppathlen)\n{\n\tchar *p;\n\n\t/*\n\t * Set the NFS remote path\n\t */\n\tp = strsep(&incoming, \",\");\n\tif (*p != '\\0' && strcmp(p, \"default\") != 0)\n\t\tif (root_nfs_copy(exppath, p, exppathlen))\n\t\t\treturn -1;\n\n\t/*\n\t * @incoming now points to the rest of the string; if it\n\t * contains something, append it to our root options buffer\n\t */\n\tif (incoming != NULL && *incoming != '\\0')\n\t\tif (root_nfs_cat(nfs_root_options, incoming,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk(",
          "args": [
            "Root-NFS: nfsroot=%s\\n\",",
            "mdline)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk(",
          "args": [
            "Root-NFS: DHCPv4 option 17: %s\\n\",",
            "oot_server_path)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcpy(",
          "args": [
            "mp,",
            "FS_ROOT)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc(",
          "args": [
            "mplen,",
            "FP_KERNEL)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_options[256];\ntatic char nfs_export_path[NFS_MAXPATHLEN + 1];\ntatic char nfs_root_device[NFS_MAXPATHLEN + 1];\n\ntatic int __init root_nfs_data(char *cmdline)\n{\n\tchar mand_options[sizeof(\"nolock,addr=\") + INET_ADDRSTRLEN + 1];\n\tint len, retval = -1;\n\tchar *tmp = NULL;\n\tconst size_t tmplen = sizeof(nfs_export_path);\n\n\ttmp = kzalloc(tmplen, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\tgoto out_nomem;\n\tstrcpy(tmp, NFS_ROOT);\n\n\tif (root_server_path[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: DHCPv4 option 17: %s\\n\",\n\t\t\troot_server_path);\n\t\tif (root_nfs_parse_options(root_server_path, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\tif (cmdline[0] != '\\0') {\n\t\tdprintk(\"Root-NFS: nfsroot=%s\\n\", cmdline);\n\t\tif (root_nfs_parse_options(cmdline, tmp, tmplen))\n\t\t\tgoto out_optionstoolong;\n\t}\n\n\t/*\n\t * Append mandatory options for nfsroot so they override\n\t * what has come before\n\t */\n\tsnprintf(mand_options, sizeof(mand_options), \"nolock,addr=%pI4\",\n\t\t\t&servaddr);\n\tif (root_nfs_cat(nfs_root_options, mand_options,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\tgoto out_optionstoolong;\n\n\t/*\n\t * Set up nfs_root_device.  For NFS mounts, this looks like\n\t *\n\t *\tserver:/path\n\t *\n\t * At this point, utsname()->nodename contains our local\n\t * IP address or hostname, set by ipconfig.  If \"%s\" exists\n\t * in tmp, substitute the nodename, then shovel the whole\n\t * mess into nfs_root_device.\n\t */\n\tlen = snprintf(nfs_export_path, sizeof(nfs_export_path),\n\t\t\t\ttmp, utsname()->nodename);\n\tif (len >= (int)sizeof(nfs_export_path))\n\t\tgoto out_devnametoolong;\n\tlen = snprintf(nfs_root_device, sizeof(nfs_root_device),\n\t\t\t\t\"%pI4:%s\", &servaddr, nfs_export_path);\n\tif (len >= (int)sizeof(nfs_root_device))\n\t\tgoto out_devnametoolong;\n\n\tretval = 0;\n\nout:\n\tkfree(tmp);\n\treturn retval;\nout_nomem:\n\tprintk(KERN_ERR \"Root-NFS: could not allocate memory\\n\");\n\tgoto out;\nout_optionstoolong:\n\tprintk(KERN_ERR \"Root-NFS: mount options string too long\\n\");\n\tgoto out;\nout_devnametoolong:\n\tprintk(KERN_ERR \"Root-NFS: root device name too long.\\n\");\n\tgoto out;\n}"
  },
  {
    "function_name": "oot_nfs_parse_options(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "185-207",
    "snippet": "tatic int __init root_nfs_parse_options(char *incoming, char *exppath,\n\t\t\t\t\t const size_t exppathlen)\n{\n\tchar *p;\n\n\t/*\n\t * Set the NFS remote path\n\t */\n\tp = strsep(&incoming, \",\");\n\tif (*p != '\\0' && strcmp(p, \"default\") != 0)\n\t\tif (root_nfs_copy(exppath, p, exppathlen))\n\t\t\treturn -1;\n\n\t/*\n\t * @incoming now points to the rest of the string; if it\n\t * contains something, append it to our root options buffer\n\t */\n\tif (incoming != NULL && *incoming != '\\0')\n\t\tif (root_nfs_cat(nfs_root_options, incoming,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char nfs_root_options[256]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "oot_nfs_cat(",
          "args": [
            "fs_root_options,",
            "ncoming,",
            "izeof(nfs_root_options))"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "oot_nfs_cat(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
          "lines": "165-177",
          "snippet": "tatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <net/ipconfig.h>",
            "include <linux/root_dev.h>\n#",
            "include <linux/utsname.h>\n#",
            "include <linux/nfs_fs.h>\n#",
            "include <linux/nfs.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/string.h>\n#",
            "include <linux/types.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oot_nfs_copy(",
          "args": [
            "xppath,",
            ",",
            "xppathlen)"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "oot_nfs_copy(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
          "lines": "157-163",
          "snippet": "tatic int __init root_nfs_copy(char *dest, const char *src,\n\t\t\t\t     const size_t destlen)\n{\n\tif (strlcpy(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <net/ipconfig.h>",
            "include <linux/root_dev.h>\n#",
            "include <linux/utsname.h>\n#",
            "include <linux/nfs_fs.h>\n#",
            "include <linux/nfs.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/string.h>\n#",
            "include <linux/types.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init root_nfs_copy(char *dest, const char *src,\n\t\t\t\t     const size_t destlen)\n{\n\tif (strlcpy(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "default\")"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trsep(",
          "args": [
            "incoming,",
            ",\")"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_options[256];\n\ntatic int __init root_nfs_parse_options(char *incoming, char *exppath,\n\t\t\t\t\t const size_t exppathlen)\n{\n\tchar *p;\n\n\t/*\n\t * Set the NFS remote path\n\t */\n\tp = strsep(&incoming, \",\");\n\tif (*p != '\\0' && strcmp(p, \"default\") != 0)\n\t\tif (root_nfs_copy(exppath, p, exppathlen))\n\t\t\treturn -1;\n\n\t/*\n\t * @incoming now points to the rest of the string; if it\n\t * contains something, append it to our root options buffer\n\t */\n\tif (incoming != NULL && *incoming != '\\0')\n\t\tif (root_nfs_cat(nfs_root_options, incoming,\n\t\t\t\t\t\tsizeof(nfs_root_options)))\n\t\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "oot_nfs_cat(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "165-177",
    "snippet": "tatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trlcat(",
          "args": [
            "est,",
            "rc,",
            "estlen)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcat(",
          "args": [
            "est,",
            ",\",",
            "estlen)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "est)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init root_nfs_cat(char *dest, const char *src,\n\t\t\t       const size_t destlen)\n{\n\tsize_t len = strlen(dest);\n\n\tif (len && dest[len - 1] != ',')\n\t\tif (strlcat(dest, \",\", destlen) > destlen)\n\t\t\treturn -1;\n\n\tif (strlcat(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "oot_nfs_copy(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "157-163",
    "snippet": "tatic int __init root_nfs_copy(char *dest, const char *src,\n\t\t\t\t     const size_t destlen)\n{\n\tif (strlcpy(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "est,",
            "rc,",
            "estlen)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init root_nfs_copy(char *dest, const char *src,\n\t\t\t\t     const size_t destlen)\n{\n\tif (strlcpy(dest, src, destlen) > destlen)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "fs_root_setup(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "130-153",
    "snippet": "tatic int __init nfs_root_setup(char *line)\n{\n\tROOT_DEV = Root_NFS;\n\n\tif (line[0] == '/' || line[0] == ',' || (line[0] >= '0' && line[0] <= '9')) {\n\t\tstrlcpy(nfs_root_parms, line, sizeof(nfs_root_parms));\n\t} else {\n\t\tsize_t n = strlen(line) + sizeof(NFS_ROOT) - 1;\n\t\tif (n >= sizeof(nfs_root_parms))\n\t\t\tline[sizeof(nfs_root_parms) - sizeof(NFS_ROOT) - 2] = '\\0';\n\t\tsprintf(nfs_root_parms, NFS_ROOT, line);\n\t}\n\n\t/*\n\t * Extract the IP address of the NFS server containing our\n\t * root file system, if one was specified.\n\t *\n\t * Note: root_nfs_parse_addr() removes the server-ip from\n\t *\t nfs_root_parms, if it exists.\n\t */\n\troot_server_addr = root_nfs_parse_addr(nfs_root_parms);\n\n\treturn 1;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char nfs_root_parms[256]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "oot_nfs_parse_addr(",
          "args": [
            "fs_root_parms)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "fs_root_parms,",
            "FS_ROOT,",
            "ine)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ine)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "fs_root_parms,",
            "ine,",
            "izeof(nfs_root_parms))"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic char nfs_root_parms[256];\n\ntatic int __init nfs_root_setup(char *line)\n{\n\tROOT_DEV = Root_NFS;\n\n\tif (line[0] == '/' || line[0] == ',' || (line[0] >= '0' && line[0] <= '9')) {\n\t\tstrlcpy(nfs_root_parms, line, sizeof(nfs_root_parms));\n\t} else {\n\t\tsize_t n = strlen(line) + sizeof(NFS_ROOT) - 1;\n\t\tif (n >= sizeof(nfs_root_parms))\n\t\t\tline[sizeof(nfs_root_parms) - sizeof(NFS_ROOT) - 2] = '\\0';\n\t\tsprintf(nfs_root_parms, NFS_ROOT, line);\n\t}\n\n\t/*\n\t * Extract the IP address of the NFS server containing our\n\t * root file system, if one was specified.\n\t *\n\t * Note: root_nfs_parse_addr() removes the server-ip from\n\t *\t nfs_root_parms, if it exists.\n\t */\n\troot_server_addr = root_nfs_parse_addr(nfs_root_parms);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fs_root_debug(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfsroot.c",
    "lines": "112-116",
    "snippet": "tatic int __init nfs_root_debug(char *__unused)\n{\n\tnfs_debug |= NFSDBG_ROOT | NFSDBG_MOUNT;\n\treturn 1;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <net/ipconfig.h>",
      "include <linux/root_dev.h>\n#",
      "include <linux/utsname.h>\n#",
      "include <linux/nfs_fs.h>\n#",
      "include <linux/nfs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/types.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"internal.h\"\ninclude <net/ipconfig.h>\ninclude <linux/root_dev.h>\n#\ninclude <linux/utsname.h>\n#\ninclude <linux/nfs_fs.h>\n#\ninclude <linux/nfs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/types.h>\n#\n\ntatic int __init nfs_root_debug(char *__unused)\n{\n\tnfs_debug |= NFSDBG_ROOT | NFSDBG_MOUNT;\n\treturn 1;\n}"
  }
]