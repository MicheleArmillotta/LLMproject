[
  {
    "function_name": "__ext4_handle_dirty_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "306-321",
    "snippet": "int __ext4_handle_dirty_super(const char *where, unsigned int line,\n\t\t\t      handle_t *handle, struct super_block *sb)\n{\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\n\tint err = 0;\n\n\text4_superblock_csum_set(sb);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t} else\n\t\tmark_buffer_dirty(bh);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_abort_handle",
          "args": [
            "where",
            "line",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "125-148",
          "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_dirty_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1262-1372",
          "snippet": "int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_superblock_csum_set",
          "args": [
            "sb"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "149-157",
          "snippet": "void ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\n\t\t\t      handle_t *handle, struct super_block *sb)\n{\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\n\tint err = 0;\n\n\text4_superblock_csum_set(sb);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t} else\n\t\tmark_buffer_dirty(bh);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext4_handle_dirty_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "247-304",
    "snippet": "int __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tset_buffer_meta(bh);\n\tset_buffer_prio(bh);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\t/* Errors can only happen due to aborted journal or a nasty bug */\n\t\tif (!is_handle_aborted(handle) && WARN_ON_ONCE(err)) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\tif (inode == NULL) {\n\t\t\t\tpr_err(\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\",\n\t\t\t\t       handle->h_type,\n\t\t\t\t       handle->h_line_no,\n\t\t\t\t       handle->h_requested_credits,\n\t\t\t\t       handle->h_buffer_credits, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t \"journal_dirty_metadata failed: \"\n\t\t\t\t\t \"handle type %u started at line %u, \"\n\t\t\t\t\t \"credits %u/%u, errcode %d\",\n\t\t\t\t\t handle->h_type,\n\t\t\t\t\t handle->h_line_no,\n\t\t\t\t\t handle->h_requested_credits,\n\t\t\t\t\t handle->h_buffer_credits, err);\n\t\t}\n\t} else {\n\t\tif (inode)\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\telse\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (inode && inode_needs_sync(inode)) {\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\t\tstruct ext4_super_block *es;\n\n\t\t\t\tes = EXT4_SB(inode->i_sb)->s_es;\n\t\t\t\tes->s_last_error_block =\n\t\t\t\t\tcpu_to_le64(bh->b_blocknr);\n\t\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t\"IO error syncing itable block\");\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "inode",
            "where",
            "line",
            "bh->b_blocknr",
            "\"IO error syncing itable block\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_needs_sync",
          "args": [
            "inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "inode_needs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1751-1758",
          "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\"",
            "handle->h_type",
            "handle->h_line_no",
            "handle->h_requested_credits",
            "handle->h_buffer_credits",
            "err"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_abort_handle",
          "args": [
            "where",
            "line",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "125-148",
          "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "err"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_dirty_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1262-1372",
          "snippet": "int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_prio",
          "args": [
            "bh"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_meta",
          "args": [
            "bh"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tset_buffer_meta(bh);\n\tset_buffer_prio(bh);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\t/* Errors can only happen due to aborted journal or a nasty bug */\n\t\tif (!is_handle_aborted(handle) && WARN_ON_ONCE(err)) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\tif (inode == NULL) {\n\t\t\t\tpr_err(\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\",\n\t\t\t\t       handle->h_type,\n\t\t\t\t       handle->h_line_no,\n\t\t\t\t       handle->h_requested_credits,\n\t\t\t\t       handle->h_buffer_credits, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t \"journal_dirty_metadata failed: \"\n\t\t\t\t\t \"handle type %u started at line %u, \"\n\t\t\t\t\t \"credits %u/%u, errcode %d\",\n\t\t\t\t\t handle->h_type,\n\t\t\t\t\t handle->h_line_no,\n\t\t\t\t\t handle->h_requested_credits,\n\t\t\t\t\t handle->h_buffer_credits, err);\n\t\t}\n\t} else {\n\t\tif (inode)\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\telse\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (inode && inode_needs_sync(inode)) {\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\t\tstruct ext4_super_block *es;\n\n\t\t\t\tes = EXT4_SB(inode->i_sb)->s_es;\n\t\t\t\tes->s_last_error_block =\n\t\t\t\t\tcpu_to_le64(bh->b_blocknr);\n\t\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t\"IO error syncing itable block\");\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "__ext4_journal_get_create_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "233-245",
    "snippet": "int __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_abort_handle",
          "args": [
            "where",
            "line",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "125-148",
          "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_create_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1046-1117",
          "snippet": "int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tWARN_ON(!transaction);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\tjournal = transaction->t_journal;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous jbd2_journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjbd2_journal_cancel_revoke(handle, jh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tWARN_ON(!transaction);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\tjournal = transaction->t_journal;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous jbd2_journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjbd2_journal_cancel_revoke(handle, jh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "__ext4_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "178-231",
    "snippet": "int __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext4_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %x\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* In the no journal case, we can just do a bforget and return */\n\tif (!ext4_handle_valid(handle)) {\n\t\tbforget(bh);\n\t\treturn 0;\n\t}\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext4_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n\t\t\terr = jbd2_journal_forget(handle, bh);\n\t\t\tif (err)\n\t\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t\t  bh, handle, err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call jbd2_journal_revoke\");\n\terr = jbd2_journal_revoke(handle, blocknr, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t  bh, handle, err);\n\t\t__ext4_abort(inode->i_sb, where, line,\n\t\t\t   \"error %d when attempting revoke\", err);\n\t}\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"exit\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_abort",
          "args": [
            "inode->i_sb",
            "where",
            "line",
            "\"error %d when attempting revoke\"",
            "err"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "563-591",
          "snippet": "void __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_abort_handle",
          "args": [
            "where",
            "line",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "125-148",
          "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_revoke",
          "args": [
            "handle",
            "blocknr",
            "bh"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "329-403",
          "snippet": "int jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD2_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call jbd2_journal_forget\");\n\t\t\tjbd2_journal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %llu, bh_in=%p\\n\",blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD2_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call jbd2_journal_forget\");\n\t\t\tjbd2_journal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %llu, bh_in=%p\\n\",blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call jbd2_journal_revoke\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_forget",
          "args": [
            "handle",
            "bh"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1391-1507",
          "snippet": "int jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = NULL;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = NULL;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call jbd2_journal_forget\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %x\\n\"",
            "bh",
            "is_metadata",
            "inode->i_mode",
            "test_opt(inode->i_sb, DATA_FLAGS)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"enter\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_forget",
          "args": [
            "inode",
            "is_metadata",
            "blocknr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext4_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %x\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* In the no journal case, we can just do a bforget and return */\n\tif (!ext4_handle_valid(handle)) {\n\t\tbforget(bh);\n\t\treturn 0;\n\t}\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext4_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n\t\t\terr = jbd2_journal_forget(handle, bh);\n\t\t\tif (err)\n\t\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t\t  bh, handle, err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call jbd2_journal_revoke\");\n\terr = jbd2_journal_revoke(handle, blocknr, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t  bh, handle, err);\n\t\t__ext4_abort(inode->i_sb, where, line,\n\t\t\t   \"error %d when attempting revoke\", err);\n\t}\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}"
  },
  {
    "function_name": "__ext4_journal_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "150-164",
    "snippet": "int __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_abort_handle",
          "args": [
            "where",
            "line",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "125-148",
          "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1013-1024",
          "snippet": "int jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_journal_abort_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "125-148",
    "snippet": "static void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_abort_handle",
          "args": [
            "handle"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\"",
            "caller",
            "line",
            "errstr",
            "err_fn"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"abort\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_handle_valid(handle)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_decode_error",
          "args": [
            "NULL",
            "err",
            "nbuf"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "493-525",
          "snippet": "const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nconst char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}"
  },
  {
    "function_name": "__ext4_journal_start_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "101-123",
    "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_start_reserved",
          "args": [
            "handle",
            "type",
            "line"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "491-524",
          "snippet": "int jbd2_journal_start_reserved(handle_t *handle, unsigned int type,\n\t\t\t\tunsigned int line_no)\n{\n\tjournal_t *journal = handle->h_journal;\n\tint ret = -EIO;\n\n\tif (WARN_ON(!handle->h_reserved)) {\n\t\t/* Someone passed in normal handle? Just stop it. */\n\t\tjbd2_journal_stop(handle);\n\t\treturn ret;\n\t}\n\t/*\n\t * Usefulness of mixing of reserved and unreserved handles is\n\t * questionable. So far nobody seems to need it so just error out.\n\t */\n\tif (WARN_ON(current->journal_info)) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\n\thandle->h_journal = NULL;\n\t/*\n\t * GFP_NOFS is here because callers are likely from writeback or\n\t * similarly constrained call sites\n\t */\n\tret = start_this_handle(journal, handle, GFP_NOFS);\n\tif (ret < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_start_reserved(handle_t *handle, unsigned int type,\n\t\t\t\tunsigned int line_no)\n{\n\tjournal_t *journal = handle->h_journal;\n\tint ret = -EIO;\n\n\tif (WARN_ON(!handle->h_reserved)) {\n\t\t/* Someone passed in normal handle? Just stop it. */\n\t\tjbd2_journal_stop(handle);\n\t\treturn ret;\n\t}\n\t/*\n\t * Usefulness of mixing of reserved and unreserved handles is\n\t * questionable. So far nobody seems to need it so just error out.\n\t */\n\tif (WARN_ON(current->journal_info)) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\n\thandle->h_journal = NULL;\n\t/*\n\t * GFP_NOFS is here because callers are likely from writeback or\n\t * similarly constrained call sites\n\t */\n\tret = start_this_handle(journal, handle, GFP_NOFS);\n\tif (ret < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_free_reserved",
          "args": [
            "handle"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_free_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "469-476",
          "snippet": "void jbd2_journal_free_reserved(handle_t *handle)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\tWARN_ON(!handle->h_reserved);\n\tsub_reserved_credits(journal, handle->h_buffer_credits);\n\tjbd2_free_handle(handle);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_free_reserved(handle_t *handle)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\tWARN_ON(!handle->h_reserved);\n\tsub_reserved_credits(journal, handle->h_buffer_credits);\n\tjbd2_free_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_check_start",
          "args": [
            "sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_check_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "41-60",
          "snippet": "static int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_journal_start_reserved",
          "args": [
            "sb",
            "handle->h_buffer_credits",
            "_RET_IP_"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_nojournal",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_nojournal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "10-22",
          "snippet": "static handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
  },
  {
    "function_name": "__ext4_journal_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "80-99",
    "snippet": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext4_std_error",
          "args": [
            "sb",
            "where",
            "line",
            "err"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_std_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "530-551",
          "snippet": "void __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_stop",
          "args": [
            "handle"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1525-1671",
          "snippet": "int jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (!transaction)\n\t\tgoto free_and_exit;\n\tjournal = transaction->t_journal;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse\n\t\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttransaction->t_tid,\n\t\t\t\thandle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_buffer_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\tcurrent->journal_info = NULL;\n\tatomic_sub(handle->h_buffer_credits,\n\t\t   &transaction->t_outstanding_credits);\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t    (atomic_read(&transaction->t_outstanding_credits) >\n\t     journal->j_max_transaction_buffers) ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, transaction->t_tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once we drop t_updates, if it goes to zero the transaction\n\t * could start committing on us and eventually disappear.  So\n\t * once we do this, we must not dereference transaction\n\t * pointer again.\n\t */\n\ttid = transaction->t_tid;\n\tif (atomic_dec_and_test(&transaction->t_updates)) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tif (handle->h_rsv_handle)\n\t\tjbd2_journal_free_reserved(handle->h_rsv_handle);\nfree_and_exit:\n\tjbd2_free_handle(handle);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (!transaction)\n\t\tgoto free_and_exit;\n\tjournal = transaction->t_journal;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse\n\t\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttransaction->t_tid,\n\t\t\t\thandle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_buffer_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\tcurrent->journal_info = NULL;\n\tatomic_sub(handle->h_buffer_credits,\n\t\t   &transaction->t_outstanding_credits);\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t    (atomic_read(&transaction->t_outstanding_credits) >\n\t     journal->j_max_transaction_buffers) ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, transaction->t_tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once we drop t_updates, if it goes to zero the transaction\n\t * could start committing on us and eventually disappear.  So\n\t * once we do this, we must not dereference transaction\n\t * pointer again.\n\t */\n\ttid = transaction->t_tid;\n\tif (atomic_dec_and_test(&transaction->t_updates)) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tif (handle->h_rsv_handle)\n\t\tjbd2_journal_free_reserved(handle->h_rsv_handle);\nfree_and_exit:\n\tjbd2_free_handle(handle);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_put_nojournal",
          "args": [
            "handle"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_put_nojournal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "26-36",
          "snippet": "static void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext4_journal_start_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "62-78",
    "snippet": "handle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks)\n{\n\tjournal_t *journal;\n\tint err;\n\n\ttrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\n\t\t\t\t   type, line);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2__journal_start",
          "args": [
            "journal",
            "blocks",
            "rsv_blocks",
            "GFP_NOFS",
            "type",
            "line"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2__journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "414-459",
          "snippet": "handle_t *jbd2__journal_start(journal_t *journal, int nblocks, int rsv_blocks,\n\t\t\t      gfp_t gfp_mask, unsigned int type,\n\t\t\t      unsigned int line_no)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (rsv_blocks) {\n\t\thandle_t *rsv_handle;\n\n\t\trsv_handle = new_handle(rsv_blocks);\n\t\tif (!rsv_handle) {\n\t\t\tjbd2_free_handle(handle);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trsv_handle->h_reserved = 1;\n\t\trsv_handle->h_journal = journal;\n\t\thandle->h_rsv_handle = rsv_handle;\n\t}\n\n\terr = start_this_handle(journal, handle, gfp_mask);\n\tif (err < 0) {\n\t\tif (handle->h_rsv_handle)\n\t\t\tjbd2_free_handle(handle->h_rsv_handle);\n\t\tjbd2_free_handle(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, nblocks);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nhandle_t *jbd2__journal_start(journal_t *journal, int nblocks, int rsv_blocks,\n\t\t\t      gfp_t gfp_mask, unsigned int type,\n\t\t\t      unsigned int line_no)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (rsv_blocks) {\n\t\thandle_t *rsv_handle;\n\n\t\trsv_handle = new_handle(rsv_blocks);\n\t\tif (!rsv_handle) {\n\t\t\tjbd2_free_handle(handle);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trsv_handle->h_reserved = 1;\n\t\trsv_handle->h_journal = journal;\n\t\thandle->h_rsv_handle = rsv_handle;\n\t}\n\n\terr = start_this_handle(journal, handle, gfp_mask);\n\tif (err < 0) {\n\t\tif (handle->h_rsv_handle)\n\t\t\tjbd2_free_handle(handle->h_rsv_handle);\n\t\tjbd2_free_handle(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, nblocks);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_nojournal",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_nojournal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "10-22",
          "snippet": "static handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_check_start",
          "args": [
            "sb"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_check_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "41-60",
          "snippet": "static int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_journal_start",
          "args": [
            "sb",
            "blocks",
            "rsv_blocks",
            "_RET_IP_"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks)\n{\n\tjournal_t *journal;\n\tint err;\n\n\ttrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\n\t\t\t\t   type, line);\n}"
  },
  {
    "function_name": "ext4_journal_check_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "41-60",
    "snippet": "static int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_abort",
          "args": [
            "sb",
            "\"Detected aborted journal\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sb->s_writers.frozen == SB_FREEZE_COMPLETE"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_put_nojournal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "26-36",
    "snippet": "static void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ref_cnt == 0"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}"
  },
  {
    "function_name": "ext4_get_nojournal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
    "lines": "10-22",
    "snippet": "static handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}"
  }
]