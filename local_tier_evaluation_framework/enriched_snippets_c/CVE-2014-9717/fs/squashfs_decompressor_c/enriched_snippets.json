[
  {
    "function_name": "squashfs_decompressor_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
    "lines": "135-148",
    "snippet": "void *squashfs_decompressor_setup(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *stream, *comp_opts = get_comp_opts(sb, flags);\n\n\tif (IS_ERR(comp_opts))\n\t\treturn comp_opts;\n\n\tstream = squashfs_decompressor_create(msblk, comp_opts);\n\tif (IS_ERR(stream))\n\t\tkfree(comp_opts);\n\n\treturn stream;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "comp_opts"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "stream"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_decompressor_create",
          "args": [
            "msblk",
            "comp_opts"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompressor_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "28-59",
          "snippet": "void *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct squashfs_stream __percpu *percpu;\n\tint err, cpu;\n\n\tpercpu = alloc_percpu(struct squashfs_stream);\n\tif (percpu == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tstream->stream = msblk->decompressor->init(msblk, comp_opts);\n\t\tif (IS_ERR(stream->stream)) {\n\t\t\terr = PTR_ERR(stream->stream);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkfree(comp_opts);\n\treturn (__force void *) percpu;\n\nout:\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tif (!IS_ERR_OR_NULL(stream->stream))\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t}\n\tfree_percpu(percpu);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct squashfs_stream __percpu *percpu;\n\tint err, cpu;\n\n\tpercpu = alloc_percpu(struct squashfs_stream);\n\tif (percpu == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tstream->stream = msblk->decompressor->init(msblk, comp_opts);\n\t\tif (IS_ERR(stream->stream)) {\n\t\t\terr = PTR_ERR(stream->stream);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkfree(comp_opts);\n\treturn (__force void *) percpu;\n\nout:\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tif (!IS_ERR_OR_NULL(stream->stream))\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t}\n\tfree_percpu(percpu);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "comp_opts"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_comp_opts",
          "args": [
            "sb",
            "flags"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "get_comp_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
          "lines": "94-132",
          "snippet": "static void *get_comp_opts(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *buffer = NULL, *comp_opts;\n\tstruct squashfs_page_actor *actor = NULL;\n\tint length = 0;\n\n\t/*\n\t * Read decompressor specific options from file system if present\n\t */\n\tif (SQUASHFS_COMP_OPTS(flags)) {\n\t\tbuffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (buffer == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tactor = squashfs_page_actor_init(&buffer, 1, 0);\n\t\tif (actor == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlength = squashfs_read_data(sb,\n\t\t\tsizeof(struct squashfs_super_block), 0, NULL, actor);\n\n\t\tif (length < 0) {\n\t\t\tcomp_opts = ERR_PTR(length);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcomp_opts = squashfs_comp_opts(msblk, buffer, length);\n\nout:\n\tkfree(actor);\n\tkfree(buffer);\n\treturn comp_opts;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};\n\nstatic void *get_comp_opts(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *buffer = NULL, *comp_opts;\n\tstruct squashfs_page_actor *actor = NULL;\n\tint length = 0;\n\n\t/*\n\t * Read decompressor specific options from file system if present\n\t */\n\tif (SQUASHFS_COMP_OPTS(flags)) {\n\t\tbuffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (buffer == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tactor = squashfs_page_actor_init(&buffer, 1, 0);\n\t\tif (actor == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlength = squashfs_read_data(sb,\n\t\t\tsizeof(struct squashfs_super_block), 0, NULL, actor);\n\n\t\tif (length < 0) {\n\t\t\tcomp_opts = ERR_PTR(length);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcomp_opts = squashfs_comp_opts(msblk, buffer, length);\n\nout:\n\tkfree(actor);\n\tkfree(buffer);\n\treturn comp_opts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nvoid *squashfs_decompressor_setup(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *stream, *comp_opts = get_comp_opts(sb, flags);\n\n\tif (IS_ERR(comp_opts))\n\t\treturn comp_opts;\n\n\tstream = squashfs_decompressor_create(msblk, comp_opts);\n\tif (IS_ERR(stream))\n\t\tkfree(comp_opts);\n\n\treturn stream;\n}"
  },
  {
    "function_name": "get_comp_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
    "lines": "94-132",
    "snippet": "static void *get_comp_opts(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *buffer = NULL, *comp_opts;\n\tstruct squashfs_page_actor *actor = NULL;\n\tint length = 0;\n\n\t/*\n\t * Read decompressor specific options from file system if present\n\t */\n\tif (SQUASHFS_COMP_OPTS(flags)) {\n\t\tbuffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (buffer == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tactor = squashfs_page_actor_init(&buffer, 1, 0);\n\t\tif (actor == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlength = squashfs_read_data(sb,\n\t\t\tsizeof(struct squashfs_super_block), 0, NULL, actor);\n\n\t\tif (length < 0) {\n\t\t\tcomp_opts = ERR_PTR(length);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcomp_opts = squashfs_comp_opts(msblk, buffer, length);\n\nout:\n\tkfree(actor);\n\tkfree(buffer);\n\treturn comp_opts;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "actor"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_comp_opts",
          "args": [
            "msblk",
            "buffer",
            "length"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_comp_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.h",
          "lines": "38-43",
          "snippet": "static inline void *squashfs_comp_opts(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\t\tvoid *buff, int length)\n{\n\treturn msblk->decompressor->comp_opts ?\n\t\tmsblk->decompressor->comp_opts(msblk, buff, length) : NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *squashfs_comp_opts(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\t\tvoid *buff, int length)\n{\n\treturn msblk->decompressor->comp_opts ?\n\t\tmsblk->decompressor->comp_opts(msblk, buff, length) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "length"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_data",
          "args": [
            "sb",
            "sizeof(struct squashfs_super_block)",
            "0",
            "NULL",
            "actor"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
          "lines": "90-214",
          "snippet": "int squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_page_actor_init",
          "args": [
            "&buffer",
            "1",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_page_actor_init_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.c",
          "lines": "83-100",
          "snippet": "struct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMP_OPTS",
          "args": [
            "flags"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};\n\nstatic void *get_comp_opts(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *buffer = NULL, *comp_opts;\n\tstruct squashfs_page_actor *actor = NULL;\n\tint length = 0;\n\n\t/*\n\t * Read decompressor specific options from file system if present\n\t */\n\tif (SQUASHFS_COMP_OPTS(flags)) {\n\t\tbuffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (buffer == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tactor = squashfs_page_actor_init(&buffer, 1, 0);\n\t\tif (actor == NULL) {\n\t\t\tcomp_opts = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlength = squashfs_read_data(sb,\n\t\t\tsizeof(struct squashfs_super_block), 0, NULL, actor);\n\n\t\tif (length < 0) {\n\t\t\tcomp_opts = ERR_PTR(length);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcomp_opts = squashfs_comp_opts(msblk, buffer, length);\n\nout:\n\tkfree(actor);\n\tkfree(buffer);\n\treturn comp_opts;\n}"
  },
  {
    "function_name": "squashfs_lookup_decompressor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
    "lines": "82-91",
    "snippet": "const struct squashfs_decompressor *squashfs_lookup_decompressor(int id)\n{\n\tint i;\n\n\tfor (i = 0; decompressor[i]->id; i++)\n\t\tif (id == decompressor[i]->id)\n\t\t\tbreak;\n\n\treturn decompressor[i];\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};\n\nconst struct squashfs_decompressor *squashfs_lookup_decompressor(int id)\n{\n\tint i;\n\n\tfor (i = 0; decompressor[i]->id; i++)\n\t\tif (id == decompressor[i]->id)\n\t\t\tbreak;\n\n\treturn decompressor[i];\n}"
  }
]