[
  {
    "function_name": "dlm_unregister_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "787-790",
    "snippet": "void dlm_unregister_debugfs(void)\n{\n\tdebugfs_remove(dlm_root);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *dlm_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dlm_root"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic struct dentry *dlm_root;\n\nvoid dlm_unregister_debugfs(void)\n{\n\tdebugfs_remove(dlm_root);\n}"
  },
  {
    "function_name": "dlm_register_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "780-785",
    "snippet": "int __init dlm_register_debugfs(void)\n{\n\tmutex_init(&debug_buf_lock);\n\tdlm_root = debugfs_create_dir(\"dlm\", NULL);\n\treturn dlm_root ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mutex debug_buf_lock;",
      "static struct dentry *dlm_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"dlm\"",
            "NULL"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&debug_buf_lock"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic struct mutex debug_buf_lock;\nstatic struct dentry *dlm_root;\n\nint __init dlm_register_debugfs(void)\n{\n\tmutex_init(&debug_buf_lock);\n\tdlm_root = debugfs_create_dir(\"dlm\", NULL);\n\treturn dlm_root ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "dlm_create_debug_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "709-778",
    "snippet": "int dlm_create_debug_file(struct dlm_ls *ls)\n{\n\tchar name[DLM_LOCKSPACE_LEN+8];\n\n\t/* format 1 */\n\n\tls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format1_fops);\n\tif (!ls->ls_debug_rsb_dentry)\n\t\tgoto fail;\n\n\t/* format 2 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_locks\", ls->ls_name);\n\n\tls->ls_debug_locks_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tdlm_root,\n\t\t\t\t\t\t\tls,\n\t\t\t\t\t\t\t&format2_fops);\n\tif (!ls->ls_debug_locks_dentry)\n\t\tgoto fail;\n\n\t/* format 3 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_all\", ls->ls_name);\n\n\tls->ls_debug_all_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format3_fops);\n\tif (!ls->ls_debug_all_dentry)\n\t\tgoto fail;\n\n\t/* format 4 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_toss\", ls->ls_name);\n\n\tls->ls_debug_toss_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t       S_IFREG | S_IRUGO,\n\t\t\t\t\t\t       dlm_root,\n\t\t\t\t\t\t       ls,\n\t\t\t\t\t\t       &format4_fops);\n\tif (!ls->ls_debug_toss_dentry)\n\t\tgoto fail;\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_waiters\", ls->ls_name);\n\n\tls->ls_debug_waiters_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t  S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t  dlm_root,\n\t\t\t\t\t\t\t  ls,\n\t\t\t\t\t\t\t  &waiters_fops);\n\tif (!ls->ls_debug_waiters_dentry)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\n\tdlm_delete_debug_file(ls);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *dlm_root;",
      "static const struct file_operations format1_fops;",
      "static const struct file_operations format2_fops;",
      "static const struct file_operations format3_fops;",
      "static const struct file_operations format4_fops;",
      "static const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations waiters_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = waiters_read,\n\t.llseek  = default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_delete_debug_file",
          "args": [
            "ls"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_delete_debug_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "700-707",
          "snippet": "void dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nvoid dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "name",
            "S_IFREG | S_IRUGO",
            "dlm_root",
            "ls",
            "&waiters_fops"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "DLM_LOCKSPACE_LEN+8",
            "\"%s_waiters\"",
            "ls->ls_name"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "DLM_LOCKSPACE_LEN+8",
            "\"%s_toss\"",
            "ls->ls_name"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "DLM_LOCKSPACE_LEN+8",
            "\"%s_all\"",
            "ls->ls_name"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "DLM_LOCKSPACE_LEN+8",
            "\"%s_locks\"",
            "ls->ls_name"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic struct dentry *dlm_root;\nstatic const struct file_operations format1_fops;\nstatic const struct file_operations format2_fops;\nstatic const struct file_operations format3_fops;\nstatic const struct file_operations format4_fops;\nstatic const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations waiters_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = waiters_read,\n\t.llseek  = default_llseek,\n};\n\nint dlm_create_debug_file(struct dlm_ls *ls)\n{\n\tchar name[DLM_LOCKSPACE_LEN+8];\n\n\t/* format 1 */\n\n\tls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format1_fops);\n\tif (!ls->ls_debug_rsb_dentry)\n\t\tgoto fail;\n\n\t/* format 2 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_locks\", ls->ls_name);\n\n\tls->ls_debug_locks_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tdlm_root,\n\t\t\t\t\t\t\tls,\n\t\t\t\t\t\t\t&format2_fops);\n\tif (!ls->ls_debug_locks_dentry)\n\t\tgoto fail;\n\n\t/* format 3 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_all\", ls->ls_name);\n\n\tls->ls_debug_all_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format3_fops);\n\tif (!ls->ls_debug_all_dentry)\n\t\tgoto fail;\n\n\t/* format 4 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_toss\", ls->ls_name);\n\n\tls->ls_debug_toss_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t       S_IFREG | S_IRUGO,\n\t\t\t\t\t\t       dlm_root,\n\t\t\t\t\t\t       ls,\n\t\t\t\t\t\t       &format4_fops);\n\tif (!ls->ls_debug_toss_dentry)\n\t\tgoto fail;\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_waiters\", ls->ls_name);\n\n\tls->ls_debug_waiters_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t  S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t  dlm_root,\n\t\t\t\t\t\t\t  ls,\n\t\t\t\t\t\t\t  &waiters_fops);\n\tif (!ls->ls_debug_waiters_dentry)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\n\tdlm_delete_debug_file(ls);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "dlm_delete_debug_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "700-707",
    "snippet": "void dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "ls->ls_debug_toss_dentry"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nvoid dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}"
  },
  {
    "function_name": "waiters_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "667-691",
    "snippet": "static ssize_t waiters_read(struct file *file, char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_ls *ls = file->private_data;\n\tstruct dlm_lkb *lkb;\n\tsize_t len = DLM_DEBUG_BUF_LEN, pos = 0, ret, rv;\n\n\tmutex_lock(&debug_buf_lock);\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tmemset(debug_buf, 0, sizeof(debug_buf));\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tret = snprintf(debug_buf + pos, len - pos, \"%x %d %d %s\\n\",\n\t\t\t       lkb->lkb_id, lkb->lkb_wait_type,\n\t\t\t       lkb->lkb_nodeid, lkb->lkb_resource->res_name);\n\t\tif (ret >= len - pos)\n\t\t\tbreak;\n\t\tpos += ret;\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, debug_buf, pos);\n\tmutex_unlock(&debug_buf_lock);\n\treturn rv;\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define DLM_DEBUG_BUF_LEN 4096"
    ],
    "globals_used": [
      "static char debug_buf[DLM_DEBUG_BUF_LEN];",
      "static struct mutex debug_buf_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&debug_buf_lock"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "userbuf",
            "count",
            "ppos",
            "debug_buf",
            "pos"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "debug_buf + pos",
            "len - pos",
            "\"%x %d %d %s\\n\"",
            "lkb->lkb_id",
            "lkb->lkb_wait_type",
            "lkb->lkb_nodeid",
            "lkb->lkb_resource->res_name"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_waiters",
            "lkb_wait_reply"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "debug_buf",
            "0",
            "sizeof(debug_buf)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&debug_buf_lock"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\n#define DLM_DEBUG_BUF_LEN 4096\n\nstatic char debug_buf[DLM_DEBUG_BUF_LEN];\nstatic struct mutex debug_buf_lock;\n\nstatic ssize_t waiters_read(struct file *file, char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_ls *ls = file->private_data;\n\tstruct dlm_lkb *lkb;\n\tsize_t len = DLM_DEBUG_BUF_LEN, pos = 0, ret, rv;\n\n\tmutex_lock(&debug_buf_lock);\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tmemset(debug_buf, 0, sizeof(debug_buf));\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tret = snprintf(debug_buf + pos, len - pos, \"%x %d %d %s\\n\",\n\t\t\t       lkb->lkb_id, lkb->lkb_wait_type,\n\t\t\t       lkb->lkb_nodeid, lkb->lkb_resource->res_name);\n\t\tif (ret >= len - pos)\n\t\t\tbreak;\n\t\tpos += ret;\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, debug_buf, pos);\n\tmutex_unlock(&debug_buf_lock);\n\treturn rv;\n}"
  },
  {
    "function_name": "table_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "610-630",
    "snippet": "static int table_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret = -1;\n\n\tif (file->f_op == &format1_fops)\n\t\tret = seq_open(file, &format1_seq_ops);\n\telse if (file->f_op == &format2_fops)\n\t\tret = seq_open(file, &format2_seq_ops);\n\telse if (file->f_op == &format3_fops)\n\t\tret = seq_open(file, &format3_seq_ops);\n\telse if (file->f_op == &format4_fops)\n\t\tret = seq_open(file, &format4_seq_ops);\n\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private; /* the dlm_ls */\n\treturn 0;\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations format1_seq_ops;",
      "static const struct seq_operations format2_seq_ops;",
      "static const struct seq_operations format3_seq_ops;",
      "static const struct seq_operations format4_seq_ops;",
      "static const struct seq_operations format1_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format2_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format3_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct file_operations format1_fops;",
      "static const struct file_operations format2_fops;",
      "static const struct file_operations format3_fops;",
      "static const struct file_operations format4_fops;",
      "static const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
      "static const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&format4_seq_ops"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic const struct seq_operations format1_seq_ops;\nstatic const struct seq_operations format2_seq_ops;\nstatic const struct seq_operations format3_seq_ops;\nstatic const struct seq_operations format4_seq_ops;\nstatic const struct seq_operations format1_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format2_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format3_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct file_operations format1_fops;\nstatic const struct file_operations format2_fops;\nstatic const struct file_operations format3_fops;\nstatic const struct file_operations format4_fops;\nstatic const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\nstatic int table_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret = -1;\n\n\tif (file->f_op == &format1_fops)\n\t\tret = seq_open(file, &format1_seq_ops);\n\telse if (file->f_op == &format2_fops)\n\t\tret = seq_open(file, &format2_seq_ops);\n\telse if (file->f_op == &format3_fops)\n\t\tret = seq_open(file, &format3_seq_ops);\n\telse if (file->f_op == &format4_fops)\n\t\tret = seq_open(file, &format4_seq_ops);\n\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private; /* the dlm_ls */\n\treturn 0;\n}"
  },
  {
    "function_name": "table_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "567-575",
    "snippet": "static void table_seq_stop(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tif (ri) {\n\t\tdlm_put_rsb(ri->rsb);\n\t\tkfree(ri);\n\t}\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "ri->rsb"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void table_seq_stop(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tif (ri) {\n\t\tdlm_put_rsb(ri->rsb);\n\t\tkfree(ri);\n\t}\n}"
  },
  {
    "function_name": "table_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "502-565",
    "snippet": "static void *table_seq_next(struct seq_file *seq, void *iter_ptr, loff_t *pos)\n{\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\tstruct rb_root *tree;\n\tstruct rb_node *next;\n\tstruct dlm_rsb *r, *rp;\n\tloff_t n = *pos;\n\tunsigned bucket;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\n\t/*\n\t * move to the next rsb in the same bucket\n\t */\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trp = ri->rsb;\n\tnext = rb_next(&rp->res_hashnode);\n\n\tif (next) {\n\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\tdlm_hold_rsb(r);\n\t\tri->rsb = r;\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\tdlm_put_rsb(rp);\n\t\t++*pos;\n\t\treturn ri;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\tdlm_put_rsb(rp);\n\n\t/*\n\t * move to the first rsb in the next non-empty bucket\n\t */\n\n\t/* zero the entry */\n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnext = rb_first(tree);\n\t\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations format4_seq_ops;",
      "static const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hold_rsb",
          "args": [
            "r"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "341-344",
          "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "tree"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "tree"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "rp"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&rp->res_hashnode"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic const struct seq_operations format4_seq_ops;\nstatic const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic void *table_seq_next(struct seq_file *seq, void *iter_ptr, loff_t *pos)\n{\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\tstruct rb_root *tree;\n\tstruct rb_node *next;\n\tstruct dlm_rsb *r, *rp;\n\tloff_t n = *pos;\n\tunsigned bucket;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\n\t/*\n\t * move to the next rsb in the same bucket\n\t */\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trp = ri->rsb;\n\tnext = rb_next(&rp->res_hashnode);\n\n\tif (next) {\n\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\tdlm_hold_rsb(r);\n\t\tri->rsb = r;\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\tdlm_put_rsb(rp);\n\t\t++*pos;\n\t\treturn ri;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\tdlm_put_rsb(rp);\n\n\t/*\n\t * move to the first rsb in the next non-empty bucket\n\t */\n\n\t/* zero the entry */\n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnext = rb_first(tree);\n\t\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}"
  },
  {
    "function_name": "table_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "422-500",
    "snippet": "static void *table_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct rb_root *tree;\n\tstruct rb_node *node;\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri;\n\tstruct dlm_rsb *r;\n\tloff_t n = *pos;\n\tunsigned bucket, entry;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\tentry = n & ((1LL << 32) - 1);\n\n\tif (bucket >= ls->ls_rsbtbl_size)\n\t\treturn NULL;\n\n\tri = kzalloc(sizeof(struct rsbtbl_iter), GFP_NOFS);\n\tif (!ri)\n\t\treturn NULL;\n\tif (n == 0)\n\t\tri->header = 1;\n\tif (seq->op == &format1_seq_ops)\n\t\tri->format = 1;\n\tif (seq->op == &format2_seq_ops)\n\t\tri->format = 2;\n\tif (seq->op == &format3_seq_ops)\n\t\tri->format = 3;\n\tif (seq->op == &format4_seq_ops)\n\t\tri->format = 4;\n\n\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tif (!RB_EMPTY_ROOT(tree)) {\n\t\tfor (node = rb_first(tree); node; node = rb_next(node)) {\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tif (!entry--) {\n\t\t\t\tdlm_hold_rsb(r);\n\t\t\t\tri->rsb = r;\n\t\t\t\tri->bucket = bucket;\n\t\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t\treturn ri;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\t/*\n\t * move to the first rsb in the next non-empty bucket\n\t */\n\n\t/* zero the entry */\n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnode = rb_first(tree);\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations format1_seq_ops;",
      "static const struct seq_operations format2_seq_ops;",
      "static const struct seq_operations format3_seq_ops;",
      "static const struct seq_operations format4_seq_ops;",
      "static const struct seq_operations format1_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format2_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format3_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};",
      "static const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hold_rsb",
          "args": [
            "r"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "341-344",
          "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "tree"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "tree"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "tree"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "tree"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct rsbtbl_iter)",
            "GFP_NOFS"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic const struct seq_operations format1_seq_ops;\nstatic const struct seq_operations format2_seq_ops;\nstatic const struct seq_operations format3_seq_ops;\nstatic const struct seq_operations format4_seq_ops;\nstatic const struct seq_operations format1_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format2_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format3_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\nstatic const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic void *table_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct rb_root *tree;\n\tstruct rb_node *node;\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri;\n\tstruct dlm_rsb *r;\n\tloff_t n = *pos;\n\tunsigned bucket, entry;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\tentry = n & ((1LL << 32) - 1);\n\n\tif (bucket >= ls->ls_rsbtbl_size)\n\t\treturn NULL;\n\n\tri = kzalloc(sizeof(struct rsbtbl_iter), GFP_NOFS);\n\tif (!ri)\n\t\treturn NULL;\n\tif (n == 0)\n\t\tri->header = 1;\n\tif (seq->op == &format1_seq_ops)\n\t\tri->format = 1;\n\tif (seq->op == &format2_seq_ops)\n\t\tri->format = 2;\n\tif (seq->op == &format3_seq_ops)\n\t\tri->format = 3;\n\tif (seq->op == &format4_seq_ops)\n\t\tri->format = 4;\n\n\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tif (!RB_EMPTY_ROOT(tree)) {\n\t\tfor (node = rb_first(tree); node; node = rb_next(node)) {\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tif (!entry--) {\n\t\t\t\tdlm_hold_rsb(r);\n\t\t\t\tri->rsb = r;\n\t\t\t\tri->bucket = bucket;\n\t\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t\treturn ri;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\t/*\n\t * move to the first rsb in the next non-empty bucket\n\t */\n\n\t/* zero the entry */\n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnode = rb_first(tree);\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}"
  },
  {
    "function_name": "table_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "383-415",
    "snippet": "static int table_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tswitch (ri->format) {\n\tcase 1:\n\t\tprint_format1(ri->rsb, seq);\n\t\tbreak;\n\tcase 2:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"id nodeid remid pid xid exflags flags sts grmode rqmode time_ms r_nodeid r_len r_name\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format2(ri->rsb, seq);\n\t\tbreak;\n\tcase 3:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version rsb 1.1 lvb 1.1 lkb 1.1\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format3(ri->rsb, seq);\n\t\tbreak;\n\tcase 4:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version 4 rsb 2\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format4(ri->rsb, seq);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_format4",
          "args": [
            "ri->rsb",
            "seq"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "print_format4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "333-367",
          "snippet": "static void print_format4(struct dlm_rsb *r, struct seq_file *s)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\tint print_name = 1;\n\tint i;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %d %d %d %lu %lx %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_master_nodeid,\n\t\t   r->res_dir_nodeid,\n\t\t   our_nodeid,\n\t\t   r->res_toss_time,\n\t\t   r->res_flags,\n\t\t   r->res_length);\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\tunlock_rsb(r);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format4(struct dlm_rsb *r, struct seq_file *s)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\tint print_name = 1;\n\tint i;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %d %d %d %lu %lx %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_master_nodeid,\n\t\t   r->res_dir_nodeid,\n\t\t   our_nodeid,\n\t\t   r->res_toss_time,\n\t\t   r->res_flags,\n\t\t   r->res_length);\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\tunlock_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"version 4 rsb 2\\n\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_format3",
          "args": [
            "ri->rsb",
            "seq"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "print_format3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "257-331",
          "snippet": "static void print_format3(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = r->res_ls->ls_lvblen;\n\tint print_name = 1;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %x %lx %d %d %u %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_first_lkid,\n\t\t   r->res_flags,\n\t\t   !list_empty(&r->res_root_list),\n\t\t   !list_empty(&r->res_recover_list),\n\t\t   r->res_recover_locks_count,\n\t\t   r->res_length);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tif (!r->res_lvbptr)\n\t\tgoto do_locks;\n\n\tseq_printf(s, \"lvb %u %d\", r->res_lvbseq, lvblen);\n\n\tfor (i = 0; i < lvblen; i++)\n\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_lvbptr[i]);\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n do_locks:\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\n\t\tprint_format3_lock(s, lkb, 1);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format3(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = r->res_ls->ls_lvblen;\n\tint print_name = 1;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %x %lx %d %d %u %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_first_lkid,\n\t\t   r->res_flags,\n\t\t   !list_empty(&r->res_root_list),\n\t\t   !list_empty(&r->res_recover_list),\n\t\t   r->res_recover_locks_count,\n\t\t   r->res_length);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tif (!r->res_lvbptr)\n\t\tgoto do_locks;\n\n\tseq_printf(s, \"lvb %u %d\", r->res_lvbseq, lvblen);\n\n\tfor (i = 0; i < lvblen; i++)\n\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_lvbptr[i]);\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n do_locks:\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\n\t\tprint_format3_lock(s, lkb, 1);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_format2",
          "args": [
            "ri->rsb",
            "seq"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "print_format2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "201-226",
          "snippet": "static void print_format2(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format2(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_format1",
          "args": [
            "ri->rsb",
            "seq"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "print_format1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "74-165",
          "snippet": "static void print_format1(struct dlm_rsb *res, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\n\n\tlock_rsb(res);\n\n\tseq_printf(s, \"\\nResource %p Name (len=%d) \\\"\", res, res->res_length);\n\n\tfor (i = 0; i < res->res_length; i++) {\n\t\tif (isprint(res->res_name[i]))\n\t\t\tseq_printf(s, \"%c\", res->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%c\", '.');\n\t}\n\n\tif (res->res_nodeid > 0)\n\t\tseq_printf(s, \"\\\"\\nLocal Copy, Master is node %d\\n\",\n\t\t\t   res->res_nodeid);\n\telse if (res->res_nodeid == 0)\n\t\tseq_puts(s, \"\\\"\\nMaster Copy\\n\");\n\telse if (res->res_nodeid == -1)\n\t\tseq_printf(s, \"\\\"\\nLooking up master (lkid %x)\\n\",\n\t\t\t   res->res_first_lkid);\n\telse\n\t\tseq_printf(s, \"\\\"\\nInvalid master %d\\n\", res->res_nodeid);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Print the LVB: */\n\tif (res->res_lvbptr) {\n\t\tseq_puts(s, \"LVB: \");\n\t\tfor (i = 0; i < lvblen; i++) {\n\t\t\tif (i == lvblen / 2)\n\t\t\t\tseq_puts(s, \"\\n     \");\n\t\t\tseq_printf(s, \"%02x \",\n\t\t\t\t   (unsigned char) res->res_lvbptr[i]);\n\t\t}\n\t\tif (rsb_flag(res, RSB_VALNOTVALID))\n\t\t\tseq_puts(s, \" (INVALID)\");\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\troot_list = !list_empty(&res->res_root_list);\n\trecover_list = !list_empty(&res->res_recover_list);\n\n\tif (root_list || recover_list) {\n\t\tseq_printf(s, \"Recovery: root %d recover %d flags %lx count %d\\n\",\n\t\t\t   root_list, recover_list,\n\t\t\t   res->res_flags, res->res_recover_locks_count);\n\t}\n\n\t/* Print the locks attached to this resource */\n\tseq_puts(s, \"Granted Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Conversion Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Waiting Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tif (list_empty(&res->res_lookup))\n\t\tgoto out;\n\n\tseq_puts(s, \"Lookup Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\n\t\tseq_printf(s, \"%08x %s\",\n\t\t\t   lkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\n\t\tif (lkb->lkb_wait_type)\n\t\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(res);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format1(struct dlm_rsb *res, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\n\n\tlock_rsb(res);\n\n\tseq_printf(s, \"\\nResource %p Name (len=%d) \\\"\", res, res->res_length);\n\n\tfor (i = 0; i < res->res_length; i++) {\n\t\tif (isprint(res->res_name[i]))\n\t\t\tseq_printf(s, \"%c\", res->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%c\", '.');\n\t}\n\n\tif (res->res_nodeid > 0)\n\t\tseq_printf(s, \"\\\"\\nLocal Copy, Master is node %d\\n\",\n\t\t\t   res->res_nodeid);\n\telse if (res->res_nodeid == 0)\n\t\tseq_puts(s, \"\\\"\\nMaster Copy\\n\");\n\telse if (res->res_nodeid == -1)\n\t\tseq_printf(s, \"\\\"\\nLooking up master (lkid %x)\\n\",\n\t\t\t   res->res_first_lkid);\n\telse\n\t\tseq_printf(s, \"\\\"\\nInvalid master %d\\n\", res->res_nodeid);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Print the LVB: */\n\tif (res->res_lvbptr) {\n\t\tseq_puts(s, \"LVB: \");\n\t\tfor (i = 0; i < lvblen; i++) {\n\t\t\tif (i == lvblen / 2)\n\t\t\t\tseq_puts(s, \"\\n     \");\n\t\t\tseq_printf(s, \"%02x \",\n\t\t\t\t   (unsigned char) res->res_lvbptr[i]);\n\t\t}\n\t\tif (rsb_flag(res, RSB_VALNOTVALID))\n\t\t\tseq_puts(s, \" (INVALID)\");\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\troot_list = !list_empty(&res->res_root_list);\n\trecover_list = !list_empty(&res->res_recover_list);\n\n\tif (root_list || recover_list) {\n\t\tseq_printf(s, \"Recovery: root %d recover %d flags %lx count %d\\n\",\n\t\t\t   root_list, recover_list,\n\t\t\t   res->res_flags, res->res_recover_locks_count);\n\t}\n\n\t/* Print the locks attached to this resource */\n\tseq_puts(s, \"Granted Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Conversion Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Waiting Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tif (list_empty(&res->res_lookup))\n\t\tgoto out;\n\n\tseq_puts(s, \"Lookup Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\n\t\tseq_printf(s, \"%08x %s\",\n\t\t\t   lkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\n\t\tif (lkb->lkb_wait_type)\n\t\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(res);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic int table_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tswitch (ri->format) {\n\tcase 1:\n\t\tprint_format1(ri->rsb, seq);\n\t\tbreak;\n\tcase 2:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"id nodeid remid pid xid exflags flags sts grmode rqmode time_ms r_nodeid r_len r_name\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format2(ri->rsb, seq);\n\t\tbreak;\n\tcase 3:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version rsb 1.1 lvb 1.1 lkb 1.1\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format3(ri->rsb, seq);\n\t\tbreak;\n\tcase 4:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version 4 rsb 2\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format4(ri->rsb, seq);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_format4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "333-367",
    "snippet": "static void print_format4(struct dlm_rsb *r, struct seq_file *s)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\tint print_name = 1;\n\tint i;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %d %d %d %lu %lx %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_master_nodeid,\n\t\t   r->res_dir_nodeid,\n\t\t   our_nodeid,\n\t\t   r->res_toss_time,\n\t\t   r->res_flags,\n\t\t   r->res_length);\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\tunlock_rsb(r);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\" %02x\"",
            "(unsigned char)r->res_name[i]"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "r->res_name[i]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "r->res_name[i]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format4(struct dlm_rsb *r, struct seq_file *s)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\tint print_name = 1;\n\tint i;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %d %d %d %lu %lx %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_master_nodeid,\n\t\t   r->res_dir_nodeid,\n\t\t   our_nodeid,\n\t\t   r->res_toss_time,\n\t\t   r->res_flags,\n\t\t   r->res_length);\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\tunlock_rsb(r);\n}"
  },
  {
    "function_name": "print_format3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "257-331",
    "snippet": "static void print_format3(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = r->res_ls->ls_lvblen;\n\tint print_name = 1;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %x %lx %d %d %u %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_first_lkid,\n\t\t   r->res_flags,\n\t\t   !list_empty(&r->res_root_list),\n\t\t   !list_empty(&r->res_recover_list),\n\t\t   r->res_recover_locks_count,\n\t\t   r->res_length);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tif (!r->res_lvbptr)\n\t\tgoto do_locks;\n\n\tseq_printf(s, \"lvb %u %d\", r->res_lvbseq, lvblen);\n\n\tfor (i = 0; i < lvblen; i++)\n\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_lvbptr[i]);\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n do_locks:\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\n\t\tprint_format3_lock(s, lkb, 1);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_format3_lock",
          "args": [
            "s",
            "lkb",
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "print_format3_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "228-255",
          "snippet": "static void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t      int rsb_lookup)\n{\n\tu64 xid = 0;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\tseq_printf(s, \"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   lkb->lkb_last_bast.mode,\n\t\t   rsb_lookup,\n\t\t   lkb->lkb_wait_type,\n\t\t   lkb->lkb_lvbseq,\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t      int rsb_lookup)\n{\n\tu64 xid = 0;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\tseq_printf(s, \"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   lkb->lkb_last_bast.mode,\n\t\t   rsb_lookup,\n\t\t   lkb->lkb_wait_type,\n\t\t   lkb->lkb_lvbseq,\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_lookup",
            "lkb_rsb_lookup"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_waitqueue",
            "lkb_statequeue"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\" %02x\"",
            "(unsigned char)r->res_lvbptr[i]"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "r->res_name[i]"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "r->res_name[i]"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format3(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = r->res_ls->ls_lvblen;\n\tint print_name = 1;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %x %lx %d %d %u %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_first_lkid,\n\t\t   r->res_flags,\n\t\t   !list_empty(&r->res_root_list),\n\t\t   !list_empty(&r->res_recover_list),\n\t\t   r->res_recover_locks_count,\n\t\t   r->res_length);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tif (!r->res_lvbptr)\n\t\tgoto do_locks;\n\n\tseq_printf(s, \"lvb %u %d\", r->res_lvbseq, lvblen);\n\n\tfor (i = 0; i < lvblen; i++)\n\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_lvbptr[i]);\n\tseq_puts(s, \"\\n\");\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n do_locks:\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\n\t\tprint_format3_lock(s, lkb, 1);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}"
  },
  {
    "function_name": "print_format3_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "228-255",
    "snippet": "static void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t      int rsb_lookup)\n{\n\tu64 xid = 0;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\tseq_printf(s, \"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   lkb->lkb_last_bast.mode,\n\t\t   rsb_lookup,\n\t\t   lkb->lkb_wait_type,\n\t\t   lkb->lkb_lvbseq,\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\"",
            "lkb->lkb_id",
            "lkb->lkb_nodeid",
            "lkb->lkb_remid",
            "lkb->lkb_ownpid",
            "(unsigned long long)xid",
            "lkb->lkb_exflags",
            "lkb->lkb_flags",
            "lkb->lkb_status",
            "lkb->lkb_grmode",
            "lkb->lkb_rqmode",
            "lkb->lkb_last_bast.mode",
            "rsb_lookup",
            "lkb->lkb_wait_type",
            "lkb->lkb_lvbseq",
            "(unsigned long long)ktime_to_ns(lkb->lkb_timestamp)",
            "(unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "lkb->lkb_last_bast_time"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "lkb->lkb_timestamp"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t      int rsb_lookup)\n{\n\tu64 xid = 0;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\tseq_printf(s, \"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   lkb->lkb_last_bast.mode,\n\t\t   rsb_lookup,\n\t\t   lkb->lkb_wait_type,\n\t\t   lkb->lkb_lvbseq,\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\n}"
  },
  {
    "function_name": "print_format2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "201-226",
    "snippet": "static void print_format2(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_format2_lock",
          "args": [
            "s",
            "lkb",
            "r"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "print_format2_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "167-199",
          "snippet": "static void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *r)\n{\n\tu64 xid = 0;\n\tu64 us;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\t/* microseconds since lkb was added to current queue */\n\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\n\n\t/* id nodeid remid pid xid exflags flags sts grmode rqmode time_us\n\t   r_nodeid r_len r_name */\n\n\tseq_printf(s, \"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   (unsigned long long)us,\n\t\t   r->res_nodeid,\n\t\t   r->res_length,\n\t\t   r->res_name);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *r)\n{\n\tu64 xid = 0;\n\tu64 us;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\t/* microseconds since lkb was added to current queue */\n\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\n\n\t/* id nodeid remid pid xid exflags flags sts grmode rqmode time_us\n\t   r_nodeid r_len r_name */\n\n\tseq_printf(s, \"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   (unsigned long long)us,\n\t\t   r->res_nodeid,\n\t\t   r->res_length,\n\t\t   r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_waitqueue",
            "lkb_statequeue"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format2(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}"
  },
  {
    "function_name": "print_format2_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "167-199",
    "snippet": "static void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *r)\n{\n\tu64 xid = 0;\n\tu64 us;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\t/* microseconds since lkb was added to current queue */\n\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\n\n\t/* id nodeid remid pid xid exflags flags sts grmode rqmode time_us\n\t   r_nodeid r_len r_name */\n\n\tseq_printf(s, \"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   (unsigned long long)us,\n\t\t   r->res_nodeid,\n\t\t   r->res_length,\n\t\t   r->res_name);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\"",
            "lkb->lkb_id",
            "lkb->lkb_nodeid",
            "lkb->lkb_remid",
            "lkb->lkb_ownpid",
            "(unsigned long long)xid",
            "lkb->lkb_exflags",
            "lkb->lkb_flags",
            "lkb->lkb_status",
            "lkb->lkb_grmode",
            "lkb->lkb_rqmode",
            "(unsigned long long)us",
            "r->res_nodeid",
            "r->res_length",
            "r->res_name"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "ktime_sub(ktime_get(), lkb->lkb_timestamp)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "lkb->lkb_timestamp"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *r)\n{\n\tu64 xid = 0;\n\tu64 us;\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\t/* microseconds since lkb was added to current queue */\n\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\n\n\t/* id nodeid remid pid xid exflags flags sts grmode rqmode time_us\n\t   r_nodeid r_len r_name */\n\n\tseq_printf(s, \"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   lkb->lkb_flags,\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   (unsigned long long)us,\n\t\t   r->res_nodeid,\n\t\t   r->res_length,\n\t\t   r->res_name);\n}"
  },
  {
    "function_name": "print_format1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "74-165",
    "snippet": "static void print_format1(struct dlm_rsb *res, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\n\n\tlock_rsb(res);\n\n\tseq_printf(s, \"\\nResource %p Name (len=%d) \\\"\", res, res->res_length);\n\n\tfor (i = 0; i < res->res_length; i++) {\n\t\tif (isprint(res->res_name[i]))\n\t\t\tseq_printf(s, \"%c\", res->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%c\", '.');\n\t}\n\n\tif (res->res_nodeid > 0)\n\t\tseq_printf(s, \"\\\"\\nLocal Copy, Master is node %d\\n\",\n\t\t\t   res->res_nodeid);\n\telse if (res->res_nodeid == 0)\n\t\tseq_puts(s, \"\\\"\\nMaster Copy\\n\");\n\telse if (res->res_nodeid == -1)\n\t\tseq_printf(s, \"\\\"\\nLooking up master (lkid %x)\\n\",\n\t\t\t   res->res_first_lkid);\n\telse\n\t\tseq_printf(s, \"\\\"\\nInvalid master %d\\n\", res->res_nodeid);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Print the LVB: */\n\tif (res->res_lvbptr) {\n\t\tseq_puts(s, \"LVB: \");\n\t\tfor (i = 0; i < lvblen; i++) {\n\t\t\tif (i == lvblen / 2)\n\t\t\t\tseq_puts(s, \"\\n     \");\n\t\t\tseq_printf(s, \"%02x \",\n\t\t\t\t   (unsigned char) res->res_lvbptr[i]);\n\t\t}\n\t\tif (rsb_flag(res, RSB_VALNOTVALID))\n\t\t\tseq_puts(s, \" (INVALID)\");\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\troot_list = !list_empty(&res->res_root_list);\n\trecover_list = !list_empty(&res->res_recover_list);\n\n\tif (root_list || recover_list) {\n\t\tseq_printf(s, \"Recovery: root %d recover %d flags %lx count %d\\n\",\n\t\t\t   root_list, recover_list,\n\t\t\t   res->res_flags, res->res_recover_locks_count);\n\t}\n\n\t/* Print the locks attached to this resource */\n\tseq_puts(s, \"Granted Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Conversion Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Waiting Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tif (list_empty(&res->res_lookup))\n\t\tgoto out;\n\n\tseq_puts(s, \"Lookup Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\n\t\tseq_printf(s, \"%08x %s\",\n\t\t\t   lkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\n\t\tif (lkb->lkb_wait_type)\n\t\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(res);\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "res"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\" wait_type: %d\"",
            "lkb->lkb_wait_type"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockmode",
          "args": [
            "lkb->lkb_rqmode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "29-49",
          "snippet": "static char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&res->res_lookup",
            "lkb_rsb_lookup"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->res_lookup"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_format1_lock",
          "args": [
            "s",
            "lkb",
            "res"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "print_format1_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "51-72",
          "snippet": "static void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *res)\n{\n\tseq_printf(s, \"%08x %s\", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\n\n\tif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\n\t    lkb->lkb_status == DLM_LKSTS_WAITING)\n\t\tseq_printf(s, \" (%s)\", print_lockmode(lkb->lkb_rqmode));\n\n\tif (lkb->lkb_nodeid) {\n\t\tif (lkb->lkb_nodeid != res->res_nodeid)\n\t\t\tseq_printf(s, \" Remote: %3d %08x\", lkb->lkb_nodeid,\n\t\t\t\t   lkb->lkb_remid);\n\t\telse\n\t\t\tseq_printf(s, \" Master:     %08x\", lkb->lkb_remid);\n\t}\n\n\tif (lkb->lkb_wait_type)\n\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\n\tseq_puts(s, \"\\n\");\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *res)\n{\n\tseq_printf(s, \"%08x %s\", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\n\n\tif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\n\t    lkb->lkb_status == DLM_LKSTS_WAITING)\n\t\tseq_printf(s, \" (%s)\", print_lockmode(lkb->lkb_rqmode));\n\n\tif (lkb->lkb_nodeid) {\n\t\tif (lkb->lkb_nodeid != res->res_nodeid)\n\t\t\tseq_printf(s, \" Remote: %3d %08x\", lkb->lkb_nodeid,\n\t\t\t\t   lkb->lkb_remid);\n\t\telse\n\t\t\tseq_printf(s, \" Master:     %08x\", lkb->lkb_remid);\n\t}\n\n\tif (lkb->lkb_wait_type)\n\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\n\tseq_puts(s, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&res->res_waitqueue",
            "lkb_statequeue"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&res->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&res->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "res",
            "RSB_VALNOTVALID"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "res->res_name[i]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format1(struct dlm_rsb *res, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\n\n\tlock_rsb(res);\n\n\tseq_printf(s, \"\\nResource %p Name (len=%d) \\\"\", res, res->res_length);\n\n\tfor (i = 0; i < res->res_length; i++) {\n\t\tif (isprint(res->res_name[i]))\n\t\t\tseq_printf(s, \"%c\", res->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%c\", '.');\n\t}\n\n\tif (res->res_nodeid > 0)\n\t\tseq_printf(s, \"\\\"\\nLocal Copy, Master is node %d\\n\",\n\t\t\t   res->res_nodeid);\n\telse if (res->res_nodeid == 0)\n\t\tseq_puts(s, \"\\\"\\nMaster Copy\\n\");\n\telse if (res->res_nodeid == -1)\n\t\tseq_printf(s, \"\\\"\\nLooking up master (lkid %x)\\n\",\n\t\t\t   res->res_first_lkid);\n\telse\n\t\tseq_printf(s, \"\\\"\\nInvalid master %d\\n\", res->res_nodeid);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Print the LVB: */\n\tif (res->res_lvbptr) {\n\t\tseq_puts(s, \"LVB: \");\n\t\tfor (i = 0; i < lvblen; i++) {\n\t\t\tif (i == lvblen / 2)\n\t\t\t\tseq_puts(s, \"\\n     \");\n\t\t\tseq_printf(s, \"%02x \",\n\t\t\t\t   (unsigned char) res->res_lvbptr[i]);\n\t\t}\n\t\tif (rsb_flag(res, RSB_VALNOTVALID))\n\t\t\tseq_puts(s, \" (INVALID)\");\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\troot_list = !list_empty(&res->res_root_list);\n\trecover_list = !list_empty(&res->res_recover_list);\n\n\tif (root_list || recover_list) {\n\t\tseq_printf(s, \"Recovery: root %d recover %d flags %lx count %d\\n\",\n\t\t\t   root_list, recover_list,\n\t\t\t   res->res_flags, res->res_recover_locks_count);\n\t}\n\n\t/* Print the locks attached to this resource */\n\tseq_puts(s, \"Granted Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Conversion Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Waiting Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tif (list_empty(&res->res_lookup))\n\t\tgoto out;\n\n\tseq_puts(s, \"Lookup Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\n\t\tseq_printf(s, \"%08x %s\",\n\t\t\t   lkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\n\t\tif (lkb->lkb_wait_type)\n\t\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\t\tseq_puts(s, \"\\n\");\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(res);\n}"
  },
  {
    "function_name": "print_format1_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "51-72",
    "snippet": "static void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *res)\n{\n\tseq_printf(s, \"%08x %s\", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\n\n\tif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\n\t    lkb->lkb_status == DLM_LKSTS_WAITING)\n\t\tseq_printf(s, \" (%s)\", print_lockmode(lkb->lkb_rqmode));\n\n\tif (lkb->lkb_nodeid) {\n\t\tif (lkb->lkb_nodeid != res->res_nodeid)\n\t\t\tseq_printf(s, \" Remote: %3d %08x\", lkb->lkb_nodeid,\n\t\t\t\t   lkb->lkb_remid);\n\t\telse\n\t\t\tseq_printf(s, \" Master:     %08x\", lkb->lkb_remid);\n\t}\n\n\tif (lkb->lkb_wait_type)\n\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\n\tseq_puts(s, \"\\n\");\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\" wait_type: %d\"",
            "lkb->lkb_wait_type"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockmode",
          "args": [
            "lkb->lkb_rqmode"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "29-49",
          "snippet": "static char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *res)\n{\n\tseq_printf(s, \"%08x %s\", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\n\n\tif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\n\t    lkb->lkb_status == DLM_LKSTS_WAITING)\n\t\tseq_printf(s, \" (%s)\", print_lockmode(lkb->lkb_rqmode));\n\n\tif (lkb->lkb_nodeid) {\n\t\tif (lkb->lkb_nodeid != res->res_nodeid)\n\t\t\tseq_printf(s, \" Remote: %3d %08x\", lkb->lkb_nodeid,\n\t\t\t\t   lkb->lkb_remid);\n\t\telse\n\t\t\tseq_printf(s, \" Master:     %08x\", lkb->lkb_remid);\n\t}\n\n\tif (lkb->lkb_wait_type)\n\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\n\tseq_puts(s, \"\\n\");\n}"
  },
  {
    "function_name": "print_lockmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
    "lines": "29-49",
    "snippet": "static char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}",
    "includes": [
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}"
  }
]