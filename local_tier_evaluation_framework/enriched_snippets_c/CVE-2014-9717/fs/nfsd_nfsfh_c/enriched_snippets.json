[
  {
    "function_name": "fsid_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "666-692",
    "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "fhp->fh_export"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
  },
  {
    "function_name": "SVCFH_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "650-664",
    "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d: %08x %08x %08x %08x %08x %08x\"",
            "fh->fh_size",
            "fh->fh_base.fh_pad[0]",
            "fh->fh_base.fh_pad[1]",
            "fh->fh_base.fh_pad[2]",
            "fh->fh_base.fh_pad[3]",
            "fh->fh_base.fh_pad[4]",
            "fh->fh_base.fh_pad[5]"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
  },
  {
    "function_name": "fh_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "625-645",
    "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "fhp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "116-122",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "fhp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "282-290",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fh_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "591-620",
    "snippet": "__be32\nfh_update(struct svc_fh *fhp)\n{\n\tstruct dentry *dentry;\n\n\tif (!fhp->fh_dentry)\n\t\tgoto out_bad;\n\n\tdentry = fhp->fh_dentry;\n\tif (!dentry->d_inode)\n\t\tgoto out_negative;\n\tif (fhp->fh_handle.fh_version != 1) {\n\t\t_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);\n\t} else {\n\t\tif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\n\t\t\treturn 0;\n\n\t\t_fh_update(fhp, fhp->fh_export, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID)\n\t\t\treturn nfserr_opnotsupp;\n\t}\n\treturn 0;\nout_bad:\n\tprintk(KERN_ERR \"fh_update: fh not verified!\\n\");\n\treturn nfserr_serverfault;\nout_negative:\n\tprintk(KERN_ERR \"fh_update: %pd2 still negative!\\n\",\n\t\tdentry);\n\treturn nfserr_serverfault;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_update: %pd2 still negative!\\n\"",
            "dentry"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_fh_update",
          "args": [
            "fhp",
            "fhp->fh_export",
            "dentry"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "_fh_update_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "411-420",
          "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_update(struct svc_fh *fhp)\n{\n\tstruct dentry *dentry;\n\n\tif (!fhp->fh_dentry)\n\t\tgoto out_bad;\n\n\tdentry = fhp->fh_dentry;\n\tif (!dentry->d_inode)\n\t\tgoto out_negative;\n\tif (fhp->fh_handle.fh_version != 1) {\n\t\t_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);\n\t} else {\n\t\tif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\n\t\t\treturn 0;\n\n\t\t_fh_update(fhp, fhp->fh_export, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID)\n\t\t\treturn nfserr_opnotsupp;\n\t}\n\treturn 0;\nout_bad:\n\tprintk(KERN_ERR \"fh_update: fh not verified!\\n\");\n\treturn nfserr_serverfault;\nout_negative:\n\tprintk(KERN_ERR \"fh_update: %pd2 still negative!\\n\",\n\t\tdentry);\n\treturn nfserr_serverfault;\n}"
  },
  {
    "function_name": "fh_compose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "511-585",
    "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "fhp"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_fh_update",
          "args": [
            "fhp",
            "exp",
            "dentry"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "_fh_update_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "411-420",
          "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "fhp->fh_handle.fh_fsid_type",
            "fhp->fh_handle.fh_fsid",
            "ex_dev",
            "exp->ex_path.dentry->d_inode->i_ino",
            "exp->ex_fsid",
            "exp->ex_uuid"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "86-136",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fhp->fh_handle.fh_fsid_type"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_t_to_u32",
          "args": [
            "parent_ino(dentry)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ino_t_to_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "13-16",
          "snippet": "static inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_ino",
          "args": [
            "dentry"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "376-389",
          "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "ex_dev"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fhp->fh_handle.fh_base",
            "0",
            "NFS_FHSIZE"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "106-110",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\"",
            "fhp->fh_maxsize",
            "dentry"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_version_and_fsid_type",
          "args": [
            "fhp",
            "exp",
            "ref_fh"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "set_version_and_fsid_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "457-509",
          "snippet": "static void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\"",
            "MAJOR(ex_dev)",
            "MINOR(ex_dev)",
            "(long) exp->ex_path.dentry->d_inode->i_ino",
            "dentry",
            "(inode ? inode->i_ino : 0)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "ex_dev"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "ex_dev"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_version_and_fsid_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "457-509",
    "snippet": "static void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "exp_sb(exp)->s_dev"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_export",
          "args": [
            "exp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "422-425",
          "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsid_type_ok_for_exp",
          "args": [
            "fsid_type",
            "exp"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_type_ok_for_exp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "432-454",
          "snippet": "static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}"
  },
  {
    "function_name": "fsid_type_ok_for_exp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "432-454",
    "snippet": "static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_export",
          "args": [
            "exp"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "422-425",
          "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "exp_sb(exp)->s_dev"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "exp_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "427-430",
    "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_inode->i_sb;\n}"
  },
  {
    "function_name": "is_root_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "422-425",
    "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
  },
  {
    "function_name": "_fh_update_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "411-420",
    "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino_t_to_u32",
          "args": [
            "dentry->d_inode->i_ino"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ino_t_to_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "13-16",
          "snippet": "static inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\n\tfh->ofh_generation = dentry->d_inode->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
  },
  {
    "function_name": "_fh_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "391-406",
    "snippet": "static void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\n\t\tstruct dentry *dentry)\n{\n\tif (dentry != exp->ex_path.dentry) {\n\t\tstruct fid *fid = (struct fid *)\n\t\t\t(fhp->fh_handle.fh_fsid + fhp->fh_handle.fh_size/4 - 1);\n\t\tint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\n\t\tint subtreecheck = !(exp->ex_flags & NFSEXP_NOSUBTREECHECK);\n\n\t\tfhp->fh_handle.fh_fileid_type =\n\t\t\texportfs_encode_fh(dentry, fid, &maxsize, subtreecheck);\n\t\tfhp->fh_handle.fh_size += maxsize * 4;\n\t} else {\n\t\tfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\n\t}\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exportfs_encode_fh",
          "args": [
            "dentry",
            "fid",
            "&maxsize",
            "subtreecheck"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "389-409",
          "snippet": "int exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\n\t\tstruct dentry *dentry)\n{\n\tif (dentry != exp->ex_path.dentry) {\n\t\tstruct fid *fid = (struct fid *)\n\t\t\t(fhp->fh_handle.fh_fsid + fhp->fh_handle.fh_size/4 - 1);\n\t\tint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\n\t\tint subtreecheck = !(exp->ex_flags & NFSEXP_NOSUBTREECHECK);\n\n\t\tfhp->fh_handle.fh_fileid_type =\n\t\t\texportfs_encode_fh(dentry, fid, &maxsize, subtreecheck);\n\t\tfhp->fh_handle.fh_size += maxsize * 4;\n\t} else {\n\t\tfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\n\t}\n}"
  },
  {
    "function_name": "fh_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "303-381",
    "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\"",
            "dentry",
            "access",
            "ntohl(error)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "error"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_permission",
          "args": [
            "rqstp",
            "exp",
            "dentry",
            "access"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "2014-2094",
          "snippet": "__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = dentry->d_inode;\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = dentry->d_inode;\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_nfsd_access",
          "args": [
            "exp",
            "rqstp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "check_nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "939-959",
          "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_mode_check",
          "args": [
            "rqstp",
            "dentry->d_inode->i_mode",
            "type"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_mode_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "61-81",
          "snippet": "static inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setuser_and_check_port",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pseudo_root",
          "args": [
            "rqstp",
            "dentry",
            "exp"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "check_pseudo_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "100-128",
          "snippet": "static inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_set_fh_dentry",
          "args": [
            "rqstp",
            "fhp"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_set_fh_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "135-274",
          "snippet": "static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: fh_verify(%s)\\n\"",
            "SVCFH_fmt(fhp)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "fhp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
  },
  {
    "function_name": "nfsd_set_fh_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "135-274",
    "snippet": "static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\"",
            "dentry"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(dentry)"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_decode_fh",
          "args": [
            "exp->ex_path.mnt",
            "fid",
            "data_left",
            "fileid_type",
            "nfsd_acceptable",
            "exp"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "412-541",
          "snippet": "struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "exp->ex_path.dentry"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setuser_and_check_port",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_creds(new)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "new"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise_nfsd_set",
          "args": [
            "new->cap_effective",
            "new->cap_permitted"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_exp_find",
          "args": [
            "rqstp",
            "FSID_DEV",
            "tfh"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1001-1032",
          "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "FSID_DEV",
            "tfh",
            "xdev",
            "xino",
            "0",
            "NULL"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "86-136",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "u32_to_ino_t",
          "args": [
            "fh->ofh_xino"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "u32_to_ino_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "18-21",
          "snippet": "static inline ino_t u32_to_ino_t(__u32 uino)\n{\n\treturn (ino_t) uino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline ino_t u32_to_ino_t(__u32 uino)\n{\n\treturn (ino_t) uino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "fh->ofh_xdev"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1]))"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "ntohl((__force __be32)fh->fh_fsid[0])",
            "ntohl((__force __be32)fh->fh_fsid[1])"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(__force __be32)fh->fh_fsid[1]"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(__force __be32)fh->fh_fsid[0]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "FSID_ENCODE_DEV"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}"
  },
  {
    "function_name": "check_pseudo_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "100-128",
    "snippet": "static inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry != exp->ex_path.dentry"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_v4client",
          "args": [
            "rqstp"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_v4client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "108-111",
          "snippet": "static inline int nfsd_v4client(struct svc_rqst *rq)\n{\n\treturn rq->rq_prog == NFS_PROGRAM && rq->rq_vers == 4;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfsd_v4client(struct svc_rqst *rq)\n{\n\treturn rq->rq_prog == NFS_PROGRAM && rq->rq_vers == 4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd_setuser_and_check_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "83-98",
    "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nfsd_setuser(rqstp, exp)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setuser",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: request from insecure port %s!\\n\"",
            "svc_print_addr(rqstp, buf, sizeof(buf))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_print_addr",
          "args": [
            "rqstp",
            "buf",
            "sizeof(buf)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsexp_flags",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nfsexp_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/auth.c",
          "lines": "7-18",
          "snippet": "int nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn f->flags;\n\t}\n\treturn exp->ex_flags;\n\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"nfsd.h\"\n#include <linux/sched.h>\n\nint nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn f->flags;\n\t}\n\treturn exp->ex_flags;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
  },
  {
    "function_name": "nfsd_mode_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "61-81",
    "snippet": "static inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}"
  },
  {
    "function_name": "nfsd_acceptable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
    "lines": "26-54",
    "snippet": "static int nfsd_acceptable(void *expv, struct dentry *dentry)\n{\n\tstruct svc_export *exp = expv;\n\tint rv;\n\tstruct dentry *tdentry;\n\tstruct dentry *parent;\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\treturn 1;\n\n\ttdentry = dget(dentry);\n\twhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\n\t\t/* make sure parents give x permission to user */\n\t\tint err;\n\t\tparent = dget_parent(tdentry);\n\t\terr = inode_permission(parent->d_inode, MAY_EXEC);\n\t\tif (err < 0) {\n\t\t\tdput(parent);\n\t\t\tbreak;\n\t\t}\n\t\tdput(tdentry);\n\t\ttdentry = parent;\n\t}\n\tif (tdentry != exp->ex_path.dentry)\n\t\tdprintk(\"nfsd_acceptable failed at %p %pd\\n\", tdentry, tdentry);\n\trv = (tdentry == exp->ex_path.dentry);\n\tdput(tdentry);\n\treturn rv;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "tdentry"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_acceptable failed at %p %pd\\n\"",
            "tdentry",
            "tdentry"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "parent->d_inode",
            "MAY_EXEC"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "tdentry"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "tdentry"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic int nfsd_acceptable(void *expv, struct dentry *dentry)\n{\n\tstruct svc_export *exp = expv;\n\tint rv;\n\tstruct dentry *tdentry;\n\tstruct dentry *parent;\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\treturn 1;\n\n\ttdentry = dget(dentry);\n\twhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\n\t\t/* make sure parents give x permission to user */\n\t\tint err;\n\t\tparent = dget_parent(tdentry);\n\t\terr = inode_permission(parent->d_inode, MAY_EXEC);\n\t\tif (err < 0) {\n\t\t\tdput(parent);\n\t\t\tbreak;\n\t\t}\n\t\tdput(tdentry);\n\t\ttdentry = parent;\n\t}\n\tif (tdentry != exp->ex_path.dentry)\n\t\tdprintk(\"nfsd_acceptable failed at %p %pd\\n\", tdentry, tdentry);\n\trv = (tdentry == exp->ex_path.dentry);\n\tdput(tdentry);\n\treturn rv;\n}"
  }
]