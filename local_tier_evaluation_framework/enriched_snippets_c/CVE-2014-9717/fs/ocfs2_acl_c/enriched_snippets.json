[
  {
    "function_name": "ocfs2_iop_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "290-310",
    "snippet": "struct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct ocfs2_super *osb;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct posix_acl *acl;\n\tint ret = -EAGAIN;\n\n\tosb = OCFS2_SB(inode->i_sb);\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn NULL;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tacl = ocfs2_get_acl_nolock(inode, type, di_bh);\n\n\tbrelse(di_bh);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_acl_nolock",
          "args": [
            "inode",
            "type",
            "di_bh"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_acl_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "122-161",
          "snippet": "static struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstruct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct ocfs2_super *osb;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct posix_acl *acl;\n\tint ret = -EAGAIN;\n\n\tosb = OCFS2_SB(inode->i_sb);\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn NULL;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tacl = ocfs2_get_acl_nolock(inode, type, di_bh);\n\n\tbrelse(di_bh);\n\n\treturn acl;\n}"
  },
  {
    "function_name": "ocfs2_iop_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "285-288",
    "snippet": "int ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_acl",
          "args": [
            "NULL",
            "inode",
            "NULL",
            "type",
            "acl",
            "NULL",
            "NULL"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "224-283",
          "snippet": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);\n}"
  },
  {
    "function_name": "ocfs2_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "224-283",
    "snippet": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_set",
          "args": [
            "inode",
            "name_index",
            "\"\"",
            "value",
            "size",
            "0"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3512-3661",
          "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "name_index",
            "\"\"",
            "value",
            "size",
            "0",
            "meta_ac",
            "data_ac"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3429-3503",
          "snippet": "int ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "value"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "value"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_acl_to_xattr",
          "args": [
            "acl",
            "&size"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "87-120",
          "snippet": "static void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_acl_set_mode",
          "args": [
            "inode",
            "di_bh",
            "handle",
            "mode"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_acl_set_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "168-219",
          "snippet": "static int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&mode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_acl_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "168-219",
    "snippet": "static int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "handle"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "di_bh"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_acl_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "122-161",
    "snippet": "static struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_acl_from_xattr",
          "args": [
            "value",
            "retval"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "43-82",
          "snippet": "static struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_nolock",
          "args": [
            "inode",
            "di_bh",
            "name_index",
            "\"\"",
            "value",
            "retval"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1266-1299",
          "snippet": "int ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nint ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "retval",
            "GFP_NOFS"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}"
  },
  {
    "function_name": "ocfs2_acl_to_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "87-120",
    "snippet": "static void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ACL_UNDEFINED_ID"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "acl->a_entries[n].e_gid"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "acl->a_entries[n].e_uid"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[n].e_perm"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[n].e_tag"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "*size",
            "GFP_NOFS"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}"
  },
  {
    "function_name": "ocfs2_acl_from_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
    "lines": "43-82",
    "snippet": "static struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_perm"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_NOFS"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}"
  }
]