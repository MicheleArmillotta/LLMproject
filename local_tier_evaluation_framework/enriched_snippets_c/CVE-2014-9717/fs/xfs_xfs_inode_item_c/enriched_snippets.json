[
  {
    "function_name": "xfs_inode_item_format_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "748-789",
    "snippet": "int\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "in_f->ilf_u.ilfu_uuid.__u_bits",
            "in_f64->ilf_u.ilfu_uuid.__u_bits",
            "sizeof(uuid_t)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "in_f->ilf_u.ilfu_uuid.__u_bits",
            "in_f32->ilf_u.ilfu_uuid.__u_bits",
            "sizeof(uuid_t)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}"
  },
  {
    "function_name": "xfs_istale_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "736-742",
    "snippet": "void\nxfs_istale_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_iflush_abort(INODE_ITEM(lip)->ili_inode, true);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iflush_abort",
          "args": [
            "INODE_ITEM(lip)->ili_inode",
            "true"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "698-734",
          "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_istale_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_iflush_abort(INODE_ITEM(lip)->ili_inode, true);\n}"
  },
  {
    "function_name": "xfs_iflush_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "698-734",
    "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "ip"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "&iip->ili_item",
            "stale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
  },
  {
    "function_name": "xfs_iflush_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "596-690",
    "snippet": "void\nxfs_iflush_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip;\n\tstruct xfs_log_item\t*blip;\n\tstruct xfs_log_item\t*next;\n\tstruct xfs_log_item\t*prev;\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\tint\t\t\tneed_ail = 0;\n\n\t/*\n\t * Scan the buffer IO completions for other inodes being completed and\n\t * attach them to the current inode log item.\n\t */\n\tblip = bp->b_fspriv;\n\tprev = NULL;\n\twhile (blip != NULL) {\n\t\tif (blip->li_cb != xfs_iflush_done) {\n\t\t\tprev = blip;\n\t\t\tblip = blip->li_bio_list;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove from list */\n\t\tnext = blip->li_bio_list;\n\t\tif (!prev) {\n\t\t\tbp->b_fspriv = next;\n\t\t} else {\n\t\t\tprev->li_bio_list = next;\n\t\t}\n\n\t\t/* add to current list */\n\t\tblip->li_bio_list = lip->li_bio_list;\n\t\tlip->li_bio_list = blip;\n\n\t\t/*\n\t\t * while we have the item, do the unlocked check for needing\n\t\t * the AIL lock.\n\t\t */\n\t\tiip = INODE_ITEM(blip);\n\t\tif (iip->ili_logged && blip->li_lsn == iip->ili_flush_lsn)\n\t\t\tneed_ail++;\n\n\t\tblip = next;\n\t}\n\n\t/* make sure we capture the state of the initial inode. */\n\tiip = INODE_ITEM(lip);\n\tif (iip->ili_logged && lip->li_lsn == iip->ili_flush_lsn)\n\t\tneed_ail++;\n\n\t/*\n\t * We only want to pull the item from the AIL if it is\n\t * actually there and its location in the log has not\n\t * changed since we started the flush.  Thus, we only bother\n\t * if the ili_logged flag is set and the inode's lsn has not\n\t * changed.  First we check the lsn outside\n\t * the lock since it's cheaper, and then we recheck while\n\t * holding the lock before removing the inode from the AIL.\n\t */\n\tif (need_ail) {\n\t\tstruct xfs_log_item *log_items[need_ail];\n\t\tint i = 0;\n\t\tspin_lock(&ailp->xa_lock);\n\t\tfor (blip = lip; blip; blip = blip->li_bio_list) {\n\t\t\tiip = INODE_ITEM(blip);\n\t\t\tif (iip->ili_logged &&\n\t\t\t    blip->li_lsn == iip->ili_flush_lsn) {\n\t\t\t\tlog_items[i++] = blip;\n\t\t\t}\n\t\t\tASSERT(i <= need_ail);\n\t\t}\n\t\t/* xfs_trans_ail_delete_bulk() drops the AIL lock. */\n\t\txfs_trans_ail_delete_bulk(ailp, log_items, i,\n\t\t\t\t\t  SHUTDOWN_CORRUPT_INCORE);\n\t}\n\n\n\t/*\n\t * clean up and unlock the flush lock now we are done. We can clear the\n\t * ili_last_fields bits now that we know that the data corresponding to\n\t * them is safely on disk.\n\t */\n\tfor (blip = lip; blip; blip = next) {\n\t\tnext = blip->li_bio_list;\n\t\tblip->li_bio_list = NULL;\n\n\t\tiip = INODE_ITEM(blip);\n\t\tiip->ili_logged = 0;\n\t\tiip->ili_last_fields = 0;\n\t\txfs_ifunlock(iip->ili_inode);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "iip->ili_inode"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "blip"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete_bulk",
          "args": [
            "ailp",
            "log_items",
            "i",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "707-754",
          "snippet": "void\nxfs_trans_ail_delete_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\tint\t\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (!(lip->li_flags & XFS_LI_IN_AIL)) {\n\t\t\tstruct xfs_mount\t*mp = ailp->xa_mount;\n\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\t\txfs_alert_tag(mp, XFS_PTAG_AILDELETE,\n\t\t\"%s: attempting to delete a log item that is not in the AIL\",\n\t\t\t\t\t\t__func__);\n\t\t\t\txfs_force_shutdown(mp, shutdown_type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\n\t\txfs_ail_delete(ailp, lip);\n\t\tlip->li_flags &= ~XFS_LI_IN_AIL;\n\t\tlip->li_lsn = 0;\n\t\tif (mlip == lip)\n\t\t\tmlip_changed = 1;\n\t}\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tif (list_empty(&ailp->xa_ail))\n\t\t\twake_up_all(&ailp->xa_empty);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_delete_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\tint\t\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (!(lip->li_flags & XFS_LI_IN_AIL)) {\n\t\t\tstruct xfs_mount\t*mp = ailp->xa_mount;\n\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\t\txfs_alert_tag(mp, XFS_PTAG_AILDELETE,\n\t\t\"%s: attempting to delete a log item that is not in the AIL\",\n\t\t\t\t\t\t__func__);\n\t\t\t\txfs_force_shutdown(mp, shutdown_type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\n\t\txfs_ail_delete(ailp, lip);\n\t\tlip->li_flags &= ~XFS_LI_IN_AIL;\n\t\tlip->li_lsn = 0;\n\t\tif (mlip == lip)\n\t\t\tmlip_changed = 1;\n\t}\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tif (list_empty(&ailp->xa_ail))\n\t\t\twake_up_all(&ailp->xa_empty);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i <= need_ail"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip;\n\tstruct xfs_log_item\t*blip;\n\tstruct xfs_log_item\t*next;\n\tstruct xfs_log_item\t*prev;\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\tint\t\t\tneed_ail = 0;\n\n\t/*\n\t * Scan the buffer IO completions for other inodes being completed and\n\t * attach them to the current inode log item.\n\t */\n\tblip = bp->b_fspriv;\n\tprev = NULL;\n\twhile (blip != NULL) {\n\t\tif (blip->li_cb != xfs_iflush_done) {\n\t\t\tprev = blip;\n\t\t\tblip = blip->li_bio_list;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove from list */\n\t\tnext = blip->li_bio_list;\n\t\tif (!prev) {\n\t\t\tbp->b_fspriv = next;\n\t\t} else {\n\t\t\tprev->li_bio_list = next;\n\t\t}\n\n\t\t/* add to current list */\n\t\tblip->li_bio_list = lip->li_bio_list;\n\t\tlip->li_bio_list = blip;\n\n\t\t/*\n\t\t * while we have the item, do the unlocked check for needing\n\t\t * the AIL lock.\n\t\t */\n\t\tiip = INODE_ITEM(blip);\n\t\tif (iip->ili_logged && blip->li_lsn == iip->ili_flush_lsn)\n\t\t\tneed_ail++;\n\n\t\tblip = next;\n\t}\n\n\t/* make sure we capture the state of the initial inode. */\n\tiip = INODE_ITEM(lip);\n\tif (iip->ili_logged && lip->li_lsn == iip->ili_flush_lsn)\n\t\tneed_ail++;\n\n\t/*\n\t * We only want to pull the item from the AIL if it is\n\t * actually there and its location in the log has not\n\t * changed since we started the flush.  Thus, we only bother\n\t * if the ili_logged flag is set and the inode's lsn has not\n\t * changed.  First we check the lsn outside\n\t * the lock since it's cheaper, and then we recheck while\n\t * holding the lock before removing the inode from the AIL.\n\t */\n\tif (need_ail) {\n\t\tstruct xfs_log_item *log_items[need_ail];\n\t\tint i = 0;\n\t\tspin_lock(&ailp->xa_lock);\n\t\tfor (blip = lip; blip; blip = blip->li_bio_list) {\n\t\t\tiip = INODE_ITEM(blip);\n\t\t\tif (iip->ili_logged &&\n\t\t\t    blip->li_lsn == iip->ili_flush_lsn) {\n\t\t\t\tlog_items[i++] = blip;\n\t\t\t}\n\t\t\tASSERT(i <= need_ail);\n\t\t}\n\t\t/* xfs_trans_ail_delete_bulk() drops the AIL lock. */\n\t\txfs_trans_ail_delete_bulk(ailp, log_items, i,\n\t\t\t\t\t  SHUTDOWN_CORRUPT_INCORE);\n\t}\n\n\n\t/*\n\t * clean up and unlock the flush lock now we are done. We can clear the\n\t * ili_last_fields bits now that we know that the data corresponding to\n\t * them is safely on disk.\n\t */\n\tfor (blip = lip; blip; blip = next) {\n\t\tnext = blip->li_bio_list;\n\t\tblip->li_bio_list = NULL;\n\n\t\tiip = INODE_ITEM(blip);\n\t\tiip->ili_logged = 0;\n\t\tiip->ili_last_fields = 0;\n\t\txfs_ifunlock(iip->ili_inode);\n\t}\n}"
  },
  {
    "function_name": "xfs_inode_item_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "576-581",
    "snippet": "void\nxfs_inode_item_destroy(\n\txfs_inode_t\t*ip)\n{\n\tkmem_zone_free(xfs_ili_zone, ip->i_itemp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_ili_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_ili_zone",
            "ip->i_itemp"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_ili_zone;\n\nvoid\nxfs_inode_item_destroy(\n\txfs_inode_t\t*ip)\n{\n\tkmem_zone_free(xfs_ili_zone, ip->i_itemp);\n}"
  },
  {
    "function_name": "xfs_inode_item_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "558-571",
    "snippet": "void\nxfs_inode_item_init(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_inode_log_item *iip;\n\n\tASSERT(ip->i_itemp == NULL);\n\tiip = ip->i_itemp = kmem_zone_zalloc(xfs_ili_zone, KM_SLEEP);\n\n\tiip->ili_inode = ip;\n\txfs_log_item_init(mp, &iip->ili_item, XFS_LI_INODE,\n\t\t\t\t\t\t&xfs_inode_item_ops);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_ili_zone;",
      "static const struct xfs_item_ops xfs_inode_item_ops = {\n\t.iop_size\t= xfs_inode_item_size,\n\t.iop_format\t= xfs_inode_item_format,\n\t.iop_pin\t= xfs_inode_item_pin,\n\t.iop_unpin\t= xfs_inode_item_unpin,\n\t.iop_unlock\t= xfs_inode_item_unlock,\n\t.iop_committed\t= xfs_inode_item_committed,\n\t.iop_push\t= xfs_inode_item_push,\n\t.iop_committing = xfs_inode_item_committing\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_item_init",
          "args": [
            "mp",
            "&iip->ili_item",
            "XFS_LI_INODE",
            "&xfs_inode_item_ops"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "961-976",
          "snippet": "void\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_ili_zone",
            "KM_SLEEP"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_itemp == NULL"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_ili_zone;\nstatic const struct xfs_item_ops xfs_inode_item_ops = {\n\t.iop_size\t= xfs_inode_item_size,\n\t.iop_format\t= xfs_inode_item_format,\n\t.iop_pin\t= xfs_inode_item_pin,\n\t.iop_unpin\t= xfs_inode_item_unpin,\n\t.iop_unlock\t= xfs_inode_item_unlock,\n\t.iop_committed\t= xfs_inode_item_committed,\n\t.iop_push\t= xfs_inode_item_push,\n\t.iop_committing = xfs_inode_item_committing\n};\n\nvoid\nxfs_inode_item_init(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_inode_log_item *iip;\n\n\tASSERT(ip->i_itemp == NULL);\n\tiip = ip->i_itemp = kmem_zone_zalloc(xfs_ili_zone, KM_SLEEP);\n\n\tiip->ili_inode = ip;\n\txfs_log_item_init(mp, &iip->ili_item, XFS_LI_INODE,\n\t\t\t\t\t\t&xfs_inode_item_ops);\n}"
  },
  {
    "function_name": "xfs_inode_item_committing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "532-538",
    "snippet": "STATIC void\nxfs_inode_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tINODE_ITEM(lip)->ili_last_lsn = lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tINODE_ITEM(lip)->ili_last_lsn = lsn;\n}"
  },
  {
    "function_name": "xfs_inode_item_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "513-526",
    "snippet": "STATIC xfs_lsn_t\nxfs_inode_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_inode_item_unpin(lip, 0);\n\t\treturn -1;\n\t}\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_item_unpin",
          "args": [
            "lip",
            "0"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_unpin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "393-404",
          "snippet": "STATIC void\nxfs_inode_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\ttrace_xfs_inode_unpin(ip, _RET_IP_);\n\tASSERT(atomic_read(&ip->i_pincount) > 0);\n\tif (atomic_dec_and_test(&ip->i_pincount))\n\t\twake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\ttrace_xfs_inode_unpin(ip, _RET_IP_);\n\tASSERT(atomic_read(&ip->i_pincount) > 0);\n\tif (atomic_dec_and_test(&ip->i_pincount))\n\t\twake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_ISTALE"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_lsn_t\nxfs_inode_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_inode_item_unpin(lip, 0);\n\t\treturn -1;\n\t}\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_inode_item_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "474-489",
    "snippet": "STATIC void\nxfs_inode_item_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tunsigned short\t\tlock_flags;\n\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tlock_flags = iip->ili_lock_flags;\n\tiip->ili_lock_flags = 0;\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock_flags"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_itemp != NULL"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tunsigned short\t\tlock_flags;\n\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tlock_flags = iip->ili_lock_flags;\n\tiip->ili_lock_flags = 0;\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n}"
  },
  {
    "function_name": "xfs_inode_item_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "406-466",
    "snippet": "STATIC uint\nxfs_inode_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\tint\t\t\terror;\n\n\tif (xfs_ipincount(ip) > 0)\n\t\treturn XFS_ITEM_PINNED;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED))\n\t\treturn XFS_ITEM_LOCKED;\n\n\t/*\n\t * Re-check the pincount now that we stabilized the value by\n\t * taking the ilock.\n\t */\n\tif (xfs_ipincount(ip) > 0) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Stale inode items should force out the iclog.\n\t */\n\tif (ip->i_flags & XFS_ISTALE) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Someone else is already flushing the inode.  Nothing we can do\n\t * here but wait for the flush to finish and remove the item from\n\t * the AIL.\n\t */\n\tif (!xfs_iflock_nowait(ip)) {\n\t\trval = XFS_ITEM_FLUSHING;\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(iip->ili_fields != 0 || XFS_FORCED_SHUTDOWN(ip->i_mount));\n\tASSERT(iip->ili_logged == 0 || XFS_FORCED_SHUTDOWN(ip->i_mount));\n\n\tspin_unlock(&lip->li_ailp->xa_lock);\n\n\terror = xfs_iflush(ip, &bp);\n\tif (!error) {\n\t\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\t\trval = XFS_ITEM_FLUSHING;\n\t\txfs_buf_relse(bp);\n\t}\n\n\tspin_lock(&lip->li_ailp->xa_lock);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush",
          "args": [
            "ip",
            "&bp"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "698-734",
          "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iip->ili_logged == 0 || XFS_FORCED_SHUTDOWN(ip->i_mount)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iip->ili_fields != 0 || XFS_FORCED_SHUTDOWN(ip->i_mount)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflock_nowait",
          "args": [
            "ip"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "234-237",
          "snippet": "static inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC uint\nxfs_inode_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\tint\t\t\terror;\n\n\tif (xfs_ipincount(ip) > 0)\n\t\treturn XFS_ITEM_PINNED;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED))\n\t\treturn XFS_ITEM_LOCKED;\n\n\t/*\n\t * Re-check the pincount now that we stabilized the value by\n\t * taking the ilock.\n\t */\n\tif (xfs_ipincount(ip) > 0) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Stale inode items should force out the iclog.\n\t */\n\tif (ip->i_flags & XFS_ISTALE) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Someone else is already flushing the inode.  Nothing we can do\n\t * here but wait for the flush to finish and remove the item from\n\t * the AIL.\n\t */\n\tif (!xfs_iflock_nowait(ip)) {\n\t\trval = XFS_ITEM_FLUSHING;\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(iip->ili_fields != 0 || XFS_FORCED_SHUTDOWN(ip->i_mount));\n\tASSERT(iip->ili_logged == 0 || XFS_FORCED_SHUTDOWN(ip->i_mount));\n\n\tspin_unlock(&lip->li_ailp->xa_lock);\n\n\terror = xfs_iflush(ip, &bp);\n\tif (!error) {\n\t\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\t\trval = XFS_ITEM_FLUSHING;\n\t\txfs_buf_relse(bp);\n\t}\n\n\tspin_lock(&lip->li_ailp->xa_lock);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_inode_item_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "393-404",
    "snippet": "STATIC void\nxfs_inode_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\ttrace_xfs_inode_unpin(ip, _RET_IP_);\n\tASSERT(atomic_read(&ip->i_pincount) > 0);\n\tif (atomic_dec_and_test(&ip->i_pincount))\n\t\twake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&ip->i_flags",
            "__XFS_IPINNED_BIT"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ip->i_pincount"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&ip->i_pincount) > 0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ip->i_pincount"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_unpin",
          "args": [
            "ip",
            "_RET_IP_"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\ttrace_xfs_inode_unpin(ip, _RET_IP_);\n\tASSERT(atomic_read(&ip->i_pincount) > 0);\n\tif (atomic_dec_and_test(&ip->i_pincount))\n\t\twake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);\n}"
  },
  {
    "function_name": "xfs_inode_item_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "374-384",
    "snippet": "STATIC void\nxfs_inode_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttrace_xfs_inode_pin(ip, _RET_IP_);\n\tatomic_inc(&ip->i_pincount);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ip->i_pincount"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_pin",
          "args": [
            "ip",
            "_RET_IP_"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttrace_xfs_inode_pin(ip, _RET_IP_);\n\tatomic_inc(&ip->i_pincount);\n}"
  },
  {
    "function_name": "xfs_inode_item_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "332-368",
    "snippet": "STATIC void\nxfs_inode_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_inode_log_format *ilf;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(ip->i_d.di_version > 1);\n\n\tilf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_IFORMAT);\n\tilf->ilf_type = XFS_LI_INODE;\n\tilf->ilf_ino = ip->i_ino;\n\tilf->ilf_blkno = ip->i_imap.im_blkno;\n\tilf->ilf_len = ip->i_imap.im_len;\n\tilf->ilf_boffset = ip->i_imap.im_boffset;\n\tilf->ilf_fields = XFS_ILOG_CORE;\n\tilf->ilf_size = 2; /* format + core */\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_inode_log_format));\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ICORE,\n\t\t\t&ip->i_d,\n\t\t\txfs_icdinode_size(ip->i_d.di_version));\n\n\txfs_inode_item_format_data_fork(iip, ilf, lv, &vecp);\n\tif (XFS_IFORK_Q(ip)) {\n\t\txfs_inode_item_format_attr_fork(iip, ilf, lv, &vecp);\n\t} else {\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT | XFS_ILOG_AEXT);\n\t}\n\n\t/* update the format with the exact fields we actually logged */\n\tilf->ilf_fields |= (iip->ili_fields & ~XFS_ILOG_TIMESTAMP);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_item_format_attr_fork",
          "args": [
            "iip",
            "ilf",
            "lv",
            "&vecp"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_format_attr_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "244-323",
          "snippet": "STATIC void\nxfs_inode_item_format_attr_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==\n\t\t\t\tip->i_d.di_anextents);\n\t\t\tASSERT(ip->i_afp->if_u1.if_extents != NULL);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tilf->ilf_asize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_AEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_AEXT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_afp->if_broot != NULL);\n\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,\n\t\t\t\t\tip->i_afp->if_broot,\n\t\t\t\t\tip->i_afp->if_broot_bytes);\n\t\t\tilf->ilf_asize = ip->i_afp->if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ABROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_AEXT | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_afp->if_bytes, 4);\n\t\t\tASSERT(ip->i_afp->if_real_bytes == 0 ||\n\t\t\t       ip->i_afp->if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_afp->if_u1.if_data != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,\n\t\t\t\t\tip->i_afp->if_u1.if_data,\n\t\t\t\t\tdata_bytes);\n\t\t\tilf->ilf_asize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ADATA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_format_attr_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==\n\t\t\t\tip->i_d.di_anextents);\n\t\t\tASSERT(ip->i_afp->if_u1.if_extents != NULL);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tilf->ilf_asize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_AEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_AEXT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_afp->if_broot != NULL);\n\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,\n\t\t\t\t\tip->i_afp->if_broot,\n\t\t\t\t\tip->i_afp->if_broot_bytes);\n\t\t\tilf->ilf_asize = ip->i_afp->if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ABROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_AEXT | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_afp->if_bytes, 4);\n\t\t\tASSERT(ip->i_afp->if_real_bytes == 0 ||\n\t\t\t       ip->i_afp->if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_afp->if_u1.if_data != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,\n\t\t\t\t\tip->i_afp->if_u1.if_data,\n\t\t\t\t\tdata_bytes);\n\t\t\tilf->ilf_asize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ADATA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_item_format_data_fork",
          "args": [
            "iip",
            "ilf",
            "lv",
            "&vecp"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_format_data_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "145-242",
          "snippet": "STATIC void\nxfs_inode_item_format_data_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_df.if_u1.if_extents != NULL);\n\t\t\tASSERT(ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tASSERT(data_bytes <= ip->i_df.if_bytes);\n\n\t\t\tilf->ilf_dsize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DEXT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_broot != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,\n\t\t\t\t\tip->i_df.if_broot,\n\t\t\t\t\tip->i_df.if_broot_bytes);\n\t\t\tilf->ilf_dsize = ip->i_df.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tASSERT(!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT));\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DBROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DEXT | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_df.if_bytes, 4);\n\t\t\tASSERT(ip->i_df.if_real_bytes == 0 ||\n\t\t\t       ip->i_df.if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_df.if_u1.if_data != NULL);\n\t\t\tASSERT(ip->i_d.di_size > 0);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,\n\t\t\t\t\tip->i_df.if_u1.if_data, data_bytes);\n\t\t\tilf->ilf_dsize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DDATA;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_DEV:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_UUID);\n\t\tif (iip->ili_fields & XFS_ILOG_DEV)\n\t\t\tilf->ilf_u.ilfu_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_DEV);\n\t\tif (iip->ili_fields & XFS_ILOG_UUID)\n\t\t\tilf->ilf_u.ilfu_uuid = ip->i_df.if_u2.if_uuid;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_format_data_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_df.if_u1.if_extents != NULL);\n\t\t\tASSERT(ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tASSERT(data_bytes <= ip->i_df.if_bytes);\n\n\t\t\tilf->ilf_dsize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DEXT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_broot != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,\n\t\t\t\t\tip->i_df.if_broot,\n\t\t\t\t\tip->i_df.if_broot_bytes);\n\t\t\tilf->ilf_dsize = ip->i_df.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tASSERT(!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT));\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DBROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DEXT | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_df.if_bytes, 4);\n\t\t\tASSERT(ip->i_df.if_real_bytes == 0 ||\n\t\t\t       ip->i_df.if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_df.if_u1.if_data != NULL);\n\t\t\tASSERT(ip->i_d.di_size > 0);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,\n\t\t\t\t\tip->i_df.if_u1.if_data, data_bytes);\n\t\t\tilf->ilf_dsize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DDATA;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_DEV:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_UUID);\n\t\tif (iip->ili_fields & XFS_ILOG_DEV)\n\t\t\tilf->ilf_u.ilfu_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_DEV);\n\t\tif (iip->ili_fields & XFS_ILOG_UUID)\n\t\t\tilf->ilf_u.ilfu_uuid = ip->i_df.if_u2.if_uuid;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "&vecp",
            "XLOG_REG_TYPE_ICORE",
            "&ip->i_d",
            "xfs_icdinode_size(ip->i_d.di_version)"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icdinode_size",
          "args": [
            "ip->i_d.di_version"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icdinode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "412-417",
          "snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "vecp",
            "sizeof(struct xfs_inode_log_format)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "&vecp",
            "XLOG_REG_TYPE_IFORMAT"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version > 1"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_inode_log_format *ilf;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(ip->i_d.di_version > 1);\n\n\tilf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_IFORMAT);\n\tilf->ilf_type = XFS_LI_INODE;\n\tilf->ilf_ino = ip->i_ino;\n\tilf->ilf_blkno = ip->i_imap.im_blkno;\n\tilf->ilf_len = ip->i_imap.im_len;\n\tilf->ilf_boffset = ip->i_imap.im_boffset;\n\tilf->ilf_fields = XFS_ILOG_CORE;\n\tilf->ilf_size = 2; /* format + core */\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_inode_log_format));\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ICORE,\n\t\t\t&ip->i_d,\n\t\t\txfs_icdinode_size(ip->i_d.di_version));\n\n\txfs_inode_item_format_data_fork(iip, ilf, lv, &vecp);\n\tif (XFS_IFORK_Q(ip)) {\n\t\txfs_inode_item_format_attr_fork(iip, ilf, lv, &vecp);\n\t} else {\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT | XFS_ILOG_AEXT);\n\t}\n\n\t/* update the format with the exact fields we actually logged */\n\tilf->ilf_fields |= (iip->ili_fields & ~XFS_ILOG_TIMESTAMP);\n}"
  },
  {
    "function_name": "xfs_inode_item_format_attr_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "244-323",
    "snippet": "STATIC void\nxfs_inode_item_format_attr_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==\n\t\t\t\tip->i_d.di_anextents);\n\t\t\tASSERT(ip->i_afp->if_u1.if_extents != NULL);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tilf->ilf_asize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_AEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_AEXT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_afp->if_broot != NULL);\n\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,\n\t\t\t\t\tip->i_afp->if_broot,\n\t\t\t\t\tip->i_afp->if_broot_bytes);\n\t\t\tilf->ilf_asize = ip->i_afp->if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ABROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_AEXT | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_afp->if_bytes, 4);\n\t\t\tASSERT(ip->i_afp->if_real_bytes == 0 ||\n\t\t\t       ip->i_afp->if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_afp->if_u1.if_data != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,\n\t\t\t\t\tip->i_afp->if_u1.if_data,\n\t\t\t\t\tdata_bytes);\n\t\t\tilf->ilf_asize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ADATA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_IATTR_LOCAL",
            "ip->i_afp->if_u1.if_data",
            "data_bytes"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp->if_u1.if_data != NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp->if_real_bytes == 0 ||\n\t\t\t       ip->i_afp->if_real_bytes == data_bytes"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ip->i_afp->if_bytes",
            "4"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp->if_broot != NULL"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "*vecp",
            "data_bytes"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iextents_copy",
          "args": [
            "ip",
            "p",
            "XFS_ATTR_FORK"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iextents_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "733-780",
          "snippet": "int\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_IATTR_EXT"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp->if_u1.if_extents != NULL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==\n\t\t\t\tip->i_d.di_anextents"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_format_attr_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==\n\t\t\t\tip->i_d.di_anextents);\n\t\t\tASSERT(ip->i_afp->if_u1.if_extents != NULL);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tilf->ilf_asize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_AEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_AEXT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_afp->if_broot != NULL);\n\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,\n\t\t\t\t\tip->i_afp->if_broot,\n\t\t\t\t\tip->i_afp->if_broot_bytes);\n\t\t\tilf->ilf_asize = ip->i_afp->if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ABROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_AEXT | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_afp->if_bytes, 4);\n\t\t\tASSERT(ip->i_afp->if_real_bytes == 0 ||\n\t\t\t       ip->i_afp->if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_afp->if_u1.if_data != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,\n\t\t\t\t\tip->i_afp->if_u1.if_data,\n\t\t\t\t\tdata_bytes);\n\t\t\tilf->ilf_asize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ADATA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_inode_item_format_data_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "145-242",
    "snippet": "STATIC void\nxfs_inode_item_format_data_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_df.if_u1.if_extents != NULL);\n\t\t\tASSERT(ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tASSERT(data_bytes <= ip->i_df.if_bytes);\n\n\t\t\tilf->ilf_dsize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DEXT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_broot != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,\n\t\t\t\t\tip->i_df.if_broot,\n\t\t\t\t\tip->i_df.if_broot_bytes);\n\t\t\tilf->ilf_dsize = ip->i_df.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tASSERT(!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT));\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DBROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DEXT | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_df.if_bytes, 4);\n\t\t\tASSERT(ip->i_df.if_real_bytes == 0 ||\n\t\t\t       ip->i_df.if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_df.if_u1.if_data != NULL);\n\t\t\tASSERT(ip->i_d.di_size > 0);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,\n\t\t\t\t\tip->i_df.if_u1.if_data, data_bytes);\n\t\t\tilf->ilf_dsize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DDATA;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_DEV:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_UUID);\n\t\tif (iip->ili_fields & XFS_ILOG_DEV)\n\t\t\tilf->ilf_u.ilfu_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_DEV);\n\t\tif (iip->ili_fields & XFS_ILOG_UUID)\n\t\t\tilf->ilf_u.ilfu_uuid = ip->i_df.if_u2.if_uuid;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_ILOCAL",
            "ip->i_df.if_u1.if_data",
            "data_bytes"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_size > 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_u1.if_data != NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_real_bytes == 0 ||\n\t\t\t       ip->i_df.if_real_bytes == data_bytes"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ip->i_df.if_bytes",
            "4"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_broot != NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "data_bytes <= ip->i_df.if_bytes"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "*vecp",
            "data_bytes"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iextents_copy",
          "args": [
            "ip",
            "p",
            "XFS_DATA_FORK"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iextents_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "733-780",
          "snippet": "int\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_IEXT"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_u1.if_extents != NULL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_format_data_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(ip->i_df.if_u1.if_extents != NULL);\n\t\t\tASSERT(ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tASSERT(data_bytes <= ip->i_df.if_bytes);\n\n\t\t\tilf->ilf_dsize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DEXT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_broot != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,\n\t\t\t\t\tip->i_df.if_broot,\n\t\t\t\t\tip->i_df.if_broot_bytes);\n\t\t\tilf->ilf_dsize = ip->i_df.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tASSERT(!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT));\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DBROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DEXT | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEV | XFS_ILOG_UUID);\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/*\n\t\t\t * Round i_bytes up to a word boundary.\n\t\t\t * The underlying memory is guaranteed to\n\t\t\t * to be there by xfs_idata_realloc().\n\t\t\t */\n\t\t\tdata_bytes = roundup(ip->i_df.if_bytes, 4);\n\t\t\tASSERT(ip->i_df.if_real_bytes == 0 ||\n\t\t\t       ip->i_df.if_real_bytes == data_bytes);\n\t\t\tASSERT(ip->i_df.if_u1.if_data != NULL);\n\t\t\tASSERT(ip->i_d.di_size > 0);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,\n\t\t\t\t\tip->i_df.if_u1.if_data, data_bytes);\n\t\t\tilf->ilf_dsize = (unsigned)data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DDATA;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_DEV:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_UUID);\n\t\tif (iip->ili_fields & XFS_ILOG_DEV)\n\t\t\tilf->ilf_u.ilfu_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT |\n\t\t\t  XFS_ILOG_DEXT | XFS_ILOG_DEV);\n\t\tif (iip->ili_fields & XFS_ILOG_UUID)\n\t\t\tilf->ilf_u.ilfu_uuid = ip->i_df.if_u2.if_uuid;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_inode_item_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "127-143",
    "snippet": "STATIC void\nxfs_inode_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_inode_log_format) +\n\t\t   xfs_icdinode_size(ip->i_d.di_version);\n\n\txfs_inode_item_data_fork_size(iip, nvecs, nbytes);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_inode_item_attr_fork_size(iip, nvecs, nbytes);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_item_attr_fork_size",
          "args": [
            "iip",
            "nvecs",
            "nbytes"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_attr_fork_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "82-118",
          "snippet": "STATIC void\nxfs_inode_item_attr_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract unused space */\n\t\t\t*nbytes += XFS_IFORK_ASIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_afp->if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_afp->if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_attr_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract unused space */\n\t\t\t*nbytes += XFS_IFORK_ASIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_afp->if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_afp->if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_item_data_fork_size",
          "args": [
            "iip",
            "nvecs",
            "nbytes"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_data_fork_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "40-80",
          "snippet": "STATIC void\nxfs_inode_item_data_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract delalloc extents */\n\t\t\t*nbytes += XFS_IFORK_DSIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_df.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_df.if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_data_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract delalloc extents */\n\t\t\t*nbytes += XFS_IFORK_DSIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_df.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_df.if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icdinode_size",
          "args": [
            "ip->i_d.di_version"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icdinode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "412-417",
          "snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_ITEM",
          "args": [
            "lip"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "35-38",
          "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_inode_log_format) +\n\t\t   xfs_icdinode_size(ip->i_d.di_version);\n\n\txfs_inode_item_data_fork_size(iip, nvecs, nbytes);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_inode_item_attr_fork_size(iip, nvecs, nbytes);\n}"
  },
  {
    "function_name": "xfs_inode_item_attr_fork_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "82-118",
    "snippet": "STATIC void\nxfs_inode_item_attr_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract unused space */\n\t\t\t*nbytes += XFS_IFORK_ASIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_afp->if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_afp->if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ip->i_afp->if_bytes",
            "4"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_ASIZE",
          "args": [
            "ip"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_attr_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_d.di_anextents > 0 &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract unused space */\n\t\t\t*nbytes += XFS_IFORK_ASIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_afp->if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_afp->if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_afp->if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_afp->if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_inode_item_data_fork_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "40-80",
    "snippet": "STATIC void\nxfs_inode_item_data_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract delalloc extents */\n\t\t\t*nbytes += XFS_IFORK_DSIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_df.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_df.if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ip->i_df.if_bytes",
            "4"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "ip"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inode_item_data_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_d.di_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t/* worst case, doesn't subtract delalloc extents */\n\t\t\t*nbytes += XFS_IFORK_DSIZE(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_df.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t*nbytes += roundup(ip->i_df.if_bytes, 4);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "INODE_ITEM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
    "lines": "35-38",
    "snippet": "static inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lip",
            "structxfs_inode_log_item",
            "ili_item"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}"
  }
]