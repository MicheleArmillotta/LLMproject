[
  {
    "function_name": "exit_qnx6_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "677-681",
    "snippet": "static void __exit exit_qnx6_fs(void)\n{\n\tunregister_filesystem(&qnx6_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type qnx6_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx6\",\n\t.mount\t\t= qnx6_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "634-642",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx6_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&qnx6_fs_type"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type qnx6_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx6\",\n\t.mount\t\t= qnx6_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_qnx6_fs(void)\n{\n\tunregister_filesystem(&qnx6_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_qnx6_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "659-675",
    "snippet": "static int __init init_qnx6_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx6_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"QNX6 filesystem 1.0.0 registered.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type qnx6_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx6\",\n\t.mount\t\t= qnx6_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"QNX6 filesystem 1.0.0 registered.\\n\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "634-642",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx6_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&qnx6_fs_type"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "622-632",
          "snippet": "static int init_inodecache(void)\n{\n\tqnx6_inode_cachep = kmem_cache_create(\"qnx6_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx6_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!qnx6_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx6_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tqnx6_inode_cachep = kmem_cache_create(\"qnx6_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx6_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!qnx6_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type qnx6_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx6\",\n\t.mount\t\t= qnx6_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_qnx6_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx6_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"QNX6 filesystem 1.0.0 registered.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx6_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "644-648",
    "snippet": "static struct dentry *qnx6_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx6_fill_super);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int qnx6_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "qnx6_fill_super"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *qnx6_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx6_fill_super);\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "634-642",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *qnx6_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "qnx6_inode_cachep"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "622-632",
    "snippet": "static int init_inodecache(void)\n{\n\tqnx6_inode_cachep = kmem_cache_create(\"qnx6_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx6_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!qnx6_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *qnx6_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"qnx6_inode_cache\"",
            "sizeof(struct qnx6_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tqnx6_inode_cachep = kmem_cache_create(\"qnx6_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx6_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!qnx6_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "615-620",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct qnx6_inode_info *ei = (struct qnx6_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct qnx6_inode_info *ei = (struct qnx6_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "qnx6_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "610-613",
    "snippet": "static void qnx6_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, qnx6_i_callback);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "qnx6_i_callback"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\n\nstatic void qnx6_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, qnx6_i_callback);\n}"
  },
  {
    "function_name": "qnx6_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "604-608",
    "snippet": "static void qnx6_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx6_inode_cachep, QNX6_I(inode));\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *qnx6_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "qnx6_inode_cachep",
            "QNX6_I(inode)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_I",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "63-66",
          "snippet": "static inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic void qnx6_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx6_inode_cachep, QNX6_I(inode));\n}"
  },
  {
    "function_name": "qnx6_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "595-602",
    "snippet": "static struct inode *qnx6_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx6_inode_info *ei;\n\tei = kmem_cache_alloc(qnx6_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *qnx6_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "qnx6_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx6_inode_info *ei;\n\tei = kmem_cache_alloc(qnx6_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "qnx6_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "519-591",
    "snippet": "struct inode *qnx6_iget(struct super_block *sb, unsigned ino)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tstruct qnx6_inode_entry *raw_inode;\n\tstruct inode *inode;\n\tstruct qnx6_inode_info\t*ei;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu32 n, offs;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = QNX6_I(inode);\n\n\tinode->i_mode = 0;\n\n\tif (ino == 0) {\n\t\tpr_err(\"bad inode number on dev %s: %u is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tn = (ino - 1) >> (PAGE_CACHE_SHIFT - QNX6_INODE_SIZE_BITS);\n\toffs = (ino - 1) & (~PAGE_CACHE_MASK >> QNX6_INODE_SIZE_BITS);\n\tmapping = sbi->inodes->i_mapping;\n\tpage = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_err(\"major problem: unable to read inode from dev %s\\n\",\n\t\t       sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_CAST(page);\n\t}\n\tkmap(page);\n\traw_inode = ((struct qnx6_inode_entry *)page_address(page)) + offs;\n\n\tinode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));\n\tinode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\n\t/* calc blocks based on 512 byte blocksize */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tmemcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,\n\t\t\t\tsizeof(raw_inode->di_block_ptr));\n\tei->di_filelevels = raw_inode->di_filelevels;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx6_dir_inode_operations;\n\t\tinode->i_fop = &qnx6_dir_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\tqnx6_put_page(page);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_put_page",
          "args": [
            "page"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "128-132",
          "snippet": "static inline void qnx6_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline void qnx6_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "0"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ei->di_block_ptr",
            "&raw_inode->di_block_ptr",
            "sizeof(raw_inode->di_block_ptr)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "raw_inode->di_ctime"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sbi",
            "raw_inode->di_size"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "77-83",
          "snippet": "static inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "(gid_t)fs32_to_cpu(sbi, raw_inode->di_gid)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "(uid_t)fs32_to_cpu(sbi, raw_inode->di_uid)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "raw_inode->di_mode"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "109-115",
          "snippet": "static inline __u16 fs16_to_cpu(struct qnx6_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u16 fs16_to_cpu(struct qnx6_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"major problem: unable to read inode from dev %s\\n\"",
            "sb->s_id"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n",
            "NULL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad inode number on dev %s: %u is out of range\\n\"",
            "sb->s_id",
            "ino"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_I",
          "args": [
            "inode"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "63-66",
          "snippet": "static inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};\n\nstruct inode *qnx6_iget(struct super_block *sb, unsigned ino)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tstruct qnx6_inode_entry *raw_inode;\n\tstruct inode *inode;\n\tstruct qnx6_inode_info\t*ei;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu32 n, offs;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = QNX6_I(inode);\n\n\tinode->i_mode = 0;\n\n\tif (ino == 0) {\n\t\tpr_err(\"bad inode number on dev %s: %u is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tn = (ino - 1) >> (PAGE_CACHE_SHIFT - QNX6_INODE_SIZE_BITS);\n\toffs = (ino - 1) & (~PAGE_CACHE_MASK >> QNX6_INODE_SIZE_BITS);\n\tmapping = sbi->inodes->i_mapping;\n\tpage = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_err(\"major problem: unable to read inode from dev %s\\n\",\n\t\t       sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_CAST(page);\n\t}\n\tkmap(page);\n\traw_inode = ((struct qnx6_inode_entry *)page_address(page)) + offs;\n\n\tinode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));\n\tinode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\n\t/* calc blocks based on 512 byte blocksize */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tmemcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,\n\t\t\t\tsizeof(raw_inode->di_block_ptr));\n\tei->di_filelevels = raw_inode->di_filelevels;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx6_dir_inode_operations;\n\t\tinode->i_fop = &qnx6_dir_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\tqnx6_put_page(page);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "qnx6_private_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "503-517",
    "snippet": "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p)\n{\n\tstruct inode *inode = new_inode(s);\n\tif (inode) {\n\t\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\t\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\t\tinode->i_size = fs64_to_cpu(sbi, p->size);\n\t\tmemcpy(ei->di_block_ptr, p->ptr, sizeof(p->ptr));\n\t\tei->di_filelevels = p->levels;\n\t\tinode->i_mode = S_IFREG | S_IRUSR; /* probably wrong */\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);",
      "static const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ei->di_block_ptr",
            "p->ptr",
            "sizeof(p->ptr)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sbi",
            "p->size"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "77-83",
          "snippet": "static inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_I",
          "args": [
            "inode"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "63-66",
          "snippet": "static inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);\nstatic const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};\n\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p)\n{\n\tstruct inode *inode = new_inode(s);\n\tif (inode) {\n\t\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\t\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\t\tinode->i_size = fs64_to_cpu(sbi, p->size);\n\t\tmemcpy(ei->di_block_ptr, p->ptr, sizeof(p->ptr));\n\t\tei->di_filelevels = p->levels;\n\t\tinode->i_mode = S_IFREG | S_IRUSR; /* probably wrong */\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "qnx6_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "493-496",
    "snippet": "static sector_t qnx6_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, qnx6_get_block);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "qnx6_get_block"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic sector_t qnx6_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, qnx6_get_block);\n}"
  },
  {
    "function_name": "qnx6_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "482-491",
    "snippet": "static void qnx6_put_super(struct super_block *sb)\n{\n\tstruct qnx6_sb_info *qs = QNX6_SB(sb);\n\tbrelse(qs->sb_buf);\n\tiput(qs->longfile);\n\tiput(qs->inodes);\n\tkfree(qs);\n\tsb->s_fs_info = NULL;\n\treturn;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qs"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "qs->inodes"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "qs->sb_buf"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nstatic void qnx6_put_super(struct super_block *sb)\n{\n\tstruct qnx6_sb_info *qs = QNX6_SB(sb);\n\tbrelse(qs->sb_buf);\n\tiput(qs->longfile);\n\tiput(qs->inodes);\n\tkfree(qs);\n\tsb->s_fs_info = NULL;\n\treturn;\n}"
  },
  {
    "function_name": "qnx6_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "297-480",
    "snippet": "static int qnx6_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh1 = NULL, *bh2 = NULL;\n\tstruct qnx6_super_block *sb1 = NULL, *sb2 = NULL;\n\tstruct qnx6_sb_info *sbi;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx6_sb_info *qs;\n\tint ret = -EINVAL;\n\tu64 offset;\n\tint bootblock_offset = QNX6_BOOTBLOCK_SIZE;\n\n\tqs = kzalloc(sizeof(struct qnx6_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\t/* Superblock always is 512 Byte long */\n\tif (!sb_set_blocksize(s, QNX6_SUPERBLOCK_SIZE)) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto outnobh;\n\t}\n\n\t/* parse the mount-options */\n\tif (!qnx6_parse_options((char *) data, s)) {\n\t\tpr_err(\"invalid mount options.\\n\");\n\t\tgoto outnobh;\n\t}\n\tif (test_opt(s, MMI_FS)) {\n\t\tsb1 = qnx6_mmi_fill_super(s, silent);\n\t\tif (sb1)\n\t\t\tgoto mmi_success;\n\t\telse\n\t\t\tgoto outnobh;\n\t}\n\tsbi = QNX6_SB(s);\n\tsbi->s_bytesex = BYTESEX_LE;\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = qnx6_check_first_superblock(s,\n\t\tbootblock_offset / QNX6_SUPERBLOCK_SIZE, silent);\n\tif (!bh1) {\n\t\t/* try again without bootblock offset */\n\t\tbh1 = qnx6_check_first_superblock(s, 0, silent);\n\t\tif (!bh1) {\n\t\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\t\tgoto outnobh;\n\t\t}\n\t\t/* seems that no bootblock at partition start */\n\t\tbootblock_offset = 0;\n\t}\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n#ifdef CONFIG_QNX6FS_DEBUG\n\tqnx6_superblock_debug(sb1, s);\n#endif\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, bootblock_offset >> s->s_blocksize_bits);\n\tif (!bh1)\n\t\tgoto outnobh;\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) +\n\t\t(bootblock_offset >> s->s_blocksize_bits) +\n\t\t(QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t/* set bootblock offset */\n\tsbi->s_blks_off = (bootblock_offset >> s->s_blocksize_bits) +\n\t\t\t  (QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t/* next the second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #2 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >=\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\nmmi_success:\n\t/* sanity check - limit maximum indirect pointer levels */\n\tif (sb1->Inode.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many inode levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Inode.levels);\n\t\tgoto out;\n\t}\n\tif (sb1->Longfile.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many longfilename levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Longfile.levels);\n\t\tgoto out;\n\t}\n\ts->s_op = &qnx6_sops;\n\ts->s_magic = QNX6_SUPER_MAGIC;\n\ts->s_flags |= MS_RDONLY;        /* Yup, read-only yet */\n\n\t/* ease the later tree level calculations */\n\tsbi = QNX6_SB(s);\n\tsbi->s_ptrbits = ilog2(s->s_blocksize / 4);\n\tsbi->inodes = qnx6_private_inode(s, &sb1->Inode);\n\tif (!sbi->inodes)\n\t\tgoto out;\n\tsbi->longfile = qnx6_private_inode(s, &sb1->Longfile);\n\tif (!sbi->longfile)\n\t\tgoto out1;\n\n\t/* prefetch root inode */\n\troot = qnx6_iget(s, QNX6_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto out2;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto out2;\n\n\tret = -EINVAL;\n\terrmsg = qnx6_checkroot(s);\n\tif (errmsg != NULL) {\n\t\tif (!silent)\n\t\t\tpr_err(\"%s\\n\", errmsg);\n\t\tgoto out3;\n\t}\n\treturn 0;\n\nout3:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout2:\n\tiput(sbi->longfile);\nout1:\n\tiput(sbi->inodes);\nout:\n\tif (bh1)\n\t\tbrelse(bh1);\n\tif (bh2)\n\t\tbrelse(bh2);\noutnobh:\n\tkfree(qs);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations qnx6_sops;",
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static int qnx6_remount(struct super_block *sb, int *flags, char *data);",
      "static int qnx6_show_options(struct seq_file *seq, struct dentry *root);",
      "static const struct super_operations qnx6_sops = {\n\t.alloc_inode\t= qnx6_alloc_inode,\n\t.destroy_inode\t= qnx6_destroy_inode,\n\t.put_super\t= qnx6_put_super,\n\t.statfs\t\t= qnx6_statfs,\n\t.remount_fs\t= qnx6_remount,\n\t.show_options\t= qnx6_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qs"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->inodes"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "s->s_root"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s\\n\"",
            "errmsg"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_checkroot",
          "args": [
            "s"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_checkroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "180-201",
          "snippet": "static const char *qnx6_checkroot(struct super_block *s)\n{\n\tstatic char match_root[2][3] = {\".\\0\\0\", \"..\\0\"};\n\tint i, error = 0;\n\tstruct qnx6_dir_entry *dir_entry;\n\tstruct inode *root = s->s_root->d_inode;\n\tstruct address_space *mapping = root->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn \"error reading root directory\";\n\tkmap(page);\n\tdir_entry = page_address(page);\n\tfor (i = 0; i < 2; i++) {\n\t\t/* maximum 3 bytes - due to match_root limitation */\n\t\tif (strncmp(dir_entry[i].de_fname, match_root[i], 3))\n\t\t\terror = 1;\n\t}\n\tqnx6_put_page(page);\n\tif (error)\n\t\treturn \"error reading root directory.\";\n\treturn NULL;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_destroy_inode(struct inode *inode);",
            "static int qnx6_show_options(struct seq_file *seq, struct dentry *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root);\n\nstatic const char *qnx6_checkroot(struct super_block *s)\n{\n\tstatic char match_root[2][3] = {\".\\0\\0\", \"..\\0\"};\n\tint i, error = 0;\n\tstruct qnx6_dir_entry *dir_entry;\n\tstruct inode *root = s->s_root->d_inode;\n\tstruct address_space *mapping = root->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn \"error reading root directory\";\n\tkmap(page);\n\tdir_entry = page_address(page);\n\tfor (i = 0; i < 2; i++) {\n\t\t/* maximum 3 bytes - due to match_root limitation */\n\t\tif (strncmp(dir_entry[i].de_fname, match_root[i], 3))\n\t\t\terror = 1;\n\t}\n\tqnx6_put_page(page);\n\tif (error)\n\t\treturn \"error reading root directory.\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"get inode failed\\n\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_iget",
          "args": [
            "s",
            "QNX6_ROOT_INO"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "519-591",
          "snippet": "struct inode *qnx6_iget(struct super_block *sb, unsigned ino)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tstruct qnx6_inode_entry *raw_inode;\n\tstruct inode *inode;\n\tstruct qnx6_inode_info\t*ei;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu32 n, offs;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = QNX6_I(inode);\n\n\tinode->i_mode = 0;\n\n\tif (ino == 0) {\n\t\tpr_err(\"bad inode number on dev %s: %u is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tn = (ino - 1) >> (PAGE_CACHE_SHIFT - QNX6_INODE_SIZE_BITS);\n\toffs = (ino - 1) & (~PAGE_CACHE_MASK >> QNX6_INODE_SIZE_BITS);\n\tmapping = sbi->inodes->i_mapping;\n\tpage = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_err(\"major problem: unable to read inode from dev %s\\n\",\n\t\t       sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_CAST(page);\n\t}\n\tkmap(page);\n\traw_inode = ((struct qnx6_inode_entry *)page_address(page)) + offs;\n\n\tinode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));\n\tinode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\n\t/* calc blocks based on 512 byte blocksize */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tmemcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,\n\t\t\t\tsizeof(raw_inode->di_block_ptr));\n\tei->di_filelevels = raw_inode->di_filelevels;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx6_dir_inode_operations;\n\t\tinode->i_fop = &qnx6_dir_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\tqnx6_put_page(page);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
            "static void qnx6_destroy_inode(struct inode *inode);",
            "static const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};\n\nstruct inode *qnx6_iget(struct super_block *sb, unsigned ino)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tstruct qnx6_inode_entry *raw_inode;\n\tstruct inode *inode;\n\tstruct qnx6_inode_info\t*ei;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu32 n, offs;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = QNX6_I(inode);\n\n\tinode->i_mode = 0;\n\n\tif (ino == 0) {\n\t\tpr_err(\"bad inode number on dev %s: %u is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tn = (ino - 1) >> (PAGE_CACHE_SHIFT - QNX6_INODE_SIZE_BITS);\n\toffs = (ino - 1) & (~PAGE_CACHE_MASK >> QNX6_INODE_SIZE_BITS);\n\tmapping = sbi->inodes->i_mapping;\n\tpage = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_err(\"major problem: unable to read inode from dev %s\\n\",\n\t\t       sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_CAST(page);\n\t}\n\tkmap(page);\n\traw_inode = ((struct qnx6_inode_entry *)page_address(page)) + offs;\n\n\tinode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));\n\tinode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\n\t/* calc blocks based on 512 byte blocksize */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tmemcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,\n\t\t\t\tsizeof(raw_inode->di_block_ptr));\n\tei->di_filelevels = raw_inode->di_filelevels;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx6_dir_inode_operations;\n\t\tinode->i_fop = &qnx6_dir_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\tqnx6_put_page(page);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_private_inode",
          "args": [
            "s",
            "&sb1->Longfile"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_private_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "503-517",
          "snippet": "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p)\n{\n\tstruct inode *inode = new_inode(s);\n\tif (inode) {\n\t\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\t\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\t\tinode->i_size = fs64_to_cpu(sbi, p->size);\n\t\tmemcpy(ei->di_block_ptr, p->ptr, sizeof(p->ptr));\n\t\tei->di_filelevels = p->levels;\n\t\tinode->i_mode = S_IFREG | S_IRUSR; /* probably wrong */\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_destroy_inode(struct inode *inode);",
            "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);",
            "static const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);\nstatic const struct address_space_operations qnx6_aops = {\n\t.readpage\t= qnx6_readpage,\n\t.readpages\t= qnx6_readpages,\n\t.bmap\t\t= qnx6_bmap\n};\n\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p)\n{\n\tstruct inode *inode = new_inode(s);\n\tif (inode) {\n\t\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\t\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\t\tinode->i_size = fs64_to_cpu(sbi, p->size);\n\t\tmemcpy(ei->di_block_ptr, p->ptr, sizeof(p->ptr));\n\t\tei->di_filelevels = p->levels;\n\t\tinode->i_mode = S_IFREG | S_IRUSR; /* probably wrong */\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "s->s_blocksize / 4"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"too many longfilename levels (max %i, sb %i)\\n\"",
            "QNX6_PTR_MAX_LEVELS",
            "sb1->Longfile.levels"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"too many inode levels (max %i, sb %i)\\n\"",
            "QNX6_PTR_MAX_LEVELS",
            "sb1->Inode.levels"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"superblock #2 active\\n\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"superblock #1 active\\n\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sbi",
            "sb2->sb_serial"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "77-83",
          "snippet": "static inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"superblock #2 checksum error\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "0",
            "(char *)(bh2->b_data + 8)",
            "504"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sb2->sb_checksum"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong signature (magic) in superblock #2.\\n\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read the second superblock\\n\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "offset"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "bootblock_offset >> s->s_blocksize_bits"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to set blocksize\\n\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "fs32_to_cpu(sbi, sb1->sb_blocksize)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"superblock #1 checksum error\\n\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "0",
            "(char *)(bh1->b_data + 8)",
            "504"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_superblock_debug",
          "args": [
            "sb1",
            "s"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_superblock_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "204-218",
          "snippet": "void qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nvoid qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read the first superblock\\n\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_check_first_superblock",
          "args": [
            "s",
            "0",
            "silent"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_check_first_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "257-292",
          "snippet": "static struct buffer_head *qnx6_check_first_superblock(struct super_block *s,\n\t\t\t\tint offset, int silent)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct buffer_head *bh;\n\tstruct qnx6_super_block *sb;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh = sb_bread(s, offset);\n\tif (!bh) {\n\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb = (struct qnx6_super_block *)bh->b_data;\n\tif (fs32_to_cpu(sbi, sb->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\t\tif (fs32_to_cpu(sbi, sb->sb_magic) == QNX6_SUPER_MAGIC) {\n\t\t\t/* we got a big endian fs */\n\t\t\tpr_debug(\"fs got different endianness.\\n\");\n\t\t\treturn bh;\n\t\t} else\n\t\t\tsbi->s_bytesex = BYTESEX_LE;\n\t\tif (!silent) {\n\t\t\tif (offset == 0) {\n\t\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\",\n\t\t\t\t\toffset * s->s_blocksize);\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nstatic struct buffer_head *qnx6_check_first_superblock(struct super_block *s,\n\t\t\t\tint offset, int silent)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct buffer_head *bh;\n\tstruct qnx6_super_block *sb;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh = sb_bread(s, offset);\n\tif (!bh) {\n\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb = (struct qnx6_super_block *)bh->b_data;\n\tif (fs32_to_cpu(sbi, sb->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\t\tif (fs32_to_cpu(sbi, sb->sb_magic) == QNX6_SUPER_MAGIC) {\n\t\t\t/* we got a big endian fs */\n\t\t\tpr_debug(\"fs got different endianness.\\n\");\n\t\t\treturn bh;\n\t\t} else\n\t\t\tsbi->s_bytesex = BYTESEX_LE;\n\t\tif (!silent) {\n\t\t\tif (offset == 0) {\n\t\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\",\n\t\t\t\t\toffset * s->s_blocksize);\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_mmi_fill_super",
          "args": [
            "s",
            "silent"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_mmi_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/super_mmi.c",
          "lines": "35-148",
          "snippet": "struct qnx6_super_block *qnx6_mmi_fill_super(struct super_block *s, int silent)\n{\n\tstruct buffer_head *bh1, *bh2 = NULL;\n\tstruct qnx6_mmi_super_block *sb1, *sb2;\n\tstruct qnx6_super_block *qsb = NULL;\n\tstruct qnx6_sb_info *sbi;\n\t__u64 offset;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1) {\n\t\tpr_err(\"Unable to read first mmi superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\tsbi = QNX6_SB(s);\n\tif (fs32_to_cpu(sbi, sb1->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent) {\n\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) + QNX6_SUPERBLOCK_AREA /\n\t\t\t\t\tfs32_to_cpu(sbi, sb1->sb_blocksize);\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1)\n\t\tgoto out;\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\n\t/* read second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_mmi_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum)\n\t\t\t!= crc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tqsb = kmalloc(sizeof(*qsb), GFP_KERNEL);\n\tif (!qsb) {\n\t\tpr_err(\"unable to allocate memory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb1);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh1->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb2);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh2->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\n\tkfree(qsb);\n\n\t/* offset for mmi_fs is just SUPERBLOCK_AREA bytes */\n\tsbi->s_blks_off = QNX6_SUPERBLOCK_AREA / s->s_blocksize;\n\n\t/* success */\n\treturn sbi->sb;\n\nout:\n\tif (bh1 != NULL)\n\t\tbrelse(bh1);\n\tif (bh2 != NULL)\n\t\tbrelse(bh2);\n\treturn NULL;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct qnx6_super_block *qnx6_mmi_fill_super(struct super_block *s, int silent)\n{\n\tstruct buffer_head *bh1, *bh2 = NULL;\n\tstruct qnx6_mmi_super_block *sb1, *sb2;\n\tstruct qnx6_super_block *qsb = NULL;\n\tstruct qnx6_sb_info *sbi;\n\t__u64 offset;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1) {\n\t\tpr_err(\"Unable to read first mmi superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\tsbi = QNX6_SB(s);\n\tif (fs32_to_cpu(sbi, sb1->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent) {\n\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) + QNX6_SUPERBLOCK_AREA /\n\t\t\t\t\tfs32_to_cpu(sbi, sb1->sb_blocksize);\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1)\n\t\tgoto out;\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\n\t/* read second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_mmi_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum)\n\t\t\t!= crc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tqsb = kmalloc(sizeof(*qsb), GFP_KERNEL);\n\tif (!qsb) {\n\t\tpr_err(\"unable to allocate memory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb1);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh1->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb2);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh2->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\n\tkfree(qsb);\n\n\t/* offset for mmi_fs is just SUPERBLOCK_AREA bytes */\n\tsbi->s_blks_off = QNX6_SUPERBLOCK_AREA / s->s_blocksize;\n\n\t/* success */\n\treturn sbi->sb;\n\nout:\n\tif (bh1 != NULL)\n\t\tbrelse(bh1);\n\tif (bh2 != NULL)\n\t\tbrelse(bh2);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "s",
            "MMI_FS"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid mount options.\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_parse_options",
          "args": [
            "(char *) data",
            "s"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "231-255",
          "snippet": "static int qnx6_parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mmifs:\n\t\t\tset_opt(sbi->s_mount_opt, MMI_FS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_mmifs, \"mmi_fs\"},\n\t{Opt_err, NULL}\n};",
            "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_mmifs, \"mmi_fs\"},\n\t{Opt_err, NULL}\n};\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);\n\nstatic int qnx6_parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mmifs:\n\t\t\tset_opt(sbi->s_mount_opt, MMI_FS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to set blocksize\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct qnx6_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct super_operations qnx6_sops;\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data);\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root);\nstatic const struct super_operations qnx6_sops = {\n\t.alloc_inode\t= qnx6_alloc_inode,\n\t.destroy_inode\t= qnx6_destroy_inode,\n\t.put_super\t= qnx6_put_super,\n\t.statfs\t\t= qnx6_statfs,\n\t.remount_fs\t= qnx6_remount,\n\t.show_options\t= qnx6_show_options,\n};\n\nstatic int qnx6_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh1 = NULL, *bh2 = NULL;\n\tstruct qnx6_super_block *sb1 = NULL, *sb2 = NULL;\n\tstruct qnx6_sb_info *sbi;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx6_sb_info *qs;\n\tint ret = -EINVAL;\n\tu64 offset;\n\tint bootblock_offset = QNX6_BOOTBLOCK_SIZE;\n\n\tqs = kzalloc(sizeof(struct qnx6_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\t/* Superblock always is 512 Byte long */\n\tif (!sb_set_blocksize(s, QNX6_SUPERBLOCK_SIZE)) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto outnobh;\n\t}\n\n\t/* parse the mount-options */\n\tif (!qnx6_parse_options((char *) data, s)) {\n\t\tpr_err(\"invalid mount options.\\n\");\n\t\tgoto outnobh;\n\t}\n\tif (test_opt(s, MMI_FS)) {\n\t\tsb1 = qnx6_mmi_fill_super(s, silent);\n\t\tif (sb1)\n\t\t\tgoto mmi_success;\n\t\telse\n\t\t\tgoto outnobh;\n\t}\n\tsbi = QNX6_SB(s);\n\tsbi->s_bytesex = BYTESEX_LE;\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = qnx6_check_first_superblock(s,\n\t\tbootblock_offset / QNX6_SUPERBLOCK_SIZE, silent);\n\tif (!bh1) {\n\t\t/* try again without bootblock offset */\n\t\tbh1 = qnx6_check_first_superblock(s, 0, silent);\n\t\tif (!bh1) {\n\t\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\t\tgoto outnobh;\n\t\t}\n\t\t/* seems that no bootblock at partition start */\n\t\tbootblock_offset = 0;\n\t}\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n#ifdef CONFIG_QNX6FS_DEBUG\n\tqnx6_superblock_debug(sb1, s);\n#endif\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, bootblock_offset >> s->s_blocksize_bits);\n\tif (!bh1)\n\t\tgoto outnobh;\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) +\n\t\t(bootblock_offset >> s->s_blocksize_bits) +\n\t\t(QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t/* set bootblock offset */\n\tsbi->s_blks_off = (bootblock_offset >> s->s_blocksize_bits) +\n\t\t\t  (QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t/* next the second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #2 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >=\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\nmmi_success:\n\t/* sanity check - limit maximum indirect pointer levels */\n\tif (sb1->Inode.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many inode levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Inode.levels);\n\t\tgoto out;\n\t}\n\tif (sb1->Longfile.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many longfilename levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Longfile.levels);\n\t\tgoto out;\n\t}\n\ts->s_op = &qnx6_sops;\n\ts->s_magic = QNX6_SUPER_MAGIC;\n\ts->s_flags |= MS_RDONLY;        /* Yup, read-only yet */\n\n\t/* ease the later tree level calculations */\n\tsbi = QNX6_SB(s);\n\tsbi->s_ptrbits = ilog2(s->s_blocksize / 4);\n\tsbi->inodes = qnx6_private_inode(s, &sb1->Inode);\n\tif (!sbi->inodes)\n\t\tgoto out;\n\tsbi->longfile = qnx6_private_inode(s, &sb1->Longfile);\n\tif (!sbi->longfile)\n\t\tgoto out1;\n\n\t/* prefetch root inode */\n\troot = qnx6_iget(s, QNX6_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto out2;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto out2;\n\n\tret = -EINVAL;\n\terrmsg = qnx6_checkroot(s);\n\tif (errmsg != NULL) {\n\t\tif (!silent)\n\t\t\tpr_err(\"%s\\n\", errmsg);\n\t\tgoto out3;\n\t}\n\treturn 0;\n\nout3:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout2:\n\tiput(sbi->longfile);\nout1:\n\tiput(sbi->inodes);\nout:\n\tif (bh1)\n\t\tbrelse(bh1);\n\tif (bh2)\n\t\tbrelse(bh2);\noutnobh:\n\tkfree(qs);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "qnx6_check_first_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "257-292",
    "snippet": "static struct buffer_head *qnx6_check_first_superblock(struct super_block *s,\n\t\t\t\tint offset, int silent)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct buffer_head *bh;\n\tstruct qnx6_super_block *sb;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh = sb_bread(s, offset);\n\tif (!bh) {\n\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb = (struct qnx6_super_block *)bh->b_data;\n\tif (fs32_to_cpu(sbi, sb->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\t\tif (fs32_to_cpu(sbi, sb->sb_magic) == QNX6_SUPER_MAGIC) {\n\t\t\t/* we got a big endian fs */\n\t\t\tpr_debug(\"fs got different endianness.\\n\");\n\t\t\treturn bh;\n\t\t} else\n\t\t\tsbi->s_bytesex = BYTESEX_LE;\n\t\tif (!silent) {\n\t\t\tif (offset == 0) {\n\t\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\",\n\t\t\t\t\toffset * s->s_blocksize);\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\"",
            "offset * s->s_blocksize"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong signature (magic) in superblock #1.\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"fs got different endianness.\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sb->sb_magic"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read the first superblock\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "offset"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nstatic struct buffer_head *qnx6_check_first_superblock(struct super_block *s,\n\t\t\t\tint offset, int silent)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct buffer_head *bh;\n\tstruct qnx6_super_block *sb;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh = sb_bread(s, offset);\n\tif (!bh) {\n\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb = (struct qnx6_super_block *)bh->b_data;\n\tif (fs32_to_cpu(sbi, sb->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\t\tif (fs32_to_cpu(sbi, sb->sb_magic) == QNX6_SUPER_MAGIC) {\n\t\t\t/* we got a big endian fs */\n\t\t\tpr_debug(\"fs got different endianness.\\n\");\n\t\t\treturn bh;\n\t\t} else\n\t\t\tsbi->s_bytesex = BYTESEX_LE;\n\t\tif (!silent) {\n\t\t\tif (offset == 0) {\n\t\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\",\n\t\t\t\t\toffset * s->s_blocksize);\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
  },
  {
    "function_name": "qnx6_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "231-255",
    "snippet": "static int qnx6_parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mmifs:\n\t\t\tset_opt(sbi->s_mount_opt, MMI_FS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static const match_table_t tokens = {\n\t{Opt_mmifs, \"mmi_fs\"},\n\t{Opt_err, NULL}\n};",
      "static struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "MMI_FS"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_mmifs, \"mmi_fs\"},\n\t{Opt_err, NULL}\n};\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);\n\nstatic int qnx6_parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mmifs:\n\t\t\tset_opt(sbi->s_mount_opt, MMI_FS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "qnx6_superblock_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "204-218",
    "snippet": "void qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"inode_levels: %02x\\n\"",
            "sb->Inode.levels"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"free_blocks: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_free_blocks)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sb->sb_free_blocks"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"num_blocks: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_num_blocks)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"free_inodes: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_free_inodes)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"num_inodes: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_num_inodes)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"blocksize: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_blocksize)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"flags: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_flags)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"serial: %llx\\n\"",
            "fs64_to_cpu(sbi, sb->sb_serial)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sbi",
            "sb->sb_serial"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "77-83",
          "snippet": "static inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"checksum: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_checksum)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"magic: %08x\\n\"",
            "fs32_to_cpu(sbi, sb->sb_magic)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nvoid qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}"
  },
  {
    "function_name": "qnx6_checkroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "180-201",
    "snippet": "static const char *qnx6_checkroot(struct super_block *s)\n{\n\tstatic char match_root[2][3] = {\".\\0\\0\", \"..\\0\"};\n\tint i, error = 0;\n\tstruct qnx6_dir_entry *dir_entry;\n\tstruct inode *root = s->s_root->d_inode;\n\tstruct address_space *mapping = root->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn \"error reading root directory\";\n\tkmap(page);\n\tdir_entry = page_address(page);\n\tfor (i = 0; i < 2; i++) {\n\t\t/* maximum 3 bytes - due to match_root limitation */\n\t\tif (strncmp(dir_entry[i].de_fname, match_root[i], 3))\n\t\t\terror = 1;\n\t}\n\tqnx6_put_page(page);\n\tif (error)\n\t\treturn \"error reading root directory.\";\n\treturn NULL;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static int qnx6_show_options(struct seq_file *seq, struct dentry *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qnx6_put_page",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "128-132",
          "snippet": "static inline void qnx6_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline void qnx6_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "dir_entry[i].de_fname",
            "match_root[i]",
            "3"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "0",
            "NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root);\n\nstatic const char *qnx6_checkroot(struct super_block *s)\n{\n\tstatic char match_root[2][3] = {\".\\0\\0\", \"..\\0\"};\n\tint i, error = 0;\n\tstruct qnx6_dir_entry *dir_entry;\n\tstruct inode *root = s->s_root->d_inode;\n\tstruct address_space *mapping = root->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn \"error reading root directory\";\n\tkmap(page);\n\tdir_entry = page_address(page);\n\tfor (i = 0; i < 2; i++) {\n\t\t/* maximum 3 bytes - due to match_root limitation */\n\t\tif (strncmp(dir_entry[i].de_fname, match_root[i], 3))\n\t\t\terror = 1;\n\t}\n\tqnx6_put_page(page);\n\tif (error)\n\t\treturn \"error reading root directory.\";\n\treturn NULL;\n}"
  },
  {
    "function_name": "qnx6_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "155-173",
    "snippet": "static int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = fs32_to_cpu(sbi, sbi->sb->sb_num_blocks);\n\tbuf->f_bfree   = fs32_to_cpu(sbi, sbi->sb->sb_free_blocks);\n\tbuf->f_files   = fs32_to_cpu(sbi, sbi->sb->sb_num_inodes);\n\tbuf->f_ffree   = fs32_to_cpu(sbi, sbi->sb->sb_free_inodes);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX6_LONG_NAME_MAX;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbi->sb->sb_free_inodes"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = fs32_to_cpu(sbi, sbi->sb->sb_num_blocks);\n\tbuf->f_bfree   = fs32_to_cpu(sbi, sbi->sb->sb_free_blocks);\n\tbuf->f_files   = fs32_to_cpu(sbi, sbi->sb->sb_num_inodes);\n\tbuf->f_ffree   = fs32_to_cpu(sbi, sbi->sb->sb_free_inodes);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX6_LONG_NAME_MAX;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx6_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "111-153",
    "snippet": "static unsigned qnx6_block_map(struct inode *inode, unsigned no)\n{\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\tunsigned block = 0;\n\tstruct buffer_head *bh;\n\t__fs32 ptr;\n\tint levelptr;\n\tint ptrbits = sbi->s_ptrbits;\n\tint bitdelta;\n\tu32 mask = (1 << ptrbits) - 1;\n\tint depth = ei->di_filelevels;\n\tint i;\n\n\tbitdelta = ptrbits * depth;\n\tlevelptr = no >> bitdelta;\n\n\tif (levelptr > QNX6_NO_DIRECT_POINTERS - 1) {\n\t\tpr_err(\"Requested file block number (%u) too big.\", no);\n\t\treturn 0;\n\t}\n\n\tblock = qnx6_get_devblock(s, ei->di_block_ptr[levelptr]);\n\n\tfor (i = 0; i < depth; i++) {\n\t\tbh = sb_bread(s, block);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Error reading block (%u)\\n\", block);\n\t\t\treturn 0;\n\t\t}\n\t\tbitdelta -= ptrbits;\n\t\tlevelptr = (no >> bitdelta) & mask;\n\t\tptr = ((__fs32 *)bh->b_data)[levelptr];\n\n\t\tif (!qnx6_check_blockptr(ptr))\n\t\t\treturn 0;\n\n\t\tblock = qnx6_get_devblock(s, ptr);\n\t\tbrelse(bh);\n\t}\n\treturn block;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_get_devblock",
          "args": [
            "s",
            "ptr"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_get_devblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "63-67",
          "snippet": "static unsigned qnx6_get_devblock(struct super_block *sb, __fs32 block)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\treturn fs32_to_cpu(sbi, block) + sbi->s_blks_off;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nstatic unsigned qnx6_get_devblock(struct super_block *sb, __fs32 block)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\treturn fs32_to_cpu(sbi, block) + sbi->s_blks_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_check_blockptr",
          "args": [
            "ptr"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_check_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "87-94",
          "snippet": "static int qnx6_check_blockptr(__fs32 ptr)\n{\n\tif (ptr == ~(__fs32)0) {\n\t\tpr_err(\"hit unused blockpointer.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx6_check_blockptr(__fs32 ptr)\n{\n\tif (ptr == ~(__fs32)0) {\n\t\tpr_err(\"hit unused blockpointer.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error reading block (%u)\\n\"",
            "block"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "block"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Requested file block number (%u) too big.\"",
            "no"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_I",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "63-66",
          "snippet": "static inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_inode_info *QNX6_I(struct inode *inode)\n{\n\treturn container_of(inode, struct qnx6_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\n\nstatic unsigned qnx6_block_map(struct inode *inode, unsigned no)\n{\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\tunsigned block = 0;\n\tstruct buffer_head *bh;\n\t__fs32 ptr;\n\tint levelptr;\n\tint ptrbits = sbi->s_ptrbits;\n\tint bitdelta;\n\tu32 mask = (1 << ptrbits) - 1;\n\tint depth = ei->di_filelevels;\n\tint i;\n\n\tbitdelta = ptrbits * depth;\n\tlevelptr = no >> bitdelta;\n\n\tif (levelptr > QNX6_NO_DIRECT_POINTERS - 1) {\n\t\tpr_err(\"Requested file block number (%u) too big.\", no);\n\t\treturn 0;\n\t}\n\n\tblock = qnx6_get_devblock(s, ei->di_block_ptr[levelptr]);\n\n\tfor (i = 0; i < depth; i++) {\n\t\tbh = sb_bread(s, block);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Error reading block (%u)\\n\", block);\n\t\t\treturn 0;\n\t\t}\n\t\tbitdelta -= ptrbits;\n\t\tlevelptr = (no >> bitdelta) & mask;\n\t\tptr = ((__fs32 *)bh->b_data)[levelptr];\n\n\t\tif (!qnx6_check_blockptr(ptr))\n\t\t\treturn 0;\n\n\t\tblock = qnx6_get_devblock(s, ptr);\n\t\tbrelse(bh);\n\t}\n\treturn block;\n}"
  },
  {
    "function_name": "qnx6_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "101-105",
    "snippet": "static int qnx6_readpages(struct file *file, struct address_space *mapping,\n\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, qnx6_get_block);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "qnx6_get_block"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx6_readpages(struct file *file, struct address_space *mapping,\n\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, qnx6_get_block);\n}"
  },
  {
    "function_name": "qnx6_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "96-99",
    "snippet": "static int qnx6_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, qnx6_get_block);\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "qnx6_get_block"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx6_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, qnx6_get_block);\n}"
  },
  {
    "function_name": "qnx6_check_blockptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "87-94",
    "snippet": "static int qnx6_check_blockptr(__fs32 ptr)\n{\n\tif (ptr == ~(__fs32)0) {\n\t\tpr_err(\"hit unused blockpointer.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hit unused blockpointer.\\n\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx6_check_blockptr(__fs32 ptr)\n{\n\tif (ptr == ~(__fs32)0) {\n\t\tpr_err(\"hit unused blockpointer.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "qnx6_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "71-85",
    "snippet": "static int qnx6_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tunsigned phys;\n\n\tpr_debug(\"qnx6_get_block inode=[%ld] iblock=[%ld]\\n\",\n\t\t inode->i_ino, (unsigned long)iblock);\n\n\tphys = qnx6_block_map(inode, iblock);\n\tif (phys) {\n\t\t/* logical block is before EOF */\n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_destroy_inode(struct inode *inode);",
      "static unsigned qnx6_block_map(struct inode *inode, unsigned iblock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "phys"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_block_map",
          "args": [
            "inode",
            "iblock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "111-153",
          "snippet": "static unsigned qnx6_block_map(struct inode *inode, unsigned no)\n{\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\tunsigned block = 0;\n\tstruct buffer_head *bh;\n\t__fs32 ptr;\n\tint levelptr;\n\tint ptrbits = sbi->s_ptrbits;\n\tint bitdelta;\n\tu32 mask = (1 << ptrbits) - 1;\n\tint depth = ei->di_filelevels;\n\tint i;\n\n\tbitdelta = ptrbits * depth;\n\tlevelptr = no >> bitdelta;\n\n\tif (levelptr > QNX6_NO_DIRECT_POINTERS - 1) {\n\t\tpr_err(\"Requested file block number (%u) too big.\", no);\n\t\treturn 0;\n\t}\n\n\tblock = qnx6_get_devblock(s, ei->di_block_ptr[levelptr]);\n\n\tfor (i = 0; i < depth; i++) {\n\t\tbh = sb_bread(s, block);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Error reading block (%u)\\n\", block);\n\t\t\treturn 0;\n\t\t}\n\t\tbitdelta -= ptrbits;\n\t\tlevelptr = (no >> bitdelta) & mask;\n\t\tptr = ((__fs32 *)bh->b_data)[levelptr];\n\n\t\tif (!qnx6_check_blockptr(ptr))\n\t\t\treturn 0;\n\n\t\tblock = qnx6_get_devblock(s, ptr);\n\t\tbrelse(bh);\n\t}\n\treturn block;\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\n\nstatic unsigned qnx6_block_map(struct inode *inode, unsigned no)\n{\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\tunsigned block = 0;\n\tstruct buffer_head *bh;\n\t__fs32 ptr;\n\tint levelptr;\n\tint ptrbits = sbi->s_ptrbits;\n\tint bitdelta;\n\tu32 mask = (1 << ptrbits) - 1;\n\tint depth = ei->di_filelevels;\n\tint i;\n\n\tbitdelta = ptrbits * depth;\n\tlevelptr = no >> bitdelta;\n\n\tif (levelptr > QNX6_NO_DIRECT_POINTERS - 1) {\n\t\tpr_err(\"Requested file block number (%u) too big.\", no);\n\t\treturn 0;\n\t}\n\n\tblock = qnx6_get_devblock(s, ei->di_block_ptr[levelptr]);\n\n\tfor (i = 0; i < depth; i++) {\n\t\tbh = sb_bread(s, block);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Error reading block (%u)\\n\", block);\n\t\t\treturn 0;\n\t\t}\n\t\tbitdelta -= ptrbits;\n\t\tlevelptr = (no >> bitdelta) & mask;\n\t\tptr = ((__fs32 *)bh->b_data)[levelptr];\n\n\t\tif (!qnx6_check_blockptr(ptr))\n\t\t\treturn 0;\n\n\t\tblock = qnx6_get_devblock(s, ptr);\n\t\tbrelse(bh);\n\t}\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"qnx6_get_block inode=[%ld] iblock=[%ld]\\n\"",
            "inode->i_ino",
            "(unsigned long)iblock"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_destroy_inode(struct inode *inode);\nstatic unsigned qnx6_block_map(struct inode *inode, unsigned iblock);\n\nstatic int qnx6_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tunsigned phys;\n\n\tpr_debug(\"qnx6_get_block inode=[%ld] iblock=[%ld]\\n\",\n\t\t inode->i_ino, (unsigned long)iblock);\n\n\tphys = qnx6_block_map(inode, iblock);\n\tif (phys) {\n\t\t/* logical block is before EOF */\n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx6_get_devblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "63-67",
    "snippet": "static unsigned qnx6_get_devblock(struct super_block *sb, __fs32 block)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\treturn fs32_to_cpu(sbi, block) + sbi->s_blks_off;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "block"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nstatic unsigned qnx6_get_devblock(struct super_block *sb, __fs32 block)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\treturn fs32_to_cpu(sbi, block) + sbi->s_blks_off;\n}"
  },
  {
    "function_name": "qnx6_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "56-61",
    "snippet": "static int qnx6_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static int qnx6_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx6_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
    "lines": "46-54",
    "snippet": "static int qnx6_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\n\tif (sbi->s_mount_opt & QNX6_MOUNT_MMI_FS)\n\t\tseq_puts(seq, \",mmi_fs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/crc32.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx6_put_super(struct super_block *sb);",
      "static struct inode *qnx6_alloc_inode(struct super_block *sb);",
      "static int qnx6_show_options(struct seq_file *seq, struct dentry *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",mmi_fs\""
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "sb"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root);\n\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\n\tif (sbi->s_mount_opt & QNX6_MOUNT_MMI_FS)\n\t\tseq_puts(seq, \",mmi_fs\");\n\treturn 0;\n}"
  }
]