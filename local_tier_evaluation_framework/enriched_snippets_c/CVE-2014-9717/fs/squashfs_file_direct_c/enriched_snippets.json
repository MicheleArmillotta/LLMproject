[
  {
    "function_name": "squashfs_read_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file_direct.c",
    "lines": "140-176",
    "snippet": "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page)\n{\n\tstruct inode *i = target_page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\t\t\t\t\t block, bsize);\n\tint bytes = buffer->length, res = buffer->error, n, offset = 0;\n\tvoid *pageaddr;\n\n\tif (res) {\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\t\tgoto out;\n\t}\n\n\tfor (n = 0; n < pages && bytes > 0; n++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tint avail = min_t(int, bytes, PAGE_CACHE_SIZE);\n\n\t\tif (page[n] == NULL)\n\t\t\tcontinue;\n\n\t\tpageaddr = kmap_atomic(page[n]);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(page[n]);\n\t\tSetPageUptodate(page[n]);\n\t\tunlock_page(page[n]);\n\t\tif (page[n] != target_page)\n\t\t\tpage_cache_release(page[n]);\n\t}\n\nout:\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_put",
          "args": [
            "buffer"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "186-205",
          "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page[n]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page[n]"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page[n]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page[n]"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pageaddr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pageaddr + avail",
            "0",
            "PAGE_CACHE_SIZE - avail"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_copy_data",
          "args": [
            "pageaddr",
            "buffer",
            "offset",
            "avail"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "306-335",
          "snippet": "int squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page[n]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "bytes",
            "PAGE_CACHE_SIZE"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read page, block %llx, size %x\\n\"",
            "block",
            "bsize"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_get_datablock",
          "args": [
            "i->i_sb",
            "block",
            "bsize"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_get_datablock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "404-410",
          "snippet": "struct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page)\n{\n\tstruct inode *i = target_page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\t\t\t\t\t block, bsize);\n\tint bytes = buffer->length, res = buffer->error, n, offset = 0;\n\tvoid *pageaddr;\n\n\tif (res) {\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\t\tgoto out;\n\t}\n\n\tfor (n = 0; n < pages && bytes > 0; n++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tint avail = min_t(int, bytes, PAGE_CACHE_SIZE);\n\n\t\tif (page[n] == NULL)\n\t\t\tcontinue;\n\n\t\tpageaddr = kmap_atomic(page[n]);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(page[n]);\n\t\tSetPageUptodate(page[n]);\n\t\tunlock_page(page[n]);\n\t\tif (page[n] != target_page)\n\t\t\tpage_cache_release(page[n]);\n\t}\n\nout:\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}"
  },
  {
    "function_name": "squashfs_readpage_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file_direct.c",
    "lines": "27-137",
    "snippet": "int squashfs_readpage_block(struct page *target_page, u64 block, int bsize)\n\n{\n\tstruct inode *inode = target_page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\n\tint file_end = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\tint mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = target_page->index & ~mask;\n\tint end_index = start_index | mask;\n\tint i, n, pages, missing_pages, bytes, res = -ENOMEM;\n\tstruct page **page;\n\tstruct squashfs_page_actor *actor;\n\tvoid *pageaddr;\n\n\tif (end_index > file_end)\n\t\tend_index = file_end;\n\n\tpages = end_index - start_index + 1;\n\n\tpage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn res;\n\n\t/*\n\t * Create a \"page actor\" which will kmap and kunmap the\n\t * page cache pages appropriately within the decompressor\n\t */\n\tactor = squashfs_page_actor_init_special(page, pages, 0);\n\tif (actor == NULL)\n\t\tgoto out;\n\n\t/* Try to grab all the pages covered by the Squashfs block */\n\tfor (missing_pages = 0, i = 0, n = start_index; i < pages; i++, n++) {\n\t\tpage[i] = (n == target_page->index) ? target_page :\n\t\t\tgrab_cache_page_nowait(target_page->mapping, n);\n\n\t\tif (page[i] == NULL) {\n\t\t\tmissing_pages++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageUptodate(page[i])) {\n\t\t\tunlock_page(page[i]);\n\t\t\tpage_cache_release(page[i]);\n\t\t\tpage[i] = NULL;\n\t\t\tmissing_pages++;\n\t\t}\n\t}\n\n\tif (missing_pages) {\n\t\t/*\n\t\t * Couldn't get one or more pages, this page has either\n\t\t * been VM reclaimed, but others are still in the page cache\n\t\t * and uptodate, or we're racing with another thread in\n\t\t * squashfs_readpage also trying to grab them.  Fall back to\n\t\t * using an intermediate buffer.\n\t\t */\n\t\tres = squashfs_read_cache(target_page, block, bsize, pages,\n\t\t\t\t\t\t\t\tpage);\n\t\tif (res < 0)\n\t\t\tgoto mark_errored;\n\n\t\tgoto out;\n\t}\n\n\t/* Decompress directly into the page cache buffers */\n\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\tif (res < 0)\n\t\tgoto mark_errored;\n\n\t/* Last page may have trailing bytes not filled */\n\tbytes = res % PAGE_CACHE_SIZE;\n\tif (bytes) {\n\t\tpageaddr = kmap_atomic(page[pages - 1]);\n\t\tmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\n\t\tkunmap_atomic(pageaddr);\n\t}\n\n\t/* Mark pages as uptodate, unlock and release */\n\tfor (i = 0; i < pages; i++) {\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageUptodate(page[i]);\n\t\tunlock_page(page[i]);\n\t\tif (page[i] != target_page)\n\t\t\tpage_cache_release(page[i]);\n\t}\n\n\tkfree(actor);\n\tkfree(page);\n\n\treturn 0;\n\nmark_errored:\n\t/* Decompression failed, mark pages as errored.  Target_page is\n\t * dealt with by the caller\n\t */\n\tfor (i = 0; i < pages; i++) {\n\t\tif (page[i] == NULL || page[i] == target_page)\n\t\t\tcontinue;\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageError(page[i]);\n\t\tunlock_page(page[i]);\n\t\tpage_cache_release(page[i]);\n\t}\n\nout:\n\tkfree(actor);\n\tkfree(page);\n\treturn res;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "actor"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page[i]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page[i]"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page[i]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page[i]"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "actor"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page[i]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page[i]"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pageaddr"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pageaddr + bytes",
            "0",
            "PAGE_CACHE_SIZE - bytes"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page[pages - 1]"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_data",
          "args": [
            "inode->i_sb",
            "block",
            "bsize",
            "NULL",
            "actor"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
          "lines": "90-214",
          "snippet": "int squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_cache",
          "args": [
            "target_page",
            "block",
            "bsize",
            "pages",
            "page"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file_direct.c",
          "lines": "140-176",
          "snippet": "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page)\n{\n\tstruct inode *i = target_page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\t\t\t\t\t block, bsize);\n\tint bytes = buffer->length, res = buffer->error, n, offset = 0;\n\tvoid *pageaddr;\n\n\tif (res) {\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\t\tgoto out;\n\t}\n\n\tfor (n = 0; n < pages && bytes > 0; n++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tint avail = min_t(int, bytes, PAGE_CACHE_SIZE);\n\n\t\tif (page[n] == NULL)\n\t\t\tcontinue;\n\n\t\tpageaddr = kmap_atomic(page[n]);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(page[n]);\n\t\tSetPageUptodate(page[n]);\n\t\tunlock_page(page[n]);\n\t\tif (page[n] != target_page)\n\t\t\tpage_cache_release(page[n]);\n\t}\n\nout:\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page)\n{\n\tstruct inode *i = target_page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\t\t\t\t\t block, bsize);\n\tint bytes = buffer->length, res = buffer->error, n, offset = 0;\n\tvoid *pageaddr;\n\n\tif (res) {\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\t\tgoto out;\n\t}\n\n\tfor (n = 0; n < pages && bytes > 0; n++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tint avail = min_t(int, bytes, PAGE_CACHE_SIZE);\n\n\t\tif (page[n] == NULL)\n\t\t\tcontinue;\n\n\t\tpageaddr = kmap_atomic(page[n]);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(page[n]);\n\t\tSetPageUptodate(page[n]);\n\t\tunlock_page(page[n]);\n\t\tif (page[n] != target_page)\n\t\t\tpage_cache_release(page[n]);\n\t}\n\nout:\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page[i]"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page[i]"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_nowait",
          "args": [
            "target_page->mapping",
            "n"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_page_actor_init_special",
          "args": [
            "page",
            "pages",
            "0"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_page_actor_init_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.c",
          "lines": "83-100",
          "snippet": "struct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);\n\nint squashfs_readpage_block(struct page *target_page, u64 block, int bsize)\n\n{\n\tstruct inode *inode = target_page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\n\tint file_end = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\tint mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = target_page->index & ~mask;\n\tint end_index = start_index | mask;\n\tint i, n, pages, missing_pages, bytes, res = -ENOMEM;\n\tstruct page **page;\n\tstruct squashfs_page_actor *actor;\n\tvoid *pageaddr;\n\n\tif (end_index > file_end)\n\t\tend_index = file_end;\n\n\tpages = end_index - start_index + 1;\n\n\tpage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn res;\n\n\t/*\n\t * Create a \"page actor\" which will kmap and kunmap the\n\t * page cache pages appropriately within the decompressor\n\t */\n\tactor = squashfs_page_actor_init_special(page, pages, 0);\n\tif (actor == NULL)\n\t\tgoto out;\n\n\t/* Try to grab all the pages covered by the Squashfs block */\n\tfor (missing_pages = 0, i = 0, n = start_index; i < pages; i++, n++) {\n\t\tpage[i] = (n == target_page->index) ? target_page :\n\t\t\tgrab_cache_page_nowait(target_page->mapping, n);\n\n\t\tif (page[i] == NULL) {\n\t\t\tmissing_pages++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageUptodate(page[i])) {\n\t\t\tunlock_page(page[i]);\n\t\t\tpage_cache_release(page[i]);\n\t\t\tpage[i] = NULL;\n\t\t\tmissing_pages++;\n\t\t}\n\t}\n\n\tif (missing_pages) {\n\t\t/*\n\t\t * Couldn't get one or more pages, this page has either\n\t\t * been VM reclaimed, but others are still in the page cache\n\t\t * and uptodate, or we're racing with another thread in\n\t\t * squashfs_readpage also trying to grab them.  Fall back to\n\t\t * using an intermediate buffer.\n\t\t */\n\t\tres = squashfs_read_cache(target_page, block, bsize, pages,\n\t\t\t\t\t\t\t\tpage);\n\t\tif (res < 0)\n\t\t\tgoto mark_errored;\n\n\t\tgoto out;\n\t}\n\n\t/* Decompress directly into the page cache buffers */\n\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\tif (res < 0)\n\t\tgoto mark_errored;\n\n\t/* Last page may have trailing bytes not filled */\n\tbytes = res % PAGE_CACHE_SIZE;\n\tif (bytes) {\n\t\tpageaddr = kmap_atomic(page[pages - 1]);\n\t\tmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\n\t\tkunmap_atomic(pageaddr);\n\t}\n\n\t/* Mark pages as uptodate, unlock and release */\n\tfor (i = 0; i < pages; i++) {\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageUptodate(page[i]);\n\t\tunlock_page(page[i]);\n\t\tif (page[i] != target_page)\n\t\t\tpage_cache_release(page[i]);\n\t}\n\n\tkfree(actor);\n\tkfree(page);\n\n\treturn 0;\n\nmark_errored:\n\t/* Decompression failed, mark pages as errored.  Target_page is\n\t * dealt with by the caller\n\t */\n\tfor (i = 0; i < pages; i++) {\n\t\tif (page[i] == NULL || page[i] == target_page)\n\t\t\tcontinue;\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageError(page[i]);\n\t\tunlock_page(page[i]);\n\t\tpage_cache_release(page[i]);\n\t}\n\nout:\n\tkfree(actor);\n\tkfree(page);\n\treturn res;\n}"
  }
]