[
  {
    "function_name": "logfs_cleanup_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "956-961",
    "snippet": "void logfs_cleanup_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor128(&super->s_object_alias_tree, 0, kill_alias);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_grim_visitor128",
          "args": [
            "&super->s_object_alias_tree",
            "0",
            "kill_alias"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor128(&super->s_object_alias_tree, 0, kill_alias);\n}"
  },
  {
    "function_name": "logfs_init_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "923-954",
    "snippet": "int logfs_init_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i = -1;\n\n\tsuper->s_alias_pool = mempool_create_kmalloc_pool(600,\n\t\t\tsizeof(struct object_alias_item));\n\tif (!super->s_alias_pool)\n\t\treturn -ENOMEM;\n\n\tsuper->s_journal_area = alloc_area(sb);\n\tif (!super->s_journal_area)\n\t\tgoto err;\n\n\tfor_each_area(i) {\n\t\tsuper->s_area[i] = alloc_area(sb);\n\t\tif (!super->s_area[i])\n\t\t\tgoto err;\n\t\tsuper->s_area[i]->a_level = GC_LEVEL(i);\n\t\tsuper->s_area[i]->a_ops = &ostore_area_ops;\n\t}\n\tbtree_init_mempool128(&super->s_object_alias_tree,\n\t\t\tsuper->s_btree_pool);\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct logfs_area_ops ostore_area_ops = {\n\t.get_free_segment\t= ostore_get_free_segment,\n\t.get_erase_count\t= ostore_get_erase_count,\n\t.erase_segment\t\t= ostore_erase_segment,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mempool_destroy",
          "args": [
            "super->s_alias_pool"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_area",
          "args": [
            "super->s_journal_area"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "free_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "866-874",
          "snippet": "void free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_init_mempool128",
          "args": [
            "&super->s_object_alias_tree",
            "super->s_btree_pool"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GC_LEVEL",
          "args": [
            "i"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_area",
          "args": [
            "sb"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "876-886",
          "snippet": "static struct logfs_area *alloc_area(struct super_block *sb)\n{\n\tstruct logfs_area *area;\n\n\tarea = kzalloc(sizeof(*area), GFP_KERNEL);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->a_sb = sb;\n\treturn area;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct logfs_area *alloc_area(struct super_block *sb)\n{\n\tstruct logfs_area *area;\n\n\tarea = kzalloc(sizeof(*area), GFP_KERNEL);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->a_sb = sb;\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_create_kmalloc_pool",
          "args": [
            "600",
            "sizeof(struct object_alias_item)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_area_ops ostore_area_ops = {\n\t.get_free_segment\t= ostore_get_free_segment,\n\t.get_erase_count\t= ostore_get_erase_count,\n\t.erase_segment\t\t= ostore_erase_segment,\n};\n\nint logfs_init_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i = -1;\n\n\tsuper->s_alias_pool = mempool_create_kmalloc_pool(600,\n\t\t\tsizeof(struct object_alias_item));\n\tif (!super->s_alias_pool)\n\t\treturn -ENOMEM;\n\n\tsuper->s_journal_area = alloc_area(sb);\n\tif (!super->s_journal_area)\n\t\tgoto err;\n\n\tfor_each_area(i) {\n\t\tsuper->s_area[i] = alloc_area(sb);\n\t\tif (!super->s_area[i])\n\t\t\tgoto err;\n\t\tsuper->s_area[i]->a_level = GC_LEVEL(i);\n\t\tsuper->s_area[i]->a_ops = &ostore_area_ops;\n\t}\n\tbtree_init_mempool128(&super->s_object_alias_tree,\n\t\t\tsuper->s_btree_pool);\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "logfs_init_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "906-921",
    "snippet": "int logfs_init_mapping(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\n\tinode = logfs_new_meta_inode(sb, LOGFS_INO_MAPPING);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_mapping_inode = inode;\n\tmapping = inode->i_mapping;\n\tmapping->a_ops = &mapping_aops;\n\t/* Would it be possible to use __GFP_HIGHMEM as well? */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations mapping_aops = {\n\t.invalidatepage = map_invalidatepage,\n\t.releasepage\t= map_releasepage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_NOFS"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_meta_inode",
          "args": [
            "sb",
            "LOGFS_INO_MAPPING"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_meta_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "262-276",
          "snippet": "struct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct address_space_operations mapping_aops = {\n\t.invalidatepage = map_invalidatepage,\n\t.releasepage\t= map_releasepage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n};\n\nint logfs_init_mapping(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\n\tinode = logfs_new_meta_inode(sb, LOGFS_INO_MAPPING);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_mapping_inode = inode;\n\tmapping = inode->i_mapping;\n\tmapping->a_ops = &mapping_aops;\n\t/* Would it be possible to use __GFP_HIGHMEM as well? */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\treturn 0;\n}"
  },
  {
    "function_name": "map_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "894-898",
    "snippet": "static int map_releasepage(struct page *page, gfp_t g)\n{\n\t/* Don't release these pages */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int map_releasepage(struct page *page, gfp_t g)\n{\n\t/* Don't release these pages */\n\treturn 0;\n}"
  },
  {
    "function_name": "map_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "888-892",
    "snippet": "static void map_invalidatepage(struct page *page, unsigned int o,\n\t\t\t       unsigned int l)\n{\n\treturn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void map_invalidatepage(struct page *page, unsigned int o,\n\t\t\t       unsigned int l)\n{\n\treturn;\n}"
  },
  {
    "function_name": "alloc_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "876-886",
    "snippet": "static struct logfs_area *alloc_area(struct super_block *sb)\n{\n\tstruct logfs_area *area;\n\n\tarea = kzalloc(sizeof(*area), GFP_KERNEL);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->a_sb = sb;\n\treturn area;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*area)",
            "GFP_KERNEL"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct logfs_area *alloc_area(struct super_block *sb)\n{\n\tstruct logfs_area *area;\n\n\tarea = kzalloc(sizeof(*area), GFP_KERNEL);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->a_sb = sb;\n\treturn area;\n}"
  },
  {
    "function_name": "free_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "866-874",
    "snippet": "void free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_area",
          "args": [
            "super->s_journal_area"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "free_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "866-874",
          "snippet": "void free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}"
  },
  {
    "function_name": "free_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "859-864",
    "snippet": "static void free_area(struct logfs_area *area)\n{\n\tif (area)\n\t\tfreeseg(area->a_sb, area->a_segno);\n\tkfree(area);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeseg",
          "args": [
            "area->a_sb",
            "area->a_segno"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "freeseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "711-730",
          "snippet": "void freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void free_area(struct logfs_area *area)\n{\n\tif (area)\n\t\tfreeseg(area->a_sb, area->a_segno);\n\tkfree(area);\n}"
  },
  {
    "function_name": "ostore_erase_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "825-851",
    "snippet": "static int ostore_erase_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_segment_header sh;\n\tu64 ofs;\n\tint err;\n\n\terr = logfs_erase_segment(sb, area->a_segno, 0);\n\tif (err)\n\t\treturn err;\n\n\tsh.pad = 0;\n\tsh.type = SEG_OSTORE;\n\tsh.level = (__force u8)area->a_level;\n\tsh.segno = cpu_to_be32(area->a_segno);\n\tsh.ec = cpu_to_be32(area->a_erase_count);\n\tsh.gec = cpu_to_be64(logfs_super(sb)->s_gec);\n\tsh.crc = logfs_crc32(&sh, sizeof(sh), 4);\n\n\tlogfs_set_segment_erased(sb, area->a_segno, area->a_erase_count,\n\t\t\tarea->a_level);\n\n\tofs = dev_ofs(sb, area->a_segno, 0);\n\tarea->a_used_bytes = sizeof(sh);\n\tlogfs_buf_write(area, ofs, &sh, sizeof(sh));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_buf_write",
          "args": [
            "area",
            "ofs",
            "&sh",
            "sizeof(sh)"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "608-612",
          "snippet": "static inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_segment_erased",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_erase_count",
            "area->a_level"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_segment_erased",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2099-2105",
          "snippet": "void logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "&sh",
            "sizeof(sh)",
            "4"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "logfs_super(sb)->s_gec"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_erase_count"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_segno"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_erase_segment",
          "args": [
            "sb",
            "area->a_segno",
            "0"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_erase_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "29-37",
          "snippet": "int logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int ostore_erase_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_segment_header sh;\n\tu64 ofs;\n\tint err;\n\n\terr = logfs_erase_segment(sb, area->a_segno, 0);\n\tif (err)\n\t\treturn err;\n\n\tsh.pad = 0;\n\tsh.type = SEG_OSTORE;\n\tsh.level = (__force u8)area->a_level;\n\tsh.segno = cpu_to_be32(area->a_segno);\n\tsh.ec = cpu_to_be32(area->a_erase_count);\n\tsh.gec = cpu_to_be64(logfs_super(sb)->s_gec);\n\tsh.crc = logfs_crc32(&sh, sizeof(sh), 4);\n\n\tlogfs_set_segment_erased(sb, area->a_segno, area->a_erase_count,\n\t\t\tarea->a_level);\n\n\tofs = dev_ofs(sb, area->a_segno, 0);\n\tarea->a_used_bytes = sizeof(sh);\n\tlogfs_buf_write(area, ofs, &sh, sizeof(sh));\n\treturn 0;\n}"
  },
  {
    "function_name": "ostore_get_erase_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "812-823",
    "snippet": "static void ostore_get_erase_count(struct logfs_area *area)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(area->a_sb, area->a_segno, &se);\n\tBUG_ON(se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED));\n\n\tec_level = be32_to_cpu(se.ec_level);\n\tarea->a_erase_count = (ec_level >> 4) + 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RESERVED"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "BADSEG"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_segment_entry",
          "args": [
            "area->a_sb",
            "area->a_segno",
            "&se"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2068-2072",
          "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void ostore_get_erase_count(struct logfs_area *area)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(area->a_sb, area->a_segno, &se);\n\tBUG_ON(se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED));\n\n\tec_level = be32_to_cpu(se.ec_level);\n\tarea->a_erase_count = (ec_level >> 4) + 1;\n}"
  },
  {
    "function_name": "ostore_get_free_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "799-810",
    "snippet": "static void ostore_get_free_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (super->s_free_list.count == 0) {\n\t\tprintk(KERN_ERR\"LOGFS: ran out of free segments\\n\");\n\t\tLOGFS_BUG(sb);\n\t}\n\n\tarea->a_segno = get_best_cand(sb, &super->s_free_list, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_best_cand",
          "args": [
            "sb",
            "&super->s_free_list",
            "NULL"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "get_best_cand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "234-248",
          "snippet": "u32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG",
          "args": [
            "sb"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: ran out of free segments\\n\""
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void ostore_get_free_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (super->s_free_list.count == 0) {\n\t\tprintk(KERN_ERR\"LOGFS: ran out of free segments\\n\");\n\t\tLOGFS_BUG(sb);\n\t}\n\n\tarea->a_segno = get_best_cand(sb, &super->s_free_list, NULL);\n}"
  },
  {
    "function_name": "logfs_sync_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "786-793",
    "snippet": "void logfs_sync_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tlogfs_sync_area(super->s_area[i]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_sync_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tlogfs_sync_area(super->s_area[i]);\n}"
  },
  {
    "function_name": "logfs_sync_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "770-784",
    "snippet": "void logfs_sync_area(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tu32 len = (area->a_used_bytes - area->a_written_bytes);\n\n\tif (super->s_writesize)\n\t\tlen &= ~(super->s_writesize - 1);\n\tif (len == 0)\n\t\treturn;\n\tpad_wbuf(area, 0);\n\tsuper->s_devops->writeseg(sb, ofs, len);\n\tarea->a_written_bytes += len;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "super->s_devops->writeseg",
          "args": [
            "sb",
            "ofs",
            "len"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad_wbuf",
          "args": [
            "area",
            "0"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "pad_wbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "155-160",
          "snippet": "static void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_written_bytes"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_sync_area(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tu32 len = (area->a_used_bytes - area->a_written_bytes);\n\n\tif (super->s_writesize)\n\t\tlen &= ~(super->s_writesize - 1);\n\tif (len == 0)\n\t\treturn;\n\tpad_wbuf(area, 0);\n\tsuper->s_devops->writeseg(sb, ofs, len);\n\tarea->a_written_bytes += len;\n}"
  },
  {
    "function_name": "logfs_open_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "732-768",
    "snippet": "int logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mark_segment_bad",
          "args": [
            "sb",
            "area->a_segno"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mark_segment_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "15-27",
          "snippet": "static int logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint err;\n\n\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\tif (err)\n\t\treturn err;\n\tlogfs_super(sb)->s_bad_segments++;\n\t/* FIXME: write to journal */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint err;\n\n\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\tif (err)\n\t\treturn err;\n\tlogfs_super(sb)->s_bad_segments++;\n\t/* FIXME: write to journal */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"LogFS: Error erasing segment %x\\n\"",
            "area->a_segno"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "area->a_ops->erase_segment",
          "args": [
            "area"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"logfs_open_area(%x, %x)\\n\"",
            "area->a_segno",
            "area->a_level"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "area->a_ops->get_erase_count",
          "args": [
            "area"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "area->a_ops->get_free_segment",
          "args": [
            "area"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeseg",
          "args": [
            "sb",
            "area->a_segno"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "freeseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "711-730",
          "snippet": "void freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_devops->writeseg",
          "args": [
            "area->a_sb",
            "ofs",
            "len"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad_wbuf",
          "args": [
            "area",
            "1"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "pad_wbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "155-160",
          "snippet": "static void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"logfs_close_area(%x)\\n\"",
            "area->a_segno"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_written_bytes"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}"
  },
  {
    "function_name": "freeseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "711-730",
    "snippet": "void freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "ofs >> PAGE_SHIFT"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "segno + 1",
            "0"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "logfs_segment_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "679-709",
    "snippet": "int logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj_len",
          "args": [
            "sb",
            "h.type"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "obj_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "279-291",
          "snippet": "static int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "h.len"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level))",
            "sb"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pos",
          "args": [
            "sb",
            "shadow->bix",
            "be64_to_cpu(h.bix)",
            "shrink_level(shadow->gc_level)"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "check_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "429-433",
          "snippet": "static int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_level",
          "args": [
            "shadow->gc_level"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "693-700",
          "snippet": "static inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "h.bix"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "be64_to_cpu(h.ino) != inode->i_ino",
            "sb"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "h.ino"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "err",
            "sb"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_obj_header",
          "args": [
            "sb",
            "shadow->old_ofs",
            "&h"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "read_obj_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "456-473",
          "snippet": "static int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_segment",
          "args": [
            "\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\"",
            "shadow->ino",
            "shadow->bix",
            "shadow->gc_level",
            "shadow->old_ofs",
            "shadow->new_ofs",
            "shadow->old_len",
            "shadow->new_len"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "shadow->old_ofs & LOGFS_FULLY_POPULATED"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_flags & LOGFS_SB_FLAG_SHUTDOWN"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_segment_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "656-677",
    "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_segment",
          "args": [
            "\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\"",
            "inode->i_ino",
            "bix",
            "level",
            "ofs",
            "err"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_btree_to_page",
          "args": [
            "inode",
            "page",
            "buf"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "move_btree_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "475-507",
          "snippet": "static void move_btree_to_page(struct inode *inode, struct page *page,\n\t\t__be64 *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head128 *head = &super->s_object_alias_tree;\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item, *next;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_OBJ_ALIAS))\n\t\treturn;\n\n\tblock = btree_remove128(head, inode->i_ino, page->index);\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_btree_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tlist_for_each_entry_safe(item, next, &block->item_list, list) {\n\t\tdata[item->child_no] = item->val;\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\tblock->ops = &indirect_block_ops;\n\tinitialize_block_counters(page, block, data, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void move_btree_to_page(struct inode *inode, struct page *page,\n\t\t__be64 *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head128 *head = &super->s_object_alias_tree;\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item, *next;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_OBJ_ALIAS))\n\t\treturn;\n\n\tblock = btree_remove128(head, inode->i_ino, page->index);\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_btree_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tlist_for_each_entry_safe(item, next, &block->item_list, list) {\n\t\tdata[item->child_no] = item->val;\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\tblock->ops = &indirect_block_ops;\n\tinitialize_block_counters(page, block, data, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_segment_read",
          "args": [
            "inode",
            "buf",
            "ofs",
            "bix",
            "level"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "567-644",
          "snippet": "static int __logfs_segment_read(struct inode *inode, void *buf,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tstruct logfs_object_header oh;\n\t__be32 crc;\n\tu16 len;\n\tint err, block_len;\n\n\tblock_len = obj_len(sb, obj_type(inode, level));\n\terr = read_obj_header(sb, ofs, &oh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (be64_to_cpu(oh.ino) != inode->i_ino\n\t\t\t|| check_pos(sb, be64_to_cpu(oh.bix), bix, level)) {\n\t\tprintk(KERN_ERR\"LOGFS: (ino, bix) don't match at %llx: \"\n\t\t\t\t\"expected (%lx, %llx), got (%llx, %llx)\\n\",\n\t\t\t\tofs, inode->i_ino, bix,\n\t\t\t\tbe64_to_cpu(oh.ino), be64_to_cpu(oh.bix));\n\t\tgoto out_err;\n\t}\n\n\tlen = be16_to_cpu(oh.len);\n\n\tswitch (oh.compr) {\n\tcase COMPR_NONE:\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len, buf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tcrc = logfs_crc32(buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tcase COMPR_ZLIB:\n\t\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len,\n\t\t\t\tcompressor_buf);\n\t\tif (err) {\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcrc = logfs_crc32(compressor_buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: compressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = logfs_uncompress(compressor_buf, buf, len, block_len);\n\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompress error at %llx\\n\", ofs);\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOGFS_BUG(sb);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\tlogfs_set_ro(sb);\n\tprintk(KERN_ERR\"LOGFS: device is read-only now\\n\");\n\tLOGFS_BUG(sb);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_segment_read(struct inode *inode, void *buf,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tstruct logfs_object_header oh;\n\t__be32 crc;\n\tu16 len;\n\tint err, block_len;\n\n\tblock_len = obj_len(sb, obj_type(inode, level));\n\terr = read_obj_header(sb, ofs, &oh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (be64_to_cpu(oh.ino) != inode->i_ino\n\t\t\t|| check_pos(sb, be64_to_cpu(oh.bix), bix, level)) {\n\t\tprintk(KERN_ERR\"LOGFS: (ino, bix) don't match at %llx: \"\n\t\t\t\t\"expected (%lx, %llx), got (%llx, %llx)\\n\",\n\t\t\t\tofs, inode->i_ino, bix,\n\t\t\t\tbe64_to_cpu(oh.ino), be64_to_cpu(oh.bix));\n\t\tgoto out_err;\n\t}\n\n\tlen = be16_to_cpu(oh.len);\n\n\tswitch (oh.compr) {\n\tcase COMPR_NONE:\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len, buf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tcrc = logfs_crc32(buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tcase COMPR_ZLIB:\n\t\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len,\n\t\t\t\tcompressor_buf);\n\t\tif (err) {\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcrc = logfs_crc32(compressor_buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: compressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = logfs_uncompress(compressor_buf, buf, len, block_len);\n\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompress error at %llx\\n\", ofs);\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOGFS_BUG(sb);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\tlogfs_set_ro(sb);\n\tprintk(KERN_ERR\"LOGFS: device is read-only now\\n\");\n\tLOGFS_BUG(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
  },
  {
    "function_name": "__logfs_segment_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "567-644",
    "snippet": "static int __logfs_segment_read(struct inode *inode, void *buf,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tstruct logfs_object_header oh;\n\t__be32 crc;\n\tu16 len;\n\tint err, block_len;\n\n\tblock_len = obj_len(sb, obj_type(inode, level));\n\terr = read_obj_header(sb, ofs, &oh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (be64_to_cpu(oh.ino) != inode->i_ino\n\t\t\t|| check_pos(sb, be64_to_cpu(oh.bix), bix, level)) {\n\t\tprintk(KERN_ERR\"LOGFS: (ino, bix) don't match at %llx: \"\n\t\t\t\t\"expected (%lx, %llx), got (%llx, %llx)\\n\",\n\t\t\t\tofs, inode->i_ino, bix,\n\t\t\t\tbe64_to_cpu(oh.ino), be64_to_cpu(oh.bix));\n\t\tgoto out_err;\n\t}\n\n\tlen = be16_to_cpu(oh.len);\n\n\tswitch (oh.compr) {\n\tcase COMPR_NONE:\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len, buf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tcrc = logfs_crc32(buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tcase COMPR_ZLIB:\n\t\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len,\n\t\t\t\tcompressor_buf);\n\t\tif (err) {\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcrc = logfs_crc32(compressor_buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: compressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = logfs_uncompress(compressor_buf, buf, len, block_len);\n\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompress error at %llx\\n\", ofs);\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOGFS_BUG(sb);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\tlogfs_set_ro(sb);\n\tprintk(KERN_ERR\"LOGFS: device is read-only now\\n\");\n\tLOGFS_BUG(sb);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGFS_BUG",
          "args": [
            "sb"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: device is read-only now\\n\""
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_ro",
          "args": [
            "sb"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "638-641",
          "snippet": "static inline void logfs_set_ro(struct super_block *sb)\n{\n\tlogfs_super(sb)->s_flags |= LOGFS_SB_FLAG_RO;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [
            "#define LOGFS_SB_FLAG_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\n#define LOGFS_SB_FLAG_RO\t0x0001\n\nstatic inline void logfs_set_ro(struct super_block *sb)\n{\n\tlogfs_super(sb)->s_flags |= LOGFS_SB_FLAG_RO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG",
          "args": [
            "sb"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_uncompress",
          "args": [
            "compressor_buf",
            "buf",
            "len",
            "block_len"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_uncompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "51-80",
          "snippet": "int logfs_uncompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_inflateInit(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(compr_mutex);",
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\nstatic DEFINE_MUTEX(compr_mutex);\nstatic struct z_stream_s stream;\n\nint logfs_uncompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_inflateInit(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "crc"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oh.data_crc"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "compressor_buf",
            "len",
            "0"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "ofs + LOGFS_OBJECT_HEADERSIZE",
            "len",
            "compressor_buf"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "crc"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oh.data_crc"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oh.len"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.bix"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.ino"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pos",
          "args": [
            "sb",
            "be64_to_cpu(oh.bix)",
            "bix",
            "level"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "check_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "429-433",
          "snippet": "static int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.bix"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.ino"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_obj_header",
          "args": [
            "sb",
            "ofs",
            "&oh"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "read_obj_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "456-473",
          "snippet": "static int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_len",
          "args": [
            "sb",
            "obj_type(inode, level)"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "obj_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "279-291",
          "snippet": "static int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_type",
          "args": [
            "inode",
            "level"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "obj_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "268-277",
          "snippet": "static int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_segment_read(struct inode *inode, void *buf,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tstruct logfs_object_header oh;\n\t__be32 crc;\n\tu16 len;\n\tint err, block_len;\n\n\tblock_len = obj_len(sb, obj_type(inode, level));\n\terr = read_obj_header(sb, ofs, &oh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (be64_to_cpu(oh.ino) != inode->i_ino\n\t\t\t|| check_pos(sb, be64_to_cpu(oh.bix), bix, level)) {\n\t\tprintk(KERN_ERR\"LOGFS: (ino, bix) don't match at %llx: \"\n\t\t\t\t\"expected (%lx, %llx), got (%llx, %llx)\\n\",\n\t\t\t\tofs, inode->i_ino, bix,\n\t\t\t\tbe64_to_cpu(oh.ino), be64_to_cpu(oh.bix));\n\t\tgoto out_err;\n\t}\n\n\tlen = be16_to_cpu(oh.len);\n\n\tswitch (oh.compr) {\n\tcase COMPR_NONE:\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len, buf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tcrc = logfs_crc32(buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tcase COMPR_ZLIB:\n\t\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\t\terr = wbuf_read(sb, ofs + LOGFS_OBJECT_HEADERSIZE, len,\n\t\t\t\tcompressor_buf);\n\t\tif (err) {\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcrc = logfs_crc32(compressor_buf, len, 0);\n\t\tif (crc != oh.data_crc) {\n\t\t\tprintk(KERN_ERR\"LOGFS: compressed data crc error at \"\n\t\t\t\t\t\"%llx: expected %x, got %x\\n\", ofs,\n\t\t\t\t\tbe32_to_cpu(oh.data_crc),\n\t\t\t\t\tbe32_to_cpu(crc));\n\t\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = logfs_uncompress(compressor_buf, buf, len, block_len);\n\t\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR\"LOGFS: uncompress error at %llx\\n\", ofs);\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOGFS_BUG(sb);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\tlogfs_set_ro(sb);\n\tprintk(KERN_ERR\"LOGFS: device is read-only now\\n\");\n\tLOGFS_BUG(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "move_page_to_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "520-565",
    "snippet": "void move_page_to_btree(struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct super_block *sb = block->sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct object_alias_item *item;\n\tunsigned long pos;\n\t__be64 *child;\n\tint err;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_SHUTDOWN) {\n\t\tblock->ops->free_block(sb, block);\n\t\treturn;\n\t}\n\tlog_blockmove(\"move_page_to_btree(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_BLOCK_FACTOR)\n\t\t\tbreak;\n\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tBUG_ON(!item); /* mempool empty */\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tchild = kmap_atomic(page);\n\t\titem->val = child[pos];\n\t\tkunmap_atomic(child);\n\t\titem->child_no = pos;\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\tblock->page = NULL;\n\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n\tblock->ops = &btree_block_ops;\n\terr = alias_tree_insert(block->sb, block->ino, block->bix, block->level,\n\t\t\tblock);\n\tBUG_ON(err); /* mempool empty */\n\tClearPageUptodate(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alias_tree_insert",
          "args": [
            "block->sb",
            "block->ino",
            "block->bix",
            "block->level",
            "block"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "alias_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "176-183",
          "snippet": "static int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&item->list",
            "&block->item_list"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "child"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "item",
            "0",
            "sizeof(*item)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!item"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "super->s_alias_pool",
            "GFP_NOFS"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnb",
          "args": [
            "block->alias_map",
            "LOGFS_BLOCK_FACTOR",
            "pos"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "fnb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "514-518",
          "snippet": "static unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_blockmove",
          "args": [
            "\"move_page_to_btree(%llx, %llx, %x)\\n\"",
            "block->ino",
            "block->bix",
            "block->level"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->ops->free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};\n\nvoid move_page_to_btree(struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct super_block *sb = block->sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct object_alias_item *item;\n\tunsigned long pos;\n\t__be64 *child;\n\tint err;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_SHUTDOWN) {\n\t\tblock->ops->free_block(sb, block);\n\t\treturn;\n\t}\n\tlog_blockmove(\"move_page_to_btree(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_BLOCK_FACTOR)\n\t\t\tbreak;\n\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tBUG_ON(!item); /* mempool empty */\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tchild = kmap_atomic(page);\n\t\titem->val = child[pos];\n\t\tkunmap_atomic(child);\n\t\titem->child_no = pos;\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\tblock->page = NULL;\n\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n\tblock->ops = &btree_block_ops;\n\terr = alias_tree_insert(block->sb, block->ino, block->bix, block->level,\n\t\t\tblock);\n\tBUG_ON(err); /* mempool empty */\n\tClearPageUptodate(page);\n}"
  },
  {
    "function_name": "fnb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "514-518",
    "snippet": "static unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "addr",
            "size",
            "offset"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}"
  },
  {
    "function_name": "move_btree_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "475-507",
    "snippet": "static void move_btree_to_page(struct inode *inode, struct page *page,\n\t\t__be64 *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head128 *head = &super->s_object_alias_tree;\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item, *next;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_OBJ_ALIAS))\n\t\treturn;\n\n\tblock = btree_remove128(head, inode->i_ino, page->index);\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_btree_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tlist_for_each_entry_safe(item, next, &block->item_list, list) {\n\t\tdata[item->child_no] = item->val;\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\tblock->ops = &indirect_block_ops;\n\tinitialize_block_counters(page, block, data, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initialize_block_counters",
          "args": [
            "page",
            "block",
            "data",
            "0"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_block_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "615-642",
          "snippet": "void initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long) block"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "item",
            "super->s_alias_pool"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&item->list"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "next",
            "&block->item_list",
            "list"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_blockmove",
          "args": [
            "\"move_btree_to_page(%llx, %llx, %x)\\n\"",
            "block->ino",
            "block->bix",
            "block->level"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_remove128",
          "args": [
            "head",
            "inode->i_ino",
            "page->index"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void move_btree_to_page(struct inode *inode, struct page *page,\n\t\t__be64 *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head128 *head = &super->s_object_alias_tree;\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item, *next;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_OBJ_ALIAS))\n\t\treturn;\n\n\tblock = btree_remove128(head, inode->i_ino, page->index);\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_btree_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tlist_for_each_entry_safe(item, next, &block->item_list, list) {\n\t\tdata[item->child_no] = item->val;\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\tblock->ops = &indirect_block_ops;\n\tinitialize_block_counters(page, block, data, 0);\n}"
  },
  {
    "function_name": "read_obj_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "456-473",
    "snippet": "static int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\"",
            "ofs",
            "be32_to_cpu(oh->crc)",
            "be32_to_cpu(crc)"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "crc"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oh->crc"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "oh",
            "sizeof(*oh) - 4",
            "4"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "ofs",
            "sizeof(*oh)",
            "oh"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_obj_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_object_header *oh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*oh), oh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(oh, sizeof(*oh) - 4, 4);\n\tif (crc != oh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(oh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "read_seg_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "436-453",
    "snippet": "static int read_seg_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_segment_header *sh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*sh), sh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(sh, sizeof(*sh), 4);\n\tif (crc != sh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(sh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\"",
            "ofs",
            "be32_to_cpu(sh->crc)",
            "be32_to_cpu(crc)"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "crc"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sh->crc"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "sh",
            "sizeof(*sh)",
            "4"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "ofs",
            "sizeof(*sh)",
            "sh"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_seg_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_segment_header *sh)\n{\n\t__be32 crc;\n\tint err;\n\n\terr = wbuf_read(sb, ofs, sizeof(*sh), sh);\n\tif (err)\n\t\treturn err;\n\tcrc = logfs_crc32(sh, sizeof(*sh), 4);\n\tif (crc != sh->crc) {\n\t\tprintk(KERN_ERR\"LOGFS: header crc error at %llx: expected %x, \"\n\t\t\t\t\"got %x\\n\", ofs, be32_to_cpu(sh->crc),\n\t\t\t\tbe32_to_cpu(crc));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "429-433",
    "snippet": "static int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_block_mask",
          "args": [
            "sb",
            "level"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "719-722",
          "snippet": "static inline u64 logfs_block_mask(struct super_block *sb, level_t level)\n{\n\treturn ~0ull << logfs_block_shift(sb, level);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 logfs_block_mask(struct super_block *sb, level_t level)\n{\n\treturn ~0ull << logfs_block_shift(sb, level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int check_pos(struct super_block *sb, u64 pos1, u64 pos2, level_t level)\n{\n\treturn\t(pos1 & logfs_block_mask(sb, level)) !=\n\t\t(pos2 & logfs_block_mask(sb, level));\n}"
  },
  {
    "function_name": "wbuf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "400-422",
    "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "page_address(page) + offset",
            "copylen"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mapping_page",
          "args": [
            "sb",
            "index",
            "1"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "get_mapping_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "52-69",
          "snippet": "static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(ulong)len",
            "PAGE_SIZE - offset"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_segment_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "363-398",
    "snippet": "int logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(shadow->new_ofs & (super->s_segsize - 1))"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_segment",
          "args": [
            "\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\"",
            "shadow->ino",
            "shadow->bix",
            "shadow->gc_level",
            "shadow->old_ofs",
            "shadow->new_ofs",
            "shadow->old_len",
            "shadow->new_len"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_segment_write",
          "args": [
            "inode",
            "buf",
            "shadow",
            "type",
            "len",
            "COMPR_NONE"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_segment_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "293-333",
          "snippet": "static int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_write_compress",
          "args": [
            "inode",
            "buf",
            "shadow",
            "type",
            "len"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_write_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "335-355",
          "snippet": "static s64 logfs_segment_write_compress(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tssize_t compr_len;\n\tint ret;\n\n\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\tcompr_len = logfs_compress(buf, compressor_buf, len, len);\n\n\tif (compr_len >= 0) {\n\t\tret = __logfs_segment_write(inode, compressor_buf, shadow,\n\t\t\t\ttype, compr_len, COMPR_ZLIB);\n\t} else {\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\t}\n\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_segment_write_compress(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tssize_t compr_len;\n\tint ret;\n\n\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\tcompr_len = logfs_compress(buf, compressor_buf, len, len);\n\n\tif (compr_len >= 0) {\n\t\tret = __logfs_segment_write(inode, compressor_buf, shadow,\n\t\t\t\ttype, compr_len, COMPR_ZLIB);\n\t} else {\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\t}\n\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_len",
          "args": [
            "sb",
            "type"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "obj_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "279-291",
          "snippet": "static int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_type",
          "args": [
            "inode",
            "shrink_level(shadow->gc_level)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "obj_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "268-277",
          "snippet": "static int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_level",
          "args": [
            "shadow->gc_level"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "693-700",
          "snippet": "static inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_flags & LOGFS_SB_FLAG_SHUTDOWN"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_segment_write_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "335-355",
    "snippet": "static s64 logfs_segment_write_compress(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tssize_t compr_len;\n\tint ret;\n\n\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\tcompr_len = logfs_compress(buf, compressor_buf, len, len);\n\n\tif (compr_len >= 0) {\n\t\tret = __logfs_segment_write(inode, compressor_buf, shadow,\n\t\t\t\ttype, compr_len, COMPR_ZLIB);\n\t} else {\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\t}\n\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_segment_write",
          "args": [
            "inode",
            "buf",
            "shadow",
            "type",
            "len",
            "COMPR_NONE"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_segment_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "293-333",
          "snippet": "static int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_compress",
          "args": [
            "buf",
            "compressor_buf",
            "len",
            "len"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "17-49",
          "snippet": "int logfs_compress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_deflateInit(&stream, COMPR_LEVEL);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define COMPR_LEVEL 3"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(compr_mutex);",
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\n#define COMPR_LEVEL 3\n\nstatic DEFINE_MUTEX(compr_mutex);\nstatic struct z_stream_s stream;\n\nint logfs_compress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_deflateInit(&stream, COMPR_LEVEL);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&logfs_super(sb)->s_journal_mutex"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_segment_write_compress(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tvoid *compressor_buf = logfs_super(sb)->s_compressed_je;\n\tssize_t compr_len;\n\tint ret;\n\n\tmutex_lock(&logfs_super(sb)->s_journal_mutex);\n\tcompr_len = logfs_compress(buf, compressor_buf, len, len);\n\n\tif (compr_len >= 0) {\n\t\tret = __logfs_segment_write(inode, compressor_buf, shadow,\n\t\t\t\ttype, compr_len, COMPR_ZLIB);\n\t} else {\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\t}\n\tmutex_unlock(&logfs_super(sb)->s_journal_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_segment_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "293-333",
    "snippet": "static int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_buf_write",
          "args": [
            "area",
            "ofs + LOGFS_OBJECT_HEADERSIZE",
            "buf",
            "len"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "608-612",
          "snippet": "static inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "buf",
            "len",
            "0"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "shadow->bix"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "len"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "ofs <= 0",
            "sb"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_free_bytes",
          "args": [
            "area",
            "len + LOGFS_OBJECT_HEADERSIZE"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_free_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "39-50",
          "snippet": "static s64 logfs_get_free_bytes(struct logfs_area *area, size_t bytes)\n{\n\ts32 ofs;\n\n\tlogfs_open_area(area, bytes);\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += bytes;\n\tBUG_ON(area->a_used_bytes >= logfs_super(area->a_sb)->s_segsize);\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_get_free_bytes(struct logfs_area *area, size_t bytes)\n{\n\ts32 ofs;\n\n\tlogfs_open_area(area, bytes);\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += bytes;\n\tBUG_ON(area->a_used_bytes >= logfs_super(area->a_sb)->s_segsize);\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_area",
          "args": [
            "sb",
            "shadow->gc_level"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "get_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "724-728",
          "snippet": "static inline struct logfs_area *get_area(struct super_block *sb,\n\t\tgc_level_t gc_level)\n{\n\treturn logfs_super(sb)->s_area[(__force u8)gc_level];\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_area *get_area(struct super_block *sb,\n\t\tgc_level_t gc_level)\n{\n\treturn logfs_super(sb)->s_area[(__force u8)gc_level];\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_len",
          "args": [
            "sb",
            "type"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "obj_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "279-291",
          "snippet": "static int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_segment_write(struct inode *inode, void *buf,\n\t\tstruct logfs_shadow *shadow, int type, int len, int compr)\n{\n\tstruct logfs_area *area;\n\tstruct super_block *sb = inode->i_sb;\n\ts64 ofs;\n\tstruct logfs_object_header h;\n\tint acc_len;\n\n\tif (shadow->gc_level == 0)\n\t\tacc_len = len;\n\telse\n\t\tacc_len = obj_len(sb, type);\n\n\tarea = get_area(sb, shadow->gc_level);\n\tofs = logfs_get_free_bytes(area, len + LOGFS_OBJECT_HEADERSIZE);\n\tLOGFS_BUG_ON(ofs <= 0, sb);\n\t/*\n\t * Order is important.  logfs_get_free_bytes(), by modifying the\n\t * segment file, may modify the content of the very page we're about\n\t * to write now.  Which is fine, as long as the calculated crc and\n\t * written data still match.  So do the modifications _before_\n\t * calculating the crc.\n\t */\n\n\th.len\t= cpu_to_be16(len);\n\th.type\t= type;\n\th.compr\t= compr;\n\th.ino\t= cpu_to_be64(inode->i_ino);\n\th.bix\t= cpu_to_be64(shadow->bix);\n\th.crc\t= logfs_crc32(&h, sizeof(h) - 4, 4);\n\th.data_crc = logfs_crc32(buf, len, 0);\n\n\tlogfs_buf_write(area, ofs, &h, sizeof(h));\n\tlogfs_buf_write(area, ofs + LOGFS_OBJECT_HEADERSIZE, buf, len);\n\n\tshadow->new_ofs = ofs;\n\tshadow->new_len = acc_len + LOGFS_OBJECT_HEADERSIZE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "obj_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "279-291",
    "snippet": "static int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_len(struct super_block *sb, int obj_type)\n{\n\tswitch (obj_type) {\n\tcase OBJ_DENTRY:\n\t\treturn sizeof(struct logfs_disk_dentry);\n\tcase OBJ_INODE:\n\t\treturn sizeof(struct logfs_disk_inode);\n\tcase OBJ_BLOCK:\n\t\treturn sb->s_blocksize;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "obj_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "268-277",
    "snippet": "static int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int obj_type(struct inode *inode, level_t level)\n{\n\tif (level == 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn OBJ_DENTRY;\n\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\treturn OBJ_INODE;\n\t}\n\treturn OBJ_BLOCK;\n}"
  },
  {
    "function_name": "kill_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "252-266",
    "snippet": "static void kill_alias(void *_block, unsigned long ignore0,\n\t\tu64 ignore1, u64 ignore2, size_t ignore3)\n{\n\tstruct logfs_block *block = _block;\n\tstruct super_block *sb = block->sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct object_alias_item *item;\n\n\twhile (!list_empty(&block->item_list)) {\n\t\titem = list_entry(block->item_list.next, typeof(*item), list);\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->ops->free_block(sb, block);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block->ops->free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "item",
            "super->s_alias_pool"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&item->list"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "block->item_list.next",
            "typeof(*item)",
            "list"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*item"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->item_list"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void kill_alias(void *_block, unsigned long ignore0,\n\t\tu64 ignore1, u64 ignore2, size_t ignore3)\n{\n\tstruct logfs_block *block = _block;\n\tstruct super_block *sb = block->sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct object_alias_item *item;\n\n\twhile (!list_empty(&block->item_list)) {\n\t\titem = list_entry(block->item_list.next, typeof(*item), list);\n\t\tlist_del(&item->list);\n\t\tmempool_free(item, super->s_alias_pool);\n\t}\n\tblock->ops->free_block(sb, block);\n}"
  },
  {
    "function_name": "logfs_load_object_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "206-250",
    "snippet": "int logfs_load_object_aliases(struct super_block *sb,\n\t\tstruct logfs_obj_alias *oa, int count)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item;\n\tu64 ino, bix;\n\tlevel_t level;\n\tint i, err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\tcount /= sizeof(*oa);\n\tfor (i = 0; i < count; i++) {\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tif (!item)\n\t\t\treturn -ENOMEM;\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tsuper->s_no_object_aliases++;\n\t\titem->val = oa[i].val;\n\t\titem->child_no = be16_to_cpu(oa[i].child_no);\n\n\t\tino = be64_to_cpu(oa[i].ino);\n\t\tbix = be64_to_cpu(oa[i].bix);\n\t\tlevel = LEVEL(oa[i].level);\n\n\t\tlog_aliases(\"logfs_load_object_aliases(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\t\tino, bix, level, item->child_no,\n\t\t\t\tbe64_to_cpu(item->val));\n\t\tblock = alias_tree_lookup(sb, ino, bix, level);\n\t\tif (!block) {\n\t\t\tblock = __alloc_block(sb, ino, bix, level);\n\t\t\tblock->ops = &btree_block_ops;\n\t\t\terr = alias_tree_insert(sb, ino, bix, level, block);\n\t\t\tBUG_ON(err); /* mempool empty */\n\t\t}\n\t\tif (test_and_set_bit(item->child_no, block->alias_map)) {\n\t\t\tprintk(KERN_ERR\"LogFS: Alias collision detected\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&item->list",
            "&block->item_list"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&block->alias_list",
            "&super->s_object_alias"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LogFS: Alias collision detected\\n\""
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "item->child_no",
            "block->alias_map"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alias_tree_insert",
          "args": [
            "sb",
            "ino",
            "bix",
            "level",
            "block"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "alias_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "176-183",
          "snippet": "static int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_block",
          "args": [
            "sb",
            "ino",
            "bix",
            "level"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "584-599",
          "snippet": "struct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alias_tree_lookup",
          "args": [
            "sb",
            "ino",
            "bix",
            "level"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "alias_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "167-174",
          "snippet": "static void *alias_tree_lookup(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_lookup128(head, ino, index);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *alias_tree_lookup(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_lookup128(head, ino, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_aliases",
          "args": [
            "\"logfs_load_object_aliases(%llx, %llx, %x, %x) %llx\\n\"",
            "ino",
            "bix",
            "level",
            "item->child_no",
            "be64_to_cpu(item->val)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "item->val"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "oa[i].level"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oa[i].bix"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oa[i].ino"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oa[i].child_no"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "item",
            "0",
            "sizeof(*item)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "super->s_alias_pool",
            "GFP_NOFS"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};\n\nint logfs_load_object_aliases(struct super_block *sb,\n\t\tstruct logfs_obj_alias *oa, int count)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item;\n\tu64 ino, bix;\n\tlevel_t level;\n\tint i, err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\tcount /= sizeof(*oa);\n\tfor (i = 0; i < count; i++) {\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tif (!item)\n\t\t\treturn -ENOMEM;\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tsuper->s_no_object_aliases++;\n\t\titem->val = oa[i].val;\n\t\titem->child_no = be16_to_cpu(oa[i].child_no);\n\n\t\tino = be64_to_cpu(oa[i].ino);\n\t\tbix = be64_to_cpu(oa[i].bix);\n\t\tlevel = LEVEL(oa[i].level);\n\n\t\tlog_aliases(\"logfs_load_object_aliases(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\t\tino, bix, level, item->child_no,\n\t\t\t\tbe64_to_cpu(item->val));\n\t\tblock = alias_tree_lookup(sb, ino, bix, level);\n\t\tif (!block) {\n\t\t\tblock = __alloc_block(sb, ino, bix, level);\n\t\t\tblock->ops = &btree_block_ops;\n\t\t\terr = alias_tree_insert(sb, ino, bix, level, block);\n\t\t\tBUG_ON(err); /* mempool empty */\n\t\t}\n\t\tif (test_and_set_bit(item->child_no, block->alias_map)) {\n\t\t\tprintk(KERN_ERR\"LogFS: Alias collision detected\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btree_write_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "185-198",
    "snippet": "static int btree_write_alias(struct super_block *sb, struct logfs_block *block,\n\t\twrite_alias_t *write_one_alias)\n{\n\tstruct object_alias_item *item;\n\tint err;\n\n\tlist_for_each_entry(item, &block->item_list, list) {\n\t\terr = write_alias_journal(sb, block->ino, block->bix,\n\t\t\t\tblock->level, item->child_no, item->val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_alias_journal",
          "args": [
            "sb",
            "block->ino",
            "block->bix",
            "block->level",
            "item->child_no",
            "item->val"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "write_alias_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "685-707",
          "snippet": "int write_alias_journal(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, int child_no, __be64 val)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_obj_alias *oa = super->s_je;\n\tint err = 0, fill = super->s_je_fill;\n\n\tlog_aliases(\"logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\tfill, ino, bix, level, child_no, be64_to_cpu(val));\n\toa[fill].ino = cpu_to_be64(ino);\n\toa[fill].bix = cpu_to_be64(bix);\n\toa[fill].val = val;\n\toa[fill].level = (__force u8)level;\n\toa[fill].child_no = cpu_to_be16(child_no);\n\tfill++;\n\tif (fill >= sb->s_blocksize / sizeof(*oa)) {\n\t\terr = logfs_write_je_buf(sb, oa, JE_OBJ_ALIAS, sb->s_blocksize);\n\t\tfill = 0;\n\t}\n\n\tsuper->s_je_fill = fill;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint write_alias_journal(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, int child_no, __be64 val)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_obj_alias *oa = super->s_je;\n\tint err = 0, fill = super->s_je_fill;\n\n\tlog_aliases(\"logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\tfill, ino, bix, level, child_no, be64_to_cpu(val));\n\toa[fill].ino = cpu_to_be64(ino);\n\toa[fill].bix = cpu_to_be64(bix);\n\toa[fill].val = val;\n\toa[fill].level = (__force u8)level;\n\toa[fill].child_no = cpu_to_be16(child_no);\n\tfill++;\n\tif (fill >= sb->s_blocksize / sizeof(*oa)) {\n\t\terr = logfs_write_je_buf(sb, oa, JE_OBJ_ALIAS, sb->s_blocksize);\n\t\tfill = 0;\n\t}\n\n\tsuper->s_je_fill = fill;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "item",
            "&block->item_list",
            "list"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int btree_write_alias(struct super_block *sb, struct logfs_block *block,\n\t\twrite_alias_t *write_one_alias)\n{\n\tstruct object_alias_item *item;\n\tint err;\n\n\tlist_for_each_entry(item, &block->item_list, list) {\n\t\terr = write_alias_journal(sb, block->ino, block->bix,\n\t\t\t\tblock->level, item->child_no, item->val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "alias_tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "176-183",
    "snippet": "static int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_insert128",
          "args": [
            "head",
            "ino",
            "index",
            "val",
            "GFP_NOFS"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_pack_index",
          "args": [
            "bix",
            "level"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_pack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "67-79",
          "snippet": "pgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\npgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int alias_tree_insert(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, void *val)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_insert128(head, ino, index, val, GFP_NOFS);\n}"
  },
  {
    "function_name": "alias_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "167-174",
    "snippet": "static void *alias_tree_lookup(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_lookup128(head, ino, index);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_lookup128",
          "args": [
            "head",
            "ino",
            "index"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_pack_index",
          "args": [
            "bix",
            "level"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_pack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "67-79",
          "snippet": "pgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\npgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *alias_tree_lookup(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct btree_head128 *head = &logfs_super(sb)->s_object_alias_tree;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\n\treturn btree_lookup128(head, ino, index);\n}"
  },
  {
    "function_name": "pad_wbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "155-160",
    "snippet": "static void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pad_full_pages",
          "args": [
            "area"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "pad_full_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "126-149",
          "snippet": "static void pad_full_pages(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tu32 len = super->s_segsize - area->a_used_bytes;\n\tpgoff_t index = PAGE_CACHE_ALIGN(ofs) >> PAGE_CACHE_SHIFT;\n\tpgoff_t no_indizes = len >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (no_indizes) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemset(page_address(page), 0xff, PAGE_CACHE_SIZE);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tno_indizes--;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_full_pages(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tu32 len = super->s_segsize - area->a_used_bytes;\n\tpgoff_t index = PAGE_CACHE_ALIGN(ofs) >> PAGE_CACHE_SHIFT;\n\tpgoff_t no_indizes = len >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (no_indizes) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemset(page_address(page), 0xff, PAGE_CACHE_SIZE);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tno_indizes--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pad_partial_page",
          "args": [
            "area"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "pad_partial_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "105-124",
          "snippet": "static void pad_partial_page(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct page *page;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tu32 len = PAGE_SIZE - offset;\n\n\tif (len % PAGE_SIZE) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tmemset(page_address(page) + offset, 0xff, len);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_partial_page(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct page *page;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tu32 len = PAGE_SIZE - offset;\n\n\tif (len % PAGE_SIZE) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tmemset(page_address(page) + offset, 0xff, len);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_wbuf(struct logfs_area *area, int final)\n{\n\tpad_partial_page(area);\n\tif (final)\n\t\tpad_full_pages(area);\n}"
  },
  {
    "function_name": "pad_full_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "126-149",
    "snippet": "static void pad_full_pages(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tu32 len = super->s_segsize - area->a_used_bytes;\n\tpgoff_t index = PAGE_CACHE_ALIGN(ofs) >> PAGE_CACHE_SHIFT;\n\tpgoff_t no_indizes = len >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (no_indizes) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemset(page_address(page), 0xff, PAGE_CACHE_SIZE);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tno_indizes--;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page)",
            "0xff",
            "PAGE_CACHE_SIZE"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mapping_page",
          "args": [
            "sb",
            "index",
            "0"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "get_mapping_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "52-69",
          "snippet": "static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "ofs"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_used_bytes"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_full_pages(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tu32 len = super->s_segsize - area->a_used_bytes;\n\tpgoff_t index = PAGE_CACHE_ALIGN(ofs) >> PAGE_CACHE_SHIFT;\n\tpgoff_t no_indizes = len >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (no_indizes) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemset(page_address(page), 0xff, PAGE_CACHE_SIZE);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tno_indizes--;\n\t}\n}"
  },
  {
    "function_name": "pad_partial_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "105-124",
    "snippet": "static void pad_partial_page(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct page *page;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tu32 len = PAGE_SIZE - offset;\n\n\tif (len % PAGE_SIZE) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tmemset(page_address(page) + offset, 0xff, len);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page) + offset",
            "0xff",
            "len"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mapping_page",
          "args": [
            "sb",
            "index",
            "0"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "get_mapping_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "52-69",
          "snippet": "static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_used_bytes"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void pad_partial_page(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct page *page;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_used_bytes);\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tu32 len = PAGE_SIZE - offset;\n\n\tif (len % PAGE_SIZE) {\n\t\tpage = get_mapping_page(sb, index, 0);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tmemset(page_address(page) + offset, 0xff, len);\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "__logfs_buf_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "71-103",
    "snippet": "int __logfs_buf_write(struct logfs_area *area, u64 ofs, void *buf, size_t len,\n\t\tint use_filler)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\t/* Only logfs_wbuf_recover may use len==0 */\n\tBUG_ON(!len && !use_filler);\n\tdo {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(area->a_sb, index, use_filler);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemcpy(page_address(page) + offset, buf, copylen);\n\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t} while (len);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page_address(page) + offset",
            "buf",
            "copylen"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mapping_page",
          "args": [
            "area->a_sb",
            "index",
            "use_filler"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "get_mapping_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "52-69",
          "snippet": "static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(ulong)len",
            "PAGE_SIZE - offset"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!len && !use_filler"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint __logfs_buf_write(struct logfs_area *area, u64 ofs, void *buf, size_t len,\n\t\tint use_filler)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\t/* Only logfs_wbuf_recover may use len==0 */\n\tBUG_ON(!len && !use_filler);\n\tdo {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(area->a_sb, index, use_filler);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tBUG_ON(!page); /* FIXME: reserve a pool */\n\t\tSetPageUptodate(page);\n\t\tmemcpy(page_address(page) + offset, buf, copylen);\n\n\t\tif (!PagePrivate(page)) {\n\t\t\tSetPagePrivate(page);\n\t\t\tpage_cache_get(page);\n\t\t}\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t} while (len);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_mapping_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "52-69",
    "snippet": "static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "index",
            "filler",
            "sb"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mapping_gfp_mask(mapping) & __GFP_FS"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *get_mapping_page(struct super_block *sb, pgoff_t index,\n\t\tint use_filler)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = super->s_devops->readpage;\n\tstruct page *page;\n\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);\n\tif (use_filler)\n\t\tpage = read_cache_page(mapping, index, filler, sb);\n\telse {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (page)\n\t\t\tunlock_page(page);\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "logfs_get_free_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "39-50",
    "snippet": "static s64 logfs_get_free_bytes(struct logfs_area *area, size_t bytes)\n{\n\ts32 ofs;\n\n\tlogfs_open_area(area, bytes);\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += bytes;\n\tBUG_ON(area->a_used_bytes >= logfs_super(area->a_sb)->s_segsize);\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "area->a_sb",
            "area->a_segno",
            "ofs"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "area->a_used_bytes >= logfs_super(area->a_sb)->s_segsize"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "area->a_sb"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_open_area",
          "args": [
            "area",
            "bytes"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_open_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "732-768",
          "snippet": "int logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_get_free_bytes(struct logfs_area *area, size_t bytes)\n{\n\ts32 ofs;\n\n\tlogfs_open_area(area, bytes);\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += bytes;\n\tBUG_ON(area->a_used_bytes >= logfs_super(area->a_sb)->s_segsize);\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}"
  },
  {
    "function_name": "logfs_erase_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "29-37",
    "snippet": "int logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "super->s_devops->erase",
          "args": [
            "sb",
            "(u64)segno << super->s_segshift",
            "super->s_segsize",
            "ensure_erase"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}"
  },
  {
    "function_name": "logfs_mark_segment_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
    "lines": "15-27",
    "snippet": "static int logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint err;\n\n\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\tif (err)\n\t\treturn err;\n\tlogfs_super(sb)->s_bad_segments++;\n\t/* FIXME: write to journal */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "head",
            "segno",
            "(void *)1",
            "GFP_NOFS"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint err;\n\n\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\tif (err)\n\t\treturn err;\n\tlogfs_super(sb)->s_bad_segments++;\n\t/* FIXME: write to journal */\n\treturn 0;\n}"
  }
]