[
  {
    "function_name": "CIFS_SessSetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "1409-1442",
    "snippet": "int CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct sess_data *sess_data;\n\n\tif (ses == NULL) {\n\t\tWARN(1, \"%s: ses == NULL!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\t/* Store result before we free sess_data */\n\trc = sess_data->result;\n\nout:\n\tkfree(sess_data);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sess_data"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_data->func",
          "args": [
            "sess_data"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_sec",
          "args": [
            "ses",
            "sess_data"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "select_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "1358-1407",
          "snippet": "static int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct sess_data)",
            "GFP_KERNEL"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: ses == NULL!\"",
            "__func__"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nint CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct sess_data *sess_data;\n\n\tif (ses == NULL) {\n\t\tWARN(1, \"%s: ses == NULL!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\t/* Store result before we free sess_data */\n\trc = sess_data->result;\n\nout:\n\tkfree(sess_data);\n\treturn rc;\n}"
  },
  {
    "function_name": "select_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "1358-1407",
    "snippet": "static int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"secType %d not supported!\\n\"",
            "type"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Kerberos negotiated but upcall support disabled!\\n\""
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unable to select appropriate authentication method!\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"sess setup type %d\\n\"",
            "type"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_sectype",
          "args": [
            "ses->server",
            "ses->sectype"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "select_sectype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "474-522",
          "snippet": "enum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nenum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sess_auth_rawntlmssp_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "1239-1356",
    "snippet": "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tchar *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Build security blob before we assemble the request */\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\t/*\n\t * 5 is an empirical value, large enough to hold\n\t * authenticate message plus max 10 of av paris,\n\t * domain, user, workstation names, flags, etc.\n\t */\n\tntlmsspblob = kzalloc(5*sizeof(struct _AUTHENTICATE_MESSAGE),\n\t\t\t\tGFP_KERNEL);\n\tif (!ntlmsspblob) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_ntlmssp_auth_blob(ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t/*\n\t * Make sure that we tell the server that we are using\n\t * the uid that it just gave us back on the response\n\t * (challenge)\n\t */\n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tif (ses->Suid != smb_buf->Uid) {\n\t\tses->Suid = smb_buf->Uid;\n\t\tcifs_dbg(FYI, \"UID changed! new UID = %llu\\n\", ses->Suid);\n\t}\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\nout_free_ntlmsspblob:\n\tkfree(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\t if (!rc)\n\t\trc = sess_establish_session(sess_data);\n\n\t/* Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->ntlmssp"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_establish_session",
          "args": [
            "sess_data"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "sess_establish_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "589-619",
          "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ntlmsspblob"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_ascii_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ascii_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "230-278",
          "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_unicode_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "decode_unicode_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "196-228",
          "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad security blob length %d\\n\"",
            "blob_len"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.SecurityBlobLength"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID changed! new UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Guest login\\n\""
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sess_auth_rawntlmssp_assemble_req",
          "args": [
            "sess_data"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "_sess_auth_rawntlmssp_assemble_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "1104-1138",
          "snippet": "static int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "blob_len"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_ntlmssp_auth_blob",
          "args": [
            "ntlmsspblob",
            "&blob_len",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "build_ntlmssp_auth_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "370-472",
          "snippet": "int build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "5*sizeof(struct _AUTHENTICATE_MESSAGE)",
            "GFP_KERNEL"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "12"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"rawntlmssp session setup authenticate phase\\n\""
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tchar *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Build security blob before we assemble the request */\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\t/*\n\t * 5 is an empirical value, large enough to hold\n\t * authenticate message plus max 10 of av paris,\n\t * domain, user, workstation names, flags, etc.\n\t */\n\tntlmsspblob = kzalloc(5*sizeof(struct _AUTHENTICATE_MESSAGE),\n\t\t\t\tGFP_KERNEL);\n\tif (!ntlmsspblob) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_ntlmssp_auth_blob(ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t/*\n\t * Make sure that we tell the server that we are using\n\t * the uid that it just gave us back on the response\n\t * (challenge)\n\t */\n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tif (ses->Suid != smb_buf->Uid) {\n\t\tses->Suid = smb_buf->Uid;\n\t\tcifs_dbg(FYI, \"UID changed! new UID = %llu\\n\", ses->Suid);\n\t}\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\nout_free_ntlmsspblob:\n\tkfree(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\t if (!rc)\n\t\trc = sess_establish_session(sess_data);\n\n\t/* Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}"
  },
  {
    "function_name": "sess_auth_rawntlmssp_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "1143-1237",
    "snippet": "static void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->ntlmssp"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ntlmssp_challenge",
          "args": [
            "bcc_ptr",
            "blob_len",
            "ses"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ntlmssp_challenge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "280-328",
          "snippet": "int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad security blob length %d\\n\"",
            "blob_len"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.SecurityBlobLength"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"rawntlmssp session setup challenge phase\\n\""
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "NT_STATUS_MORE_PROCESSING_REQUIRED"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sess_auth_rawntlmssp_assemble_req",
          "args": [
            "sess_data"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "_sess_auth_rawntlmssp_assemble_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "1104-1138",
          "snippet": "static int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(NEGOTIATE_MESSAGE)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_ntlmssp_negotiate_blob",
          "args": [
            "pSMB->req.SecurityBlob",
            "ses"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "build_ntlmssp_negotiate_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "334-365",
          "snippet": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "12"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ntlmssp_auth)",
            "GFP_KERNEL"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"rawntlmssp session setup negotiate phase\\n\""
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}"
  },
  {
    "function_name": "_sess_auth_rawntlmssp_assemble_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "1104-1138",
    "snippet": "static int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unicode_oslm_strings",
          "args": [
            "&bcc_ptr",
            "sess_data->nls_cp"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_oslm_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "80-101",
          "snippet": "static void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "capabilities"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"NTLMSSP requires Unicode support\\n\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_ssetup_hdr",
          "args": [
            "ses",
            "pSMB"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ssetup_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "35-78",
          "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sess_auth_kerberos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "960-1096",
    "snippet": "static void\nsess_auth_kerberos(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\tstruct key *spnego_key = NULL;\n\tstruct cifs_spnego_msg *msg;\n\tu16 blob_len;\n\n\t/* extended security */\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data;\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t  \"incorrect version of cifs.upcall (expected %d but got %d)\",\n\t\t\t      CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\",\n\t\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities = cpu_to_le32(capabilities);\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif ((sess_data->iov[0].iov_len\n\t\t\t+ sess_data->iov[1].iov_len) % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\t\tunicode_domain_string(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\t/* BB: is this right? */\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_put_spnego_key;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "spnego_key"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_invalidate",
          "args": [
            "spnego_key"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_establish_session",
          "args": [
            "sess_data"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "sess_establish_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "589-619",
          "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ascii_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ascii_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "230-278",
          "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_unicode_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "decode_unicode_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "196-228",
          "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad security blob length %d\\n\"",
            "blob_len"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.SecurityBlobLength"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Guest login\\n\""
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascii_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "158-194",
          "snippet": "static void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_domain_string",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_domain_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "103-123",
          "snippet": "static void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_oslm_strings",
          "args": [
            "&bcc_ptr",
            "sess_data->nls_cp"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_oslm_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "80-101",
          "snippet": "static void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sess_data->iov[1].iov_len"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "capabilities"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Kerberos can't allocate (%u bytes) memory\"",
            "msg->sesskey_len"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "msg->data",
            "msg->sesskey_len",
            "GFP_KERNEL"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"incorrect version of cifs.upcall (expected %d but got %d)\"",
            "CIFS_SPNEGO_UPCALL_VERSION",
            "msg->version"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "spnego_key"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "spnego_key"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_spnego_key",
          "args": [
            "ses"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_spnego_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_spnego.c",
          "lines": "95-179",
          "snippet": "struct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifs_spnego.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define PID_KEY_LEN\t\t7",
            "#define USER_KEY_LEN\t\t6",
            "#define CREDUID_KEY_LEN\t\t11",
            "#define UID_KEY_LEN\t\t7",
            "#define IP_KEY_LEN\t\t5",
            "#define HOST_KEY_LEN\t\t5",
            "#define MAX_MECH_STR_LEN\t13",
            "#define MAX_VER_STR_LEN\t\t8"
          ],
          "globals_used": [
            "struct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifs_spnego.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#define PID_KEY_LEN\t\t7\n#define USER_KEY_LEN\t\t6\n#define CREDUID_KEY_LEN\t\t11\n#define UID_KEY_LEN\t\t7\n#define IP_KEY_LEN\t\t5\n#define HOST_KEY_LEN\t\t5\n#define MAX_MECH_STR_LEN\t13\n#define MAX_VER_STR_LEN\t\t8\n\nstruct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};\n\nstruct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_ssetup_hdr",
          "args": [
            "ses",
            "pSMB"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ssetup_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "35-78",
          "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "12"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_kerberos(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\tstruct key *spnego_key = NULL;\n\tstruct cifs_spnego_msg *msg;\n\tu16 blob_len;\n\n\t/* extended security */\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data;\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t  \"incorrect version of cifs.upcall (expected %d but got %d)\",\n\t\t\t      CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\",\n\t\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities = cpu_to_le32(capabilities);\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif ((sess_data->iov[0].iov_len\n\t\t\t+ sess_data->iov[1].iov_len) % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\t\tunicode_domain_string(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\t/* BB: is this right? */\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_put_spnego_key;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}"
  },
  {
    "function_name": "sess_auth_ntlmv2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "855-957",
    "snippet": "static void\nsess_auth_ntlmv2(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\n\t/* LM2 password would be here if we supported it */\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\n\t/* calculate nlmv2 response and session key */\n\trc = setup_ntlmv2_rsp(ses, sess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMv2 authentication\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t/* set case sensitive password length after tilen may get\n\t * assigned, tilen is 0 otherwise.\n\t */\n\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_establish_session",
          "args": [
            "sess_data"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "sess_establish_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "589-619",
          "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ascii_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ascii_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "230-278",
          "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_unicode_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "decode_unicode_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "196-228",
          "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Guest login\\n\""
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.Action"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascii_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "158-194",
          "snippet": "static void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "126-156",
          "snippet": "static void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ses->auth_key.len - CIFS_SESS_KEY_SIZE"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bcc_ptr",
            "ses->auth_key.response + CIFS_SESS_KEY_SIZE",
            "ses->auth_key.len - CIFS_SESS_KEY_SIZE"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error %d during NTLMv2 authentication\\n\"",
            "rc"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ntlmv2_rsp",
          "args": [
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ntlmv2_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "631-733",
          "snippet": "int\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "capabilities"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_ssetup_hdr",
          "args": [
            "ses",
            "pSMB"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ssetup_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "35-78",
          "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "13"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_ntlmv2(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\n\t/* LM2 password would be here if we supported it */\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\n\t/* calculate nlmv2 response and session key */\n\trc = setup_ntlmv2_rsp(ses, sess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMv2 authentication\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t/* set case sensitive password length after tilen may get\n\t * assigned, tilen is 0 otherwise.\n\t */\n\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}"
  },
  {
    "function_name": "sess_auth_ntlm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "750-853",
    "snippet": "static void\nsess_auth_ntlm(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength =\n\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t/* calculate ntlm response and session key */\n\trc = setup_ntlm_response(ses, sess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLM authentication\\n\",\n\t\t\t\t rc);\n\t\tgoto out;\n\t}\n\n\t/* copy ntlm response */\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tCIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tCIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_establish_session",
          "args": [
            "sess_data"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "sess_establish_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "589-619",
          "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ascii_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ascii_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "230-278",
          "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_unicode_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "decode_unicode_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "196-228",
          "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Guest login\\n\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.Action"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascii_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "158-194",
          "snippet": "static void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "126-156",
          "snippet": "static void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bcc_ptr",
            "ses->auth_key.response + CIFS_SESS_KEY_SIZE",
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bcc_ptr",
            "ses->auth_key.response + CIFS_SESS_KEY_SIZE",
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error %d during NTLM authentication\\n\"",
            "rc"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ntlm_response",
          "args": [
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ntlm_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "262-298",
          "snippet": "int setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\n\tchar temp_key[CIFS_SESS_KEY_SIZE];\n\n\tif (!ses)\n\t\treturn -EINVAL;\n\n\tses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\n\tif (!ses->auth_key.response)\n\t\treturn -ENOMEM;\n\n\tses->auth_key.len = temp_len;\n\n\trc = SMBNTencrypt(ses->password, ses->server->cryptkey,\n\t\t\tses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM response, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = E_md4hash(ses->password, temp_key, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM session key, error: %d\\n\",\n\t\t\t __func__, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\n\tchar temp_key[CIFS_SESS_KEY_SIZE];\n\n\tif (!ses)\n\t\treturn -EINVAL;\n\n\tses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\n\tif (!ses->auth_key.response)\n\t\treturn -ENOMEM;\n\n\tses->auth_key.len = temp_len;\n\n\trc = SMBNTencrypt(ses->password, ses->server->cryptkey,\n\t\t\tses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM response, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = E_md4hash(ses->password, temp_key, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM session key, error: %d\\n\",\n\t\t\t __func__, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "capabilities"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_ssetup_hdr",
          "args": [
            "ses",
            "pSMB"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ssetup_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "35-78",
          "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "13"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_ntlm(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength =\n\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t/* calculate ntlm response and session key */\n\trc = setup_ntlm_response(ses, sess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLM authentication\\n\",\n\t\t\t\t rc);\n\t\tgoto out;\n\t}\n\n\t/* copy ntlm response */\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tCIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tCIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}"
  },
  {
    "function_name": "sess_auth_lanman",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "649-746",
    "snippet": "static void\nsess_auth_lanman(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* lanman 2 style sessionsetup */\n\t/* wct = 10 */\n\trc = sess_alloc_buffer(sess_data, 10);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\n\n\t/* no capabilities flags in old lanman negotiation */\n\tpSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t/* Calculate hash with password and copy into bcc_ptr.\n\t * Encryption Key (stored as in cryptkey) gets used if the\n\t * security mode bit in Negottiate Protocol response states\n\t * to use challenge/response method (i.e. Password bit is 1).\n\t */\n\trc = calc_lanman_hash(ses->password, ses->server->cryptkey,\n\t\t\t      ses->server->sec_mode & SECMODE_PW_ENCRYPT ?\n\t\t\t      true : false, lnm_session_key);\n\n\tmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\n\t/*\n\t * can not sign if LANMAN negotiated so no need\n\t * to calculate signing key? but what if server\n\t * changed to do higher than lanman dialect and\n\t * we reconnected would we ever calc signing_key?\n\t */\n\n\tcifs_dbg(FYI, \"Negotiating LANMAN setting up strings\\n\");\n\t/* Unicode not allowed for LANMAN dialects */\n\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* lanman response has a word count of 3 */\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sess_free_buffer",
          "args": [
            "sess_data"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "sess_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "580-587",
          "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_establish_session",
          "args": [
            "sess_data"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "sess_establish_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "589-619",
          "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ascii_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ascii_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "230-278",
          "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_unicode_ssetup",
          "args": [
            "&bcc_ptr",
            "bytes_remaining",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "decode_unicode_ssetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "196-228",
          "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buf"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buf"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UID = %llu\\n\"",
            "ses->Suid"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Guest login\\n\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->resp.Action"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad word count %d\\n\"",
            "smb_buf->WordCount"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess_sendreceive",
          "args": [
            "sess_data"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "sess_sendreceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "621-639",
          "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascii_ssetup_strings",
          "args": [
            "&bcc_ptr",
            "ses",
            "sess_data->nls_cp"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_ssetup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "158-194",
          "snippet": "static void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Negotiating LANMAN setting up strings\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bcc_ptr",
            "(char *)lnm_session_key",
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_lanman_hash",
          "args": [
            "ses->password",
            "ses->server->cryptkey",
            "ses->server->sec_mode & SECMODE_PW_ENCRYPT ?\n\t\t\t      true : false",
            "lnm_session_key"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "calc_lanman_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "301-335",
          "snippet": "int calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_ssetup_hdr",
          "args": [
            "ses",
            "pSMB"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ssetup_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "35-78",
          "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sess_alloc_buffer",
          "args": [
            "sess_data",
            "10"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "sess_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "542-578",
          "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_lanman(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* lanman 2 style sessionsetup */\n\t/* wct = 10 */\n\trc = sess_alloc_buffer(sess_data, 10);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\n\n\t/* no capabilities flags in old lanman negotiation */\n\tpSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t/* Calculate hash with password and copy into bcc_ptr.\n\t * Encryption Key (stored as in cryptkey) gets used if the\n\t * security mode bit in Negottiate Protocol response states\n\t * to use challenge/response method (i.e. Password bit is 1).\n\t */\n\trc = calc_lanman_hash(ses->password, ses->server->cryptkey,\n\t\t\t      ses->server->sec_mode & SECMODE_PW_ENCRYPT ?\n\t\t\t      true : false, lnm_session_key);\n\n\tmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\n\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\n\t/*\n\t * can not sign if LANMAN negotiated so no need\n\t * to calculate signing key? but what if server\n\t * changed to do higher than lanman dialect and\n\t * we reconnected would we ever calc signing_key?\n\t */\n\n\tcifs_dbg(FYI, \"Negotiating LANMAN setting up strings\\n\");\n\t/* Unicode not allowed for LANMAN dialects */\n\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* lanman response has a word count of 3 */\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n}"
  },
  {
    "function_name": "sess_sendreceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "621-639",
    "snippet": "static int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "sess_data->xid",
            "sess_data->ses",
            "sess_data->iov",
            "3/* num_iovecs */",
            "&sess_data->buf0_type",
            "CIFS_LOG_ERROR"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bcc",
          "args": [
            "count",
            "smb_buf"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "put_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "455-461",
          "snippet": "static inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "be32_to_cpu(smb_buf->smb_buf_length) + count"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb_buf->smb_buf_length"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "sess_establish_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "589-619",
    "snippet": "static int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"CIFS session established successfully\\n\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "ses->auth_key.response",
            "ses->auth_key.len",
            "GFP_KERNEL"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sess_free_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "580-587",
    "snippet": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sess_data->iov[2].iov_base"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "sess_data->buf0_type",
            "sess_data->iov[0].iov_base"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}"
  },
  {
    "function_name": "sess_alloc_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "542-578",
    "snippet": "static int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb_buf"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2000",
            "GFP_KERNEL"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb_buf->smb_buf_length"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init_no_tc",
          "args": [
            "SMB_COM_SESSION_SETUP_ANDX",
            "wct",
            "ses",
            "(void **)&smb_buf"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}"
  },
  {
    "function_name": "select_sectype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "474-522",
    "snippet": "enum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nenum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}"
  },
  {
    "function_name": "build_ntlmssp_auth_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "370-472",
    "snippet": "int build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_CPHTXT_SIZE"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_CPHTXT_SIZE"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "ses->ntlmssp->ciphertext",
            "CIFS_CPHTXT_SIZE"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_seckey",
          "args": [
            "ses"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "calc_seckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "735-781",
          "snippet": "int\ncalc_seckey(struct cifs_ses *ses)\n{\n\tint rc;\n\tstruct crypto_blkcipher *tfm_arc4;\n\tstruct scatterlist sgin, sgout;\n\tstruct blkcipher_desc desc;\n\tunsigned char sec_key[CIFS_SESS_KEY_SIZE]; /* a nonce */\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\ttfm_arc4 = crypto_alloc_blkcipher(\"ecb(arc4)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_arc4)) {\n\t\trc = PTR_ERR(tfm_arc4);\n\t\tcifs_dbg(VFS, \"could not allocate crypto API arc4\\n\");\n\t\treturn rc;\n\t}\n\n\tdesc.tfm = tfm_arc4;\n\n\trc = crypto_blkcipher_setkey(tfm_arc4, ses->auth_key.response,\n\t\t\t\t\tCIFS_SESS_KEY_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set response as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\tsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\n\tsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\n\trc = crypto_blkcipher_encrypt(&desc, &sgout, &sgin, CIFS_CPHTXT_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not encrypt session key rc: %d\\n\", rc);\n\t\tcrypto_free_blkcipher(tfm_arc4);\n\t\treturn rc;\n\t}\n\n\t/* make secondary_key/nonce as session key */\n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n\t/* and make len as that of session key only */\n\tses->auth_key.len = CIFS_SESS_KEY_SIZE;\n\n\tcrypto_free_blkcipher(tfm_arc4);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncalc_seckey(struct cifs_ses *ses)\n{\n\tint rc;\n\tstruct crypto_blkcipher *tfm_arc4;\n\tstruct scatterlist sgin, sgout;\n\tstruct blkcipher_desc desc;\n\tunsigned char sec_key[CIFS_SESS_KEY_SIZE]; /* a nonce */\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\ttfm_arc4 = crypto_alloc_blkcipher(\"ecb(arc4)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_arc4)) {\n\t\trc = PTR_ERR(tfm_arc4);\n\t\tcifs_dbg(VFS, \"could not allocate crypto API arc4\\n\");\n\t\treturn rc;\n\t}\n\n\tdesc.tfm = tfm_arc4;\n\n\trc = crypto_blkcipher_setkey(tfm_arc4, ses->auth_key.response,\n\t\t\t\t\tCIFS_SESS_KEY_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set response as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\tsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\n\tsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\n\trc = crypto_blkcipher_encrypt(&desc, &sgout, &sgin, CIFS_CPHTXT_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not encrypt session key rc: %d\\n\", rc);\n\t\tcrypto_free_blkcipher(tfm_arc4);\n\t\treturn rc;\n\t}\n\n\t/* make secondary_key/nonce as session key */\n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n\t/* and make len as that of session key only */\n\tses->auth_key.len = CIFS_SESS_KEY_SIZE;\n\n\tcrypto_free_blkcipher(tfm_arc4);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *)tmp",
            "ses->user_name",
            "CIFS_MAX_USERNAME_LEN",
            "nls_cp"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ses->auth_key.len - CIFS_SESS_KEY_SIZE"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ses->auth_key.len - CIFS_SESS_KEY_SIZE"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "ses->auth_key.response + CIFS_SESS_KEY_SIZE",
            "ses->auth_key.len - CIFS_SESS_KEY_SIZE"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error %d during NTLMSSP authentication\\n\"",
            "rc"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ntlmv2_rsp",
          "args": [
            "ses",
            "nls_cp"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ntlmv2_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "631-733",
          "snippet": "int\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp - pbuffer"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(AUTHENTICATE_MESSAGE)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sec_blob->Signature",
            "NTLMSSP_SIGNATURE",
            "8"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}"
  },
  {
    "function_name": "build_ntlmssp_negotiate_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "334-365",
    "snippet": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sec_blob->Signature",
            "NTLMSSP_SIGNATURE",
            "8"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pbuffer",
            "0",
            "sizeof(NEGOTIATE_MESSAGE)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}"
  },
  {
    "function_name": "decode_ntlmssp_challenge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "280-328",
    "snippet": "int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Challenge target info alloc failure\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "bcc_ptr + tioffset",
            "tilen",
            "GFP_KERNEL"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"tioffset + tilen too high %u + %u\"",
            "tioffset",
            "tilen"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pblob->TargetInfoArray.Length"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pblob->TargetInfoArray.BufferOffset"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ses->ntlmssp->cryptkey",
            "pblob->Challenge",
            "CIFS_CRYPTO_KEY_SIZE"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Incorrect message type %d\\n\"",
            "pblob->MessageType"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"blob signature incorrect %s\\n\"",
            "pblob->Signature"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "pblob->Signature",
            "\"NTLMSSP\"",
            "8"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"challenge blob len %d too small\\n\"",
            "blob_len"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_ascii_ssetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "230-278",
    "snippet": "static void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ascii: bytes left %d\\n\"",
            "bleft"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "bcc_ptr",
            "bleft"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ses->serverNOS",
            "bcc_ptr",
            "len"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->serverNOS"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "bcc_ptr",
            "bleft"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"OS/2 server\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ses->serverOS",
            "\"OS/2\"",
            "4"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ses->serverOS",
            "bcc_ptr",
            "len"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->serverOS"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "bcc_ptr",
            "bleft"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"decode sessetup ascii. bleft %d\\n\"",
            "bleft"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}"
  },
  {
    "function_name": "decode_unicode_ssetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "196-228",
    "snippet": "static void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"serverDomain=%s\\n\"",
            "ses->serverDomain"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "data",
            "bleft",
            "true",
            "nls_cp"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->serverDomain"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UniStrnlen",
          "args": [
            "(wchar_t *) data",
            "bleft / 2"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "207-218",
          "snippet": "static inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"serverNOS=%s\\n\"",
            "ses->serverNOS"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->serverNOS"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"serverOS=%s\\n\"",
            "ses->serverOS"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->serverOS"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"bleft %d\\n\"",
            "bleft"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}"
  },
  {
    "function_name": "ascii_ssetup_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "158-194",
    "snippet": "static void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "CIFS_NETWORK_OPSYS"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bcc_ptr",
            "CIFS_NETWORK_OPSYS"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bcc_ptr",
            "init_utsname()->release"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bcc_ptr",
            "\"Linux version \""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "ses->domainName",
            "CIFS_MAX_DOMAINNAME_LEN"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "bcc_ptr",
            "ses->domainName",
            "CIFS_MAX_DOMAINNAME_LEN"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "ses->user_name",
            "CIFS_MAX_USERNAME_LEN"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "bcc_ptr",
            "ses->user_name",
            "CIFS_MAX_USERNAME_LEN"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}"
  },
  {
    "function_name": "unicode_ssetup_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "126-156",
    "snippet": "static void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unicode_oslm_strings",
          "args": [
            "&bcc_ptr",
            "nls_cp"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_oslm_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "80-101",
          "snippet": "static void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_domain_string",
          "args": [
            "&bcc_ptr",
            "ses",
            "nls_cp"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_domain_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "103-123",
          "snippet": "static void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) bcc_ptr",
            "ses->user_name",
            "CIFS_MAX_USERNAME_LEN",
            "nls_cp"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}"
  },
  {
    "function_name": "unicode_domain_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "103-123",
    "snippet": "static void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) bcc_ptr",
            "ses->domainName",
            "CIFS_MAX_DOMAINNAME_LEN",
            "nls_cp"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}"
  },
  {
    "function_name": "unicode_oslm_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "80-101",
    "snippet": "static void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) bcc_ptr",
            "CIFS_NETWORK_OPSYS",
            "32",
            "nls_cp"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}"
  },
  {
    "function_name": "cifs_ssetup_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
    "lines": "35-78",
    "snippet": "static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}",
    "includes": [
      "#include \"cifs_spnego.h\"",
      "#include <linux/slab.h>",
      "#include <linux/utsname.h>",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ses->server->maxReq"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4",
            "USHRT_MAX"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}"
  }
]