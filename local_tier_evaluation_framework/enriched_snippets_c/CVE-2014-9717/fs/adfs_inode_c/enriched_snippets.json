[
  {
    "function_name": "adfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "355-371",
    "snippet": "int adfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct object_info obj;\n\tint ret;\n\n\tobj.file_id\t= inode->i_ino;\n\tobj.name_len\t= 0;\n\tobj.parent_id\t= ADFS_I(inode)->parent_id;\n\tobj.loadaddr\t= ADFS_I(inode)->loadaddr;\n\tobj.execaddr\t= ADFS_I(inode)->execaddr;\n\tobj.attr\t= ADFS_I(inode)->attr;\n\tobj.size\t= inode->i_size;\n\n\tret = adfs_dir_update(sb, &obj, wbc->sync_mode == WB_SYNC_ALL);\n\treturn ret;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_dir_update",
          "args": [
            "sb",
            "&obj",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir.c",
          "lines": "67-101",
          "snippet": "int\nadfs_dir_update(struct super_block *sb, struct object_info *obj, int wait)\n{\n\tint ret = -EINVAL;\n#ifdef CONFIG_ADFS_FS_RW\n\tstruct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\n\tstruct adfs_dir dir;\n\n\tprintk(KERN_INFO \"adfs_dir_update: object %06X in dir %06X\\n\",\n\t\t obj->file_id, obj->parent_id);\n\n\tif (!ops->update) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ops->read(sb, obj->parent_id, 0, &dir);\n\tif (ret)\n\t\tgoto out;\n\n\twrite_lock(&adfs_dir_lock);\n\tret = ops->update(&dir, obj);\n\twrite_unlock(&adfs_dir_lock);\n\n\tif (wait) {\n\t\tint err = ops->sync(&dir);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\tops->free(&dir);\nout:\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"adfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(adfs_dir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n\nstatic DEFINE_RWLOCK(adfs_dir_lock);\n\nint\nadfs_dir_update(struct super_block *sb, struct object_info *obj, int wait)\n{\n\tint ret = -EINVAL;\n#ifdef CONFIG_ADFS_FS_RW\n\tstruct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\n\tstruct adfs_dir dir;\n\n\tprintk(KERN_INFO \"adfs_dir_update: object %06X in dir %06X\\n\",\n\t\t obj->file_id, obj->parent_id);\n\n\tif (!ops->update) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ops->read(sb, obj->parent_id, 0, &dir);\n\tif (ret)\n\t\tgoto out;\n\n\twrite_lock(&adfs_dir_lock);\n\tret = ops->update(&dir, obj);\n\twrite_unlock(&adfs_dir_lock);\n\n\tif (wait) {\n\t\tint err = ops->sync(&dir);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\tops->free(&dir);\nout:\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nint adfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct object_info obj;\n\tint ret;\n\n\tobj.file_id\t= inode->i_ino;\n\tobj.name_len\t= 0;\n\tobj.parent_id\t= ADFS_I(inode)->parent_id;\n\tobj.loadaddr\t= ADFS_I(inode)->loadaddr;\n\tobj.execaddr\t= ADFS_I(inode)->execaddr;\n\tobj.attr\t= ADFS_I(inode)->attr;\n\tobj.size\t= inode->i_size;\n\n\tret = adfs_dir_update(sb, &obj, wbc->sync_mode == WB_SYNC_ALL);\n\treturn ret;\n}"
  },
  {
    "function_name": "adfs_notify_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "298-348",
    "snippet": "int\nadfs_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\t\n\terror = inode_change_ok(inode, attr);\n\n\t/*\n\t * we can't change the UID or GID of any file -\n\t * we have a global UID/GID in the superblock\n\t */\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, ADFS_SB(sb)->s_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, ADFS_SB(sb)->s_gid)))\n\t\terror = -EPERM;\n\n\tif (error)\n\t\tgoto out;\n\n\t/* XXX: this is missing some actual on-disk truncation.. */\n\tif (ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tif (ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = attr->ia_mtime;\n\t\tadfs_unix2adfs_time(inode, attr->ia_mtime.tv_sec);\n\t}\n\t/*\n\t * FIXME: should we make these == to i_mtime since we don't\n\t * have the ability to represent them in our filesystem?\n\t */\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = attr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tADFS_I(inode)->attr = adfs_mode2atts(sb, inode);\n\t\tinode->i_mode = adfs_atts2mode(sb, inode);\n\t}\n\n\t/*\n\t * FIXME: should we be marking this inode dirty even if\n\t * we don't have any metadata to write back?\n\t */\n\tif (ia_valid & (ATTR_SIZE | ATTR_MTIME | ATTR_MODE))\n\t\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_atts2mode",
          "args": [
            "sb",
            "inode"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_atts2mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "88-126",
          "snippet": "static umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_mode2atts",
          "args": [
            "sb",
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_mode2atts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "132-162",
          "snippet": "static int\nadfs_mode2atts(struct super_block *sb, struct inode *inode)\n{\n\tumode_t mode;\n\tint attr;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\t/* FIXME: should we be able to alter a link? */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ADFS_I(inode)->attr;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tattr = ADFS_NDA_DIRECTORY;\n\telse\n\t\tattr = 0;\n\n\tmode = inode->i_mode & asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_OWNER_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_OWNER_WRITE;\n\n\tmode = inode->i_mode & asb->s_other_mask;\n\tmode &= ~asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_WRITE;\n\n\treturn attr;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_mode2atts(struct super_block *sb, struct inode *inode)\n{\n\tumode_t mode;\n\tint attr;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\t/* FIXME: should we be able to alter a link? */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ADFS_I(inode)->attr;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tattr = ADFS_NDA_DIRECTORY;\n\telse\n\t\tattr = 0;\n\n\tmode = inode->i_mode & asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_OWNER_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_OWNER_WRITE;\n\n\tmode = inode->i_mode & asb->s_other_mask;\n\tmode &= ~asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_WRITE;\n\n\treturn attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_unix2adfs_time",
          "args": [
            "inode",
            "attr->ia_mtime.tv_sec"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_unix2adfs_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "214-228",
          "snippet": "static void\nadfs_unix2adfs_time(struct inode *inode, unsigned int secs)\n{\n\tunsigned int high, low;\n\n\tif (ADFS_I(inode)->stamped) {\n\t\t/* convert 32-bit seconds to 40-bit centi-seconds */\n\t\tlow  = (secs & 255) * 100;\n\t\thigh = (secs / 256) * 100 + (low >> 8) + 0x336e996a;\n\n\t\tADFS_I(inode)->loadaddr = (high >> 24) |\n\t\t\t\t(ADFS_I(inode)->loadaddr & ~0xff);\n\t\tADFS_I(inode)->execaddr = (low & 255) | (high << 8);\n\t}\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void\nadfs_unix2adfs_time(struct inode *inode, unsigned int secs)\n{\n\tunsigned int high, low;\n\n\tif (ADFS_I(inode)->stamped) {\n\t\t/* convert 32-bit seconds to 40-bit centi-seconds */\n\t\tlow  = (secs & 255) * 100;\n\t\thigh = (secs / 256) * 100 + (low >> 8) + 0x336e996a;\n\n\t\tADFS_I(inode)->loadaddr = (high >> 24) |\n\t\t\t\t(ADFS_I(inode)->loadaddr & ~0xff);\n\t\tADFS_I(inode)->execaddr = (low & 255) | (high << 8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "ADFS_SB(sb)->s_gid"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "ADFS_SB(sb)->s_uid"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nint\nadfs_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\t\n\terror = inode_change_ok(inode, attr);\n\n\t/*\n\t * we can't change the UID or GID of any file -\n\t * we have a global UID/GID in the superblock\n\t */\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, ADFS_SB(sb)->s_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, ADFS_SB(sb)->s_gid)))\n\t\terror = -EPERM;\n\n\tif (error)\n\t\tgoto out;\n\n\t/* XXX: this is missing some actual on-disk truncation.. */\n\tif (ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tif (ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = attr->ia_mtime;\n\t\tadfs_unix2adfs_time(inode, attr->ia_mtime.tv_sec);\n\t}\n\t/*\n\t * FIXME: should we make these == to i_mtime since we don't\n\t * have the ability to represent them in our filesystem?\n\t */\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = attr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tADFS_I(inode)->attr = adfs_mode2atts(sb, inode);\n\t\tinode->i_mode = adfs_atts2mode(sb, inode);\n\t}\n\n\t/*\n\t * FIXME: should we be marking this inode dirty even if\n\t * we don't have any metadata to write back?\n\t */\n\tif (ia_valid & (ATTR_SIZE | ATTR_MTIME | ATTR_MODE))\n\t\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "adfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "242-291",
    "snippet": "struct inode *\nadfs_iget(struct super_block *sb, struct object_info *obj)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_uid\t = ADFS_SB(sb)->s_uid;\n\tinode->i_gid\t = ADFS_SB(sb)->s_gid;\n\tinode->i_ino\t = obj->file_id;\n\tinode->i_size\t = obj->size;\n\tset_nlink(inode, 2);\n\tinode->i_blocks\t = (inode->i_size + sb->s_blocksize - 1) >>\n\t\t\t    sb->s_blocksize_bits;\n\n\t/*\n\t * we need to save the parent directory ID so that\n\t * write_inode can update the directory information\n\t * for this file.  This will need special handling\n\t * for cross-directory renames.\n\t */\n\tADFS_I(inode)->parent_id = obj->parent_id;\n\tADFS_I(inode)->loadaddr  = obj->loadaddr;\n\tADFS_I(inode)->execaddr  = obj->execaddr;\n\tADFS_I(inode)->attr      = obj->attr;\n\tADFS_I(inode)->filetype  = obj->filetype;\n\tADFS_I(inode)->stamped   = ((obj->loadaddr & 0xfff00000) == 0xfff00000);\n\n\tinode->i_mode\t = adfs_atts2mode(sb, inode);\n\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\tinode->i_atime = inode->i_mtime;\n\tinode->i_ctime = inode->i_mtime;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_dir_inode_operations;\n\t\tinode->i_fop\t= &adfs_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_file_inode_operations;\n\t\tinode->i_fop\t= &adfs_file_operations;\n\t\tinode->i_mapping->a_ops = &adfs_aops;\n\t\tADFS_I(inode)->mmu_private = inode->i_size;\n\t}\n\n\tinsert_inode_hash(inode);\n\nout:\n\treturn inode;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations adfs_aops = {\n\t.readpage\t= adfs_readpage,\n\t.writepage\t= adfs_writepage,\n\t.write_begin\t= adfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= _adfs_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_adfs2unix_time",
          "args": [
            "&inode->i_mtime",
            "inode"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_adfs2unix_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "169-208",
          "snippet": "static void\nadfs_adfs2unix_time(struct timespec *tv, struct inode *inode)\n{\n\tunsigned int high, low;\n\t/* 01 Jan 1970 00:00:00 (Unix epoch) as nanoseconds since\n\t * 01 Jan 1900 00:00:00 (RISC OS epoch)\n\t */\n\tstatic const s64 nsec_unix_epoch_diff_risc_os_epoch =\n\t\t\t\t\t\t\t2208988800000000000LL;\n\ts64 nsec;\n\n\tif (ADFS_I(inode)->stamped == 0)\n\t\tgoto cur_time;\n\n\thigh = ADFS_I(inode)->loadaddr & 0xFF; /* top 8 bits of timestamp */\n\tlow  = ADFS_I(inode)->execaddr;    /* bottom 32 bits of timestamp */\n\n\t/* convert 40-bit centi-seconds to 32-bit seconds\n\t * going via nanoseconds to retain precision\n\t */\n\tnsec = (((s64) high << 32) | (s64) low) * 10000000; /* cs to ns */\n\n\t/* Files dated pre  01 Jan 1970 00:00:00. */\n\tif (nsec < nsec_unix_epoch_diff_risc_os_epoch)\n\t\tgoto too_early;\n\n\t/* convert from RISC OS to Unix epoch */\n\tnsec -= nsec_unix_epoch_diff_risc_os_epoch;\n\n\t*tv = ns_to_timespec(nsec);\n\treturn;\n\n cur_time:\n\t*tv = CURRENT_TIME;\n\treturn;\n\n too_early:\n\ttv->tv_sec = tv->tv_nsec = 0;\n\treturn;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void\nadfs_adfs2unix_time(struct timespec *tv, struct inode *inode)\n{\n\tunsigned int high, low;\n\t/* 01 Jan 1970 00:00:00 (Unix epoch) as nanoseconds since\n\t * 01 Jan 1900 00:00:00 (RISC OS epoch)\n\t */\n\tstatic const s64 nsec_unix_epoch_diff_risc_os_epoch =\n\t\t\t\t\t\t\t2208988800000000000LL;\n\ts64 nsec;\n\n\tif (ADFS_I(inode)->stamped == 0)\n\t\tgoto cur_time;\n\n\thigh = ADFS_I(inode)->loadaddr & 0xFF; /* top 8 bits of timestamp */\n\tlow  = ADFS_I(inode)->execaddr;    /* bottom 32 bits of timestamp */\n\n\t/* convert 40-bit centi-seconds to 32-bit seconds\n\t * going via nanoseconds to retain precision\n\t */\n\tnsec = (((s64) high << 32) | (s64) low) * 10000000; /* cs to ns */\n\n\t/* Files dated pre  01 Jan 1970 00:00:00. */\n\tif (nsec < nsec_unix_epoch_diff_risc_os_epoch)\n\t\tgoto too_early;\n\n\t/* convert from RISC OS to Unix epoch */\n\tnsec -= nsec_unix_epoch_diff_risc_os_epoch;\n\n\t*tv = ns_to_timespec(nsec);\n\treturn;\n\n cur_time:\n\t*tv = CURRENT_TIME;\n\treturn;\n\n too_early:\n\ttv->tv_sec = tv->tv_nsec = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_atts2mode",
          "args": [
            "sb",
            "inode"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_atts2mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "88-126",
          "snippet": "static umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations adfs_aops = {\n\t.readpage\t= adfs_readpage,\n\t.writepage\t= adfs_writepage,\n\t.write_begin\t= adfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= _adfs_bmap\n};\n\nstruct inode *\nadfs_iget(struct super_block *sb, struct object_info *obj)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_uid\t = ADFS_SB(sb)->s_uid;\n\tinode->i_gid\t = ADFS_SB(sb)->s_gid;\n\tinode->i_ino\t = obj->file_id;\n\tinode->i_size\t = obj->size;\n\tset_nlink(inode, 2);\n\tinode->i_blocks\t = (inode->i_size + sb->s_blocksize - 1) >>\n\t\t\t    sb->s_blocksize_bits;\n\n\t/*\n\t * we need to save the parent directory ID so that\n\t * write_inode can update the directory information\n\t * for this file.  This will need special handling\n\t * for cross-directory renames.\n\t */\n\tADFS_I(inode)->parent_id = obj->parent_id;\n\tADFS_I(inode)->loadaddr  = obj->loadaddr;\n\tADFS_I(inode)->execaddr  = obj->execaddr;\n\tADFS_I(inode)->attr      = obj->attr;\n\tADFS_I(inode)->filetype  = obj->filetype;\n\tADFS_I(inode)->stamped   = ((obj->loadaddr & 0xfff00000) == 0xfff00000);\n\n\tinode->i_mode\t = adfs_atts2mode(sb, inode);\n\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\tinode->i_atime = inode->i_mtime;\n\tinode->i_ctime = inode->i_mtime;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_dir_inode_operations;\n\t\tinode->i_fop\t= &adfs_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_file_inode_operations;\n\t\tinode->i_fop\t= &adfs_file_operations;\n\t\tinode->i_mapping->a_ops = &adfs_aops;\n\t\tADFS_I(inode)->mmu_private = inode->i_size;\n\t}\n\n\tinsert_inode_hash(inode);\n\nout:\n\treturn inode;\n}"
  },
  {
    "function_name": "adfs_unix2adfs_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "214-228",
    "snippet": "static void\nadfs_unix2adfs_time(struct inode *inode, unsigned int secs)\n{\n\tunsigned int high, low;\n\n\tif (ADFS_I(inode)->stamped) {\n\t\t/* convert 32-bit seconds to 40-bit centi-seconds */\n\t\tlow  = (secs & 255) * 100;\n\t\thigh = (secs / 256) * 100 + (low >> 8) + 0x336e996a;\n\n\t\tADFS_I(inode)->loadaddr = (high >> 24) |\n\t\t\t\t(ADFS_I(inode)->loadaddr & ~0xff);\n\t\tADFS_I(inode)->execaddr = (low & 255) | (high << 8);\n\t}\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void\nadfs_unix2adfs_time(struct inode *inode, unsigned int secs)\n{\n\tunsigned int high, low;\n\n\tif (ADFS_I(inode)->stamped) {\n\t\t/* convert 32-bit seconds to 40-bit centi-seconds */\n\t\tlow  = (secs & 255) * 100;\n\t\thigh = (secs / 256) * 100 + (low >> 8) + 0x336e996a;\n\n\t\tADFS_I(inode)->loadaddr = (high >> 24) |\n\t\t\t\t(ADFS_I(inode)->loadaddr & ~0xff);\n\t\tADFS_I(inode)->execaddr = (low & 255) | (high << 8);\n\t}\n}"
  },
  {
    "function_name": "adfs_adfs2unix_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "169-208",
    "snippet": "static void\nadfs_adfs2unix_time(struct timespec *tv, struct inode *inode)\n{\n\tunsigned int high, low;\n\t/* 01 Jan 1970 00:00:00 (Unix epoch) as nanoseconds since\n\t * 01 Jan 1900 00:00:00 (RISC OS epoch)\n\t */\n\tstatic const s64 nsec_unix_epoch_diff_risc_os_epoch =\n\t\t\t\t\t\t\t2208988800000000000LL;\n\ts64 nsec;\n\n\tif (ADFS_I(inode)->stamped == 0)\n\t\tgoto cur_time;\n\n\thigh = ADFS_I(inode)->loadaddr & 0xFF; /* top 8 bits of timestamp */\n\tlow  = ADFS_I(inode)->execaddr;    /* bottom 32 bits of timestamp */\n\n\t/* convert 40-bit centi-seconds to 32-bit seconds\n\t * going via nanoseconds to retain precision\n\t */\n\tnsec = (((s64) high << 32) | (s64) low) * 10000000; /* cs to ns */\n\n\t/* Files dated pre  01 Jan 1970 00:00:00. */\n\tif (nsec < nsec_unix_epoch_diff_risc_os_epoch)\n\t\tgoto too_early;\n\n\t/* convert from RISC OS to Unix epoch */\n\tnsec -= nsec_unix_epoch_diff_risc_os_epoch;\n\n\t*tv = ns_to_timespec(nsec);\n\treturn;\n\n cur_time:\n\t*tv = CURRENT_TIME;\n\treturn;\n\n too_early:\n\ttv->tv_sec = tv->tv_nsec = 0;\n\treturn;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec",
          "args": [
            "nsec"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void\nadfs_adfs2unix_time(struct timespec *tv, struct inode *inode)\n{\n\tunsigned int high, low;\n\t/* 01 Jan 1970 00:00:00 (Unix epoch) as nanoseconds since\n\t * 01 Jan 1900 00:00:00 (RISC OS epoch)\n\t */\n\tstatic const s64 nsec_unix_epoch_diff_risc_os_epoch =\n\t\t\t\t\t\t\t2208988800000000000LL;\n\ts64 nsec;\n\n\tif (ADFS_I(inode)->stamped == 0)\n\t\tgoto cur_time;\n\n\thigh = ADFS_I(inode)->loadaddr & 0xFF; /* top 8 bits of timestamp */\n\tlow  = ADFS_I(inode)->execaddr;    /* bottom 32 bits of timestamp */\n\n\t/* convert 40-bit centi-seconds to 32-bit seconds\n\t * going via nanoseconds to retain precision\n\t */\n\tnsec = (((s64) high << 32) | (s64) low) * 10000000; /* cs to ns */\n\n\t/* Files dated pre  01 Jan 1970 00:00:00. */\n\tif (nsec < nsec_unix_epoch_diff_risc_os_epoch)\n\t\tgoto too_early;\n\n\t/* convert from RISC OS to Unix epoch */\n\tnsec -= nsec_unix_epoch_diff_risc_os_epoch;\n\n\t*tv = ns_to_timespec(nsec);\n\treturn;\n\n cur_time:\n\t*tv = CURRENT_TIME;\n\treturn;\n\n too_early:\n\ttv->tv_sec = tv->tv_nsec = 0;\n\treturn;\n}"
  },
  {
    "function_name": "adfs_mode2atts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "132-162",
    "snippet": "static int\nadfs_mode2atts(struct super_block *sb, struct inode *inode)\n{\n\tumode_t mode;\n\tint attr;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\t/* FIXME: should we be able to alter a link? */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ADFS_I(inode)->attr;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tattr = ADFS_NDA_DIRECTORY;\n\telse\n\t\tattr = 0;\n\n\tmode = inode->i_mode & asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_OWNER_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_OWNER_WRITE;\n\n\tmode = inode->i_mode & asb->s_other_mask;\n\tmode &= ~asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_WRITE;\n\n\treturn attr;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_mode2atts(struct super_block *sb, struct inode *inode)\n{\n\tumode_t mode;\n\tint attr;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\t/* FIXME: should we be able to alter a link? */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ADFS_I(inode)->attr;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tattr = ADFS_NDA_DIRECTORY;\n\telse\n\t\tattr = 0;\n\n\tmode = inode->i_mode & asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_OWNER_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_OWNER_WRITE;\n\n\tmode = inode->i_mode & asb->s_other_mask;\n\tmode &= ~asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_WRITE;\n\n\treturn attr;\n}"
  },
  {
    "function_name": "adfs_atts2mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "88-126",
    "snippet": "static umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (ADFS_I(inode)->filetype) {\n\tcase 0xfc0:\t/* LinkFS */\n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t/* UnixExec */\n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}"
  },
  {
    "function_name": "_adfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "72-75",
    "snippet": "static sector_t _adfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, adfs_get_block);\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "adfs_get_block"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic sector_t _adfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, adfs_get_block);\n}"
  },
  {
    "function_name": "adfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "56-70",
    "snippet": "static int adfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tadfs_get_block,\n\t\t\t\t&ADFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\tadfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "48-54",
          "snippet": "static void adfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void adfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "adfs_get_block",
            "&ADFS_I(mapping->host)->mmu_private"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int adfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tadfs_get_block,\n\t\t\t\t&ADFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\tadfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "48-54",
    "snippet": "static void adfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic void adfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
  },
  {
    "function_name": "adfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "43-46",
    "snippet": "static int adfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, adfs_get_block);\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "adfs_get_block"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int adfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, adfs_get_block);\n}"
  },
  {
    "function_name": "adfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "38-41",
    "snippet": "static int adfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, adfs_get_block, wbc);\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "adfs_get_block",
            "wbc"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int adfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, adfs_get_block, wbc);\n}"
  },
  {
    "function_name": "adfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
    "lines": "18-36",
    "snippet": "static int\nadfs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t       int create)\n{\n\tif (!create) {\n\t\tif (block >= inode->i_blocks)\n\t\t\tgoto abort_toobig;\n\n\t\tblock = __adfs_block_map(inode->i_sb, inode->i_ino, block);\n\t\tif (block)\n\t\t\tmap_bh(bh, inode->i_sb, block);\n\t\treturn 0;\n\t}\n\t/* don't support allocation of blocks yet */\n\treturn -EIO;\n\nabort_toobig:\n\treturn 0;\n}",
    "includes": [
      "#include \"adfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "block"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adfs_block_map",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "block"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "196-208",
          "snippet": "static inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t       int create)\n{\n\tif (!create) {\n\t\tif (block >= inode->i_blocks)\n\t\t\tgoto abort_toobig;\n\n\t\tblock = __adfs_block_map(inode->i_sb, inode->i_ino, block);\n\t\tif (block)\n\t\t\tmap_bh(bh, inode->i_sb, block);\n\t\treturn 0;\n\t}\n\t/* don't support allocation of blocks yet */\n\treturn -EIO;\n\nabort_toobig:\n\treturn 0;\n}"
  }
]