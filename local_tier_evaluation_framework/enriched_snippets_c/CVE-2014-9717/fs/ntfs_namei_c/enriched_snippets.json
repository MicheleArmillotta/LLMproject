[
  {
    "function_name": "ntfs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/namei.c",
    "lines": "374-379",
    "snippet": "static struct dentry *ntfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ntfs_nfs_get_inode"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n\nstatic struct dentry *ntfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}"
  },
  {
    "function_name": "ntfs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/namei.c",
    "lines": "367-372",
    "snippet": "static struct dentry *ntfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ntfs_nfs_get_inode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n\nstatic struct dentry *ntfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}"
  },
  {
    "function_name": "ntfs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/namei.c",
    "lines": "351-365",
    "snippet": "static struct inode *ntfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_iget(sb, ino);\n\tif (!IS_ERR(inode)) {\n\t\tif (is_bad_inode(inode) || inode->i_generation != generation) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n\nstatic struct inode *ntfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_iget(sb, ino);\n\tif (!IS_ERR(inode)) {\n\t\tif (is_bad_inode(inode) || inode->i_generation != generation) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ntfs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/namei.c",
    "lines": "300-349",
    "snippet": "static struct dentry *ntfs_get_parent(struct dentry *child_dent)\n{\n\tstruct inode *vi = child_dent->d_inode;\n\tntfs_inode *ni = NTFS_I(vi);\n\tMFT_RECORD *mrec;\n\tntfs_attr_search_ctx *ctx;\n\tATTR_RECORD *attr;\n\tFILE_NAME_ATTR *fn;\n\tunsigned long parent_ino;\n\tint err;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\t/* Get the mft record of the inode belonging to the child dentry. */\n\tmrec = map_mft_record(ni);\n\tif (IS_ERR(mrec))\n\t\treturn (struct dentry *)mrec;\n\t/* Find the first file name attribute in the mft record. */\n\tctx = ntfs_attr_get_search_ctx(ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tunmap_mft_record(ni);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\ntry_next:\n\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"Inode 0x%lx does not have a \"\n\t\t\t\t\t\"file name attribute.  Run chkdsk.\",\n\t\t\t\t\tvi->i_ino);\n\t\treturn ERR_PTR(err);\n\t}\n\tattr = ctx->attr;\n\tif (unlikely(attr->non_resident))\n\t\tgoto try_next;\n\tfn = (FILE_NAME_ATTR *)((u8 *)attr +\n\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\tif (unlikely((u8 *)fn + le32_to_cpu(attr->data.resident.value_length) >\n\t\t\t(u8*)attr + le32_to_cpu(attr->length)))\n\t\tgoto try_next;\n\t/* Get the inode number of the parent directory. */\n\tparent_ino = MREF_LE(fn->parent_directory);\n\t/* Release the search context and the mft record of the child. */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\n\n\treturn d_obtain_alias(ntfs_iget(vi->i_sb, parent_ino));\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ntfs_iget(vi->i_sb, parent_ino)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vi->i_sb",
            "parent_ino"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "fn->parent_directory"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(u8 *)fn + le32_to_cpu(attr->data.resident.value_length) >\n\t\t\t(u8*)attr + le32_to_cpu(attr->length)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "attr->length"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "attr->data.resident.value_offset"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "attr->non_resident"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Inode 0x%lx does not have a \"\n\t\t\t\t\t\"file name attribute.  Run chkdsk.\"",
            "vi->i_ino"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_FILE_NAME",
            "NULL",
            "0",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "mrec"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n\nstatic struct dentry *ntfs_get_parent(struct dentry *child_dent)\n{\n\tstruct inode *vi = child_dent->d_inode;\n\tntfs_inode *ni = NTFS_I(vi);\n\tMFT_RECORD *mrec;\n\tntfs_attr_search_ctx *ctx;\n\tATTR_RECORD *attr;\n\tFILE_NAME_ATTR *fn;\n\tunsigned long parent_ino;\n\tint err;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\t/* Get the mft record of the inode belonging to the child dentry. */\n\tmrec = map_mft_record(ni);\n\tif (IS_ERR(mrec))\n\t\treturn (struct dentry *)mrec;\n\t/* Find the first file name attribute in the mft record. */\n\tctx = ntfs_attr_get_search_ctx(ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tunmap_mft_record(ni);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\ntry_next:\n\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"Inode 0x%lx does not have a \"\n\t\t\t\t\t\"file name attribute.  Run chkdsk.\",\n\t\t\t\t\tvi->i_ino);\n\t\treturn ERR_PTR(err);\n\t}\n\tattr = ctx->attr;\n\tif (unlikely(attr->non_resident))\n\t\tgoto try_next;\n\tfn = (FILE_NAME_ATTR *)((u8 *)attr +\n\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\tif (unlikely((u8 *)fn + le32_to_cpu(attr->data.resident.value_length) >\n\t\t\t(u8*)attr + le32_to_cpu(attr->length)))\n\t\tgoto try_next;\n\t/* Get the inode number of the parent directory. */\n\tparent_ino = MREF_LE(fn->parent_directory);\n\t/* Release the search context and the mft record of the child. */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\n\n\treturn d_obtain_alias(ntfs_iget(vi->i_sb, parent_ino));\n}"
  },
  {
    "function_name": "ntfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/namei.c",
    "lines": "103-274",
    "snippet": "static struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,\n\t\tunsigned int flags)\n{\n\tntfs_volume *vol = NTFS_SB(dir_ino->i_sb);\n\tstruct inode *dent_inode;\n\tntfschar *uname;\n\tntfs_name *name = NULL;\n\tMFT_REF mref;\n\tunsigned long dent_ino;\n\tint uname_len;\n\n\tntfs_debug(\"Looking up %pd in directory inode 0x%lx.\",\n\t\t\tdent, dir_ino->i_ino);\n\t/* Convert the name of the dentry to Unicode. */\n\tuname_len = ntfs_nlstoucs(vol, dent->d_name.name, dent->d_name.len,\n\t\t\t&uname);\n\tif (uname_len < 0) {\n\t\tif (uname_len != -ENAMETOOLONG)\n\t\t\tntfs_error(vol->sb, \"Failed to convert name to \"\n\t\t\t\t\t\"Unicode.\");\n\t\treturn ERR_PTR(uname_len);\n\t}\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(dir_ino), uname, uname_len,\n\t\t\t&name);\n\tkmem_cache_free(ntfs_name_cache, uname);\n\tif (!IS_ERR_MREF(mref)) {\n\t\tdent_ino = MREF(mref);\n\t\tntfs_debug(\"Found inode 0x%lx. Calling ntfs_iget.\", dent_ino);\n\t\tdent_inode = ntfs_iget(vol->sb, dent_ino);\n\t\tif (likely(!IS_ERR(dent_inode))) {\n\t\t\t/* Consistency check. */\n\t\t\tif (is_bad_inode(dent_inode) || MSEQNO(mref) ==\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no ||\n\t\t\t\t\tdent_ino == FILE_MFT) {\n\t\t\t\t/* Perfect WIN32/POSIX match. -- Case 1. */\n\t\t\t\tif (!name) {\n\t\t\t\t\tntfs_debug(\"Done.  (Case 1.)\");\n\t\t\t\t\treturn d_splice_alias(dent_inode, dent);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We are too indented.  Handle imperfect\n\t\t\t\t * matches and short file names further below.\n\t\t\t\t */\n\t\t\t\tgoto handle_name;\n\t\t\t}\n\t\t\tntfs_error(vol->sb, \"Found stale reference to inode \"\n\t\t\t\t\t\"0x%lx (reference sequence number = \"\n\t\t\t\t\t\"0x%x, inode sequence number = 0x%x), \"\n\t\t\t\t\t\"returning -EIO. Run chkdsk.\",\n\t\t\t\t\tdent_ino, MSEQNO(mref),\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no);\n\t\t\tiput(dent_inode);\n\t\t\tdent_inode = ERR_PTR(-EIO);\n\t\t} else\n\t\t\tntfs_error(vol->sb, \"ntfs_iget(0x%lx) failed with \"\n\t\t\t\t\t\"error code %li.\", dent_ino,\n\t\t\t\t\tPTR_ERR(dent_inode));\n\t\tkfree(name);\n\t\t/* Return the error code. */\n\t\treturn (struct dentry *)dent_inode;\n\t}\n\t/* It is guaranteed that @name is no longer allocated at this point. */\n\tif (MREF_ERR(mref) == -ENOENT) {\n\t\tntfs_debug(\"Entry was not found, adding negative dentry.\");\n\t\t/* The dcache will handle negative entries. */\n\t\td_add(dent, NULL);\n\t\tntfs_debug(\"Done.\");\n\t\treturn NULL;\n\t}\n\tntfs_error(vol->sb, \"ntfs_lookup_ino_by_name() failed with error \"\n\t\t\t\"code %i.\", -MREF_ERR(mref));\n\treturn ERR_PTR(MREF_ERR(mref));\n\t// TODO: Consider moving this lot to a separate function! (AIA)\nhandle_name:\n   {\n\tMFT_RECORD *m;\n\tntfs_attr_search_ctx *ctx;\n\tntfs_inode *ni = NTFS_I(dent_inode);\n\tint err;\n\tstruct qstr nls_name;\n\n\tnls_name.name = NULL;\n\tif (name->type != FILE_NAME_DOS) {\t\t\t/* Case 2. */\n\t\tntfs_debug(\"Case 2.\");\n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&name->name, name->len,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\t\tkfree(name);\n\t} else /* if (name->type == FILE_NAME_DOS) */ {\t\t/* Case 3. */\n\t\tFILE_NAME_ATTR *fn;\n\n\t\tntfs_debug(\"Case 3.\");\n\t\tkfree(name);\n\n\t\t/* Find the WIN32 name corresponding to the matched DOS name. */\n\t\tni = NTFS_I(dent_inode);\n\t\tm = map_mft_record(ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tdo {\n\t\t\tATTR_RECORD *a;\n\t\t\tu32 val_len;\n\n\t\t\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0,\n\t\t\t\t\tNULL, 0, ctx);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tntfs_error(vol->sb, \"Inode corrupt: No WIN32 \"\n\t\t\t\t\t\t\"namespace counterpart to DOS \"\n\t\t\t\t\t\t\"file name. Run chkdsk.\");\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Consistency checks. */\n\t\t\ta = ctx->attr;\n\t\t\tif (a->non_resident || a->flags)\n\t\t\t\tgoto eio_err_out;\n\t\t\tval_len = le32_to_cpu(a->data.resident.value_length);\n\t\t\tif (le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\t\tval_len > le32_to_cpu(a->length))\n\t\t\t\tgoto eio_err_out;\n\t\t\tfn = (FILE_NAME_ATTR*)((u8*)ctx->attr + le16_to_cpu(\n\t\t\t\t\tctx->attr->data.resident.value_offset));\n\t\t\tif ((u32)(fn->file_name_length * sizeof(ntfschar) +\n\t\t\t\t\tsizeof(FILE_NAME_ATTR)) > val_len)\n\t\t\t\tgoto eio_err_out;\n\t\t} while (fn->file_name_type != FILE_NAME_WIN32);\n\n\t\t/* Convert the found WIN32 name to current NLS code page. */\n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&fn->file_name, fn->file_name_length,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t}\n\tm = NULL;\n\tctx = NULL;\n\n\t/* Check if a conversion error occurred. */\n\tif ((signed)nls_name.len < 0) {\n\t\terr = (signed)nls_name.len;\n\t\tgoto err_out;\n\t}\n\tnls_name.hash = full_name_hash(nls_name.name, nls_name.len);\n\n\tdent = d_add_ci(dent, dent_inode, &nls_name);\n\tkfree(nls_name.name);\n\treturn dent;\n\neio_err_out:\n\tntfs_error(vol->sb, \"Illegal file name attribute. Run chkdsk.\");\n\terr = -EIO;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\n\tiput(dent_inode);\n\tntfs_error(vol->sb, \"Failed, returning error code %i.\", err);\n\treturn ERR_PTR(err);\n   }\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed, returning error code %i.\"",
            "err"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dent_inode"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Illegal file name attribute. Run chkdsk.\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nls_name.name"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add_ci",
          "args": [
            "dent",
            "dent_inode",
            "&nls_name"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "d_add_ci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2020-2046",
          "snippet": "struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found;\n\tstruct dentry *new;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (!found) {\n\t\tnew = d_alloc(dentry->d_parent, name);\n\t\tif (!new) {\n\t\t\tfound = ERR_PTR(-ENOMEM);\n\t\t} else {\n\t\t\tfound = d_splice_alias(inode, new);\n\t\t\tif (found) {\n\t\t\t\tdput(new);\n\t\t\t\treturn found;\n\t\t\t}\n\t\t\treturn new;\n\t\t}\n\t}\n\tiput(inode);\n\treturn found;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found;\n\tstruct dentry *new;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (!found) {\n\t\tnew = d_alloc(dentry->d_parent, name);\n\t\tif (!new) {\n\t\t\tfound = ERR_PTR(-ENOMEM);\n\t\t} else {\n\t\t\tfound = d_splice_alias(inode, new);\n\t\t\tif (found) {\n\t\t\t\tdput(new);\n\t\t\t\treturn found;\n\t\t\t}\n\t\t\treturn new;\n\t\t}\n\t}\n\tiput(inode);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "nls_name.name",
            "nls_name.len"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_ucstonls",
          "args": [
            "vol",
            "(ntfschar*)&fn->file_name",
            "fn->file_name_length",
            "(unsigned char**)&nls_name.name",
            "0"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ucstonls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "336-398",
          "snippet": "int ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fn->file_name_length * sizeof(ntfschar) +\n\t\t\t\t\tsizeof(FILE_NAME_ATTR)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_offset"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Inode corrupt: No WIN32 \"\n\t\t\t\t\t\t\"namespace counterpart to DOS \"\n\t\t\t\t\t\t\"file name. Run chkdsk.\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_FILE_NAME",
            "NULL",
            "0",
            "0",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "m"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "dent_inode"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Case 3.\""
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "MREF_ERR(mref)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dent",
            "NULL"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent_inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSEQNO",
          "args": [
            "mref"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "dent_inode",
            "dent"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSEQNO",
          "args": [
            "mref"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "dent_inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(dent_inode)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent_inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "dent_ino"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Found inode 0x%lx. Calling ntfs_iget.\"",
            "dent_ino"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF",
          "args": [
            "mref"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_MREF",
          "args": [
            "mref"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_name_cache",
            "uname"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_lookup_inode_by_name",
          "args": [
            "NTFS_I(dir_ino)",
            "uname",
            "uname_len",
            "&name"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_lookup_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
          "lines": "80-604",
          "snippet": "MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include \"dir.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "uname_len"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to convert name to \"\n\t\t\t\t\t\"Unicode.\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_nlstoucs",
          "args": [
            "vol",
            "dent->d_name.name",
            "dent->d_name.len",
            "&uname"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_nlstoucs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "259-309",
          "snippet": "int ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\n\t\tconst int ins_len, ntfschar **outs)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tntfschar *ucs;\n\twchar_t wc;\n\tint i, o, wc_len;\n\n\t/* We do not trust outside sources. */\n\tif (likely(ins)) {\n\t\tucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\n\t\tif (likely(ucs)) {\n\t\t\tfor (i = o = 0; i < ins_len; i += wc_len) {\n\t\t\t\twc_len = nls->char2uni(ins + i, ins_len - i,\n\t\t\t\t\t\t&wc);\n\t\t\t\tif (likely(wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN)) {\n\t\t\t\t\tif (likely(wc)) {\n\t\t\t\t\t\tucs[o++] = cpu_to_le16(wc);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} /* else if (!wc) */\n\t\t\t\t\tbreak;\n\t\t\t\t} /* else if (wc_len < 0 ||\n\t\t\t\t\t\to >= NTFS_MAX_NAME_LEN) */\n\t\t\t\tgoto name_err;\n\t\t\t}\n\t\t\tucs[o] = 0;\n\t\t\t*outs = ucs;\n\t\t\treturn o;\n\t\t} /* else if (!ucs) */\n\t\tntfs_error(vol->sb, \"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\");\n\t\treturn -ENOMEM;\n\t} /* else if (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nname_err:\n\tkmem_cache_free(ntfs_name_cache, ucs);\n\tif (wc_len < 0) {\n\t\tntfs_error(vol->sb, \"Name using character set %s contains \"\n\t\t\t\t\"characters that cannot be converted to \"\n\t\t\t\t\"Unicode.\", nls->charset);\n\t\ti = -EILSEQ;\n\t} else /* if (o >= NTFS_MAX_NAME_LEN) */ {\n\t\tntfs_error(vol->sb, \"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\",\n\t\t\t\tNTFS_MAX_NAME_LEN);\n\t\ti = -ENAMETOOLONG;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\n\t\tconst int ins_len, ntfschar **outs)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tntfschar *ucs;\n\twchar_t wc;\n\tint i, o, wc_len;\n\n\t/* We do not trust outside sources. */\n\tif (likely(ins)) {\n\t\tucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\n\t\tif (likely(ucs)) {\n\t\t\tfor (i = o = 0; i < ins_len; i += wc_len) {\n\t\t\t\twc_len = nls->char2uni(ins + i, ins_len - i,\n\t\t\t\t\t\t&wc);\n\t\t\t\tif (likely(wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN)) {\n\t\t\t\t\tif (likely(wc)) {\n\t\t\t\t\t\tucs[o++] = cpu_to_le16(wc);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} /* else if (!wc) */\n\t\t\t\t\tbreak;\n\t\t\t\t} /* else if (wc_len < 0 ||\n\t\t\t\t\t\to >= NTFS_MAX_NAME_LEN) */\n\t\t\t\tgoto name_err;\n\t\t\t}\n\t\t\tucs[o] = 0;\n\t\t\t*outs = ucs;\n\t\t\treturn o;\n\t\t} /* else if (!ucs) */\n\t\tntfs_error(vol->sb, \"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\");\n\t\treturn -ENOMEM;\n\t} /* else if (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nname_err:\n\tkmem_cache_free(ntfs_name_cache, ucs);\n\tif (wc_len < 0) {\n\t\tntfs_error(vol->sb, \"Name using character set %s contains \"\n\t\t\t\t\"characters that cannot be converted to \"\n\t\t\t\t\"Unicode.\", nls->charset);\n\t\ti = -EILSEQ;\n\t} else /* if (o >= NTFS_MAX_NAME_LEN) */ {\n\t\tntfs_error(vol->sb, \"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\",\n\t\t\t\tNTFS_MAX_NAME_LEN);\n\t\ti = -ENAMETOOLONG;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Looking up %pd in directory inode 0x%lx.\"",
            "dent",
            "dir_ino->i_ino"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "dir_ino->i_sb"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n\nstatic struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,\n\t\tunsigned int flags)\n{\n\tntfs_volume *vol = NTFS_SB(dir_ino->i_sb);\n\tstruct inode *dent_inode;\n\tntfschar *uname;\n\tntfs_name *name = NULL;\n\tMFT_REF mref;\n\tunsigned long dent_ino;\n\tint uname_len;\n\n\tntfs_debug(\"Looking up %pd in directory inode 0x%lx.\",\n\t\t\tdent, dir_ino->i_ino);\n\t/* Convert the name of the dentry to Unicode. */\n\tuname_len = ntfs_nlstoucs(vol, dent->d_name.name, dent->d_name.len,\n\t\t\t&uname);\n\tif (uname_len < 0) {\n\t\tif (uname_len != -ENAMETOOLONG)\n\t\t\tntfs_error(vol->sb, \"Failed to convert name to \"\n\t\t\t\t\t\"Unicode.\");\n\t\treturn ERR_PTR(uname_len);\n\t}\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(dir_ino), uname, uname_len,\n\t\t\t&name);\n\tkmem_cache_free(ntfs_name_cache, uname);\n\tif (!IS_ERR_MREF(mref)) {\n\t\tdent_ino = MREF(mref);\n\t\tntfs_debug(\"Found inode 0x%lx. Calling ntfs_iget.\", dent_ino);\n\t\tdent_inode = ntfs_iget(vol->sb, dent_ino);\n\t\tif (likely(!IS_ERR(dent_inode))) {\n\t\t\t/* Consistency check. */\n\t\t\tif (is_bad_inode(dent_inode) || MSEQNO(mref) ==\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no ||\n\t\t\t\t\tdent_ino == FILE_MFT) {\n\t\t\t\t/* Perfect WIN32/POSIX match. -- Case 1. */\n\t\t\t\tif (!name) {\n\t\t\t\t\tntfs_debug(\"Done.  (Case 1.)\");\n\t\t\t\t\treturn d_splice_alias(dent_inode, dent);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We are too indented.  Handle imperfect\n\t\t\t\t * matches and short file names further below.\n\t\t\t\t */\n\t\t\t\tgoto handle_name;\n\t\t\t}\n\t\t\tntfs_error(vol->sb, \"Found stale reference to inode \"\n\t\t\t\t\t\"0x%lx (reference sequence number = \"\n\t\t\t\t\t\"0x%x, inode sequence number = 0x%x), \"\n\t\t\t\t\t\"returning -EIO. Run chkdsk.\",\n\t\t\t\t\tdent_ino, MSEQNO(mref),\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no);\n\t\t\tiput(dent_inode);\n\t\t\tdent_inode = ERR_PTR(-EIO);\n\t\t} else\n\t\t\tntfs_error(vol->sb, \"ntfs_iget(0x%lx) failed with \"\n\t\t\t\t\t\"error code %li.\", dent_ino,\n\t\t\t\t\tPTR_ERR(dent_inode));\n\t\tkfree(name);\n\t\t/* Return the error code. */\n\t\treturn (struct dentry *)dent_inode;\n\t}\n\t/* It is guaranteed that @name is no longer allocated at this point. */\n\tif (MREF_ERR(mref) == -ENOENT) {\n\t\tntfs_debug(\"Entry was not found, adding negative dentry.\");\n\t\t/* The dcache will handle negative entries. */\n\t\td_add(dent, NULL);\n\t\tntfs_debug(\"Done.\");\n\t\treturn NULL;\n\t}\n\tntfs_error(vol->sb, \"ntfs_lookup_ino_by_name() failed with error \"\n\t\t\t\"code %i.\", -MREF_ERR(mref));\n\treturn ERR_PTR(MREF_ERR(mref));\n\t// TODO: Consider moving this lot to a separate function! (AIA)\nhandle_name:\n   {\n\tMFT_RECORD *m;\n\tntfs_attr_search_ctx *ctx;\n\tntfs_inode *ni = NTFS_I(dent_inode);\n\tint err;\n\tstruct qstr nls_name;\n\n\tnls_name.name = NULL;\n\tif (name->type != FILE_NAME_DOS) {\t\t\t/* Case 2. */\n\t\tntfs_debug(\"Case 2.\");\n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&name->name, name->len,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\t\tkfree(name);\n\t} else /* if (name->type == FILE_NAME_DOS) */ {\t\t/* Case 3. */\n\t\tFILE_NAME_ATTR *fn;\n\n\t\tntfs_debug(\"Case 3.\");\n\t\tkfree(name);\n\n\t\t/* Find the WIN32 name corresponding to the matched DOS name. */\n\t\tni = NTFS_I(dent_inode);\n\t\tm = map_mft_record(ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tdo {\n\t\t\tATTR_RECORD *a;\n\t\t\tu32 val_len;\n\n\t\t\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0,\n\t\t\t\t\tNULL, 0, ctx);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tntfs_error(vol->sb, \"Inode corrupt: No WIN32 \"\n\t\t\t\t\t\t\"namespace counterpart to DOS \"\n\t\t\t\t\t\t\"file name. Run chkdsk.\");\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Consistency checks. */\n\t\t\ta = ctx->attr;\n\t\t\tif (a->non_resident || a->flags)\n\t\t\t\tgoto eio_err_out;\n\t\t\tval_len = le32_to_cpu(a->data.resident.value_length);\n\t\t\tif (le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\t\tval_len > le32_to_cpu(a->length))\n\t\t\t\tgoto eio_err_out;\n\t\t\tfn = (FILE_NAME_ATTR*)((u8*)ctx->attr + le16_to_cpu(\n\t\t\t\t\tctx->attr->data.resident.value_offset));\n\t\t\tif ((u32)(fn->file_name_length * sizeof(ntfschar) +\n\t\t\t\t\tsizeof(FILE_NAME_ATTR)) > val_len)\n\t\t\t\tgoto eio_err_out;\n\t\t} while (fn->file_name_type != FILE_NAME_WIN32);\n\n\t\t/* Convert the found WIN32 name to current NLS code page. */\n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&fn->file_name, fn->file_name_length,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t}\n\tm = NULL;\n\tctx = NULL;\n\n\t/* Check if a conversion error occurred. */\n\tif ((signed)nls_name.len < 0) {\n\t\terr = (signed)nls_name.len;\n\t\tgoto err_out;\n\t}\n\tnls_name.hash = full_name_hash(nls_name.name, nls_name.len);\n\n\tdent = d_add_ci(dent, dent_inode, &nls_name);\n\tkfree(nls_name.name);\n\treturn dent;\n\neio_err_out:\n\tntfs_error(vol->sb, \"Illegal file name attribute. Run chkdsk.\");\n\terr = -EIO;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\n\tiput(dent_inode);\n\tntfs_error(vol->sb, \"Failed, returning error code %i.\", err);\n\treturn ERR_PTR(err);\n   }\n}"
  }
]