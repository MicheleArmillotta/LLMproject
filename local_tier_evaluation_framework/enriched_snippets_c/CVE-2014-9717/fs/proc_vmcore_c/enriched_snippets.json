[
  {
    "function_name": "vmcore_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "1176-1194",
    "snippet": "void vmcore_cleanup(void)\n{\n\tstruct list_head *pos, *next;\n\n\tif (proc_vmcore) {\n\t\tproc_remove(proc_vmcore);\n\t\tproc_vmcore = NULL;\n\t}\n\n\t/* clear the vmcore list. */\n\tlist_for_each_safe(pos, next, &vmcore_list) {\n\t\tstruct vmcore *m;\n\n\t\tm = list_entry(pos, struct vmcore, list);\n\t\tlist_del(&m->list);\n\t\tkfree(m);\n\t}\n\tfree_elfcorebuf();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static struct proc_dir_entry *proc_vmcore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_elfcorebuf",
          "args": [],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "free_elfcorebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "991-997",
          "snippet": "static void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz_orig;",
            "static char *elfnotes_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\n\nstatic void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&m->list"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structvmcore",
            "list"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&vmcore_list"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_remove",
          "args": [
            "proc_vmcore"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "proc_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "611-615",
          "snippet": "void proc_remove(struct proc_dir_entry *de)\n{\n\tif (de)\n\t\tremove_proc_subtree(de->name, de->parent);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nvoid proc_remove(struct proc_dir_entry *de)\n{\n\tif (de)\n\t\tremove_proc_subtree(de->name, de->parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic struct proc_dir_entry *proc_vmcore;\n\nvoid vmcore_cleanup(void)\n{\n\tstruct list_head *pos, *next;\n\n\tif (proc_vmcore) {\n\t\tproc_remove(proc_vmcore);\n\t\tproc_vmcore = NULL;\n\t}\n\n\t/* clear the vmcore list. */\n\tlist_for_each_safe(pos, next, &vmcore_list) {\n\t\tstruct vmcore *m;\n\n\t\tm = list_entry(pos, struct vmcore, list);\n\t\tlist_del(&m->list);\n\t\tkfree(m);\n\t}\n\tfree_elfcorebuf();\n}"
  },
  {
    "function_name": "vmcore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "1146-1172",
    "snippet": "static int __init vmcore_init(void)\n{\n\tint rc = 0;\n\n\t/* Allow architectures to allocate ELF header in 2nd kernel */\n\trc = elfcorehdr_alloc(&elfcorehdr_addr, &elfcorehdr_size);\n\tif (rc)\n\t\treturn rc;\n\t/*\n\t * If elfcorehdr= has been passed in cmdline or created in 2nd kernel,\n\t * then capture the dump.\n\t */\n\tif (!(is_vmcore_usable()))\n\t\treturn rc;\n\trc = parse_crash_elf_headers();\n\tif (rc) {\n\t\tpr_warn(\"Kdump: vmcore not initialized\\n\");\n\t\treturn rc;\n\t}\n\telfcorehdr_free(elfcorehdr_addr);\n\telfcorehdr_addr = ELFCORE_ADDR_ERR;\n\n\tproc_vmcore = proc_create(\"vmcore\", S_IRUSR, NULL, &proc_vmcore_operations);\n\tif (proc_vmcore)\n\t\tproc_vmcore->size = vmcore_size;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 vmcore_size;",
      "static struct proc_dir_entry *proc_vmcore;",
      "static const struct file_operations proc_vmcore_operations = {\n\t.read\t\t= read_vmcore,\n\t.llseek\t\t= default_llseek,\n\t.mmap\t\t= mmap_vmcore,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"vmcore\"",
            "S_IRUSR",
            "NULL",
            "&proc_vmcore_operations"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elfcorehdr_free",
          "args": [
            "elfcorehdr_addr"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "138-139",
          "snippet": "void __weak elfcorehdr_free(unsigned long long addr)\n{}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nvoid __weak elfcorehdr_free(unsigned long long addr)\n{}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Kdump: vmcore not initialized\\n\""
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_crash_elf_headers",
          "args": [],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crash_elf_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "1110-1143",
          "snippet": "static int __init parse_crash_elf_headers(void)\n{\n\tunsigned char e_ident[EI_NIDENT];\n\tu64 addr;\n\tint rc=0;\n\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(e_ident, EI_NIDENT, &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tpr_warn(\"Warning: Core image elf header not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (e_ident[EI_CLASS] == ELFCLASS64) {\n\t\trc = parse_crash_elf64_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (e_ident[EI_CLASS] == ELFCLASS32) {\n\t\trc = parse_crash_elf32_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Determine vmcore size. */\n\tvmcore_size = get_vmcore_size(elfcorebuf_sz, elfnotes_sz,\n\t\t\t\t      &vmcore_list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(vmcore_list);",
            "static size_t elfcorebuf_sz;",
            "static size_t elfnotes_sz;",
            "static u64 vmcore_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic size_t elfcorebuf_sz;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\n\nstatic int __init parse_crash_elf_headers(void)\n{\n\tunsigned char e_ident[EI_NIDENT];\n\tu64 addr;\n\tint rc=0;\n\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(e_ident, EI_NIDENT, &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tpr_warn(\"Warning: Core image elf header not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (e_ident[EI_CLASS] == ELFCLASS64) {\n\t\trc = parse_crash_elf64_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (e_ident[EI_CLASS] == ELFCLASS32) {\n\t\trc = parse_crash_elf32_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Determine vmcore size. */\n\tvmcore_size = get_vmcore_size(elfcorebuf_sz, elfnotes_sz,\n\t\t\t\t      &vmcore_list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vmcore_usable",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elfcorehdr_alloc",
          "args": [
            "&elfcorehdr_addr",
            "&elfcorehdr_size"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "130-133",
          "snippet": "int __weak elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nint __weak elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic u64 vmcore_size;\nstatic struct proc_dir_entry *proc_vmcore;\nstatic const struct file_operations proc_vmcore_operations = {\n\t.read\t\t= read_vmcore,\n\t.llseek\t\t= default_llseek,\n\t.mmap\t\t= mmap_vmcore,\n};\n\nstatic int __init vmcore_init(void)\n{\n\tint rc = 0;\n\n\t/* Allow architectures to allocate ELF header in 2nd kernel */\n\trc = elfcorehdr_alloc(&elfcorehdr_addr, &elfcorehdr_size);\n\tif (rc)\n\t\treturn rc;\n\t/*\n\t * If elfcorehdr= has been passed in cmdline or created in 2nd kernel,\n\t * then capture the dump.\n\t */\n\tif (!(is_vmcore_usable()))\n\t\treturn rc;\n\trc = parse_crash_elf_headers();\n\tif (rc) {\n\t\tpr_warn(\"Kdump: vmcore not initialized\\n\");\n\t\treturn rc;\n\t}\n\telfcorehdr_free(elfcorehdr_addr);\n\telfcorehdr_addr = ELFCORE_ADDR_ERR;\n\n\tproc_vmcore = proc_create(\"vmcore\", S_IRUSR, NULL, &proc_vmcore_operations);\n\tif (proc_vmcore)\n\t\tproc_vmcore->size = vmcore_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_crash_elf_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "1110-1143",
    "snippet": "static int __init parse_crash_elf_headers(void)\n{\n\tunsigned char e_ident[EI_NIDENT];\n\tu64 addr;\n\tint rc=0;\n\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(e_ident, EI_NIDENT, &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tpr_warn(\"Warning: Core image elf header not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (e_ident[EI_CLASS] == ELFCLASS64) {\n\t\trc = parse_crash_elf64_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (e_ident[EI_CLASS] == ELFCLASS32) {\n\t\trc = parse_crash_elf32_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Determine vmcore size. */\n\tvmcore_size = get_vmcore_size(elfcorebuf_sz, elfnotes_sz,\n\t\t\t\t      &vmcore_list);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static size_t elfcorebuf_sz;",
      "static size_t elfnotes_sz;",
      "static u64 vmcore_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vmcore_size",
          "args": [
            "elfcorebuf_sz",
            "elfnotes_sz",
            "&vmcore_list"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcore_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "502-513",
          "snippet": "static u64 __init get_vmcore_size(size_t elfsz, size_t elfnotesegsz,\n\t\t\t\t  struct list_head *vc_list)\n{\n\tu64 size;\n\tstruct vmcore *m;\n\n\tsize = elfsz + elfnotesegsz;\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tsize += m->size;\n\t}\n\treturn size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic u64 __init get_vmcore_size(size_t elfsz, size_t elfnotesegsz,\n\t\t\t\t  struct list_head *vc_list)\n{\n\tu64 size;\n\tstruct vmcore *m;\n\n\tsize = elfsz + elfnotesegsz;\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tsize += m->size;\n\t}\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Core image elf header is not sane\\n\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_crash_elf32_headers",
          "args": [],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crash_elf32_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "1055-1108",
          "snippet": "static int __init parse_crash_elf32_headers(void)\n{\n\tint rc=0;\n\tElf32_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf32_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!elf_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS32||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf32_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf32_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf32(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf32(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(vmcore_list);",
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz;",
            "static size_t elfcorebuf_sz_orig;",
            "static char *elfnotes_buf;",
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\n\nstatic int __init parse_crash_elf32_headers(void)\n{\n\tint rc=0;\n\tElf32_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf32_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!elf_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS32||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf32_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf32_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf32(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf32(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_crash_elf64_headers",
          "args": [],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crash_elf64_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "999-1053",
          "snippet": "static int __init parse_crash_elf64_headers(void)\n{\n\tint rc=0;\n\tElf64_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf64_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!vmcore_elf64_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS64 ||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf64_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf64_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +\n\t\t\t\tehdr.e_phnum * sizeof(Elf64_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf64(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf64(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(vmcore_list);",
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz;",
            "static size_t elfcorebuf_sz_orig;",
            "static char *elfnotes_buf;",
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\n\nstatic int __init parse_crash_elf64_headers(void)\n{\n\tint rc=0;\n\tElf64_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf64_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!vmcore_elf64_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS64 ||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf64_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf64_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +\n\t\t\t\tehdr.e_phnum * sizeof(Elf64_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf64(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf64(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Core image elf header not found\\n\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elfcorehdr_read",
          "args": [
            "e_ident",
            "EI_NIDENT",
            "&addr"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic size_t elfcorebuf_sz;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\n\nstatic int __init parse_crash_elf_headers(void)\n{\n\tunsigned char e_ident[EI_NIDENT];\n\tu64 addr;\n\tint rc=0;\n\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(e_ident, EI_NIDENT, &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tpr_warn(\"Warning: Core image elf header not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (e_ident[EI_CLASS] == ELFCLASS64) {\n\t\trc = parse_crash_elf64_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (e_ident[EI_CLASS] == ELFCLASS32) {\n\t\trc = parse_crash_elf32_headers();\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Determine vmcore size. */\n\tvmcore_size = get_vmcore_size(elfcorebuf_sz, elfnotes_sz,\n\t\t\t\t      &vmcore_list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_crash_elf32_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "1055-1108",
    "snippet": "static int __init parse_crash_elf32_headers(void)\n{\n\tint rc=0;\n\tElf32_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf32_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!elf_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS32||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf32_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf32_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf32(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf32(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static char *elfcorebuf;",
      "static size_t elfcorebuf_sz;",
      "static size_t elfcorebuf_sz_orig;",
      "static char *elfnotes_buf;",
      "static size_t elfnotes_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_elfcorebuf",
          "args": [],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "free_elfcorebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "991-997",
          "snippet": "static void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz_orig;",
            "static char *elfnotes_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\n\nstatic void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_vmcore_list_offsets",
          "args": [
            "elfcorebuf_sz",
            "elfnotes_sz",
            "&vmcore_list"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "set_vmcore_list_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "976-989",
          "snippet": "static void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_ptload_program_headers_elf32",
          "args": [
            "elfcorebuf",
            "elfcorebuf_sz",
            "elfnotes_sz",
            "&vmcore_list"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "process_ptload_program_headers_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "932-973",
          "snippet": "static int __init process_ptload_program_headers_elf32(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\tphdr_ptr = (Elf32_Phdr*)(elfptr + sizeof(Elf32_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic int __init process_ptload_program_headers_elf32(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\tphdr_ptr = (Elf32_Phdr*)(elfptr + sizeof(Elf32_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_note_headers_elf32",
          "args": [
            "elfcorebuf",
            "&elfcorebuf_sz",
            "&elfnotes_buf",
            "&elfnotes_sz"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "merge_note_headers_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "831-885",
          "snippet": "static int __init merge_note_headers_elf32(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf32(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf32(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf32(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf32_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf32_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf32_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf32_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init merge_note_headers_elf32(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf32(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf32(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf32(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf32_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf32_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf32_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf32_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elfcorehdr_read",
          "args": [
            "elfcorebuf",
            "elfcorebuf_sz_orig",
            "&addr"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL | __GFP_ZERO",
            "get_order(elfcorebuf_sz_orig)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "elfcorebuf_sz_orig"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Core image elf header is not sane\\n\""
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&ehdr"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ehdr.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\n\nstatic int __init parse_crash_elf32_headers(void)\n{\n\tint rc=0;\n\tElf32_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf32_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!elf_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS32||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf32_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf32_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf32(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf32(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_crash_elf64_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "999-1053",
    "snippet": "static int __init parse_crash_elf64_headers(void)\n{\n\tint rc=0;\n\tElf64_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf64_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!vmcore_elf64_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS64 ||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf64_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf64_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +\n\t\t\t\tehdr.e_phnum * sizeof(Elf64_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf64(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf64(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static char *elfcorebuf;",
      "static size_t elfcorebuf_sz;",
      "static size_t elfcorebuf_sz_orig;",
      "static char *elfnotes_buf;",
      "static size_t elfnotes_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_elfcorebuf",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "free_elfcorebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "991-997",
          "snippet": "static void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz_orig;",
            "static char *elfnotes_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\n\nstatic void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_vmcore_list_offsets",
          "args": [
            "elfcorebuf_sz",
            "elfnotes_sz",
            "&vmcore_list"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "set_vmcore_list_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "976-989",
          "snippet": "static void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_ptload_program_headers_elf64",
          "args": [
            "elfcorebuf",
            "elfcorebuf_sz",
            "elfnotes_sz",
            "&vmcore_list"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "process_ptload_program_headers_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "889-930",
          "snippet": "static int __init process_ptload_program_headers_elf64(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\tphdr_ptr = (Elf64_Phdr*)(elfptr + sizeof(Elf64_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset. */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t elfnotes_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic int __init process_ptload_program_headers_elf64(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\tphdr_ptr = (Elf64_Phdr*)(elfptr + sizeof(Elf64_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset. */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_note_headers_elf64",
          "args": [
            "elfcorebuf",
            "&elfcorebuf_sz",
            "&elfnotes_buf",
            "&elfnotes_sz"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "merge_note_headers_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "645-699",
          "snippet": "static int __init merge_note_headers_elf64(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf64(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf64(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf64(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf64_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf64_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf64_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf64_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init merge_note_headers_elf64(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf64(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf64(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf64(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf64_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf64_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf64_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf64_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elfcorehdr_read",
          "args": [
            "elfcorebuf",
            "elfcorebuf_sz_orig",
            "&addr"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL | __GFP_ZERO",
            "get_order(elfcorebuf_sz_orig)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "elfcorebuf_sz_orig"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Core image elf header is not sane\\n\""
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcore_elf64_check_arch",
          "args": [
            "&ehdr"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ehdr.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\n\nstatic int __init parse_crash_elf64_headers(void)\n{\n\tint rc=0;\n\tElf64_Ehdr ehdr;\n\tu64 addr;\n\n\taddr = elfcorehdr_addr;\n\n\t/* Read Elf header */\n\trc = elfcorehdr_read((char *)&ehdr, sizeof(Elf64_Ehdr), &addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Do some basic Verification. */\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\n\t\t(ehdr.e_type != ET_CORE) ||\n\t\t!vmcore_elf64_check_arch(&ehdr) ||\n\t\tehdr.e_ident[EI_CLASS] != ELFCLASS64 ||\n\t\tehdr.e_ident[EI_VERSION] != EV_CURRENT ||\n\t\tehdr.e_version != EV_CURRENT ||\n\t\tehdr.e_ehsize != sizeof(Elf64_Ehdr) ||\n\t\tehdr.e_phentsize != sizeof(Elf64_Phdr) ||\n\t\tehdr.e_phnum == 0) {\n\t\tpr_warn(\"Warning: Core image elf header is not sane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read in all elf headers. */\n\telfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +\n\t\t\t\tehdr.e_phnum * sizeof(Elf64_Phdr);\n\telfcorebuf_sz = elfcorebuf_sz_orig;\n\telfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t      get_order(elfcorebuf_sz_orig));\n\tif (!elfcorebuf)\n\t\treturn -ENOMEM;\n\taddr = elfcorehdr_addr;\n\trc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* Merge all PT_NOTE headers into one. */\n\trc = merge_note_headers_elf64(elfcorebuf, &elfcorebuf_sz,\n\t\t\t\t      &elfnotes_buf, &elfnotes_sz);\n\tif (rc)\n\t\tgoto fail;\n\trc = process_ptload_program_headers_elf64(elfcorebuf, elfcorebuf_sz,\n\t\t\t\t\t\t  elfnotes_sz, &vmcore_list);\n\tif (rc)\n\t\tgoto fail;\n\tset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\n\treturn 0;\nfail:\n\tfree_elfcorebuf();\n\treturn rc;\n}"
  },
  {
    "function_name": "free_elfcorebuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "991-997",
    "snippet": "static void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *elfcorebuf;",
      "static size_t elfcorebuf_sz_orig;",
      "static char *elfnotes_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "elfnotes_buf"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)elfcorebuf",
            "get_order(elfcorebuf_sz_orig)"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "elfcorebuf_sz_orig"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz_orig;\nstatic char *elfnotes_buf;\n\nstatic void free_elfcorebuf(void)\n{\n\tfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\n\telfcorebuf = NULL;\n\tvfree(elfnotes_buf);\n\telfnotes_buf = NULL;\n}"
  },
  {
    "function_name": "set_vmcore_list_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "976-989",
    "snippet": "static void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t elfnotes_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "vc_list",
            "list"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\n\t\t\t\t\t   struct list_head *vc_list)\n{\n\tloff_t vmcore_off;\n\tstruct vmcore *m;\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tm->offset = vmcore_off;\n\t\tvmcore_off += m->size;\n\t}\n}"
  },
  {
    "function_name": "process_ptload_program_headers_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "932-973",
    "snippet": "static int __init process_ptload_program_headers_elf32(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\tphdr_ptr = (Elf32_Phdr*)(elfptr + sizeof(Elf32_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t elfnotes_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "vc_list"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_element",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "497-500",
          "snippet": "static struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "paddr + phdr_ptr->p_memsz",
            "PAGE_SIZE"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "paddr",
            "PAGE_SIZE"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic int __init process_ptload_program_headers_elf32(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\tphdr_ptr = (Elf32_Phdr*)(elfptr + sizeof(Elf32_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "process_ptload_program_headers_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "889-930",
    "snippet": "static int __init process_ptload_program_headers_elf64(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\tphdr_ptr = (Elf64_Phdr*)(elfptr + sizeof(Elf64_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset. */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t elfnotes_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "vc_list"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_element",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "497-500",
          "snippet": "static struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "paddr + phdr_ptr->p_memsz",
            "PAGE_SIZE"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "paddr",
            "PAGE_SIZE"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic size_t elfnotes_sz;\n\nstatic int __init process_ptload_program_headers_elf64(char *elfptr,\n\t\t\t\t\t\tsize_t elfsz,\n\t\t\t\t\t\tsize_t elfnotes_sz,\n\t\t\t\t\t\tstruct list_head *vc_list)\n{\n\tint i;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr *phdr_ptr;\n\tloff_t vmcore_off;\n\tstruct vmcore *new;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\tphdr_ptr = (Elf64_Phdr*)(elfptr + sizeof(Elf64_Ehdr)); /* PT_NOTE hdr */\n\n\t/* Skip Elf header, program headers and Elf note segment. */\n\tvmcore_off = elfsz + elfnotes_sz;\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 paddr, start, end, size;\n\n\t\tif (phdr_ptr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tpaddr = phdr_ptr->p_offset;\n\t\tstart = rounddown(paddr, PAGE_SIZE);\n\t\tend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\n\t\tsize = end - start;\n\n\t\t/* Add this contiguous chunk of memory to vmcore list.*/\n\t\tnew = get_new_element();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->paddr = start;\n\t\tnew->size = size;\n\t\tlist_add_tail(&new->list, vc_list);\n\n\t\t/* Update the program header offset. */\n\t\tphdr_ptr->p_offset = vmcore_off + (paddr - start);\n\t\tvmcore_off = vmcore_off + size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_note_headers_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "831-885",
    "snippet": "static int __init merge_note_headers_elf32(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf32(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf32(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf32(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf32_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf32_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf32_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf32_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "*elfsz",
            "PAGE_SIZE"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elfptr + *elfsz",
            "0",
            "i"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp+i",
            "((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr))"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "&phdr",
            "sizeof(phdr)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_notes_elf32",
          "args": [
            "ehdr_ptr",
            "*notes_buf"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "copy_notes_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "808-828",
          "snippet": "static int __init copy_notes_elf32(const Elf32_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init copy_notes_elf32(const Elf32_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_elfnotes_buf",
          "args": [
            "*notes_sz"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_elfnotes_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "314-321",
          "snippet": "static inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_note_number_and_size_elf32",
          "args": [
            "ehdr_ptr",
            "&nr_ptnote",
            "&phdr_sz"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "get_note_number_and_size_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "773-790",
          "snippet": "static int __init get_note_number_and_size_elf32(const Elf32_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf32_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init get_note_number_and_size_elf32(const Elf32_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf32_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_note_header_size_elf32",
          "args": [
            "ehdr_ptr"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "update_note_header_size_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "710-753",
          "snippet": "static int __init update_note_header_size_elf32(const Elf32_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\tElf32_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf32_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf32_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init update_note_header_size_elf32(const Elf32_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\tElf32_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf32_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf32_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init merge_note_headers_elf32(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf32_Ehdr *ehdr_ptr;\n\tElf32_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf32_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf32(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf32(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf32(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf32_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf32_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf32_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf32_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_notes_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "808-828",
    "snippet": "static int __init copy_notes_elf32(const Elf32_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elfcorehdr_read_notes",
          "args": [
            "notes_buf",
            "phdr_ptr->p_memsz",
            "&offset"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init copy_notes_elf32(const Elf32_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_note_number_and_size_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "773-790",
    "snippet": "static int __init get_note_number_and_size_elf32(const Elf32_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf32_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init get_note_number_and_size_elf32(const Elf32_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf32_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_note_header_size_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "710-753",
    "snippet": "static int __init update_note_header_size_elf32(const Elf32_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\tElf32_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf32_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf32_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Zero PT_NOTE entries found\\n\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "notes_section"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\"",
            "nhdr_ptr->n_namesz",
            "nhdr_ptr->n_descsz"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "notes_section"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elfcorehdr_read_notes",
          "args": [
            "notes_section",
            "max_sz",
            "&offset"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "max_sz",
            "GFP_KERNEL"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init update_note_header_size_elf32(const Elf32_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf32_Phdr *phdr_ptr;\n\tElf32_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf32_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf32_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "merge_note_headers_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "645-699",
    "snippet": "static int __init merge_note_headers_elf64(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf64(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf64(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf64(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf64_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf64_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf64_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf64_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "*elfsz",
            "PAGE_SIZE"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elfptr + *elfsz",
            "0",
            "i"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp+i",
            "((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr))"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "&phdr",
            "sizeof(phdr)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_notes_elf64",
          "args": [
            "ehdr_ptr",
            "*notes_buf"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "copy_notes_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "622-642",
          "snippet": "static int __init copy_notes_elf64(const Elf64_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init copy_notes_elf64(const Elf64_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_elfnotes_buf",
          "args": [
            "*notes_sz"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_elfnotes_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "314-321",
          "snippet": "static inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_note_number_and_size_elf64",
          "args": [
            "ehdr_ptr",
            "&nr_ptnote",
            "&phdr_sz"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "get_note_number_and_size_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "587-604",
          "snippet": "static int __init get_note_number_and_size_elf64(const Elf64_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf64_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init get_note_number_and_size_elf64(const Elf64_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf64_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_note_header_size_elf64",
          "args": [
            "ehdr_ptr"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "update_note_header_size_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "524-567",
          "snippet": "static int __init update_note_header_size_elf64(const Elf64_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\tElf64_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf64_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf64_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init update_note_header_size_elf64(const Elf64_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\tElf64_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf64_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf64_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init merge_note_headers_elf64(char *elfptr, size_t *elfsz,\n\t\t\t\t\t   char **notes_buf, size_t *notes_sz)\n{\n\tint i, nr_ptnote=0, rc=0;\n\tchar *tmp;\n\tElf64_Ehdr *ehdr_ptr;\n\tElf64_Phdr phdr;\n\tu64 phdr_sz = 0, note_off;\n\n\tehdr_ptr = (Elf64_Ehdr *)elfptr;\n\n\trc = update_note_header_size_elf64(ehdr_ptr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = get_note_number_and_size_elf64(ehdr_ptr, &nr_ptnote, &phdr_sz);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*notes_sz = roundup(phdr_sz, PAGE_SIZE);\n\t*notes_buf = alloc_elfnotes_buf(*notes_sz);\n\tif (!*notes_buf)\n\t\treturn -ENOMEM;\n\n\trc = copy_notes_elf64(ehdr_ptr, *notes_buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Prepare merged PT_NOTE program header. */\n\tphdr.p_type    = PT_NOTE;\n\tphdr.p_flags   = 0;\n\tnote_off = sizeof(Elf64_Ehdr) +\n\t\t\t(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf64_Phdr);\n\tphdr.p_offset  = roundup(note_off, PAGE_SIZE);\n\tphdr.p_vaddr   = phdr.p_paddr = 0;\n\tphdr.p_filesz  = phdr.p_memsz = phdr_sz;\n\tphdr.p_align   = 0;\n\n\t/* Add merged PT_NOTE program header*/\n\ttmp = elfptr + sizeof(Elf64_Ehdr);\n\tmemcpy(tmp, &phdr, sizeof(phdr));\n\ttmp += sizeof(phdr);\n\n\t/* Remove unwanted PT_NOTE program headers. */\n\ti = (nr_ptnote - 1) * sizeof(Elf64_Phdr);\n\t*elfsz = *elfsz - i;\n\tmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr)));\n\tmemset(elfptr + *elfsz, 0, i);\n\t*elfsz = roundup(*elfsz, PAGE_SIZE);\n\n\t/* Modify e_phnum to reflect merged headers. */\n\tehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_notes_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "622-642",
    "snippet": "static int __init copy_notes_elf64(const Elf64_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elfcorehdr_read_notes",
          "args": [
            "notes_buf",
            "phdr_ptr->p_memsz",
            "&offset"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init copy_notes_elf64(const Elf64_Ehdr *ehdr_ptr, char *notes_buf)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr*)(ehdr_ptr + 1);\n\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tu64 offset;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\toffset = phdr_ptr->p_offset;\n\t\trc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\n\t\t\t\t\t   &offset);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotes_buf += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_note_number_and_size_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "587-604",
    "snippet": "static int __init get_note_number_and_size_elf64(const Elf64_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf64_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init get_note_number_and_size_elf64(const Elf64_Ehdr *ehdr_ptr,\n\t\t\t\t\t\t int *nr_ptnote, u64 *sz_ptnote)\n{\n\tint i;\n\tElf64_Phdr *phdr_ptr;\n\n\t*nr_ptnote = *sz_ptnote = 0;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\t*nr_ptnote += 1;\n\t\t*sz_ptnote += phdr_ptr->p_memsz;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_note_header_size_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "524-567",
    "snippet": "static int __init update_note_header_size_elf64(const Elf64_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\tElf64_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf64_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf64_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Zero PT_NOTE entries found\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "notes_section"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\"",
            "nhdr_ptr->n_namesz",
            "nhdr_ptr->n_descsz"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "notes_section"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elfcorehdr_read_notes",
          "args": [
            "notes_section",
            "max_sz",
            "&offset"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "elfcorehdr_read_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "152-155",
          "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "max_sz",
            "GFP_KERNEL"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int __init update_note_header_size_elf64(const Elf64_Ehdr *ehdr_ptr)\n{\n\tint i, rc=0;\n\tElf64_Phdr *phdr_ptr;\n\tElf64_Nhdr *nhdr_ptr;\n\n\tphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\n\tfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\n\t\tvoid *notes_section;\n\t\tu64 offset, max_sz, sz, real_sz = 0;\n\t\tif (phdr_ptr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tmax_sz = phdr_ptr->p_memsz;\n\t\toffset = phdr_ptr->p_offset;\n\t\tnotes_section = kmalloc(max_sz, GFP_KERNEL);\n\t\tif (!notes_section)\n\t\t\treturn -ENOMEM;\n\t\trc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\n\t\tif (rc < 0) {\n\t\t\tkfree(notes_section);\n\t\t\treturn rc;\n\t\t}\n\t\tnhdr_ptr = notes_section;\n\t\twhile (nhdr_ptr->n_namesz != 0) {\n\t\t\tsz = sizeof(Elf64_Nhdr) +\n\t\t\t\t(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\n\t\t\t\t(((u64)nhdr_ptr->n_descsz + 3) & ~3);\n\t\t\tif ((real_sz + sz) > max_sz) {\n\t\t\t\tpr_warn(\"Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\\n\",\n\t\t\t\t\tnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treal_sz += sz;\n\t\t\tnhdr_ptr = (Elf64_Nhdr*)((char*)nhdr_ptr + sz);\n\t\t}\n\t\tkfree(notes_section);\n\t\tphdr_ptr->p_memsz = real_sz;\n\t\tif (real_sz == 0) {\n\t\t\tpr_warn(\"Warning: Zero PT_NOTE entries found\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_vmcore_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "502-513",
    "snippet": "static u64 __init get_vmcore_size(size_t elfsz, size_t elfnotesegsz,\n\t\t\t\t  struct list_head *vc_list)\n{\n\tu64 size;\n\tstruct vmcore *m;\n\n\tsize = elfsz + elfnotesegsz;\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tsize += m->size;\n\t}\n\treturn size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "vc_list",
            "list"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic u64 __init get_vmcore_size(size_t elfsz, size_t elfnotesegsz,\n\t\t\t\t  struct list_head *vc_list)\n{\n\tu64 size;\n\tstruct vmcore *m;\n\n\tsize = elfsz + elfnotesegsz;\n\tlist_for_each_entry(m, vc_list, list) {\n\t\tsize += m->size;\n\t}\n\treturn size;\n}"
  },
  {
    "function_name": "get_new_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "497-500",
    "snippet": "static struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct vmcore)",
            "GFP_KERNEL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic struct vmcore* __init get_new_element(void)\n{\n\treturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\n}"
  },
  {
    "function_name": "mmap_vmcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "485-488",
    "snippet": "static int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "mmap_vmcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "407-483",
    "snippet": "static int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t size = vma->vm_end - vma->vm_start;\n\tu64 start, end, len, tsz;\n\tstruct vmcore *m;\n\n\tstart = (u64)vma->vm_pgoff << PAGE_SHIFT;\n\tend = start + size;\n\n\tif (size > vmcore_size || end > vmcore_size)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_flags & (VM_WRITE | VM_EXEC))\n\t\treturn -EPERM;\n\n\tvma->vm_flags &= ~(VM_MAYWRITE | VM_MAYEXEC);\n\tvma->vm_flags |= VM_MIXEDMAP;\n\tvma->vm_ops = &vmcore_mmap_ops;\n\n\tlen = 0;\n\n\tif (start < elfcorebuf_sz) {\n\t\tu64 pfn;\n\n\t\ttsz = min(elfcorebuf_sz - (size_t)start, size);\n\t\tpfn = __pa(elfcorebuf + start) >> PAGE_SHIFT;\n\t\tif (remap_pfn_range(vma, vma->vm_start, pfn, tsz,\n\t\t\t\t    vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t\tsize -= tsz;\n\t\tstart += tsz;\n\t\tlen += tsz;\n\n\t\tif (size == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (start < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)start, size);\n\t\tkaddr = elfnotes_buf + start - elfcorebuf_sz;\n\t\tif (remap_vmalloc_range_partial(vma, vma->vm_start + len,\n\t\t\t\t\t\tkaddr, tsz))\n\t\t\tgoto fail;\n\t\tsize -= tsz;\n\t\tstart += tsz;\n\t\tlen += tsz;\n\n\t\tif (size == 0)\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (start < m->offset + m->size) {\n\t\t\tu64 paddr = 0;\n\n\t\t\ttsz = min_t(size_t, m->offset + m->size - start, size);\n\t\t\tpaddr = m->paddr + start - m->offset;\n\t\t\tif (vmcore_remap_oldmem_pfn(vma, vma->vm_start + len,\n\t\t\t\t\t\t    paddr >> PAGE_SHIFT, tsz,\n\t\t\t\t\t\t    vma->vm_page_prot))\n\t\t\t\tgoto fail;\n\t\t\tsize -= tsz;\n\t\t\tstart += tsz;\n\t\t\tlen += tsz;\n\n\t\t\tif (size == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, vma->vm_start, len);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static char *elfcorebuf;",
      "static size_t elfcorebuf_sz;",
      "static char *elfnotes_buf;",
      "static size_t elfnotes_sz;",
      "static u64 vmcore_size;",
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);",
      "static const struct vm_operations_struct vmcore_mmap_ops = {\n\t.fault = mmap_vmcore_fault,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "vma->vm_mm",
            "vma->vm_start",
            "len"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcore_remap_oldmem_pfn",
          "args": [
            "vma",
            "vma->vm_start + len",
            "paddr >> PAGE_SHIFT",
            "tsz",
            "vma->vm_page_prot"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "vmcore_remap_oldmem_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "393-405",
          "snippet": "static int vmcore_remap_oldmem_pfn(struct vm_area_struct *vma,\n\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t    unsigned long size, pgprot_t prot)\n{\n\t/*\n\t * Check if oldmem_pfn_is_ram was registered to avoid\n\t * looping over all pages without a reason.\n\t */\n\tif (oldmem_pfn_is_ram)\n\t\treturn remap_oldmem_pfn_checked(vma, from, pfn, size, prot);\n\telse\n\t\treturn remap_oldmem_pfn_range(vma, from, pfn, size, prot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int vmcore_remap_oldmem_pfn(struct vm_area_struct *vma,\n\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t    unsigned long size, pgprot_t prot)\n{\n\t/*\n\t * Check if oldmem_pfn_is_ram was registered to avoid\n\t * looping over all pages without a reason.\n\t */\n\tif (oldmem_pfn_is_ram)\n\t\treturn remap_oldmem_pfn_checked(vma, from, pfn, size, prot);\n\telse\n\t\treturn remap_oldmem_pfn_range(vma, from, pfn, size, prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "m->offset + m->size - start",
            "size"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "&vmcore_list",
            "list"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_vmalloc_range_partial",
          "args": [
            "vma",
            "vma->vm_start + len",
            "kaddr",
            "tsz"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "elfcorebuf_sz + elfnotes_sz - (size_t)start",
            "size"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "pfn",
            "tsz",
            "vma->vm_page_prot"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "elfcorebuf + start"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\nstatic const struct vm_operations_struct vmcore_mmap_ops = {\n\t.fault = mmap_vmcore_fault,\n};\n\nstatic int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t size = vma->vm_end - vma->vm_start;\n\tu64 start, end, len, tsz;\n\tstruct vmcore *m;\n\n\tstart = (u64)vma->vm_pgoff << PAGE_SHIFT;\n\tend = start + size;\n\n\tif (size > vmcore_size || end > vmcore_size)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_flags & (VM_WRITE | VM_EXEC))\n\t\treturn -EPERM;\n\n\tvma->vm_flags &= ~(VM_MAYWRITE | VM_MAYEXEC);\n\tvma->vm_flags |= VM_MIXEDMAP;\n\tvma->vm_ops = &vmcore_mmap_ops;\n\n\tlen = 0;\n\n\tif (start < elfcorebuf_sz) {\n\t\tu64 pfn;\n\n\t\ttsz = min(elfcorebuf_sz - (size_t)start, size);\n\t\tpfn = __pa(elfcorebuf + start) >> PAGE_SHIFT;\n\t\tif (remap_pfn_range(vma, vma->vm_start, pfn, tsz,\n\t\t\t\t    vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t\tsize -= tsz;\n\t\tstart += tsz;\n\t\tlen += tsz;\n\n\t\tif (size == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (start < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)start, size);\n\t\tkaddr = elfnotes_buf + start - elfcorebuf_sz;\n\t\tif (remap_vmalloc_range_partial(vma, vma->vm_start + len,\n\t\t\t\t\t\tkaddr, tsz))\n\t\t\tgoto fail;\n\t\tsize -= tsz;\n\t\tstart += tsz;\n\t\tlen += tsz;\n\n\t\tif (size == 0)\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (start < m->offset + m->size) {\n\t\t\tu64 paddr = 0;\n\n\t\t\ttsz = min_t(size_t, m->offset + m->size - start, size);\n\t\t\tpaddr = m->paddr + start - m->offset;\n\t\t\tif (vmcore_remap_oldmem_pfn(vma, vma->vm_start + len,\n\t\t\t\t\t\t    paddr >> PAGE_SHIFT, tsz,\n\t\t\t\t\t\t    vma->vm_page_prot))\n\t\t\t\tgoto fail;\n\t\t\tsize -= tsz;\n\t\t\tstart += tsz;\n\t\t\tlen += tsz;\n\n\t\t\tif (size == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, vma->vm_start, len);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "vmcore_remap_oldmem_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "393-405",
    "snippet": "static int vmcore_remap_oldmem_pfn(struct vm_area_struct *vma,\n\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t    unsigned long size, pgprot_t prot)\n{\n\t/*\n\t * Check if oldmem_pfn_is_ram was registered to avoid\n\t * looping over all pages without a reason.\n\t */\n\tif (oldmem_pfn_is_ram)\n\t\treturn remap_oldmem_pfn_checked(vma, from, pfn, size, prot);\n\telse\n\t\treturn remap_oldmem_pfn_range(vma, from, pfn, size, prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_oldmem_pfn_range",
          "args": [
            "vma",
            "from",
            "pfn",
            "size",
            "prot"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "remap_oldmem_pfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "160-165",
          "snippet": "int __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nint __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remap_oldmem_pfn_checked",
          "args": [
            "vma",
            "from",
            "pfn",
            "size",
            "prot"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "remap_oldmem_pfn_checked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "343-391",
          "snippet": "static int remap_oldmem_pfn_checked(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t\t    unsigned long size, pgprot_t prot)\n{\n\tunsigned long map_size;\n\tunsigned long pos_start, pos_end, pos;\n\tunsigned long zeropage_pfn = my_zero_pfn(0);\n\tsize_t len = 0;\n\n\tpos_start = pfn;\n\tpos_end = pfn + (size >> PAGE_SHIFT);\n\n\tfor (pos = pos_start; pos < pos_end; ++pos) {\n\t\tif (!pfn_is_ram(pos)) {\n\t\t\t/*\n\t\t\t * We hit a page which is not ram. Remap the continuous\n\t\t\t * region between pos_start and pos-1 and replace\n\t\t\t * the non-ram page at pos with the zero page.\n\t\t\t */\n\t\t\tif (pos > pos_start) {\n\t\t\t\t/* Remap continuous region */\n\t\t\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t\t   pos_start, map_size,\n\t\t\t\t\t\t\t   prot))\n\t\t\t\t\tgoto fail;\n\t\t\t\tlen += map_size;\n\t\t\t}\n\t\t\t/* Remap the zero page */\n\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t   zeropage_pfn,\n\t\t\t\t\t\t   PAGE_SIZE, prot))\n\t\t\t\tgoto fail;\n\t\t\tlen += PAGE_SIZE;\n\t\t\tpos_start = pos + 1;\n\t\t}\n\t}\n\tif (pos > pos_start) {\n\t\t/* Remap the rest */\n\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\tif (remap_oldmem_pfn_range(vma, from + len, pos_start,\n\t\t\t\t\t   map_size, prot))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, from, len);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int remap_oldmem_pfn_checked(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t\t    unsigned long size, pgprot_t prot)\n{\n\tunsigned long map_size;\n\tunsigned long pos_start, pos_end, pos;\n\tunsigned long zeropage_pfn = my_zero_pfn(0);\n\tsize_t len = 0;\n\n\tpos_start = pfn;\n\tpos_end = pfn + (size >> PAGE_SHIFT);\n\n\tfor (pos = pos_start; pos < pos_end; ++pos) {\n\t\tif (!pfn_is_ram(pos)) {\n\t\t\t/*\n\t\t\t * We hit a page which is not ram. Remap the continuous\n\t\t\t * region between pos_start and pos-1 and replace\n\t\t\t * the non-ram page at pos with the zero page.\n\t\t\t */\n\t\t\tif (pos > pos_start) {\n\t\t\t\t/* Remap continuous region */\n\t\t\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t\t   pos_start, map_size,\n\t\t\t\t\t\t\t   prot))\n\t\t\t\t\tgoto fail;\n\t\t\t\tlen += map_size;\n\t\t\t}\n\t\t\t/* Remap the zero page */\n\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t   zeropage_pfn,\n\t\t\t\t\t\t   PAGE_SIZE, prot))\n\t\t\t\tgoto fail;\n\t\t\tlen += PAGE_SIZE;\n\t\t\tpos_start = pos + 1;\n\t\t}\n\t}\n\tif (pos > pos_start) {\n\t\t/* Remap the rest */\n\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\tif (remap_oldmem_pfn_range(vma, from + len, pos_start,\n\t\t\t\t\t   map_size, prot))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, from, len);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int vmcore_remap_oldmem_pfn(struct vm_area_struct *vma,\n\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t    unsigned long size, pgprot_t prot)\n{\n\t/*\n\t * Check if oldmem_pfn_is_ram was registered to avoid\n\t * looping over all pages without a reason.\n\t */\n\tif (oldmem_pfn_is_ram)\n\t\treturn remap_oldmem_pfn_checked(vma, from, pfn, size, prot);\n\telse\n\t\treturn remap_oldmem_pfn_range(vma, from, pfn, size, prot);\n}"
  },
  {
    "function_name": "remap_oldmem_pfn_checked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "343-391",
    "snippet": "static int remap_oldmem_pfn_checked(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t\t    unsigned long size, pgprot_t prot)\n{\n\tunsigned long map_size;\n\tunsigned long pos_start, pos_end, pos;\n\tunsigned long zeropage_pfn = my_zero_pfn(0);\n\tsize_t len = 0;\n\n\tpos_start = pfn;\n\tpos_end = pfn + (size >> PAGE_SHIFT);\n\n\tfor (pos = pos_start; pos < pos_end; ++pos) {\n\t\tif (!pfn_is_ram(pos)) {\n\t\t\t/*\n\t\t\t * We hit a page which is not ram. Remap the continuous\n\t\t\t * region between pos_start and pos-1 and replace\n\t\t\t * the non-ram page at pos with the zero page.\n\t\t\t */\n\t\t\tif (pos > pos_start) {\n\t\t\t\t/* Remap continuous region */\n\t\t\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t\t   pos_start, map_size,\n\t\t\t\t\t\t\t   prot))\n\t\t\t\t\tgoto fail;\n\t\t\t\tlen += map_size;\n\t\t\t}\n\t\t\t/* Remap the zero page */\n\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t   zeropage_pfn,\n\t\t\t\t\t\t   PAGE_SIZE, prot))\n\t\t\t\tgoto fail;\n\t\t\tlen += PAGE_SIZE;\n\t\t\tpos_start = pos + 1;\n\t\t}\n\t}\n\tif (pos > pos_start) {\n\t\t/* Remap the rest */\n\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\tif (remap_oldmem_pfn_range(vma, from + len, pos_start,\n\t\t\t\t\t   map_size, prot))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, from, len);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "vma->vm_mm",
            "from",
            "len"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_oldmem_pfn_range",
          "args": [
            "vma",
            "from + len",
            "pos_start",
            "map_size",
            "prot"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "remap_oldmem_pfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "160-165",
          "snippet": "int __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nint __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_is_ram",
          "args": [
            "pos"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_is_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "69-85",
          "snippet": "static int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_zero_pfn",
          "args": [
            "0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int remap_oldmem_pfn_checked(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long from, unsigned long pfn,\n\t\t\t\t    unsigned long size, pgprot_t prot)\n{\n\tunsigned long map_size;\n\tunsigned long pos_start, pos_end, pos;\n\tunsigned long zeropage_pfn = my_zero_pfn(0);\n\tsize_t len = 0;\n\n\tpos_start = pfn;\n\tpos_end = pfn + (size >> PAGE_SHIFT);\n\n\tfor (pos = pos_start; pos < pos_end; ++pos) {\n\t\tif (!pfn_is_ram(pos)) {\n\t\t\t/*\n\t\t\t * We hit a page which is not ram. Remap the continuous\n\t\t\t * region between pos_start and pos-1 and replace\n\t\t\t * the non-ram page at pos with the zero page.\n\t\t\t */\n\t\t\tif (pos > pos_start) {\n\t\t\t\t/* Remap continuous region */\n\t\t\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t\t   pos_start, map_size,\n\t\t\t\t\t\t\t   prot))\n\t\t\t\t\tgoto fail;\n\t\t\t\tlen += map_size;\n\t\t\t}\n\t\t\t/* Remap the zero page */\n\t\t\tif (remap_oldmem_pfn_range(vma, from + len,\n\t\t\t\t\t\t   zeropage_pfn,\n\t\t\t\t\t\t   PAGE_SIZE, prot))\n\t\t\t\tgoto fail;\n\t\t\tlen += PAGE_SIZE;\n\t\t\tpos_start = pos + 1;\n\t\t}\n\t}\n\tif (pos > pos_start) {\n\t\t/* Remap the rest */\n\t\tmap_size = (pos - pos_start) << PAGE_SHIFT;\n\t\tif (remap_oldmem_pfn_range(vma, from + len, pos_start,\n\t\t\t\t\t   map_size, prot))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tdo_munmap(vma->vm_mm, from, len);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "alloc_elfnotes_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "314-321",
    "snippet": "static inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "notes_sz"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "notes_sz"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}"
  },
  {
    "function_name": "mmap_vmcore_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "266-296",
    "snippet": "static int mmap_vmcore_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n#ifdef CONFIG_S390\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t index = vmf->pgoff;\n\tstruct page *page;\n\tloff_t offset;\n\tchar *buf;\n\tint rc;\n\n\tpage = find_or_create_page(mapping, index, GFP_KERNEL);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\tif (!PageUptodate(page)) {\n\t\toffset = (loff_t) index << PAGE_CACHE_SHIFT;\n\t\tbuf = __va((page_to_pfn(page) << PAGE_SHIFT));\n\t\trc = __read_vmcore(buf, PAGE_SIZE, &offset, 0);\n\t\tif (rc < 0) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn (rc == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\tvmf->page = page;\n\treturn 0;\n#else\n\treturn VM_FAULT_SIGBUS;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_vmcore",
          "args": [
            "buf",
            "PAGE_SIZE",
            "&offset",
            "0"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__read_vmcore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "184-251",
          "snippet": "static ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(vmcore_list);",
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz;",
            "static char *elfnotes_buf;",
            "static size_t elfnotes_sz;",
            "static u64 vmcore_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\n\nstatic ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "(page_to_pfn(page) << PAGE_SHIFT)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_KERNEL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int mmap_vmcore_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n#ifdef CONFIG_S390\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t index = vmf->pgoff;\n\tstruct page *page;\n\tloff_t offset;\n\tchar *buf;\n\tint rc;\n\n\tpage = find_or_create_page(mapping, index, GFP_KERNEL);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\tif (!PageUptodate(page)) {\n\t\toffset = (loff_t) index << PAGE_CACHE_SHIFT;\n\t\tbuf = __va((page_to_pfn(page) << PAGE_SHIFT));\n\t\trc = __read_vmcore(buf, PAGE_SIZE, &offset, 0);\n\t\tif (rc < 0) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn (rc == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\tvmf->page = page;\n\treturn 0;\n#else\n\treturn VM_FAULT_SIGBUS;\n#endif\n}"
  },
  {
    "function_name": "read_vmcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "253-257",
    "snippet": "static ssize_t read_vmcore(struct file *file, char __user *buffer,\n\t\t\t   size_t buflen, loff_t *fpos)\n{\n\treturn __read_vmcore((__force char *) buffer, buflen, fpos, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__read_vmcore",
          "args": [
            "(__force char *) buffer",
            "buflen",
            "fpos",
            "1"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__read_vmcore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "184-251",
          "snippet": "static ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(vmcore_list);",
            "static char *elfcorebuf;",
            "static size_t elfcorebuf_sz;",
            "static char *elfnotes_buf;",
            "static size_t elfnotes_sz;",
            "static u64 vmcore_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\n\nstatic ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic ssize_t read_vmcore(struct file *file, char __user *buffer,\n\t\t\t   size_t buflen, loff_t *fpos)\n{\n\treturn __read_vmcore((__force char *) buffer, buflen, fpos, 1);\n}"
  },
  {
    "function_name": "__read_vmcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "184-251",
    "snippet": "static ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(vmcore_list);",
      "static char *elfcorebuf;",
      "static size_t elfcorebuf_sz;",
      "static char *elfnotes_buf;",
      "static size_t elfnotes_sz;",
      "static u64 vmcore_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_from_oldmem",
          "args": [
            "buffer",
            "tsz",
            "&start",
            "userbuf"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "read_from_oldmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "88-125",
          "snippet": "static ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "m->offset + m->size - *fpos",
            "buflen"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "&vmcore_list",
            "list"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to",
          "args": [
            "buffer",
            "kaddr",
            "tsz",
            "userbuf"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "170-179",
          "snippet": "static int copy_to(void *target, void *src, size_t size, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *) target, src, size))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy(target, src, size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int copy_to(void *target, void *src, size_t size, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *) target, src, size))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy(target, src, size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "elfcorebuf_sz + elfnotes_sz - (size_t)*fpos",
            "buflen"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(vmcore_list);\nstatic char *elfcorebuf;\nstatic size_t elfcorebuf_sz;\nstatic char *elfnotes_buf;\nstatic size_t elfnotes_sz;\nstatic u64 vmcore_size;\n\nstatic ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\n\t\t\t     int userbuf)\n{\n\tssize_t acc = 0, tmp;\n\tsize_t tsz;\n\tu64 start;\n\tstruct vmcore *m = NULL;\n\n\tif (buflen == 0 || *fpos >= vmcore_size)\n\t\treturn 0;\n\n\t/* trim buflen to not go beyond EOF */\n\tif (buflen > vmcore_size - *fpos)\n\t\tbuflen = vmcore_size - *fpos;\n\n\t/* Read ELF core header */\n\tif (*fpos < elfcorebuf_sz) {\n\t\ttsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\n\t\tif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\t/* Read Elf note segment */\n\tif (*fpos < elfcorebuf_sz + elfnotes_sz) {\n\t\tvoid *kaddr;\n\n\t\ttsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\n\t\tkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\n\t\tif (copy_to(buffer, kaddr, tsz, userbuf))\n\t\t\treturn -EFAULT;\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tbuffer += tsz;\n\t\tacc += tsz;\n\n\t\t/* leave now if filled buffer already */\n\t\tif (buflen == 0)\n\t\t\treturn acc;\n\t}\n\n\tlist_for_each_entry(m, &vmcore_list, list) {\n\t\tif (*fpos < m->offset + m->size) {\n\t\t\ttsz = min_t(size_t, m->offset + m->size - *fpos, buflen);\n\t\t\tstart = m->paddr + *fpos - m->offset;\n\t\t\ttmp = read_from_oldmem(buffer, tsz, &start, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\tbuflen -= tsz;\n\t\t\t*fpos += tsz;\n\t\t\tbuffer += tsz;\n\t\t\tacc += tsz;\n\n\t\t\t/* leave now if filled buffer already */\n\t\t\tif (buflen == 0)\n\t\t\t\treturn acc;\n\t\t}\n\t}\n\n\treturn acc;\n}"
  },
  {
    "function_name": "copy_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "170-179",
    "snippet": "static int copy_to(void *target, void *src, size_t size, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *) target, src, size))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy(target, src, size);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target",
            "src",
            "size"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(char __user *) target",
            "src",
            "size"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int copy_to(void *target, void *src, size_t size, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *) target, src, size))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy(target, src, size);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "remap_oldmem_pfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "160-165",
    "snippet": "int __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "from",
            "pfn",
            "size",
            "prot"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nint __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long from, unsigned long pfn,\n\t\t\t\t  unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, from, pfn, size, prot);\n}"
  },
  {
    "function_name": "elfcorehdr_read_notes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "152-155",
    "snippet": "ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_from_oldmem",
          "args": [
            "buf",
            "count",
            "ppos",
            "0"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "read_from_oldmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "88-125",
          "snippet": "static ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
  },
  {
    "function_name": "elfcorehdr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "144-147",
    "snippet": "ssize_t __weak elfcorehdr_read(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_from_oldmem",
          "args": [
            "buf",
            "count",
            "ppos",
            "0"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "read_from_oldmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "88-125",
          "snippet": "static ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nssize_t __weak elfcorehdr_read(char *buf, size_t count, u64 *ppos)\n{\n\treturn read_from_oldmem(buf, count, ppos, 0);\n}"
  },
  {
    "function_name": "elfcorehdr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "138-139",
    "snippet": "void __weak elfcorehdr_free(unsigned long long addr)\n{}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nvoid __weak elfcorehdr_free(unsigned long long addr)\n{}"
  },
  {
    "function_name": "elfcorehdr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "130-133",
    "snippet": "int __weak elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nint __weak elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "read_from_oldmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "88-125",
    "snippet": "static ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_oldmem_page",
          "args": [
            "pfn",
            "buf",
            "nr_bytes",
            "offset",
            "userbuf"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "nr_bytes"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_is_ram",
          "args": [
            "pfn"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_is_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "69-85",
          "snippet": "static int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic ssize_t read_from_oldmem(char *buf, size_t count,\n\t\t\t\tu64 *ppos, int userbuf)\n{\n\tunsigned long pfn, offset;\n\tsize_t nr_bytes;\n\tssize_t read = 0, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\toffset = (unsigned long)(*ppos % PAGE_SIZE);\n\tpfn = (unsigned long)(*ppos / PAGE_SIZE);\n\n\tdo {\n\t\tif (count > (PAGE_SIZE - offset))\n\t\t\tnr_bytes = PAGE_SIZE - offset;\n\t\telse\n\t\t\tnr_bytes = count;\n\n\t\t/* If pfn is not ram, return zeros for sparse dump files */\n\t\tif (pfn_is_ram(pfn) == 0)\n\t\t\tmemset(buf, 0, nr_bytes);\n\t\telse {\n\t\t\ttmp = copy_oldmem_page(pfn, buf, nr_bytes,\n\t\t\t\t\t\toffset, userbuf);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t}\n\t\t*ppos += nr_bytes;\n\t\tcount -= nr_bytes;\n\t\tbuf += nr_bytes;\n\t\tread += nr_bytes;\n\t\t++pfn;\n\t\toffset = 0;\n\t} while (count);\n\n\treturn read;\n}"
  },
  {
    "function_name": "pfn_is_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "69-85",
    "snippet": "static int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pfn"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_elfnotes_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
          "lines": "314-321",
          "snippet": "static inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/list.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/printk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/kcore.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic inline char *alloc_elfnotes_buf(size_t notes_sz)\n{\n#ifdef CONFIG_MMU\n\treturn vmalloc_user(notes_sz);\n#else\n\treturn vzalloc(notes_sz);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nstatic int pfn_is_ram(unsigned long pfn)\n{\n\tint (*fn)(unsigned long pfn);\n\t/* pfn is ram unless fn() checks pagetype */\n\tint ret = 1;\n\n\t/*\n\t * Ask hypervisor if the pfn is really ram.\n\t * A ballooned page contains no data and reading from such a page\n\t * will cause high load in the hypervisor.\n\t */\n\tfn = oldmem_pfn_is_ram;\n\tif (fn)\n\t\tret = fn(pfn);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_oldmem_pfn_is_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "62-66",
    "snippet": "void unregister_oldmem_pfn_is_ram(void)\n{\n\toldmem_pfn_is_ram = NULL;\n\twmb();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nvoid unregister_oldmem_pfn_is_ram(void)\n{\n\toldmem_pfn_is_ram = NULL;\n\twmb();\n}"
  },
  {
    "function_name": "register_oldmem_pfn_is_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/vmcore.c",
    "lines": "53-59",
    "snippet": "int register_oldmem_pfn_is_ram(int (*fn)(unsigned long pfn))\n{\n\tif (oldmem_pfn_is_ram)\n\t\treturn -EBUSY;\n\toldmem_pfn_is_ram = fn;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/list.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/printk.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/kcore.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*oldmem_pfn_is_ram)(unsigned long pfn);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/crash_dump.h>\n#include <linux/init.h>\n#include <linux/bootmem.h>\n#include <linux/printk.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/kcore.h>\n#include <linux/mm.h>\n\nstatic int (*oldmem_pfn_is_ram)(unsigned long pfn);\n\nint register_oldmem_pfn_is_ram(int (*fn)(unsigned long pfn))\n{\n\tif (oldmem_pfn_is_ram)\n\t\treturn -EBUSY;\n\toldmem_pfn_is_ram = fn;\n\treturn 0;\n}"
  }
]