[
  {
    "function_name": "v9fs_mmap_vm_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "804-827",
    "snippet": "static void v9fs_mmap_vm_close(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.range_start = vma->vm_pgoff * PAGE_SIZE,\n\t\t /* absolute end, byte at end included */\n\t\t.range_end = vma->vm_pgoff * PAGE_SIZE +\n\t\t\t(vma->vm_end - vma->vm_start - 1),\n\t};\n\n\n\tp9_debug(P9_DEBUG_VFS, \"9p VMA close, %p, flushing\", vma);\n\n\tinode = file_inode(vma->vm_file);\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\tsync_inode(inode, &wbc);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inodes_one_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "70-74",
          "snippet": "static void sync_inodes_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tsync_inodes_sb(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void sync_inodes_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tsync_inodes_sb(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_writeback_dirty",
          "args": [
            "inode->i_mapping"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"9p VMA close, %p, flushing\"",
            "vma"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_mmap_vm_close(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.range_start = vma->vm_pgoff * PAGE_SIZE,\n\t\t /* absolute end, byte at end included */\n\t\t.range_end = vma->vm_pgoff * PAGE_SIZE +\n\t\t\t(vma->vm_end - vma->vm_start - 1),\n\t};\n\n\n\tp9_debug(P9_DEBUG_VFS, \"9p VMA close, %p, flushing\", vma);\n\n\tinode = file_inode(vma->vm_file);\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\tsync_inode(inode, &wbc);\n}"
  },
  {
    "function_name": "v9fs_mmap_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "793-802",
    "snippet": "static ssize_t\nv9fs_mmap_file_write(struct file *filp, const char __user *data,\n\t\t       size_t count, loff_t *offset)\n{\n\t/*\n\t * TODO: invalidate mmaps on filp's inode between\n\t * offset and offset+count\n\t */\n\treturn v9fs_file_write(filp, data, count, offset);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_write",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "504-531",
          "snippet": "static ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_mmap_file_write(struct file *filp, const char __user *data,\n\t\t       size_t count, loff_t *offset)\n{\n\t/*\n\t * TODO: invalidate mmaps on filp's inode between\n\t * offset and offset+count\n\t */\n\treturn v9fs_file_write(filp, data, count, offset);\n}"
  },
  {
    "function_name": "v9fs_cached_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "774-782",
    "snippet": "static ssize_t\nv9fs_cached_file_write(struct file *filp, const char __user * data,\n\t\t       size_t count, loff_t *offset)\n{\n\n\tif (filp->f_flags & O_DIRECT)\n\t\treturn v9fs_direct_write(filp, data, count, offset);\n\treturn new_sync_write(filp, data, count, offset);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_write",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "524-541",
          "snippet": "ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_direct_write",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "714-764",
          "snippet": "static ssize_t\nv9fs_direct_write(struct file *filp, const char __user * data,\n\t\t  size_t count, loff_t *offsetp)\n{\n\tloff_t offset;\n\tssize_t retval;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t      offset + count - 1);\n\tif (retval)\n\t\tgoto err_out;\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that if we fail\n\t * here we fall back to buffered write\n\t */\n\tif (mapping->nrpages) {\n\t\tpgoff_t pg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tpgoff_t pg_end   = (offset + count - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tretval = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t\t\tpg_start, pg_end);\n\t\t/*\n\t\t * If a page can not be invalidated, fall back\n\t\t * to buffered write.\n\t\t */\n\t\tif (retval) {\n\t\t\tif (retval == -EBUSY)\n\t\t\t\tgoto buff_write;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = v9fs_file_write(filp, data, count, offsetp);\nerr_out:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n\nbuff_write:\n\tmutex_unlock(&inode->i_mutex);\n\treturn new_sync_write(filp, data, count, offsetp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_direct_write(struct file *filp, const char __user * data,\n\t\t  size_t count, loff_t *offsetp)\n{\n\tloff_t offset;\n\tssize_t retval;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t      offset + count - 1);\n\tif (retval)\n\t\tgoto err_out;\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that if we fail\n\t * here we fall back to buffered write\n\t */\n\tif (mapping->nrpages) {\n\t\tpgoff_t pg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tpgoff_t pg_end   = (offset + count - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tretval = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t\t\tpg_start, pg_end);\n\t\t/*\n\t\t * If a page can not be invalidated, fall back\n\t\t * to buffered write.\n\t\t */\n\t\tif (retval) {\n\t\t\tif (retval == -EBUSY)\n\t\t\t\tgoto buff_write;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = v9fs_file_write(filp, data, count, offsetp);\nerr_out:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n\nbuff_write:\n\tmutex_unlock(&inode->i_mutex);\n\treturn new_sync_write(filp, data, count, offsetp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_cached_file_write(struct file *filp, const char __user * data,\n\t\t       size_t count, loff_t *offset)\n{\n\n\tif (filp->f_flags & O_DIRECT)\n\t\treturn v9fs_direct_write(filp, data, count, offset);\n\treturn new_sync_write(filp, data, count, offset);\n}"
  },
  {
    "function_name": "v9fs_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "714-764",
    "snippet": "static ssize_t\nv9fs_direct_write(struct file *filp, const char __user * data,\n\t\t  size_t count, loff_t *offsetp)\n{\n\tloff_t offset;\n\tssize_t retval;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t      offset + count - 1);\n\tif (retval)\n\t\tgoto err_out;\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that if we fail\n\t * here we fall back to buffered write\n\t */\n\tif (mapping->nrpages) {\n\t\tpgoff_t pg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tpgoff_t pg_end   = (offset + count - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tretval = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t\t\tpg_start, pg_end);\n\t\t/*\n\t\t * If a page can not be invalidated, fall back\n\t\t * to buffered write.\n\t\t */\n\t\tif (retval) {\n\t\t\tif (retval == -EBUSY)\n\t\t\t\tgoto buff_write;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = v9fs_file_write(filp, data, count, offsetp);\nerr_out:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n\nbuff_write:\n\tmutex_unlock(&inode->i_mutex);\n\treturn new_sync_write(filp, data, count, offsetp);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_write",
          "args": [
            "filp",
            "data",
            "count",
            "offsetp"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "524-541",
          "snippet": "ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_file_write",
          "args": [
            "filp",
            "data",
            "count",
            "offsetp"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "504-531",
          "snippet": "static ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "pg_start",
            "pg_end"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "offset",
            "offset + count - 1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_direct_write(struct file *filp, const char __user * data,\n\t\t  size_t count, loff_t *offsetp)\n{\n\tloff_t offset;\n\tssize_t retval;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t      offset + count - 1);\n\tif (retval)\n\t\tgoto err_out;\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that if we fail\n\t * here we fall back to buffered write\n\t */\n\tif (mapping->nrpages) {\n\t\tpgoff_t pg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tpgoff_t pg_end   = (offset + count - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tretval = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t\t\tpg_start, pg_end);\n\t\t/*\n\t\t * If a page can not be invalidated, fall back\n\t\t * to buffered write.\n\t\t */\n\t\tif (retval) {\n\t\t\tif (retval == -EBUSY)\n\t\t\t\tgoto buff_write;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = v9fs_file_write(filp, data, count, offsetp);\nerr_out:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n\nbuff_write:\n\tmutex_unlock(&inode->i_mutex);\n\treturn new_sync_write(filp, data, count, offsetp);\n}"
  },
  {
    "function_name": "v9fs_mmap_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "706-712",
    "snippet": "static ssize_t\nv9fs_mmap_file_read(struct file *filp, char __user *data, size_t count,\n\t\t      loff_t *offset)\n{\n\t/* TODO: Check if there are dirty pages */\n\treturn v9fs_file_read(filp, data, count, offset);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_read",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "432-453",
          "snippet": "static ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_mmap_file_read(struct file *filp, char __user *data, size_t count,\n\t\t      loff_t *offset)\n{\n\t/* TODO: Check if there are dirty pages */\n\treturn v9fs_file_read(filp, data, count, offset);\n}"
  },
  {
    "function_name": "v9fs_cached_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "689-696",
    "snippet": "static ssize_t\nv9fs_cached_file_read(struct file *filp, char __user *data, size_t count,\n\t\t      loff_t *offset)\n{\n\tif (filp->f_flags & O_DIRECT)\n\t\treturn v9fs_direct_read(filp, data, count, offset);\n\treturn new_sync_read(filp, data, count, offset);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_read",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "440-457",
          "snippet": "ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_direct_read",
          "args": [
            "filp",
            "data",
            "count",
            "offset"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_direct_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "660-679",
          "snippet": "static ssize_t\nv9fs_direct_read(struct file *filp, char __user *udata, size_t count,\n\t\t loff_t *offsetp)\n{\n\tloff_t size, offset;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\tsize = i_size_read(inode);\n\tif (offset < size)\n\t\tfilemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t     offset + count - 1);\n\n\treturn v9fs_file_read(filp, udata, count, offsetp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_direct_read(struct file *filp, char __user *udata, size_t count,\n\t\t loff_t *offsetp)\n{\n\tloff_t size, offset;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\tsize = i_size_read(inode);\n\tif (offset < size)\n\t\tfilemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t     offset + count - 1);\n\n\treturn v9fs_file_read(filp, udata, count, offsetp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_cached_file_read(struct file *filp, char __user *data, size_t count,\n\t\t      loff_t *offset)\n{\n\tif (filp->f_flags & O_DIRECT)\n\t\treturn v9fs_direct_read(filp, data, count, offset);\n\treturn new_sync_read(filp, data, count, offset);\n}"
  },
  {
    "function_name": "v9fs_direct_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "660-679",
    "snippet": "static ssize_t\nv9fs_direct_read(struct file *filp, char __user *udata, size_t count,\n\t\t loff_t *offsetp)\n{\n\tloff_t size, offset;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\tsize = i_size_read(inode);\n\tif (offset < size)\n\t\tfilemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t     offset + count - 1);\n\n\treturn v9fs_file_read(filp, udata, count, offsetp);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_read",
          "args": [
            "filp",
            "udata",
            "count",
            "offsetp"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "432-453",
          "snippet": "static ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "offset",
            "offset + count - 1"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_direct_read(struct file *filp, char __user *udata, size_t count,\n\t\t loff_t *offsetp)\n{\n\tloff_t size, offset;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\n\toffset = *offsetp;\n\tmapping = filp->f_mapping;\n\tinode = mapping->host;\n\tif (!count)\n\t\treturn 0;\n\tsize = i_size_read(inode);\n\tif (offset < size)\n\t\tfilemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t     offset + count - 1);\n\n\treturn v9fs_file_read(filp, udata, count, offsetp);\n}"
  },
  {
    "function_name": "v9fs_vm_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "630-658",
    "snippet": "static int\nv9fs_vm_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct page *page = vmf->page;\n\tstruct file *filp = vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\n\n\tp9_debug(P9_DEBUG_VFS, \"page %p fid %lx\\n\",\n\t\t page, (unsigned long)filp->private_data);\n\n\t/* Update file times before taking page lock */\n\tfile_update_time(filp);\n\n\tv9inode = V9FS_I(inode);\n\t/* make sure the cache has finished storing the page */\n\tv9fs_fscache_wait_on_page_write(inode, page);\n\tBUG_ON(!v9inode->writeback_fid);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto out_unlock;\n\twait_for_stable_page(page);\n\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tunlock_page(page);\n\treturn VM_FAULT_NOPAGE;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!v9inode->writeback_fid"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fscache_wait_on_page_write",
          "args": [
            "inode",
            "page"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "408-414",
          "snippet": "void __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "filp"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"page %p fid %lx\\n\"",
            "page",
            "(unsigned long)filp->private_data"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vm_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct page *page = vmf->page;\n\tstruct file *filp = vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\n\n\tp9_debug(P9_DEBUG_VFS, \"page %p fid %lx\\n\",\n\t\t page, (unsigned long)filp->private_data);\n\n\t/* Update file times before taking page lock */\n\tfile_update_time(filp);\n\n\tv9inode = V9FS_I(inode);\n\t/* make sure the cache has finished storing the page */\n\tv9fs_fscache_wait_on_page_write(inode, page);\n\tBUG_ON(!v9inode->writeback_fid);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto out_unlock;\n\twait_for_stable_page(page);\n\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tunlock_page(page);\n\treturn VM_FAULT_NOPAGE;\n}"
  },
  {
    "function_name": "v9fs_mmap_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "593-628",
    "snippet": "static int\nv9fs_mmap_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct v9fs_inode *v9inode;\n\tstruct p9_fid *fid;\n\n\tinode = file_inode(filp);\n\tv9inode = V9FS_I(inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif (!v9inode->writeback_fid &&\n\t    (vma->vm_flags & VM_WRITE)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during mmap instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tfid = v9fs_writeback_fid(filp->f_path.dentry);\n\t\tif (IS_ERR(fid)) {\n\t\t\tretval = PTR_ERR(fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\treturn retval;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\n\tretval = generic_file_mmap(filp, vma);\n\tif (!retval)\n\t\tvma->vm_ops = &v9fs_mmap_file_vm_ops;\n\n\treturn retval;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct v9fs_mmap_file_vm_ops;",
      "static const struct vm_operations_struct v9fs_mmap_file_vm_ops = {\n\t.close = v9fs_mmap_vm_close,\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = v9fs_vm_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "filp",
            "vma"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_writeback_fid",
          "args": [
            "filp->f_path.dentry"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_writeback_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "284-306",
          "snippet": "struct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct vm_operations_struct v9fs_mmap_file_vm_ops;\nstatic const struct vm_operations_struct v9fs_mmap_file_vm_ops = {\n\t.close = v9fs_mmap_vm_close,\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = v9fs_vm_page_mkwrite,\n};\n\nstatic int\nv9fs_mmap_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct v9fs_inode *v9inode;\n\tstruct p9_fid *fid;\n\n\tinode = file_inode(filp);\n\tv9inode = V9FS_I(inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif (!v9inode->writeback_fid &&\n\t    (vma->vm_flags & VM_WRITE)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during mmap instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tfid = v9fs_writeback_fid(filp->f_path.dentry);\n\t\tif (IS_ERR(fid)) {\n\t\t\tretval = PTR_ERR(fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\treturn retval;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\n\tretval = generic_file_mmap(filp, vma);\n\tif (!retval)\n\t\tvma->vm_ops = &v9fs_mmap_file_vm_ops;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "580-591",
    "snippet": "static int\nv9fs_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint retval;\n\n\n\tretval = generic_file_mmap(filp, vma);\n\tif (!retval)\n\t\tvma->vm_ops = &v9fs_file_vm_ops;\n\n\treturn retval;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct v9fs_file_vm_ops;",
      "static const struct vm_operations_struct v9fs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = v9fs_vm_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "filp",
            "vma"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct vm_operations_struct v9fs_file_vm_ops;\nstatic const struct vm_operations_struct v9fs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = v9fs_vm_page_mkwrite,\n};\n\nstatic int\nv9fs_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint retval;\n\n\n\tretval = generic_file_mmap(filp, vma);\n\tif (!retval)\n\t\tvma->vm_ops = &v9fs_file_vm_ops;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_file_fsync_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "558-578",
    "snippet": "int v9fs_file_fsync_dotl(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tint retval;\n\n\tretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\n\tretval = p9_client_fsync(fid, datasync);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_fsync",
          "args": [
            "fid",
            "datasync"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp %p datasync %x\\n\"",
            "filp",
            "datasync"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_file_fsync_dotl(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tint retval;\n\n\tretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\n\tretval = p9_client_fsync(fid, datasync);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "534-556",
    "snippet": "static int v9fs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct p9_wstat wstat;\n\tint retval;\n\n\tretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\tv9fs_blank_wstat(&wstat);\n\n\tretval = p9_client_wstat(fid, &wstat);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_wstat",
          "args": [
            "fid",
            "&wstat"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_blank_wstat",
          "args": [
            "&wstat"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_blank_wstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "212-232",
          "snippet": "void\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp %p datasync %x\\n\"",
            "filp",
            "datasync"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct p9_wstat wstat;\n\tint retval;\n\n\tretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\tv9fs_blank_wstat(&wstat);\n\n\tretval = p9_client_wstat(fid, &wstat);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "504-531",
    "snippet": "static ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_write_internal",
          "args": [
            "file_inode(filp)",
            "filp->private_data",
            "data",
            "count",
            "&origin",
            "1"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_write_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "455-494",
          "snippet": "ssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "filp",
            "&origin",
            "&count",
            "0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_write(struct file *filp, const char __user * data,\n\t\tsize_t count, loff_t *offset)\n{\n\tssize_t retval = 0;\n\tloff_t origin = *offset;\n\n\n\tretval = generic_write_checks(filp, &origin, &count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tretval = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tretval = v9fs_file_write_internal(file_inode(filp),\n\t\t\t\t\tfilp->private_data,\n\t\t\t\t\tdata, count, &origin, 1);\n\t/* update offset on successful write */\n\tif (retval > 0)\n\t\t*offset = origin;\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_file_write_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "455-494",
    "snippet": "ssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "*offset"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "*offset - i_size"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "pg_start",
            "pg_end"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_write",
          "args": [
            "fid",
            "NULL",
            "data+total",
            "origin+total",
            "count"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"data %p count %d offset %x\\n\"",
            "data",
            "(int)count",
            "(int)*offset"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}"
  },
  {
    "function_name": "v9fs_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "432-453",
    "snippet": "static ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_read",
          "args": [
            "fid",
            "NULL",
            "udata",
            "*offset",
            "count"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_file_readn",
          "args": [
            "filp",
            "NULL",
            "udata",
            "count",
            "*offset"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_readn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "416-421",
          "snippet": "ssize_t\nv9fs_file_readn(struct file *filp, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\treturn v9fs_fid_readn(filp->private_data, data, udata, count, offset);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_file_readn(struct file *filp, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\treturn v9fs_fid_readn(filp->private_data, data, udata, count, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"count %zu offset %lld\\n\"",
            "count",
            "*offset"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\n\t       loff_t * offset)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\tsize_t size;\n\n\tp9_debug(P9_DEBUG_VFS, \"count %zu offset %lld\\n\", count, *offset);\n\tfid = filp->private_data;\n\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tif (count > size)\n\t\tret = v9fs_file_readn(filp, NULL, udata, count, *offset);\n\telse\n\t\tret = p9_client_read(fid, NULL, udata, *offset, count);\n\n\tif (ret > 0)\n\t\t*offset += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_file_readn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "416-421",
    "snippet": "ssize_t\nv9fs_file_readn(struct file *filp, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\treturn v9fs_fid_readn(filp->private_data, data, udata, count, offset);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_fid_readn",
          "args": [
            "filp->private_data",
            "data",
            "udata",
            "count",
            "offset"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_readn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "375-405",
          "snippet": "ssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_file_readn(struct file *filp, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\treturn v9fs_fid_readn(filp->private_data, data, udata, count, offset);\n}"
  },
  {
    "function_name": "v9fs_fid_readn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "375-405",
    "snippet": "ssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_read",
          "args": [
            "fid",
            "data",
            "udata",
            "offset",
            "count"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid %d offset %llu count %d\\n\"",
            "fid->fid",
            "(long long unsigned)offset",
            "count"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}"
  },
  {
    "function_name": "v9fs_file_flock_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "334-364",
    "snippet": "static int v9fs_file_flock_dotl(struct file *filp, int cmd,\n\tstruct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\tgoto out_err;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\t/* Convert flock to posix lock */\n\tfl->fl_flags |= FL_POSIX;\n\tfl->fl_flags ^= FL_FLOCK;\n\n\tif (IS_SETLK(cmd) | IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse\n\t\tret = -EINVAL;\nout_err:\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_do_lock",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_do_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "148-235",
          "snippet": "static int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp: %p cmd:%d lock: %p name: %pD\\n\"",
            "filp",
            "cmd",
            "fl",
            "filp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_flock_dotl(struct file *filp, int cmd,\n\tstruct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\tgoto out_err;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\t/* Convert flock to posix lock */\n\tfl->fl_flags |= FL_POSIX;\n\tfl->fl_flags ^= FL_FLOCK;\n\n\tif (IS_SETLK(cmd) | IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse\n\t\tret = -EINVAL;\nout_err:\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_file_lock_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "299-324",
    "snippet": "static int v9fs_file_lock_dotl(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse if (IS_GETLK(cmd))\n\t\tret = v9fs_file_getlock(filp, fl);\n\telse\n\t\tret = -EINVAL;\nout_err:\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_file_getlock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_getlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "237-289",
          "snippet": "static int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\n{\n\tstruct p9_getlock glock;\n\tstruct p9_fid *fid;\n\tint res = 0;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tposix_test_lock(filp, fl);\n\t/*\n\t * if we have a conflicting lock locally, no need to validate\n\t * with server\n\t */\n\tif (fl->fl_type != F_UNLCK)\n\t\treturn res;\n\n\t/* convert posix lock to p9 tgetlock args */\n\tmemset(&glock, 0, sizeof(glock));\n\tglock.type  = P9_LOCK_TYPE_UNLCK;\n\tglock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tglock.length = 0;\n\telse\n\t\tglock.length = fl->fl_end - fl->fl_start + 1;\n\tglock.proc_id = fl->fl_pid;\n\tglock.client_id = fid->clnt->name;\n\n\tres = p9_client_getlock_dotl(fid, &glock);\n\tif (res < 0)\n\t\treturn res;\n\t/* map 9p lock type to os lock type */\n\tswitch (glock.type) {\n\tcase P9_LOCK_TYPE_RDLCK:\n\t\tfl->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_WRLCK:\n\t\tfl->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_UNLCK:\n\t\tfl->fl_type = F_UNLCK;\n\t\tbreak;\n\t}\n\tif (glock.type != P9_LOCK_TYPE_UNLCK) {\n\t\tfl->fl_start = glock.start;\n\t\tif (glock.length == 0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\telse\n\t\t\tfl->fl_end = glock.start + glock.length - 1;\n\t\tfl->fl_pid = glock.proc_id;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\n{\n\tstruct p9_getlock glock;\n\tstruct p9_fid *fid;\n\tint res = 0;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tposix_test_lock(filp, fl);\n\t/*\n\t * if we have a conflicting lock locally, no need to validate\n\t * with server\n\t */\n\tif (fl->fl_type != F_UNLCK)\n\t\treturn res;\n\n\t/* convert posix lock to p9 tgetlock args */\n\tmemset(&glock, 0, sizeof(glock));\n\tglock.type  = P9_LOCK_TYPE_UNLCK;\n\tglock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tglock.length = 0;\n\telse\n\t\tglock.length = fl->fl_end - fl->fl_start + 1;\n\tglock.proc_id = fl->fl_pid;\n\tglock.client_id = fid->clnt->name;\n\n\tres = p9_client_getlock_dotl(fid, &glock);\n\tif (res < 0)\n\t\treturn res;\n\t/* map 9p lock type to os lock type */\n\tswitch (glock.type) {\n\tcase P9_LOCK_TYPE_RDLCK:\n\t\tfl->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_WRLCK:\n\t\tfl->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_UNLCK:\n\t\tfl->fl_type = F_UNLCK;\n\t\tbreak;\n\t}\n\tif (glock.type != P9_LOCK_TYPE_UNLCK) {\n\t\tfl->fl_start = glock.start;\n\t\tif (glock.length == 0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\telse\n\t\t\tfl->fl_end = glock.start + glock.length - 1;\n\t\tfl->fl_pid = glock.proc_id;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_file_do_lock",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_do_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "148-235",
          "snippet": "static int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp: %p cmd:%d lock: %p name: %pD\\n\"",
            "filp",
            "cmd",
            "fl",
            "filp"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_lock_dotl(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse if (IS_GETLK(cmd))\n\t\tret = v9fs_file_getlock(filp, fl);\n\telse\n\t\tret = -EINVAL;\nout_err:\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_file_getlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "237-289",
    "snippet": "static int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\n{\n\tstruct p9_getlock glock;\n\tstruct p9_fid *fid;\n\tint res = 0;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tposix_test_lock(filp, fl);\n\t/*\n\t * if we have a conflicting lock locally, no need to validate\n\t * with server\n\t */\n\tif (fl->fl_type != F_UNLCK)\n\t\treturn res;\n\n\t/* convert posix lock to p9 tgetlock args */\n\tmemset(&glock, 0, sizeof(glock));\n\tglock.type  = P9_LOCK_TYPE_UNLCK;\n\tglock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tglock.length = 0;\n\telse\n\t\tglock.length = fl->fl_end - fl->fl_start + 1;\n\tglock.proc_id = fl->fl_pid;\n\tglock.client_id = fid->clnt->name;\n\n\tres = p9_client_getlock_dotl(fid, &glock);\n\tif (res < 0)\n\t\treturn res;\n\t/* map 9p lock type to os lock type */\n\tswitch (glock.type) {\n\tcase P9_LOCK_TYPE_RDLCK:\n\t\tfl->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_WRLCK:\n\t\tfl->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_UNLCK:\n\t\tfl->fl_type = F_UNLCK;\n\t\tbreak;\n\t}\n\tif (glock.type != P9_LOCK_TYPE_UNLCK) {\n\t\tfl->fl_start = glock.start;\n\t\tif (glock.length == 0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\telse\n\t\t\tfl->fl_end = glock.start + glock.length - 1;\n\t\tfl->fl_pid = glock.proc_id;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_getlock_dotl",
          "args": [
            "fid",
            "&glock"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&glock",
            "0",
            "sizeof(glock)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fid == NULL"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\n{\n\tstruct p9_getlock glock;\n\tstruct p9_fid *fid;\n\tint res = 0;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tposix_test_lock(filp, fl);\n\t/*\n\t * if we have a conflicting lock locally, no need to validate\n\t * with server\n\t */\n\tif (fl->fl_type != F_UNLCK)\n\t\treturn res;\n\n\t/* convert posix lock to p9 tgetlock args */\n\tmemset(&glock, 0, sizeof(glock));\n\tglock.type  = P9_LOCK_TYPE_UNLCK;\n\tglock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tglock.length = 0;\n\telse\n\t\tglock.length = fl->fl_end - fl->fl_start + 1;\n\tglock.proc_id = fl->fl_pid;\n\tglock.client_id = fid->clnt->name;\n\n\tres = p9_client_getlock_dotl(fid, &glock);\n\tif (res < 0)\n\t\treturn res;\n\t/* map 9p lock type to os lock type */\n\tswitch (glock.type) {\n\tcase P9_LOCK_TYPE_RDLCK:\n\t\tfl->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_WRLCK:\n\t\tfl->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_UNLCK:\n\t\tfl->fl_type = F_UNLCK;\n\t\tbreak;\n\t}\n\tif (glock.type != P9_LOCK_TYPE_UNLCK) {\n\t\tfl->fl_start = glock.start;\n\t\tif (glock.length == 0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\telse\n\t\t\tfl->fl_end = glock.start + glock.length - 1;\n\t\tfl->fl_pid = glock.proc_id;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "v9fs_file_do_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "148-235",
    "snippet": "static int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "filp",
            "fl"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "P9_LOCK_TIMEOUT"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_lock_dotl",
          "args": [
            "fid",
            "&flock",
            "&status"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&flock",
            "0",
            "sizeof(flock)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fid == NULL"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status;\n\tint res = 0;\n\tunsigned char fl_type;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\n\t\tBUG();\n\n\tres = posix_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t/* convert posix lock to p9 tlock args */\n\tmemset(&flock, 0, sizeof(flock));\n\t/* map the lock type */\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\t/*\n\t * if its a blocked request and we get P9_LOCK_BLOCKED as the status\n\t * for lock request, keep on trying\n\t */\n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* map 9p status to VFS status */\n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * incase server returned error for lock request, revert\n\t * it locally\n\t */\n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\tres = posix_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\nout:\n\treturn res;\n}"
  },
  {
    "function_name": "v9fs_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "129-146",
    "snippet": "static int v9fs_file_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tint res = 0;\n\tstruct inode *inode = file_inode(filp);\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p lock: %p\\n\", filp, fl);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp: %p lock: %p\\n\"",
            "filp",
            "fl"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_file_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tint res = 0;\n\tstruct inode *inode = file_inode(filp);\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p lock: %p\\n\", filp, fl);\n\n\t/* No mandatory locks */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "v9fs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
    "lines": "57-117",
    "snippet": "int v9fs_file_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tint omode;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p file: %p\\n\", inode, file);\n\tv9inode = V9FS_I(inode);\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9fs_proto_dotl(v9ses))\n\t\tomode = v9fs_open_to_dotl_flags(file->f_flags);\n\telse\n\t\tomode = v9fs_uflags2omode(file->f_flags,\n\t\t\t\t\tv9fs_proto_dotu(v9ses));\n\tfid = file->private_data;\n\tif (!fid) {\n\t\tfid = v9fs_fid_clone(file->f_path.dentry);\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\terr = p9_client_open(fid, omode);\n\t\tif (err < 0) {\n\t\t\tp9_client_clunk(fid);\n\t\t\treturn err;\n\t\t}\n\t\tif ((file->f_flags & O_APPEND) &&\n\t\t\t(!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)))\n\t\t\tgeneric_file_llseek(file, 0, SEEK_END);\n\t}\n\n\tfile->private_data = fid;\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((file->f_flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tfid = v9fs_writeback_fid(file->f_path.dentry);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto out_error;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(inode, file);\n\treturn 0;\nout_error:\n\tp9_client_clunk(file->private_data);\n\tfile->private_data = NULL;\n\treturn err;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/utsname.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/list.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "file->private_data"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_set_cookie",
          "args": [
            "inode",
            "file"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_set_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "239-254",
          "snippet": "void v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_writeback_fid",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_writeback_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "284-306",
          "snippet": "struct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "0",
            "SEEK_END"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_open",
          "args": [
            "fid",
            "omode"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_clone",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "260-270",
          "snippet": "struct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_uflags2omode",
          "args": [
            "file->f_flags",
            "v9fs_proto_dotu(v9ses)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_uflags2omode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "175-204",
          "snippet": "int v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_open_to_dotl_flags",
          "args": [
            "file->f_flags"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_open_to_dotl_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "211-223",
          "snippet": "int v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode: %p file: %p\\n\"",
            "inode",
            "file"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_file_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tint omode;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p file: %p\\n\", inode, file);\n\tv9inode = V9FS_I(inode);\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9fs_proto_dotl(v9ses))\n\t\tomode = v9fs_open_to_dotl_flags(file->f_flags);\n\telse\n\t\tomode = v9fs_uflags2omode(file->f_flags,\n\t\t\t\t\tv9fs_proto_dotu(v9ses));\n\tfid = file->private_data;\n\tif (!fid) {\n\t\tfid = v9fs_fid_clone(file->f_path.dentry);\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\terr = p9_client_open(fid, omode);\n\t\tif (err < 0) {\n\t\t\tp9_client_clunk(fid);\n\t\t\treturn err;\n\t\t}\n\t\tif ((file->f_flags & O_APPEND) &&\n\t\t\t(!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)))\n\t\t\tgeneric_file_llseek(file, 0, SEEK_END);\n\t}\n\n\tfile->private_data = fid;\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((file->f_flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tfid = v9fs_writeback_fid(file->f_path.dentry);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto out_error;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(inode, file);\n\treturn 0;\nout_error:\n\tp9_client_clunk(file->private_data);\n\tfile->private_data = NULL;\n\treturn err;\n}"
  }
]