[
  {
    "function_name": "ext_tree_mark_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "569-602",
    "snippet": "void\next_tree_mark_committed(struct nfs4_layoutcommit_args *arg, int status)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tstruct pnfs_block_extent *be;\n\n\tdprintk(\"%s status %d\\n\", __func__, status);\n\n\text_tree_free_commitdata(arg, arg->layoutupdate_len);\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(root); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_COMMITTING)\n\t\t\tcontinue;\n\n\t\tif (status) {\n\t\t\t/*\n\t\t\t * Mark as written and try again.\n\t\t\t *\n\t\t\t * XXX: some real error handling here wouldn't hurt..\n\t\t\t */\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t} else {\n\t\t\tbe->be_state = PNFS_BLOCK_READWRITE_DATA;\n\t\t\tbe->be_tag = 0;\n\t\t}\n\n\t\tbe = ext_try_to_merge_left(root, be);\n\t\tbe = ext_try_to_merge_right(root, be);\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_right",
          "args": [
            "root",
            "be"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "109-122",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_left",
          "args": [
            "root",
            "be"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "93-107",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_first",
          "args": [
            "root"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "17-22",
          "snippet": "static struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_free_commitdata",
          "args": [
            "arg",
            "arg->layoutupdate_len"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_free_commitdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "465-477",
          "snippet": "static void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s status %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LO2EXT",
          "args": [
            "NFS_I(arg->inode)->layout"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LO2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "153-157",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "arg->inode"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nvoid\next_tree_mark_committed(struct nfs4_layoutcommit_args *arg, int status)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tstruct pnfs_block_extent *be;\n\n\tdprintk(\"%s status %d\\n\", __func__, status);\n\n\text_tree_free_commitdata(arg, arg->layoutupdate_len);\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(root); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_COMMITTING)\n\t\t\tcontinue;\n\n\t\tif (status) {\n\t\t\t/*\n\t\t\t * Mark as written and try again.\n\t\t\t *\n\t\t\t * XXX: some real error handling here wouldn't hurt..\n\t\t\t */\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t} else {\n\t\t\tbe->be_state = PNFS_BLOCK_READWRITE_DATA;\n\t\t\tbe->be_tag = 0;\n\t\t}\n\n\t\tbe = ext_try_to_merge_left(root, be);\n\t\tbe = ext_try_to_merge_right(root, be);\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n}"
  },
  {
    "function_name": "ext_tree_prepare_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "512-567",
    "snippet": "int\next_tree_prepare_commit(struct nfs4_layoutcommit_args *arg)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tsize_t count = 0, buffer_size = PAGE_SIZE;\n\t__be32 *start_p;\n\tint ret;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\targ->layoutupdate_page = alloc_page(GFP_NOFS);\n\tif (!arg->layoutupdate_page)\n\t\treturn -ENOMEM;\n\tstart_p = page_address(arg->layoutupdate_page);\n\targ->layoutupdate_pages = &arg->layoutupdate_page;\n\nretry:\n\tret = ext_tree_encode_commit(bl, start_p + 1, buffer_size, &count);\n\tif (unlikely(ret)) {\n\t\text_tree_free_commitdata(arg, buffer_size);\n\n\t\tbuffer_size = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\t\tcount = 0;\n\n\t\targ->layoutupdate_pages =\n\t\t\tkcalloc(DIV_ROUND_UP(buffer_size, PAGE_SIZE),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (!arg->layoutupdate_pages)\n\t\t\treturn -ENOMEM;\n\n\t\tstart_p = __vmalloc(buffer_size, GFP_NOFS, PAGE_KERNEL);\n\t\tif (!start_p) {\n\t\t\tkfree(arg->layoutupdate_pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgoto retry;\n\t}\n\n\t*start_p = cpu_to_be32(count);\n\targ->layoutupdate_len = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\n\tif (unlikely(arg->layoutupdate_pages != &arg->layoutupdate_page)) {\n\t\t__be32 *p = start_p;\n\t\tint i = 0;\n\n\t\tfor (p = start_p;\n\t\t     p < start_p + arg->layoutupdate_len;\n\t\t     p += PAGE_SIZE) {\n\t\t\targ->layoutupdate_pages[i++] = vmalloc_to_page(p);\n\t\t}\n\t}\n\n\tdprintk(\"%s found %zu ranges\\n\", __func__, count);\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s found %zu ranges\\n\"",
            "__func__",
            "count"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "p"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arg->layoutupdate_pages != &arg->layoutupdate_page"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "count"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg->layoutupdate_pages"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "buffer_size",
            "GFP_NOFS",
            "PAGE_KERNEL"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "DIV_ROUND_UP(buffer_size, PAGE_SIZE)",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "buffer_size",
            "PAGE_SIZE"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_free_commitdata",
          "args": [
            "arg",
            "buffer_size"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_free_commitdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "465-477",
          "snippet": "static void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_encode_commit",
          "args": [
            "bl",
            "start_p + 1",
            "buffer_size",
            "&count"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_encode_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "479-510",
          "snippet": "static int ext_tree_encode_commit(struct pnfs_block_layout *bl, __be32 *p,\n\t\tsize_t buffer_size, size_t *count)\n{\n\tstruct pnfs_block_extent *be;\n\tint ret = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(&bl->bl_ext_rw); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_WRITTEN)\n\t\t\tcontinue;\n\n\t\t(*count)++;\n\t\tif (*count * BL_EXTENT_SIZE > buffer_size) {\n\t\t\t/* keep counting.. */\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = xdr_encode_opaque_fixed(p, be->be_device->deviceid.data,\n\t\t\t\tNFS4_DEVICEID4_SIZE);\n\t\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, 0LL);\n\t\t*p++ = cpu_to_be32(PNFS_BLOCK_READWRITE_DATA);\n\n\t\tbe->be_tag = EXTENT_COMMITTING;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int ext_tree_encode_commit(struct pnfs_block_layout *bl, __be32 *p,\n\t\tsize_t buffer_size, size_t *count)\n{\n\tstruct pnfs_block_extent *be;\n\tint ret = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(&bl->bl_ext_rw); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_WRITTEN)\n\t\t\tcontinue;\n\n\t\t(*count)++;\n\t\tif (*count * BL_EXTENT_SIZE > buffer_size) {\n\t\t\t/* keep counting.. */\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = xdr_encode_opaque_fixed(p, be->be_device->deviceid.data,\n\t\t\t\tNFS4_DEVICEID4_SIZE);\n\t\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, 0LL);\n\t\t*p++ = cpu_to_be32(PNFS_BLOCK_READWRITE_DATA);\n\n\t\tbe->be_tag = EXTENT_COMMITTING;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "arg->layoutupdate_page"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LO2EXT",
          "args": [
            "NFS_I(arg->inode)->layout"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LO2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "153-157",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "arg->inode"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_prepare_commit(struct nfs4_layoutcommit_args *arg)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tsize_t count = 0, buffer_size = PAGE_SIZE;\n\t__be32 *start_p;\n\tint ret;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\targ->layoutupdate_page = alloc_page(GFP_NOFS);\n\tif (!arg->layoutupdate_page)\n\t\treturn -ENOMEM;\n\tstart_p = page_address(arg->layoutupdate_page);\n\targ->layoutupdate_pages = &arg->layoutupdate_page;\n\nretry:\n\tret = ext_tree_encode_commit(bl, start_p + 1, buffer_size, &count);\n\tif (unlikely(ret)) {\n\t\text_tree_free_commitdata(arg, buffer_size);\n\n\t\tbuffer_size = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\t\tcount = 0;\n\n\t\targ->layoutupdate_pages =\n\t\t\tkcalloc(DIV_ROUND_UP(buffer_size, PAGE_SIZE),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (!arg->layoutupdate_pages)\n\t\t\treturn -ENOMEM;\n\n\t\tstart_p = __vmalloc(buffer_size, GFP_NOFS, PAGE_KERNEL);\n\t\tif (!start_p) {\n\t\t\tkfree(arg->layoutupdate_pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgoto retry;\n\t}\n\n\t*start_p = cpu_to_be32(count);\n\targ->layoutupdate_len = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\n\tif (unlikely(arg->layoutupdate_pages != &arg->layoutupdate_page)) {\n\t\t__be32 *p = start_p;\n\t\tint i = 0;\n\n\t\tfor (p = start_p;\n\t\t     p < start_p + arg->layoutupdate_len;\n\t\t     p += PAGE_SIZE) {\n\t\t\targ->layoutupdate_pages[i++] = vmalloc_to_page(p);\n\t\t}\n\t}\n\n\tdprintk(\"%s found %zu ranges\\n\", __func__, count);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext_tree_encode_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "479-510",
    "snippet": "static int ext_tree_encode_commit(struct pnfs_block_layout *bl, __be32 *p,\n\t\tsize_t buffer_size, size_t *count)\n{\n\tstruct pnfs_block_extent *be;\n\tint ret = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(&bl->bl_ext_rw); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_WRITTEN)\n\t\t\tcontinue;\n\n\t\t(*count)++;\n\t\tif (*count * BL_EXTENT_SIZE > buffer_size) {\n\t\t\t/* keep counting.. */\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = xdr_encode_opaque_fixed(p, be->be_device->deviceid.data,\n\t\t\t\tNFS4_DEVICEID4_SIZE);\n\t\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, 0LL);\n\t\t*p++ = cpu_to_be32(PNFS_BLOCK_READWRITE_DATA);\n\n\t\tbe->be_tag = EXTENT_COMMITTING;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "PNFS_BLOCK_READWRITE_DATA"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "0LL"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "be->be_length << SECTOR_SHIFT"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "be->be_f_offset << SECTOR_SHIFT"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "be->be_device->deviceid.data",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_first",
          "args": [
            "&bl->bl_ext_rw"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "17-22",
          "snippet": "static struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int ext_tree_encode_commit(struct pnfs_block_layout *bl, __be32 *p,\n\t\tsize_t buffer_size, size_t *count)\n{\n\tstruct pnfs_block_extent *be;\n\tint ret = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(&bl->bl_ext_rw); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_WRITTEN)\n\t\t\tcontinue;\n\n\t\t(*count)++;\n\t\tif (*count * BL_EXTENT_SIZE > buffer_size) {\n\t\t\t/* keep counting.. */\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = xdr_encode_opaque_fixed(p, be->be_device->deviceid.data,\n\t\t\t\tNFS4_DEVICEID4_SIZE);\n\t\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n\t\tp = xdr_encode_hyper(p, 0LL);\n\t\t*p++ = cpu_to_be32(PNFS_BLOCK_READWRITE_DATA);\n\n\t\tbe->be_tag = EXTENT_COMMITTING;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext_tree_free_commitdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "465-477",
    "snippet": "static void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "arg->layoutupdate_page"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg->layoutupdate_pages"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "buffer_size",
            "PAGE_SIZE"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}"
  },
  {
    "function_name": "ext_tree_mark_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "391-463",
    "snippet": "int\next_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,\n\t\tsector_t len)\n{\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tsector_t end = start + len;\n\tstruct pnfs_block_extent *be;\n\tint err = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\t/*\n\t * First remove all COW extents or holes from written to range.\n\t */\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Then mark all invalid extents in the range as written to.\n\t */\n\tfor (be = __ext_tree_search(root, start); be; be = ext_tree_next(be)) {\n\t\tif (be->be_f_offset >= end)\n\t\t\tbreak;\n\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA || be->be_tag)\n\t\t\tcontinue;\n\n\t\tif (be->be_f_offset < start) {\n\t\t\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\t\t\tif (left && ext_can_merge(left, be)) {\n\t\t\t\tsector_t diff = start - be->be_f_offset;\n\n\t\t\t\tleft->be_length += diff;\n\n\t\t\t\tbe->be_f_offset += diff;\n\t\t\t\tbe->be_v_offset += diff;\n\t\t\t\tbe->be_length -= diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, start);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext_f_end(be) > end) {\n\t\t\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\t\t\tif (right && ext_can_merge(be, right)) {\n\t\t\t\tsector_t diff = end - be->be_f_offset;\n\n\t\t\t\tbe->be_length -= diff;\n\n\t\t\t\tright->be_f_offset -= diff;\n\t\t\t\tright->be_v_offset -= diff;\n\t\t\t\tright->be_length += diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, end);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (be->be_f_offset >= start && ext_f_end(be) <= end) {\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t}\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_right",
          "args": [
            "root",
            "be"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "109-122",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_left",
          "args": [
            "root",
            "be"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "93-107",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_split",
          "args": [
            "root",
            "be",
            "end"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "366-389",
          "snippet": "static int\next_tree_split(struct rb_root *root, struct pnfs_block_extent *be,\n\t\tsector_t split)\n{\n\tstruct pnfs_block_extent *new;\n\tsector_t orig_len = be->be_length;\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tbe->be_length = split - be->be_f_offset;\n\n\tnew->be_f_offset = split;\n\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\tnew->be_v_offset = be->be_v_offset + be->be_length;\n\tnew->be_length = orig_len - be->be_length;\n\tnew->be_state = be->be_state;\n\tnew->be_tag = be->be_tag;\n\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t__ext_tree_insert(root, new, false);\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int\next_tree_split(struct rb_root *root, struct pnfs_block_extent *be,\n\t\tsector_t split)\n{\n\tstruct pnfs_block_extent *new;\n\tsector_t orig_len = be->be_length;\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tbe->be_length = split - be->be_f_offset;\n\n\tnew->be_f_offset = split;\n\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\tnew->be_v_offset = be->be_v_offset + be->be_length;\n\tnew->be_length = orig_len - be->be_length;\n\tnew->be_state = be->be_state;\n\tnew->be_tag = be->be_tag;\n\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t__ext_tree_insert(root, new, false);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_can_merge",
          "args": [
            "be",
            "right"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ext_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "71-91",
          "snippet": "static bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_prev",
          "args": [
            "be"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "24-29",
          "snippet": "static struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_search",
          "args": [
            "root",
            "start"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "44-69",
          "snippet": "static struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_remove",
          "args": [
            "&bl->bl_ext_ro",
            "start",
            "end"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "165-241",
          "snippet": "static int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,\n\t\tsector_t len)\n{\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tsector_t end = start + len;\n\tstruct pnfs_block_extent *be;\n\tint err = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\t/*\n\t * First remove all COW extents or holes from written to range.\n\t */\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Then mark all invalid extents in the range as written to.\n\t */\n\tfor (be = __ext_tree_search(root, start); be; be = ext_tree_next(be)) {\n\t\tif (be->be_f_offset >= end)\n\t\t\tbreak;\n\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA || be->be_tag)\n\t\t\tcontinue;\n\n\t\tif (be->be_f_offset < start) {\n\t\t\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\t\t\tif (left && ext_can_merge(left, be)) {\n\t\t\t\tsector_t diff = start - be->be_f_offset;\n\n\t\t\t\tleft->be_length += diff;\n\n\t\t\t\tbe->be_f_offset += diff;\n\t\t\t\tbe->be_v_offset += diff;\n\t\t\t\tbe->be_length -= diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, start);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext_f_end(be) > end) {\n\t\t\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\t\t\tif (right && ext_can_merge(be, right)) {\n\t\t\t\tsector_t diff = end - be->be_f_offset;\n\n\t\t\t\tbe->be_length -= diff;\n\n\t\t\t\tright->be_f_offset -= diff;\n\t\t\t\tright->be_v_offset -= diff;\n\t\t\t\tright->be_length += diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, end);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (be->be_f_offset >= start && ext_f_end(be) <= end) {\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t}\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "ext_tree_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "366-389",
    "snippet": "static int\next_tree_split(struct rb_root *root, struct pnfs_block_extent *be,\n\t\tsector_t split)\n{\n\tstruct pnfs_block_extent *new;\n\tsector_t orig_len = be->be_length;\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tbe->be_length = split - be->be_f_offset;\n\n\tnew->be_f_offset = split;\n\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\tnew->be_v_offset = be->be_v_offset + be->be_length;\n\tnew->be_length = orig_len - be->be_length;\n\tnew->be_state = be->be_state;\n\tnew->be_tag = be->be_tag;\n\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t__ext_tree_insert(root, new, false);\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext_tree_insert",
          "args": [
            "root",
            "new",
            "false"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "124-163",
          "snippet": "static void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_deviceid",
          "args": [
            "be->be_device"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "357-362",
          "snippet": "static inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int\next_tree_split(struct rb_root *root, struct pnfs_block_extent *be,\n\t\tsector_t split)\n{\n\tstruct pnfs_block_extent *new;\n\tsector_t orig_len = be->be_length;\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tbe->be_length = split - be->be_f_offset;\n\n\tnew->be_f_offset = split;\n\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\tnew->be_v_offset = be->be_v_offset + be->be_length;\n\tnew->be_length = orig_len - be->be_length;\n\tnew->be_state = be->be_state;\n\tnew->be_tag = be->be_tag;\n\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t__ext_tree_insert(root, new, false);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext_tree_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "349-364",
    "snippet": "int ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_remove",
          "args": [
            "&bl->bl_ext_rw",
            "start",
            "end"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "165-241",
          "snippet": "static int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "333-347",
    "snippet": "bool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_lookup",
          "args": [
            "&bl->bl_ext_rw",
            "isect",
            "ret"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "310-331",
          "snippet": "static bool\n__ext_tree_lookup(struct rb_root *root, sector_t isect,\n\t\tstruct pnfs_block_extent *ret)\n{\n\tstruct rb_node *node;\n\tstruct pnfs_block_extent *be;\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (isect < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (isect >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*ret = *be;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\n__ext_tree_lookup(struct rb_root *root, sector_t isect,\n\t\tstruct pnfs_block_extent *ret)\n{\n\tstruct rb_node *node;\n\tstruct pnfs_block_extent *be;\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (isect < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (isect >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*ret = *be;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nbool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}"
  },
  {
    "function_name": "__ext_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "310-331",
    "snippet": "static bool\n__ext_tree_lookup(struct rb_root *root, sector_t isect,\n\t\tstruct pnfs_block_extent *ret)\n{\n\tstruct rb_node *node;\n\tstruct pnfs_block_extent *be;\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (isect < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (isect >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*ret = *be;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "node"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\n__ext_tree_lookup(struct rb_root *root, sector_t isect,\n\t\tstruct pnfs_block_extent *ret)\n{\n\tstruct rb_node *node;\n\tstruct pnfs_block_extent *be;\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (isect < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (isect >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*ret = *be;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "ext_tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "243-308",
    "snippet": "int\next_tree_insert(struct pnfs_block_layout *bl, struct pnfs_block_extent *new)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct rb_root *root;\n\tint err = 0;\n\n\tswitch (new->be_state) {\n\tcase PNFS_BLOCK_READWRITE_DATA:\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\troot = &bl->bl_ext_rw;\n\t\tbreak;\n\tcase PNFS_BLOCK_READ_DATA:\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\troot = &bl->bl_ext_ro;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"invalid extent type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bl->bl_ext_lock);\nretry:\n\tbe = __ext_tree_search(root, new->be_f_offset);\n\tif (!be || be->be_f_offset >= ext_f_end(new)) {\n\t\t__ext_tree_insert(root, new, true);\n\t} else if (new->be_f_offset >= be->be_f_offset) {\n\t\tif (ext_f_end(new) <= ext_f_end(be)) {\n\t\t\tnfs4_put_deviceid_node(new->be_device);\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\t\tsector_t diff = new->be_length - new_len;\n\n\t\t\tnew->be_f_offset += diff;\n\t\t\tnew->be_v_offset += diff;\n\t\t\tnew->be_length = new_len;\n\t\t\tgoto retry;\n\t\t}\n\t} else if (ext_f_end(new) <= ext_f_end(be)) {\n\t\tnew->be_length = be->be_f_offset - new->be_f_offset;\n\t\t__ext_tree_insert(root, new, true);\n\t} else {\n\t\tstruct pnfs_block_extent *split;\n\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\tsector_t diff = new->be_length - new_len;\n\n\t\tsplit = kmemdup(new, sizeof(*new), GFP_ATOMIC);\n\t\tif (!split) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsplit->be_length = be->be_f_offset - split->be_f_offset;\n\t\tsplit->be_device = nfs4_get_deviceid(new->be_device);\n\t\t__ext_tree_insert(root, split, true);\n\n\t\tnew->be_f_offset += diff;\n\t\tnew->be_v_offset += diff;\n\t\tnew->be_length = new_len;\n\t\tgoto retry;\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_insert",
          "args": [
            "root",
            "split",
            "true"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "124-163",
          "snippet": "static void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_deviceid",
          "args": [
            "new->be_device"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "357-362",
          "snippet": "static inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "new",
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "new->be_device"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_search",
          "args": [
            "root",
            "new->be_f_offset"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "44-69",
          "snippet": "static struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"invalid extent type\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_insert(struct pnfs_block_layout *bl, struct pnfs_block_extent *new)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct rb_root *root;\n\tint err = 0;\n\n\tswitch (new->be_state) {\n\tcase PNFS_BLOCK_READWRITE_DATA:\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\troot = &bl->bl_ext_rw;\n\t\tbreak;\n\tcase PNFS_BLOCK_READ_DATA:\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\troot = &bl->bl_ext_ro;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"invalid extent type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bl->bl_ext_lock);\nretry:\n\tbe = __ext_tree_search(root, new->be_f_offset);\n\tif (!be || be->be_f_offset >= ext_f_end(new)) {\n\t\t__ext_tree_insert(root, new, true);\n\t} else if (new->be_f_offset >= be->be_f_offset) {\n\t\tif (ext_f_end(new) <= ext_f_end(be)) {\n\t\t\tnfs4_put_deviceid_node(new->be_device);\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\t\tsector_t diff = new->be_length - new_len;\n\n\t\t\tnew->be_f_offset += diff;\n\t\t\tnew->be_v_offset += diff;\n\t\t\tnew->be_length = new_len;\n\t\t\tgoto retry;\n\t\t}\n\t} else if (ext_f_end(new) <= ext_f_end(be)) {\n\t\tnew->be_length = be->be_f_offset - new->be_f_offset;\n\t\t__ext_tree_insert(root, new, true);\n\t} else {\n\t\tstruct pnfs_block_extent *split;\n\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\tsector_t diff = new->be_length - new_len;\n\n\t\tsplit = kmemdup(new, sizeof(*new), GFP_ATOMIC);\n\t\tif (!split) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsplit->be_length = be->be_f_offset - split->be_f_offset;\n\t\tsplit->be_device = nfs4_get_deviceid(new->be_device);\n\t\t__ext_tree_insert(root, split, true);\n\n\t\tnew->be_f_offset += diff;\n\t\tnew->be_v_offset += diff;\n\t\tnew->be_length = new_len;\n\t\tgoto retry;\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext_tree_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "165-241",
    "snippet": "static int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "be"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "be->be_device"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&be->be_node",
            "root"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext_tree_insert",
          "args": [
            "root",
            "new",
            "true"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "124-163",
          "snippet": "static void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_deviceid",
          "args": [
            "be->be_device"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "357-362",
          "snippet": "static inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext_tree_search",
          "args": [
            "root",
            "start"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__ext_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "44-69",
          "snippet": "static struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic int\n__ext_tree_remove(struct rb_root *root, sector_t start, sector_t end)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ext_tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "124-163",
    "snippet": "static void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "new->be_device"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->be_node",
            "root"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->be_node",
            "parent",
            "p"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_right",
          "args": [
            "root",
            "be"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "109-122",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_can_merge",
          "args": [
            "be",
            "new"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ext_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "71-91",
          "snippet": "static bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_try_to_merge_left",
          "args": [
            "root",
            "be"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ext_try_to_merge_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "93-107",
          "snippet": "static struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "parent"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}"
  },
  {
    "function_name": "ext_try_to_merge_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "109-122",
    "snippet": "static struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "right"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "right->be_device"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&right->be_node",
            "root"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_can_merge",
          "args": [
            "be",
            "right"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ext_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "71-91",
          "snippet": "static bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}"
  },
  {
    "function_name": "ext_try_to_merge_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "93-107",
    "snippet": "static struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "be"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "be->be_device"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&be->be_node",
            "root"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_can_merge",
          "args": [
            "left",
            "be"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ext_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "71-91",
          "snippet": "static bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_prev",
          "args": [
            "be"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "24-29",
          "snippet": "static struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}"
  },
  {
    "function_name": "ext_can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "71-91",
    "snippet": "static bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__ext_tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "44-69",
    "snippet": "static struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_tree_next",
          "args": [
            "be"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "31-36",
          "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_f_end",
          "args": [
            "be"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ext_f_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "38-42",
          "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "node"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext_f_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "38-42",
    "snippet": "static inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}"
  },
  {
    "function_name": "ext_tree_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "31-36",
    "snippet": "static struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "node"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&be->be_node"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
  },
  {
    "function_name": "ext_tree_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "24-29",
    "snippet": "static struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "node"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&be->be_node"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}"
  },
  {
    "function_name": "ext_tree_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "17-22",
    "snippet": "static struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_node",
          "args": [
            "node"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "ext_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "11-15",
          "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}"
  },
  {
    "function_name": "ext_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
    "lines": "11-15",
    "snippet": "static inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structpnfs_block_extent",
            "be_node"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}"
  }
]