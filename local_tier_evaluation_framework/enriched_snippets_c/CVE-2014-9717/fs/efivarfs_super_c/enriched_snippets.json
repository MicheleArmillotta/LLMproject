[
  {
    "function_name": "efivarfs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "256-259",
    "snippet": "static __exit void efivarfs_exit(void)\n{\n\tunregister_filesystem(&efivarfs_type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type efivarfs_type = {\n\t.owner   = THIS_MODULE,\n\t.name    = \"efivarfs\",\n\t.mount   = efivarfs_mount,\n\t.kill_sb = efivarfs_kill_sb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&efivarfs_type"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct file_system_type efivarfs_type = {\n\t.owner   = THIS_MODULE,\n\t.name    = \"efivarfs\",\n\t.mount   = efivarfs_mount,\n\t.kill_sb = efivarfs_kill_sb,\n};\n\nstatic __exit void efivarfs_exit(void)\n{\n\tunregister_filesystem(&efivarfs_type);\n}"
  },
  {
    "function_name": "efivarfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "245-254",
    "snippet": "static __init int efivarfs_init(void)\n{\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn -ENODEV;\n\n\tif (!efivars_kobject())\n\t\treturn -ENODEV;\n\n\treturn register_filesystem(&efivarfs_type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type efivarfs_type = {\n\t.owner   = THIS_MODULE,\n\t.name    = \"efivarfs\",\n\t.mount   = efivarfs_mount,\n\t.kill_sb = efivarfs_kill_sb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&efivarfs_type"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivars_kobject",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efi_enabled",
          "args": [
            "EFI_RUNTIME_SERVICES"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct file_system_type efivarfs_type = {\n\t.owner   = THIS_MODULE,\n\t.name    = \"efivarfs\",\n\t.mount   = efivarfs_mount,\n\t.kill_sb = efivarfs_kill_sb,\n};\n\nstatic __init int efivarfs_init(void)\n{\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn -ENODEV;\n\n\tif (!efivars_kobject())\n\t\treturn -ENODEV;\n\n\treturn register_filesystem(&efivarfs_type);\n}"
  },
  {
    "function_name": "efivarfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "229-236",
    "snippet": "static void efivarfs_kill_sb(struct super_block *sb)\n{\n\tkill_litter_super(sb);\n\tefivarfs_sb = NULL;\n\n\t/* Remove all entries and destroy */\n\t__efivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *efivarfs_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__efivar_entry_iter",
          "args": [
            "efivarfs_destroy",
            "&efivarfs_list",
            "NULL",
            "NULL"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct super_block *efivarfs_sb;\n\nstatic void efivarfs_kill_sb(struct super_block *sb)\n{\n\tkill_litter_super(sb);\n\tefivarfs_sb = NULL;\n\n\t/* Remove all entries and destroy */\n\t__efivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL, NULL);\n}"
  },
  {
    "function_name": "efivarfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "223-227",
    "snippet": "static struct dentry *efivarfs_mount(struct file_system_type *fs_type,\n\t\t\t\t    int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, efivarfs_fill_super);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "efivarfs_fill_super"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *efivarfs_mount(struct file_system_type *fs_type,\n\t\t\t\t    int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, efivarfs_fill_super);\n}"
  },
  {
    "function_name": "efivarfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "187-221",
    "snippet": "static int efivarfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode = NULL;\n\tstruct dentry *root;\n\tint err;\n\n\tefivarfs_sb = sb;\n\n\tsb->s_maxbytes          = MAX_LFS_FILESIZE;\n\tsb->s_blocksize         = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits    = PAGE_CACHE_SHIFT;\n\tsb->s_magic             = EFIVARFS_MAGIC;\n\tsb->s_op                = &efivarfs_ops;\n\tsb->s_d_op\t\t= &efivarfs_d_ops;\n\tsb->s_time_gran         = 1;\n\n\tinode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode->i_op = &efivarfs_dir_inode_operations;\n\n\troot = d_make_root(inode);\n\tsb->s_root = root;\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&efivarfs_list);\n\n\terr = efivar_init(efivarfs_callback, (void *)sb, false,\n\t\t\t  true, &efivarfs_list);\n\tif (err)\n\t\t__efivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL, NULL);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations efivarfs_ops = {\n\t.statfs = simple_statfs,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = efivarfs_evict_inode,\n\t.show_options = generic_show_options,\n};",
      "static struct super_block *efivarfs_sb;",
      "static const struct dentry_operations efivarfs_d_ops = {\n\t.d_compare = efivarfs_d_compare,\n\t.d_hash = efivarfs_d_hash,\n\t.d_delete = always_delete_dentry,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__efivar_entry_iter",
          "args": [
            "efivarfs_destroy",
            "&efivarfs_list",
            "NULL",
            "NULL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivar_init",
          "args": [
            "efivarfs_callback",
            "(void *)sb",
            "false",
            "true",
            "&efivarfs_list"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&efivarfs_list"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivarfs_get_inode",
          "args": [
            "sb",
            "NULL",
            "S_IFDIR | 0755",
            "0"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "17-38",
          "snippet": "struct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nconst struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};\n\nstruct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic const struct super_operations efivarfs_ops = {\n\t.statfs = simple_statfs,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = efivarfs_evict_inode,\n\t.show_options = generic_show_options,\n};\nstatic struct super_block *efivarfs_sb;\nstatic const struct dentry_operations efivarfs_d_ops = {\n\t.d_compare = efivarfs_d_compare,\n\t.d_hash = efivarfs_d_hash,\n\t.d_delete = always_delete_dentry,\n};\n\nstatic int efivarfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode = NULL;\n\tstruct dentry *root;\n\tint err;\n\n\tefivarfs_sb = sb;\n\n\tsb->s_maxbytes          = MAX_LFS_FILESIZE;\n\tsb->s_blocksize         = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits    = PAGE_CACHE_SHIFT;\n\tsb->s_magic             = EFIVARFS_MAGIC;\n\tsb->s_op                = &efivarfs_ops;\n\tsb->s_d_op\t\t= &efivarfs_d_ops;\n\tsb->s_time_gran         = 1;\n\n\tinode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode->i_op = &efivarfs_dir_inode_operations;\n\n\troot = d_make_root(inode);\n\tsb->s_root = root;\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&efivarfs_list);\n\n\terr = efivar_init(efivarfs_callback, (void *)sb, false,\n\t\t\t  true, &efivarfs_list);\n\tif (err)\n\t\t__efivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL, NULL);\n\n\treturn err;\n}"
  },
  {
    "function_name": "efivarfs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "180-185",
    "snippet": "static int efivarfs_destroy(struct efivar_entry *entry, void *data)\n{\n\tefivar_entry_remove(entry);\n\tkfree(entry);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivar_entry_remove",
          "args": [
            "entry"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic int efivarfs_destroy(struct efivar_entry *entry, void *data)\n{\n\tefivar_entry_remove(entry);\n\tkfree(entry);\n\treturn 0;\n}"
  },
  {
    "function_name": "efivarfs_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "112-178",
    "snippet": "static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,\n\t\t\t     unsigned long name_size, void *data)\n{\n\tstruct super_block *sb = (struct super_block *)data;\n\tstruct efivar_entry *entry;\n\tstruct inode *inode = NULL;\n\tstruct dentry *dentry, *root = sb->s_root;\n\tunsigned long size = 0;\n\tchar *name;\n\tint len, i;\n\tint err = -ENOMEM;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn err;\n\n\tmemcpy(entry->var.VariableName, name16, name_size);\n\tmemcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));\n\n\tlen = ucs2_strlen(entry->var.VariableName);\n\n\t/* name, plus '-', plus GUID, plus NUL*/\n\tname = kmalloc(len + 1 + EFI_VARIABLE_GUID_LEN + 1, GFP_KERNEL);\n\tif (!name)\n\t\tgoto fail;\n\n\tfor (i = 0; i < len; i++)\n\t\tname[i] = entry->var.VariableName[i] & 0xFF;\n\n\tname[len] = '-';\n\n\tefi_guid_to_str(&entry->var.VendorGuid, name + len + 1);\n\n\tname[len + EFI_VARIABLE_GUID_LEN+1] = '\\0';\n\n\tinode = efivarfs_get_inode(sb, root->d_inode, S_IFREG | 0644, 0);\n\tif (!inode)\n\t\tgoto fail_name;\n\n\tdentry = efivarfs_alloc_dentry(root, name);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto fail_inode;\n\t}\n\n\t/* copied by the above to local storage in the dentry. */\n\tkfree(name);\n\n\tefivar_entry_size(entry, &size);\n\tefivar_entry_add(entry, &efivarfs_list);\n\n\tmutex_lock(&inode->i_mutex);\n\tinode->i_private = entry;\n\ti_size_write(inode, size + sizeof(entry->var.Attributes));\n\tmutex_unlock(&inode->i_mutex);\n\td_add(dentry, inode);\n\n\treturn 0;\n\nfail_inode:\n\tiput(inode);\nfail_name:\n\tkfree(name);\nfail:\n\tkfree(entry);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size + sizeof(entry->var.Attributes)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivar_entry_add",
          "args": [
            "entry",
            "&efivarfs_list"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivar_entry_size",
          "args": [
            "entry",
            "&size"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivarfs_alloc_dentry",
          "args": [
            "root",
            "name"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_alloc_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
          "lines": "92-110",
          "snippet": "static struct dentry *efivarfs_alloc_dentry(struct dentry *parent, char *name)\n{\n\tstruct dentry *d;\n\tstruct qstr q;\n\tint err;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\n\terr = efivarfs_d_hash(NULL, &q);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\td = d_alloc(parent, &q);\n\tif (d)\n\t\treturn d;\n\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/ucs2_string.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *efivarfs_alloc_dentry(struct dentry *parent, char *name)\n{\n\tstruct dentry *d;\n\tstruct qstr q;\n\tint err;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\n\terr = efivarfs_d_hash(NULL, &q);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\td = d_alloc(parent, &q);\n\tif (d)\n\t\treturn d;\n\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivarfs_get_inode",
          "args": [
            "sb",
            "root->d_inode",
            "S_IFREG | 0644",
            "0"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "17-38",
          "snippet": "struct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nconst struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};\n\nstruct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efi_guid_to_str",
          "args": [
            "&entry->var.VendorGuid",
            "name + len + 1"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1 + EFI_VARIABLE_GUID_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucs2_strlen",
          "args": [
            "entry->var.VariableName"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(entry->var.VendorGuid)",
            "&vendor",
            "sizeof(efi_guid_t)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->var.VariableName",
            "name16",
            "name_size"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,\n\t\t\t     unsigned long name_size, void *data)\n{\n\tstruct super_block *sb = (struct super_block *)data;\n\tstruct efivar_entry *entry;\n\tstruct inode *inode = NULL;\n\tstruct dentry *dentry, *root = sb->s_root;\n\tunsigned long size = 0;\n\tchar *name;\n\tint len, i;\n\tint err = -ENOMEM;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn err;\n\n\tmemcpy(entry->var.VariableName, name16, name_size);\n\tmemcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));\n\n\tlen = ucs2_strlen(entry->var.VariableName);\n\n\t/* name, plus '-', plus GUID, plus NUL*/\n\tname = kmalloc(len + 1 + EFI_VARIABLE_GUID_LEN + 1, GFP_KERNEL);\n\tif (!name)\n\t\tgoto fail;\n\n\tfor (i = 0; i < len; i++)\n\t\tname[i] = entry->var.VariableName[i] & 0xFF;\n\n\tname[len] = '-';\n\n\tefi_guid_to_str(&entry->var.VendorGuid, name + len + 1);\n\n\tname[len + EFI_VARIABLE_GUID_LEN+1] = '\\0';\n\n\tinode = efivarfs_get_inode(sb, root->d_inode, S_IFREG | 0644, 0);\n\tif (!inode)\n\t\tgoto fail_name;\n\n\tdentry = efivarfs_alloc_dentry(root, name);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto fail_inode;\n\t}\n\n\t/* copied by the above to local storage in the dentry. */\n\tkfree(name);\n\n\tefivar_entry_size(entry, &size);\n\tefivar_entry_add(entry, &efivarfs_list);\n\n\tmutex_lock(&inode->i_mutex);\n\tinode->i_private = entry;\n\ti_size_write(inode, size + sizeof(entry->var.Attributes));\n\tmutex_unlock(&inode->i_mutex);\n\td_add(dentry, inode);\n\n\treturn 0;\n\nfail_inode:\n\tiput(inode);\nfail_name:\n\tkfree(name);\nfail:\n\tkfree(entry);\n\treturn err;\n}"
  },
  {
    "function_name": "efivarfs_alloc_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "92-110",
    "snippet": "static struct dentry *efivarfs_alloc_dentry(struct dentry *parent, char *name)\n{\n\tstruct dentry *d;\n\tstruct qstr q;\n\tint err;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\n\terr = efivarfs_d_hash(NULL, &q);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\td = d_alloc(parent, &q);\n\tif (d)\n\t\treturn d;\n\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&q"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivarfs_d_hash",
          "args": [
            "NULL",
            "&q"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_d_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
          "lines": "66-84",
          "snippet": "static int efivarfs_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long hash = init_name_hash();\n\tconst unsigned char *s = qstr->name;\n\tunsigned int len = qstr->len;\n\n\tif (!efivarfs_valid_name(s, len))\n\t\treturn -EINVAL;\n\n\twhile (len-- > EFI_VARIABLE_GUID_LEN)\n\t\thash = partial_name_hash(*s++, hash);\n\n\t/* GUID is case-insensitive. */\n\twhile (len--)\n\t\thash = partial_name_hash(tolower(*s++), hash);\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/ucs2_string.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic int efivarfs_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long hash = init_name_hash();\n\tconst unsigned char *s = qstr->name;\n\tunsigned int len = qstr->len;\n\n\tif (!efivarfs_valid_name(s, len))\n\t\treturn -EINVAL;\n\n\twhile (len-- > EFI_VARIABLE_GUID_LEN)\n\t\thash = partial_name_hash(*s++, hash);\n\n\t/* GUID is case-insensitive. */\n\twhile (len--)\n\t\thash = partial_name_hash(tolower(*s++), hash);\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *efivarfs_alloc_dentry(struct dentry *parent, char *name)\n{\n\tstruct dentry *d;\n\tstruct qstr q;\n\tint err;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\n\terr = efivarfs_d_hash(NULL, &q);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\td = d_alloc(parent, &q);\n\tif (d)\n\t\treturn d;\n\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "efivarfs_d_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "66-84",
    "snippet": "static int efivarfs_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long hash = init_name_hash();\n\tconst unsigned char *s = qstr->name;\n\tunsigned int len = qstr->len;\n\n\tif (!efivarfs_valid_name(s, len))\n\t\treturn -EINVAL;\n\n\twhile (len-- > EFI_VARIABLE_GUID_LEN)\n\t\thash = partial_name_hash(*s++, hash);\n\n\t/* GUID is case-insensitive. */\n\twhile (len--)\n\t\thash = partial_name_hash(tolower(*s++), hash);\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "tolower(*s++)",
            "hash"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*s++"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "*s++",
            "hash"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivarfs_valid_name",
          "args": [
            "s",
            "len"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "45-80",
          "snippet": "bool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nbool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic int efivarfs_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long hash = init_name_hash();\n\tconst unsigned char *s = qstr->name;\n\tunsigned int len = qstr->len;\n\n\tif (!efivarfs_valid_name(s, len))\n\t\treturn -EINVAL;\n\n\twhile (len-- > EFI_VARIABLE_GUID_LEN)\n\t\thash = partial_name_hash(*s++, hash);\n\n\t/* GUID is case-insensitive. */\n\twhile (len--)\n\t\thash = partial_name_hash(tolower(*s++), hash);\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}"
  },
  {
    "function_name": "efivarfs_d_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "48-64",
    "snippet": "static int efivarfs_d_compare(const struct dentry *parent,\n\t\t\t      const struct dentry *dentry,\n\t\t\t      unsigned int len, const char *str,\n\t\t\t      const struct qstr *name)\n{\n\tint guid = len - EFI_VARIABLE_GUID_LEN;\n\n\tif (name->len != len)\n\t\treturn 1;\n\n\t/* Case-sensitive compare for the variable name */\n\tif (memcmp(str, name->name, guid))\n\t\treturn 1;\n\n\t/* Case-insensitive compare for the GUID */\n\treturn strncasecmp(name->name + guid, str + guid, EFI_VARIABLE_GUID_LEN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "name->name + guid",
            "str + guid",
            "EFI_VARIABLE_GUID_LEN"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str",
            "name->name",
            "guid"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic int efivarfs_d_compare(const struct dentry *parent,\n\t\t\t      const struct dentry *dentry,\n\t\t\t      unsigned int len, const char *str,\n\t\t\t      const struct qstr *name)\n{\n\tint guid = len - EFI_VARIABLE_GUID_LEN;\n\n\tif (name->len != len)\n\t\treturn 1;\n\n\t/* Case-sensitive compare for the variable name */\n\tif (memcmp(str, name->name, guid))\n\t\treturn 1;\n\n\t/* Case-insensitive compare for the GUID */\n\treturn strncasecmp(name->name + guid, str + guid, EFI_VARIABLE_GUID_LEN);\n}"
  },
  {
    "function_name": "efivarfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/super.c",
    "lines": "23-26",
    "snippet": "static void efivarfs_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/ucs2_string.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "960-973",
          "snippet": "void ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n#include <linux/ctype.h>\n\nstatic void efivarfs_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n}"
  }
]