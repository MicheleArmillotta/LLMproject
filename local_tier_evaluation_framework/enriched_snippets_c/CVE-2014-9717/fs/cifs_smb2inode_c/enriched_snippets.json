[
  {
    "function_name": "smb2_set_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "257-273",
    "snippet": "int\nsmb2_set_file_info(struct inode *inode, const char *full_path,\n\t\t   FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tint rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\trc = smb2_open_op_close(xid, tlink_tcon(tlink), cifs_sb, full_path,\n\t\t\t\tFILE_WRITE_ATTRIBUTES, FILE_OPEN, 0, buf,\n\t\t\t\tSMB2_OP_SET_INFO);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tlink_tcon(tlink)",
            "cifs_sb",
            "full_path",
            "FILE_WRITE_ATTRIBUTES",
            "FILE_OPEN",
            "0",
            "buf",
            "SMB2_OP_SET_INFO"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_set_file_info(struct inode *inode, const char *full_path,\n\t\t   FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tint rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\trc = smb2_open_op_close(xid, tlink_tcon(tlink), cifs_sb, full_path,\n\t\t\t\tFILE_WRITE_ATTRIBUTES, FILE_OPEN, 0, buf,\n\t\t\t\tSMB2_OP_SET_INFO);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_set_path_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "246-255",
    "snippet": "int\nsmb2_set_path_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, __u64 size,\n\t\t   struct cifs_sb_info *cifs_sb, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\t  FILE_WRITE_DATA, FILE_OPEN, 0, &eof,\n\t\t\t\t  SMB2_OP_SET_EOF);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path",
            "FILE_WRITE_DATA",
            "FILE_OPEN",
            "0",
            "&eof",
            "SMB2_OP_SET_EOF"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "size"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_set_path_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, __u64 size,\n\t\t   struct cifs_sb_info *cifs_sb, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\t  FILE_WRITE_DATA, FILE_OPEN, 0, &eof,\n\t\t\t\t  SMB2_OP_SET_EOF);\n}"
  },
  {
    "function_name": "smb2_create_hardlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "237-244",
    "snippet": "int\nsmb2_create_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *from_name, const char *to_name,\n\t\t     struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name, cifs_sb,\n\t\t\t\t  FILE_READ_ATTRIBUTES, SMB2_OP_HARDLINK);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_set_path_attr",
          "args": [
            "xid",
            "tcon",
            "from_name",
            "to_name",
            "cifs_sb",
            "FILE_READ_ATTRIBUTES",
            "SMB2_OP_HARDLINK"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_set_path_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "207-226",
          "snippet": "static int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_create_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *from_name, const char *to_name,\n\t\t     struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name, cifs_sb,\n\t\t\t\t  FILE_READ_ATTRIBUTES, SMB2_OP_HARDLINK);\n}"
  },
  {
    "function_name": "smb2_rename_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "228-235",
    "snippet": "int\nsmb2_rename_path(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *from_name, const char *to_name,\n\t\t struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name, cifs_sb,\n\t\t\t\t  DELETE, SMB2_OP_RENAME);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_set_path_attr",
          "args": [
            "xid",
            "tcon",
            "from_name",
            "to_name",
            "cifs_sb",
            "DELETE",
            "SMB2_OP_RENAME"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_set_path_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "207-226",
          "snippet": "static int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_rename_path(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *from_name, const char *to_name,\n\t\t struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name, cifs_sb,\n\t\t\t\t  DELETE, SMB2_OP_RENAME);\n}"
  },
  {
    "function_name": "smb2_set_path_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "207-226",
    "snippet": "static int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb2_to_name"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "from_name",
            "access",
            "FILE_OPEN",
            "0",
            "smb2_to_name",
            "command"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "to_name",
            "cifs_sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, from_name, access,\n\t\t\t\tFILE_OPEN, 0, smb2_to_name, command);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "198-205",
    "snippet": "int\nsmb2_unlink(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\t  CREATE_DELETE_ON_CLOSE | OPEN_REPARSE_POINT,\n\t\t\t\t  NULL, SMB2_OP_DELETE);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "name",
            "DELETE",
            "FILE_OPEN",
            "CREATE_DELETE_ON_CLOSE | OPEN_REPARSE_POINT",
            "NULL",
            "SMB2_OP_DELETE"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_unlink(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\t  CREATE_DELETE_ON_CLOSE | OPEN_REPARSE_POINT,\n\t\t\t\t  NULL, SMB2_OP_DELETE);\n}"
  },
  {
    "function_name": "smb2_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "189-196",
    "snippet": "int\nsmb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\t  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,\n\t\t\t\t  NULL, SMB2_OP_DELETE);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "name",
            "DELETE",
            "FILE_OPEN",
            "CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE",
            "NULL",
            "SMB2_OP_DELETE"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\t  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,\n\t\t\t\t  NULL, SMB2_OP_DELETE);\n}"
  },
  {
    "function_name": "smb2_mkdir_setinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "168-187",
    "snippet": "void\nsmb2_mkdir_setinfo(struct inode *inode, const char *name,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO data;\n\tstruct cifsInodeInfo *cifs_i;\n\tu32 dosattrs;\n\tint tmprc;\n\n\tmemset(&data, 0, sizeof(data));\n\tcifs_i = CIFS_I(inode);\n\tdosattrs = cifs_i->cifsAttrs | ATTR_READONLY;\n\tdata.Attributes = cpu_to_le32(dosattrs);\n\ttmprc = smb2_open_op_close(xid, tcon, cifs_sb, name,\n\t\t\t\t   FILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\t   CREATE_NOT_FILE, &data, SMB2_OP_SET_INFO);\n\tif (tmprc == 0)\n\t\tcifs_i->cifsAttrs = dosattrs;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "name",
            "FILE_WRITE_ATTRIBUTES",
            "FILE_CREATE",
            "CREATE_NOT_FILE",
            "&data",
            "SMB2_OP_SET_INFO"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dosattrs"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid\nsmb2_mkdir_setinfo(struct inode *inode, const char *name,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO data;\n\tstruct cifsInodeInfo *cifs_i;\n\tu32 dosattrs;\n\tint tmprc;\n\n\tmemset(&data, 0, sizeof(data));\n\tcifs_i = CIFS_I(inode);\n\tdosattrs = cifs_i->cifsAttrs | ATTR_READONLY;\n\tdata.Attributes = cpu_to_le32(dosattrs);\n\ttmprc = smb2_open_op_close(xid, tcon, cifs_sb, name,\n\t\t\t\t   FILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\t   CREATE_NOT_FILE, &data, SMB2_OP_SET_INFO);\n\tif (tmprc == 0)\n\t\tcifs_i->cifsAttrs = dosattrs;\n}"
  },
  {
    "function_name": "smb2_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "159-166",
    "snippet": "int\nsmb2_mkdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name,\n\t\t\t\t  FILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\t  CREATE_NOT_FILE, NULL, SMB2_OP_MKDIR);\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "name",
            "FILE_WRITE_ATTRIBUTES",
            "FILE_CREATE",
            "CREATE_NOT_FILE",
            "NULL",
            "SMB2_OP_MKDIR"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_mkdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_open_op_close(xid, tcon, cifs_sb, name,\n\t\t\t\t  FILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\t  CREATE_NOT_FILE, NULL, SMB2_OP_MKDIR);\n}"
  },
  {
    "function_name": "smb2_query_path_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "123-157",
    "snippet": "int\nsmb2_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t     FILE_ALL_INFO *data, bool *adjust_tz, bool *symlink)\n{\n\tint rc;\n\tstruct smb2_file_all_info *smb2_data;\n\n\t*adjust_tz = false;\n\t*symlink = false;\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL)\n\t\treturn -ENOMEM;\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\tFILE_READ_ATTRIBUTES, FILE_OPEN, 0,\n\t\t\t\tsmb2_data, SMB2_OP_QUERY_INFO);\n\tif (rc == -EOPNOTSUPP) {\n\t\t*symlink = true;\n\t\t/* Failed on a symbolic link - query a reparse point info */\n\t\trc = smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\t\tFILE_READ_ATTRIBUTES, FILE_OPEN,\n\t\t\t\t\tOPEN_REPARSE_POINT, smb2_data,\n\t\t\t\t\tSMB2_OP_QUERY_INFO);\n\t}\n\tif (rc)\n\t\tgoto out;\n\n\tmove_smb2_info_to_cifs(data, smb2_data);\nout:\n\tkfree(smb2_data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb2_data"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_smb2_info_to_cifs",
          "args": [
            "data",
            "smb2_data"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "move_smb2_info_to_cifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "113-121",
          "snippet": "void\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_open_op_close",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path",
            "FILE_READ_ATTRIBUTES",
            "FILE_OPEN",
            "OPEN_REPARSE_POINT",
            "smb2_data",
            "SMB2_OP_QUERY_INFO"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_open_op_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "40-111",
          "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smb2_file_all_info) + PATH_MAX * 2",
            "GFP_KERNEL"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t     FILE_ALL_INFO *data, bool *adjust_tz, bool *symlink)\n{\n\tint rc;\n\tstruct smb2_file_all_info *smb2_data;\n\n\t*adjust_tz = false;\n\t*symlink = false;\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL)\n\t\treturn -ENOMEM;\n\n\trc = smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\tFILE_READ_ATTRIBUTES, FILE_OPEN, 0,\n\t\t\t\tsmb2_data, SMB2_OP_QUERY_INFO);\n\tif (rc == -EOPNOTSUPP) {\n\t\t*symlink = true;\n\t\t/* Failed on a symbolic link - query a reparse point info */\n\t\trc = smb2_open_op_close(xid, tcon, cifs_sb, full_path,\n\t\t\t\t\tFILE_READ_ATTRIBUTES, FILE_OPEN,\n\t\t\t\t\tOPEN_REPARSE_POINT, smb2_data,\n\t\t\t\t\tSMB2_OP_QUERY_INFO);\n\t}\n\tif (rc)\n\t\tgoto out;\n\n\tmove_smb2_info_to_cifs(data, smb2_data);\nout:\n\tkfree(smb2_data);\n\treturn rc;\n}"
  },
  {
    "function_name": "move_smb2_info_to_cifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "113-121",
    "snippet": "void\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(size_t)(&src->CurrentByteOffset) - (size_t)src"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}"
  },
  {
    "function_name": "smb2_open_op_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
    "lines": "40-111",
    "snippet": "static int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Invalid command\\n\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_set_info",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "(FILE_BASIC_INFO *)data"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2385-2394",
          "snippet": "int\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_set_eof",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "current->tgid",
            "(__le64 *)data",
            "false"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_set_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2364-2383",
          "snippet": "int\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_set_hardlink",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "(__le16 *)data"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_set_hardlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2333-2362",
          "snippet": "int\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_rename",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "(__le16 *)data"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2301-2331",
          "snippet": "int\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_query_info",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "(struct smb2_file_all_info *)data"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_query_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1529-1538",
          "snippet": "int\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "full_path",
            "cifs_sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t   __u32 desired_access, __u32 create_disposition,\n\t\t   __u32 create_options, void *data, int command)\n{\n\tint rc, tmprc = 0;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = desired_access;\n\toparms.disposition = create_disposition;\n\toparms.create_options = create_options;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_DELETE:\n\t\tbreak;\n\tcase SMB2_OP_QUERY_INFO:\n\t\ttmprc = SMB2_query_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t\tfid.volatile_fid,\n\t\t\t\t\t(struct smb2_file_all_info *)data);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t/*\n\t\t * Directories are created through parameters in the\n\t\t * SMB2_open() call.\n\t\t */\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\ttmprc = SMB2_rename(xid, tcon, fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\ttmprc = SMB2_set_hardlink(xid, tcon, fid.persistent_fid,\n\t\t\t\t\t  fid.volatile_fid, (__le16 *)data);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\ttmprc = SMB2_set_eof(xid, tcon, fid.persistent_fid,\n\t\t\t\t     fid.volatile_fid, current->tgid,\n\t\t\t\t     (__le64 *)data, false);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\ttmprc = SMB2_set_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t      fid.volatile_fid,\n\t\t\t\t      (FILE_BASIC_INFO *)data);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\tbreak;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tif (tmprc)\n\t\trc = tmprc;\n\tkfree(utf16_path);\n\treturn rc;\n}"
  }
]