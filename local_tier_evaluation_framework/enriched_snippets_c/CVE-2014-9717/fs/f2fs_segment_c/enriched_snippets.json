[
  {
    "function_name": "destroy_segment_manager_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2295-2300",
    "snippet": "void destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *discard_entry_slab;",
      "static struct kmem_cache *sit_entry_set_slab;",
      "static struct kmem_cache *inmem_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "inmem_entry_slab"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "discard_entry_slab"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "sit_entry_set_slab"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}"
  },
  {
    "function_name": "create_segment_manager_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2269-2293",
    "snippet": "int __init create_segment_manager_caches(void)\n{\n\tdiscard_entry_slab = f2fs_kmem_cache_create(\"discard_entry\",\n\t\t\tsizeof(struct discard_entry));\n\tif (!discard_entry_slab)\n\t\tgoto fail;\n\n\tsit_entry_set_slab = f2fs_kmem_cache_create(\"sit_entry_set\",\n\t\t\tsizeof(struct sit_entry_set));\n\tif (!sit_entry_set_slab)\n\t\tgoto destory_discard_entry;\n\n\tinmem_entry_slab = f2fs_kmem_cache_create(\"inmem_page_entry\",\n\t\t\tsizeof(struct inmem_pages));\n\tif (!inmem_entry_slab)\n\t\tgoto destroy_sit_entry_set;\n\treturn 0;\n\ndestroy_sit_entry_set:\n\tkmem_cache_destroy(sit_entry_set_slab);\ndestory_discard_entry:\n\tkmem_cache_destroy(discard_entry_slab);\nfail:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *discard_entry_slab;",
      "static struct kmem_cache *sit_entry_set_slab;",
      "static struct kmem_cache *inmem_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "discard_entry_slab"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "sit_entry_set_slab"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_create",
          "args": [
            "\"inmem_page_entry\"",
            "sizeof(struct inmem_pages)"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1058-1062",
          "snippet": "static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nint __init create_segment_manager_caches(void)\n{\n\tdiscard_entry_slab = f2fs_kmem_cache_create(\"discard_entry\",\n\t\t\tsizeof(struct discard_entry));\n\tif (!discard_entry_slab)\n\t\tgoto fail;\n\n\tsit_entry_set_slab = f2fs_kmem_cache_create(\"sit_entry_set\",\n\t\t\tsizeof(struct sit_entry_set));\n\tif (!sit_entry_set_slab)\n\t\tgoto destory_discard_entry;\n\n\tinmem_entry_slab = f2fs_kmem_cache_create(\"inmem_page_entry\",\n\t\t\tsizeof(struct inmem_pages));\n\tif (!inmem_entry_slab)\n\t\tgoto destroy_sit_entry_set;\n\treturn 0;\n\ndestroy_sit_entry_set:\n\tkmem_cache_destroy(sit_entry_set_slab);\ndestory_discard_entry:\n\tkmem_cache_destroy(discard_entry_slab);\nfail:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "destroy_segment_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2254-2267",
    "snippet": "void destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sm_info"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_sit_info",
          "args": [
            "sbi"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2229-2252",
          "snippet": "static void destroy_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int start;\n\n\tif (!sit_i)\n\t\treturn;\n\n\tif (sit_i->sentries) {\n\t\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\t\tkfree(sit_i->sentries[start].cur_valid_map);\n\t\t\tkfree(sit_i->sentries[start].ckpt_valid_map);\n\t\t}\n\t}\n\tkfree(sit_i->tmp_map);\n\n\tvfree(sit_i->sentries);\n\tvfree(sit_i->sec_entries);\n\tkfree(sit_i->dirty_sentries_bitmap);\n\n\tSM_I(sbi)->sit_info = NULL;\n\tkfree(sit_i->sit_bitmap);\n\tkfree(sit_i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int start;\n\n\tif (!sit_i)\n\t\treturn;\n\n\tif (sit_i->sentries) {\n\t\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\t\tkfree(sit_i->sentries[start].cur_valid_map);\n\t\t\tkfree(sit_i->sentries[start].ckpt_valid_map);\n\t\t}\n\t}\n\tkfree(sit_i->tmp_map);\n\n\tvfree(sit_i->sentries);\n\tvfree(sit_i->sec_entries);\n\tkfree(sit_i->dirty_sentries_bitmap);\n\n\tSM_I(sbi)->sit_info = NULL;\n\tkfree(sit_i->sit_bitmap);\n\tkfree(sit_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_free_segmap",
          "args": [
            "sbi"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_free_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2218-2227",
          "snippet": "static void destroy_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i = SM_I(sbi)->free_info;\n\tif (!free_i)\n\t\treturn;\n\tSM_I(sbi)->free_info = NULL;\n\tkfree(free_i->free_segmap);\n\tkfree(free_i->free_secmap);\n\tkfree(free_i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i = SM_I(sbi)->free_info;\n\tif (!free_i)\n\t\treturn;\n\tSM_I(sbi)->free_info = NULL;\n\tkfree(free_i->free_segmap);\n\tkfree(free_i->free_secmap);\n\tkfree(free_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_curseg",
          "args": [
            "sbi"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2205-2216",
          "snippet": "static void destroy_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array = SM_I(sbi)->curseg_array;\n\tint i;\n\n\tif (!array)\n\t\treturn;\n\tSM_I(sbi)->curseg_array = NULL;\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tkfree(array[i].sum_blk);\n\tkfree(array);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array = SM_I(sbi)->curseg_array;\n\tint i;\n\n\tif (!array)\n\t\treturn;\n\tSM_I(sbi)->curseg_array = NULL;\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tkfree(array[i].sum_blk);\n\tkfree(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_dirty_segmap",
          "args": [
            "sbi"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_dirty_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2188-2203",
          "snippet": "static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tif (!dirty_i)\n\t\treturn;\n\n\t/* discard pre-free/dirty segments list */\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++)\n\t\tdiscard_dirty_segmap(sbi, i);\n\n\tdestroy_victim_secmap(sbi);\n\tSM_I(sbi)->dirty_info = NULL;\n\tkfree(dirty_i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tif (!dirty_i)\n\t\treturn;\n\n\t/* discard pre-free/dirty segments list */\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++)\n\t\tdiscard_dirty_segmap(sbi, i);\n\n\tdestroy_victim_secmap(sbi);\n\tSM_I(sbi)->dirty_info = NULL;\n\tkfree(dirty_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_flush_cmd_control",
          "args": [
            "sbi"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_flush_cmd_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "371-379",
          "snippet": "void destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}"
  },
  {
    "function_name": "destroy_sit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2229-2252",
    "snippet": "static void destroy_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int start;\n\n\tif (!sit_i)\n\t\treturn;\n\n\tif (sit_i->sentries) {\n\t\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\t\tkfree(sit_i->sentries[start].cur_valid_map);\n\t\t\tkfree(sit_i->sentries[start].ckpt_valid_map);\n\t\t}\n\t}\n\tkfree(sit_i->tmp_map);\n\n\tvfree(sit_i->sentries);\n\tvfree(sit_i->sec_entries);\n\tkfree(sit_i->dirty_sentries_bitmap);\n\n\tSM_I(sbi)->sit_info = NULL;\n\tkfree(sit_i->sit_bitmap);\n\tkfree(sit_i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i->sit_bitmap"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i->dirty_sentries_bitmap"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sit_i->sec_entries"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sit_i->sentries"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i->tmp_map"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i->sentries[start].ckpt_valid_map"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sit_i->sentries[start].cur_valid_map"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int start;\n\n\tif (!sit_i)\n\t\treturn;\n\n\tif (sit_i->sentries) {\n\t\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\t\tkfree(sit_i->sentries[start].cur_valid_map);\n\t\t\tkfree(sit_i->sentries[start].ckpt_valid_map);\n\t\t}\n\t}\n\tkfree(sit_i->tmp_map);\n\n\tvfree(sit_i->sentries);\n\tvfree(sit_i->sec_entries);\n\tkfree(sit_i->dirty_sentries_bitmap);\n\n\tSM_I(sbi)->sit_info = NULL;\n\tkfree(sit_i->sit_bitmap);\n\tkfree(sit_i);\n}"
  },
  {
    "function_name": "destroy_free_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2218-2227",
    "snippet": "static void destroy_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i = SM_I(sbi)->free_info;\n\tif (!free_i)\n\t\treturn;\n\tSM_I(sbi)->free_info = NULL;\n\tkfree(free_i->free_segmap);\n\tkfree(free_i->free_secmap);\n\tkfree(free_i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free_i"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free_i->free_secmap"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free_i->free_segmap"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i = SM_I(sbi)->free_info;\n\tif (!free_i)\n\t\treturn;\n\tSM_I(sbi)->free_info = NULL;\n\tkfree(free_i->free_segmap);\n\tkfree(free_i->free_secmap);\n\tkfree(free_i);\n}"
  },
  {
    "function_name": "destroy_curseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2205-2216",
    "snippet": "static void destroy_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array = SM_I(sbi)->curseg_array;\n\tint i;\n\n\tif (!array)\n\t\treturn;\n\tSM_I(sbi)->curseg_array = NULL;\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tkfree(array[i].sum_blk);\n\tkfree(array);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array[i].sum_blk"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array = SM_I(sbi)->curseg_array;\n\tint i;\n\n\tif (!array)\n\t\treturn;\n\tSM_I(sbi)->curseg_array = NULL;\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tkfree(array[i].sum_blk);\n\tkfree(array);\n}"
  },
  {
    "function_name": "destroy_dirty_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2188-2203",
    "snippet": "static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tif (!dirty_i)\n\t\treturn;\n\n\t/* discard pre-free/dirty segments list */\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++)\n\t\tdiscard_dirty_segmap(sbi, i);\n\n\tdestroy_victim_secmap(sbi);\n\tSM_I(sbi)->dirty_info = NULL;\n\tkfree(dirty_i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dirty_i"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_victim_secmap",
          "args": [
            "sbi"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_victim_secmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2182-2186",
          "snippet": "static void destroy_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tkfree(dirty_i->victim_secmap);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tkfree(dirty_i->victim_secmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_dirty_segmap",
          "args": [
            "sbi",
            "i"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "discard_dirty_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2171-2180",
          "snippet": "static void discard_dirty_segmap(struct f2fs_sb_info *sbi,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tkfree(dirty_i->dirty_segmap[dirty_type]);\n\tdirty_i->nr_dirty[dirty_type] = 0;\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void discard_dirty_segmap(struct f2fs_sb_info *sbi,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tkfree(dirty_i->dirty_segmap[dirty_type]);\n\tdirty_i->nr_dirty[dirty_type] = 0;\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tif (!dirty_i)\n\t\treturn;\n\n\t/* discard pre-free/dirty segments list */\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++)\n\t\tdiscard_dirty_segmap(sbi, i);\n\n\tdestroy_victim_secmap(sbi);\n\tSM_I(sbi)->dirty_info = NULL;\n\tkfree(dirty_i);\n}"
  },
  {
    "function_name": "destroy_victim_secmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2182-2186",
    "snippet": "static void destroy_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tkfree(dirty_i->victim_secmap);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dirty_i->victim_secmap"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void destroy_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tkfree(dirty_i->victim_secmap);\n}"
  },
  {
    "function_name": "discard_dirty_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2171-2180",
    "snippet": "static void discard_dirty_segmap(struct f2fs_sb_info *sbi,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tkfree(dirty_i->dirty_segmap[dirty_type]);\n\tdirty_i->nr_dirty[dirty_type] = 0;\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dirty_i->dirty_segmap[dirty_type]"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void discard_dirty_segmap(struct f2fs_sb_info *sbi,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tkfree(dirty_i->dirty_segmap[dirty_type]);\n\tdirty_i->nr_dirty[dirty_type] = 0;\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
  },
  {
    "function_name": "build_segment_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2109-2169",
    "snippet": "int build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\n\tINIT_LIST_HEAD(&sm_info->discard_list);\n\tsm_info->nr_discards = 0;\n\tsm_info->max_discards = 0;\n\n\tsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\tbuild_sit_entries(sbi);\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_min_max_mtime",
          "args": [
            "sbi"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "init_min_max_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2084-2107",
          "snippet": "static void init_min_max_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tsit_i->min_mtime = LLONG_MAX;\n\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tunsigned int i;\n\t\tunsigned long long mtime = 0;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;\n\n\t\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t\tif (sit_i->min_mtime > mtime)\n\t\t\tsit_i->min_mtime = mtime;\n\t}\n\tsit_i->max_mtime = get_mtime(sbi);\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_min_max_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tsit_i->min_mtime = LLONG_MAX;\n\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tunsigned int i;\n\t\tunsigned long long mtime = 0;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;\n\n\t\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t\tif (sit_i->min_mtime > mtime)\n\t\t\tsit_i->min_mtime = mtime;\n\t}\n\tsit_i->max_mtime = get_mtime(sbi);\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_dirty_segmap",
          "args": [
            "sbi"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "build_dirty_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2056-2079",
          "snippet": "static int build_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i;\n\tunsigned int bitmap_size, i;\n\n\t/* allocate memory for dirty segments list information */\n\tdirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);\n\tif (!dirty_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->dirty_info = dirty_i;\n\tmutex_init(&dirty_i->seglist_lock);\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++) {\n\t\tdirty_i->dirty_segmap[i] = kzalloc(bitmap_size, GFP_KERNEL);\n\t\tif (!dirty_i->dirty_segmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinit_dirty_segmap(sbi);\n\treturn init_victim_secmap(sbi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i;\n\tunsigned int bitmap_size, i;\n\n\t/* allocate memory for dirty segments list information */\n\tdirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);\n\tif (!dirty_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->dirty_info = dirty_i;\n\tmutex_init(&dirty_i->seglist_lock);\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++) {\n\t\tdirty_i->dirty_segmap[i] = kzalloc(bitmap_size, GFP_KERNEL);\n\t\tif (!dirty_i->dirty_segmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinit_dirty_segmap(sbi);\n\treturn init_victim_secmap(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_free_segmap",
          "args": [
            "sbi"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "init_free_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2001-2017",
          "snippet": "static void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_sit_entries",
          "args": [
            "sbi"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "build_sit_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1952-1999",
          "snippet": "static void build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint nrpages = MAX_BIO_BLOCKS(sbi);\n\n\tdo {\n\t\treaded = ra_meta_pages(sbi, start_blk, nrpages, META_SIT);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct seg_entry *se = &sit_i->sentries[start];\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct f2fs_sit_entry sit;\n\t\t\tstruct page *page;\n\n\t\t\tmutex_lock(&curseg->curseg_mutex);\n\t\t\tfor (i = 0; i < sits_in_cursum(sum); i++) {\n\t\t\t\tif (le32_to_cpu(segno_in_journal(sum, i))\n\t\t\t\t\t\t\t\t== start) {\n\t\t\t\t\tsit = sit_in_journal(sum, i);\n\t\t\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\t\t\t\t\tgoto got_it;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\n\t\t\tpage = get_current_sit_page(sbi, start);\n\t\t\tsit_blk = (struct f2fs_sit_block *)page_address(page);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_put_page(page, 1);\ngot_it:\n\t\t\tcheck_block_count(sbi, start, &sit);\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\t\t\tif (sbi->segs_per_sec > 1) {\n\t\t\t\tstruct sec_entry *e = get_sec_entry(sbi, start);\n\t\t\t\te->valid_blocks += se->valid_blocks;\n\t\t\t}\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint nrpages = MAX_BIO_BLOCKS(sbi);\n\n\tdo {\n\t\treaded = ra_meta_pages(sbi, start_blk, nrpages, META_SIT);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct seg_entry *se = &sit_i->sentries[start];\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct f2fs_sit_entry sit;\n\t\t\tstruct page *page;\n\n\t\t\tmutex_lock(&curseg->curseg_mutex);\n\t\t\tfor (i = 0; i < sits_in_cursum(sum); i++) {\n\t\t\t\tif (le32_to_cpu(segno_in_journal(sum, i))\n\t\t\t\t\t\t\t\t== start) {\n\t\t\t\t\tsit = sit_in_journal(sum, i);\n\t\t\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\t\t\t\t\tgoto got_it;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\n\t\t\tpage = get_current_sit_page(sbi, start);\n\t\t\tsit_blk = (struct f2fs_sit_block *)page_address(page);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_put_page(page, 1);\ngot_it:\n\t\t\tcheck_block_count(sbi, start, &sit);\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\t\t\tif (sbi->segs_per_sec > 1) {\n\t\t\t\tstruct sec_entry *e = get_sec_entry(sbi, start);\n\t\t\t\te->valid_blocks += se->valid_blocks;\n\t\t\t}\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_curseg",
          "args": [
            "sbi"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "build_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1930-1950",
          "snippet": "static int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array;\n\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) {\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t}\n\treturn restore_curseg_summaries(sbi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array;\n\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) {\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t}\n\treturn restore_curseg_summaries(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_free_segmap",
          "args": [
            "sbi"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "build_free_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1896-1928",
          "snippet": "static int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = kmalloc(bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = kmalloc(sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = kmalloc(bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = kmalloc(sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_sit_info",
          "args": [
            "sbi"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "build_sit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1823-1894",
          "snippet": "static int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *dst_bitmap;\n\tunsigned int bitmap_size;\n\n\t/* allocate memory for SIT information */\n\tsit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries = vzalloc(MAIN_SEGS(sbi) * sizeof(struct seg_entry));\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tsit_i->sentries[start].ckpt_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tif (!sit_i->sentries[start].cur_valid_map\n\t\t\t\t|| !sit_i->sentries[start].ckpt_valid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (sbi->segs_per_sec > 1) {\n\t\tsit_i->sec_entries = vzalloc(MAIN_SECS(sbi) *\n\t\t\t\t\tsizeof(struct sec_entry));\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tbitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tdst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);\n\tif (!dst_bitmap)\n\t\treturn -ENOMEM;\n\n\t/* init SIT information */\n\tsit_i->s_ops = &default_salloc_ops;\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;\n\tsit_i->written_valid_blocks = le64_to_cpu(ckpt->valid_block_count);\n\tsit_i->sit_bitmap = dst_bitmap;\n\tsit_i->bitmap_size = bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;\n\tmutex_init(&sit_i->sentry_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct segment_allocation default_salloc_ops = {\n\t.allocate_segment = allocate_segment_by_default,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic const struct segment_allocation default_salloc_ops = {\n\t.allocate_segment = allocate_segment_by_default,\n};\n\nstatic int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *dst_bitmap;\n\tunsigned int bitmap_size;\n\n\t/* allocate memory for SIT information */\n\tsit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries = vzalloc(MAIN_SEGS(sbi) * sizeof(struct seg_entry));\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tsit_i->sentries[start].ckpt_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tif (!sit_i->sentries[start].cur_valid_map\n\t\t\t\t|| !sit_i->sentries[start].ckpt_valid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (sbi->segs_per_sec > 1) {\n\t\tsit_i->sec_entries = vzalloc(MAIN_SECS(sbi) *\n\t\t\t\t\tsizeof(struct sec_entry));\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tbitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tdst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);\n\tif (!dst_bitmap)\n\t\treturn -ENOMEM;\n\n\t/* init SIT information */\n\tsit_i->s_ops = &default_salloc_ops;\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;\n\tsit_i->written_valid_blocks = le64_to_cpu(ckpt->valid_block_count);\n\tsit_i->sit_bitmap = dst_bitmap;\n\tsit_i->bitmap_size = bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;\n\tmutex_init(&sit_i->sentry_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_flush_cmd_control",
          "args": [
            "sbi"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "create_flush_cmd_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "347-369",
          "snippet": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sbi->sb"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FLUSH_MERGE"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sm_info->sit_entry_set"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sm_info->discard_list"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->ssa_blkaddr"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct f2fs_sm_info)",
            "GFP_KERNEL"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\n\tINIT_LIST_HEAD(&sm_info->discard_list);\n\tsm_info->nr_discards = 0;\n\tsm_info->max_discards = 0;\n\n\tsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\tbuild_sit_entries(sbi);\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_min_max_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2084-2107",
    "snippet": "static void init_min_max_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tsit_i->min_mtime = LLONG_MAX;\n\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tunsigned int i;\n\t\tunsigned long long mtime = 0;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;\n\n\t\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t\tif (sit_i->min_mtime > mtime)\n\t\t\tsit_i->min_mtime = mtime;\n\t}\n\tsit_i->max_mtime = get_mtime(sbi);\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mtime",
          "args": [
            "sbi"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "get_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "664-669",
          "snippet": "static inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "mtime",
            "sbi->segs_per_sec"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno + i"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_min_max_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tsit_i->min_mtime = LLONG_MAX;\n\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tunsigned int i;\n\t\tunsigned long long mtime = 0;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;\n\n\t\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t\tif (sit_i->min_mtime > mtime)\n\t\t\tsit_i->min_mtime = mtime;\n\t}\n\tsit_i->max_mtime = get_mtime(sbi);\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
  },
  {
    "function_name": "build_dirty_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2056-2079",
    "snippet": "static int build_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i;\n\tunsigned int bitmap_size, i;\n\n\t/* allocate memory for dirty segments list information */\n\tdirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);\n\tif (!dirty_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->dirty_info = dirty_i;\n\tmutex_init(&dirty_i->seglist_lock);\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++) {\n\t\tdirty_i->dirty_segmap[i] = kzalloc(bitmap_size, GFP_KERNEL);\n\t\tif (!dirty_i->dirty_segmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinit_dirty_segmap(sbi);\n\treturn init_victim_secmap(sbi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_victim_secmap",
          "args": [
            "sbi"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "init_victim_secmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2045-2054",
          "snippet": "static int init_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tdirty_i->victim_secmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!dirty_i->victim_secmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int init_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tdirty_i->victim_secmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!dirty_i->victim_secmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dirty_segmap",
          "args": [
            "sbi"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "init_dirty_segmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2019-2043",
          "snippet": "static void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0;\n\tunsigned short valid_blocks;\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\t\tif (valid_blocks == sbi->blocks_per_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > sbi->blocks_per_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0;\n\tunsigned short valid_blocks;\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\t\tif (valid_blocks == sbi->blocks_per_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > sbi->blocks_per_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dirty_seglist_info)",
            "GFP_KERNEL"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i;\n\tunsigned int bitmap_size, i;\n\n\t/* allocate memory for dirty segments list information */\n\tdirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);\n\tif (!dirty_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->dirty_info = dirty_i;\n\tmutex_init(&dirty_i->seglist_lock);\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++) {\n\t\tdirty_i->dirty_segmap[i] = kzalloc(bitmap_size, GFP_KERNEL);\n\t\tif (!dirty_i->dirty_segmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinit_dirty_segmap(sbi);\n\treturn init_victim_secmap(sbi);\n}"
  },
  {
    "function_name": "init_victim_secmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2045-2054",
    "snippet": "static int init_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tdirty_i->victim_secmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!dirty_i->victim_secmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SECS(sbi)"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int init_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tdirty_i->victim_secmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!dirty_i->victim_secmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_dirty_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2019-2043",
    "snippet": "static void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0;\n\tunsigned short valid_blocks;\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\t\tif (valid_blocks == sbi->blocks_per_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > sbi->blocks_per_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__locate_dirty_segment",
          "args": [
            "sbi",
            "segno",
            "DIRTY"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "__locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "381-404",
          "snippet": "static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "1"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "0"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_inuse",
          "args": [
            "free_i",
            "MAIN_SEGS(sbi)",
            "offset"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "318-326",
          "snippet": "static inline unsigned int find_next_inuse(struct free_segmap_info *free_i,\n\t\tunsigned int max, unsigned int segno)\n{\n\tunsigned int ret;\n\tspin_lock(&free_i->segmap_lock);\n\tret = find_next_bit(free_i->free_segmap, max, segno);\n\tspin_unlock(&free_i->segmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int find_next_inuse(struct free_segmap_info *free_i,\n\t\tunsigned int max, unsigned int segno)\n{\n\tunsigned int ret;\n\tspin_lock(&free_i->segmap_lock);\n\tret = find_next_bit(free_i->free_segmap, max, segno);\n\tspin_unlock(&free_i->segmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_I",
          "args": [
            "sbi"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "FREE_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "695-698",
          "snippet": "static inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0;\n\tunsigned short valid_blocks;\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\t\tif (valid_blocks == sbi->blocks_per_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > sbi->blocks_per_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n}"
  },
  {
    "function_name": "init_free_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "2001-2017",
    "snippet": "static void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_test_and_inuse",
          "args": [
            "sbi",
            "curseg_t->segno"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "__set_test_and_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "380-392",
          "snippet": "static inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tspin_lock(&free_i->segmap_lock);\n\tif (!test_and_set_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments--;\n\t\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\t\tfree_i->free_sections--;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tspin_lock(&free_i->segmap_lock);\n\tif (!test_and_set_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments--;\n\t\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\t\tfree_i->free_sections--;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_free",
          "args": [
            "sbi",
            "start"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "__set_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "328-345",
          "snippet": "static inline void __set_free(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tunsigned int start_segno = secno * sbi->segs_per_sec;\n\tunsigned int next;\n\n\tspin_lock(&free_i->segmap_lock);\n\tclear_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments++;\n\n\tnext = find_next_bit(free_i->free_segmap, MAIN_SEGS(sbi), start_segno);\n\tif (next >= start_segno + sbi->segs_per_sec) {\n\t\tclear_bit(secno, free_i->free_secmap);\n\t\tfree_i->free_sections++;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void __set_free(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tunsigned int start_segno = secno * sbi->segs_per_sec;\n\tunsigned int next;\n\n\tspin_lock(&free_i->segmap_lock);\n\tclear_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments++;\n\n\tnext = find_next_bit(free_i->free_segmap, MAIN_SEGS(sbi), start_segno);\n\tif (next >= start_segno + sbi->segs_per_sec) {\n\t\tclear_bit(secno, free_i->free_secmap);\n\t\tfree_i->free_sections++;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "start"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}"
  },
  {
    "function_name": "build_sit_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1952-1999",
    "snippet": "static void build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint nrpages = MAX_BIO_BLOCKS(sbi);\n\n\tdo {\n\t\treaded = ra_meta_pages(sbi, start_blk, nrpages, META_SIT);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct seg_entry *se = &sit_i->sentries[start];\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct f2fs_sit_entry sit;\n\t\t\tstruct page *page;\n\n\t\t\tmutex_lock(&curseg->curseg_mutex);\n\t\t\tfor (i = 0; i < sits_in_cursum(sum); i++) {\n\t\t\t\tif (le32_to_cpu(segno_in_journal(sum, i))\n\t\t\t\t\t\t\t\t== start) {\n\t\t\t\t\tsit = sit_in_journal(sum, i);\n\t\t\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\t\t\t\t\tgoto got_it;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\n\t\t\tpage = get_current_sit_page(sbi, start);\n\t\t\tsit_blk = (struct f2fs_sit_block *)page_address(page);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_put_page(page, 1);\ngot_it:\n\t\t\tcheck_block_count(sbi, start, &sit);\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\t\t\tif (sbi->segs_per_sec > 1) {\n\t\t\t\tstruct sec_entry *e = get_sec_entry(sbi, start);\n\t\t\t\te->valid_blocks += se->valid_blocks;\n\t\t\t}\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_sec_entry",
          "args": [
            "sbi",
            "start"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "get_sec_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "275-280",
          "snippet": "static inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sec_entries[GET_SECNO(sbi, segno)];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sec_entries[GET_SECNO(sbi, segno)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "seg_info_from_raw_sit",
          "args": [
            "se",
            "&sit"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "seg_info_from_raw_sit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "295-304",
          "snippet": "static inline void seg_info_from_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tse->valid_blocks = GET_SIT_VBLOCKS(rs);\n\tse->ckpt_valid_blocks = GET_SIT_VBLOCKS(rs);\n\tmemcpy(se->cur_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tse->type = GET_SIT_TYPE(rs);\n\tse->mtime = le64_to_cpu(rs->mtime);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void seg_info_from_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tse->valid_blocks = GET_SIT_VBLOCKS(rs);\n\tse->ckpt_valid_blocks = GET_SIT_VBLOCKS(rs);\n\tmemcpy(se->cur_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tse->type = GET_SIT_TYPE(rs);\n\tse->mtime = le64_to_cpu(rs->mtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_block_count",
          "args": [
            "sbi",
            "start",
            "&sit"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "check_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "615-625",
          "snippet": "static inline void check_block_count(struct f2fs_sb_info *sbi,\n\t\tint segno, struct f2fs_sit_entry *raw_sit)\n{\n\t/* check segment usage */\n\tif (GET_SIT_VBLOCKS(raw_sit) > sbi->blocks_per_seg)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\t/* check boundary of a given segment number */\n\tif (segno > TOTAL_SEGS(sbi) - 1)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void check_block_count(struct f2fs_sb_info *sbi,\n\t\tint segno, struct f2fs_sit_entry *raw_sit)\n{\n\t/* check segment usage */\n\tif (GET_SIT_VBLOCKS(raw_sit) > sbi->blocks_per_seg)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\t/* check boundary of a given segment number */\n\tif (segno > TOTAL_SEGS(sbi) - 1)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_ENTRY_OFFSET",
          "args": [
            "sit_i",
            "start"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_sit_page",
          "args": [
            "sbi",
            "start"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_sit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1600-1604",
          "snippet": "static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\treturn get_meta_page(sbi, current_sit_addr(sbi, segno));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_current_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\treturn get_meta_page(sbi, current_sit_addr(sbi, segno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sit_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "segno_in_journal(sum, i)"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segno_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sits_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "start_blk",
            "nrpages",
            "META_SIT"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_BIO_BLOCKS",
          "args": [
            "sbi"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_BLK_CNT",
          "args": [
            "sbi"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_COLD_DATA"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint nrpages = MAX_BIO_BLOCKS(sbi);\n\n\tdo {\n\t\treaded = ra_meta_pages(sbi, start_blk, nrpages, META_SIT);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct seg_entry *se = &sit_i->sentries[start];\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct f2fs_sit_entry sit;\n\t\t\tstruct page *page;\n\n\t\t\tmutex_lock(&curseg->curseg_mutex);\n\t\t\tfor (i = 0; i < sits_in_cursum(sum); i++) {\n\t\t\t\tif (le32_to_cpu(segno_in_journal(sum, i))\n\t\t\t\t\t\t\t\t== start) {\n\t\t\t\t\tsit = sit_in_journal(sum, i);\n\t\t\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\t\t\t\t\tgoto got_it;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&curseg->curseg_mutex);\n\n\t\t\tpage = get_current_sit_page(sbi, start);\n\t\t\tsit_blk = (struct f2fs_sit_block *)page_address(page);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_put_page(page, 1);\ngot_it:\n\t\t\tcheck_block_count(sbi, start, &sit);\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\t\t\tif (sbi->segs_per_sec > 1) {\n\t\t\t\tstruct sec_entry *e = get_sec_entry(sbi, start);\n\t\t\t\te->valid_blocks += se->valid_blocks;\n\t\t\t}\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n}"
  },
  {
    "function_name": "build_curseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1930-1950",
    "snippet": "static int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array;\n\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) {\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t}\n\treturn restore_curseg_summaries(sbi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_curseg_summaries",
          "args": [
            "sbi"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "restore_curseg_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1460-1489",
          "snippet": "static int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) {\n\t\tint npages = npages_for_summary_flush(sbi, true);\n\n\t\tif (npages >= 2)\n\t\t\tra_meta_pages(sbi, start_sum_block(sbi), npages,\n\t\t\t\t\t\t\t\tMETA_CP);\n\n\t\t/* restore for compacted data summary */\n\t\tif (read_compacted_summaries(sbi))\n\t\t\treturn -EINVAL;\n\t\ttype = CURSEG_HOT_NODE;\n\t}\n\n\tif (__exist_node_summaries(sbi))\n\t\tra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),\n\t\t\t\t\tNR_CURSEG_TYPE - type, META_CP);\n\n\tfor (; type <= CURSEG_COLD_NODE; type++) {\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) {\n\t\tint npages = npages_for_summary_flush(sbi, true);\n\n\t\tif (npages >= 2)\n\t\t\tra_meta_pages(sbi, start_sum_block(sbi), npages,\n\t\t\t\t\t\t\t\tMETA_CP);\n\n\t\t/* restore for compacted data summary */\n\t\tif (read_compacted_summaries(sbi))\n\t\t\treturn -EINVAL;\n\t\ttype = CURSEG_HOT_NODE;\n\t}\n\n\tif (__exist_node_summaries(sbi))\n\t\tra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),\n\t\t\t\t\tNR_CURSEG_TYPE - type, META_CP);\n\n\tfor (; type <= CURSEG_COLD_NODE; type++) {\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&array[i].curseg_mutex"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "NR_CURSEG_TYPE",
            "sizeof(*array)",
            "GFP_KERNEL"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array;\n\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) {\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t}\n\treturn restore_curseg_summaries(sbi);\n}"
  },
  {
    "function_name": "build_free_segmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1896-1928",
    "snippet": "static int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = kmalloc(bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = kmalloc(sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&free_i->segmap_lock"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SEGNO_FROM_SEG0",
          "args": [
            "sbi",
            "MAIN_BLKADDR(sbi)"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "free_i->free_secmap",
            "0xff",
            "sec_bitmap_size"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "free_i->free_segmap",
            "0xff",
            "bitmap_size"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sec_bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SECS(sbi)"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct free_segmap_info)",
            "GFP_KERNEL"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = kmalloc(bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = kmalloc(sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "build_sit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1823-1894",
    "snippet": "static int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *dst_bitmap;\n\tunsigned int bitmap_size;\n\n\t/* allocate memory for SIT information */\n\tsit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries = vzalloc(MAIN_SEGS(sbi) * sizeof(struct seg_entry));\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tsit_i->sentries[start].ckpt_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tif (!sit_i->sentries[start].cur_valid_map\n\t\t\t\t|| !sit_i->sentries[start].ckpt_valid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (sbi->segs_per_sec > 1) {\n\t\tsit_i->sec_entries = vzalloc(MAIN_SECS(sbi) *\n\t\t\t\t\tsizeof(struct sec_entry));\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tbitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tdst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);\n\tif (!dst_bitmap)\n\t\treturn -ENOMEM;\n\n\t/* init SIT information */\n\tsit_i->s_ops = &default_salloc_ops;\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;\n\tsit_i->written_valid_blocks = le64_to_cpu(ckpt->valid_block_count);\n\tsit_i->sit_bitmap = dst_bitmap;\n\tsit_i->bitmap_size = bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;\n\tmutex_init(&sit_i->sentry_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct segment_allocation default_salloc_ops = {\n\t.allocate_segment = allocate_segment_by_default,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbi->ckpt->elapsed_time"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->sit_blkaddr"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "src_bitmap",
            "bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bitmap_ptr",
          "args": [
            "sbi",
            "SIT_BITMAP"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "923-938",
          "snippet": "static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_size",
          "args": [
            "sbi",
            "SIT_BITMAP"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "910-921",
          "snippet": "static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "MAIN_SECS(sbi) *\n\t\t\t\t\tsizeof(struct sec_entry)"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SIT_VBLOCK_MAP_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SIT_VBLOCK_MAP_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SIT_VBLOCK_MAP_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "MAIN_SEGS(sbi) * sizeof(struct seg_entry)"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct sit_info)",
            "GFP_KERNEL"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic const struct segment_allocation default_salloc_ops = {\n\t.allocate_segment = allocate_segment_by_default,\n};\n\nstatic int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *dst_bitmap;\n\tunsigned int bitmap_size;\n\n\t/* allocate memory for SIT information */\n\tsit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries = vzalloc(MAIN_SEGS(sbi) * sizeof(struct seg_entry));\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tsit_i->sentries[start].ckpt_valid_map\n\t\t\t= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\t\tif (!sit_i->sentries[start].cur_valid_map\n\t\t\t\t|| !sit_i->sentries[start].ckpt_valid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (sbi->segs_per_sec > 1) {\n\t\tsit_i->sec_entries = vzalloc(MAIN_SECS(sbi) *\n\t\t\t\t\tsizeof(struct sec_entry));\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tbitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tdst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);\n\tif (!dst_bitmap)\n\t\treturn -ENOMEM;\n\n\t/* init SIT information */\n\tsit_i->s_ops = &default_salloc_ops;\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;\n\tsit_i->written_valid_blocks = le64_to_cpu(ckpt->valid_block_count);\n\tsit_i->sit_bitmap = dst_bitmap;\n\tsit_i->bitmap_size = bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;\n\tmutex_init(&sit_i->sentry_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_sit_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1719-1821",
    "snippet": "void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned long *bitmap = sit_i->dirty_sentries_bitmap;\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct sit_entry_set *ses, *tmp;\n\tstruct list_head *head = &SM_I(sbi)->sit_entry_set;\n\tbool to_journal = true;\n\tstruct seg_entry *se;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\t/*\n\t * add and account sit entries of dirty bitmap in sit entry\n\t * set temporarily\n\t */\n\tadd_sits_in_set(sbi);\n\n\t/*\n\t * if there are no enough space in journal to store dirty sit\n\t * entries, remove all entries from journal and add and account\n\t * them in sit entry set.\n\t */\n\tif (!__has_cursum_space(sum, sit_i->dirty_sentries, SIT_JOURNAL))\n\t\tremove_sits_in_journal(sbi);\n\n\tif (!sit_i->dirty_sentries)\n\t\tgoto out;\n\n\t/*\n\t * there are two steps to flush sit entries:\n\t * #1, flush sit entries to journal in current cold data summary block.\n\t * #2, flush sit entries to sit page.\n\t */\n\tlist_for_each_entry_safe(ses, tmp, head, set_list) {\n\t\tstruct page *page = NULL;\n\t\tstruct f2fs_sit_block *raw_sit = NULL;\n\t\tunsigned int start_segno = ses->start_segno;\n\t\tunsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\t\tunsigned int segno = start_segno;\n\n\t\tif (to_journal &&\n\t\t\t!__has_cursum_space(sum, ses->entry_cnt, SIT_JOURNAL))\n\t\t\tto_journal = false;\n\n\t\tif (!to_journal) {\n\t\t\tpage = get_next_sit_page(sbi, start_segno);\n\t\t\traw_sit = page_address(page);\n\t\t}\n\n\t\t/* flush dirty sit entries in region of current sit set */\n\t\tfor_each_set_bit_from(segno, bitmap, end) {\n\t\t\tint offset, sit_offset;\n\n\t\t\tse = get_seg_entry(sbi, segno);\n\n\t\t\t/* add discard candidates */\n\t\t\tif (cpc->reason != CP_DISCARD) {\n\t\t\t\tcpc->trim_start = segno;\n\t\t\t\tadd_discard_addrs(sbi, cpc);\n\t\t\t}\n\n\t\t\tif (to_journal) {\n\t\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tSIT_JOURNAL, segno, 1);\n\t\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\t\tsegno_in_journal(sum, offset) =\n\t\t\t\t\t\t\tcpu_to_le32(segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&sit_in_journal(sum, offset));\n\t\t\t} else {\n\t\t\t\tsit_offset = SIT_ENTRY_OFFSET(sit_i, segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t}\n\n\t\t\t__clear_bit(segno, bitmap);\n\t\t\tsit_i->dirty_sentries--;\n\t\t\tses->entry_cnt--;\n\t\t}\n\n\t\tif (!to_journal)\n\t\t\tf2fs_put_page(page, 1);\n\n\t\tf2fs_bug_on(sbi, ses->entry_cnt);\n\t\trelease_sit_entry_set(ses);\n\t}\n\n\tf2fs_bug_on(sbi, !list_empty(head));\n\tf2fs_bug_on(sbi, sit_i->dirty_sentries);\nout:\n\tif (cpc->reason == CP_DISCARD) {\n\t\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)\n\t\t\tadd_discard_addrs(sbi, cpc);\n\t}\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tset_prefree_as_free_segments(sbi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_prefree_as_free_segments",
          "args": [
            "sbi"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "set_prefree_as_free_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "574-583",
          "snippet": "static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))\n\t\t__set_test_and_free(sbi, segno);\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))\n\t\t__set_test_and_free(sbi, segno);\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_discard_addrs",
          "args": [
            "sbi",
            "cpc"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "add_discard_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "501-557",
          "snippet": "static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tint max_blocks = sbi->blocks_per_seg;\n\tstruct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *dmap = SIT_I(sbi)->tmp_map;\n\tunsigned int start = 0, end = -1;\n\tbool force = (cpc->reason == CP_DISCARD);\n\tint i;\n\n\tif (!force && (!test_opt(sbi, DISCARD) ||\n\t\t\tSM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards))\n\t\treturn;\n\n\tif (force && !se->valid_blocks) {\n\t\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\t\t/*\n\t\t * if this segment is registered in the prefree list, then\n\t\t * we should skip adding a discard candidate, and let the\n\t\t * checkpoint do that later.\n\t\t */\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\tif (test_bit(cpc->trim_start, dirty_i->dirty_segmap[PRE])) {\n\t\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t\t\tcpc->trimmed += sbi->blocks_per_seg;\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t\t__add_discard_entry(sbi, cpc, 0, sbi->blocks_per_seg);\n\t\treturn;\n\t}\n\n\t/* zero block will be discarded through the prefree list */\n\tif (!se->valid_blocks || se->valid_blocks == max_blocks)\n\t\treturn;\n\n\t/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */\n\tfor (i = 0; i < entries; i++)\n\t\tdmap[i] = force ? ~ckpt_map[i] :\n\t\t\t\t(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];\n\n\twhile (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {\n\t\tstart = __find_rev_next_bit(dmap, max_blocks, end + 1);\n\t\tif (start >= max_blocks)\n\t\t\tbreak;\n\n\t\tend = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);\n\n\t\tif (end - start < cpc->trim_minlen)\n\t\t\tcontinue;\n\n\t\t__add_discard_entry(sbi, cpc, start, end);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tint max_blocks = sbi->blocks_per_seg;\n\tstruct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *dmap = SIT_I(sbi)->tmp_map;\n\tunsigned int start = 0, end = -1;\n\tbool force = (cpc->reason == CP_DISCARD);\n\tint i;\n\n\tif (!force && (!test_opt(sbi, DISCARD) ||\n\t\t\tSM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards))\n\t\treturn;\n\n\tif (force && !se->valid_blocks) {\n\t\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\t\t/*\n\t\t * if this segment is registered in the prefree list, then\n\t\t * we should skip adding a discard candidate, and let the\n\t\t * checkpoint do that later.\n\t\t */\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\tif (test_bit(cpc->trim_start, dirty_i->dirty_segmap[PRE])) {\n\t\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t\t\tcpc->trimmed += sbi->blocks_per_seg;\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t\t__add_discard_entry(sbi, cpc, 0, sbi->blocks_per_seg);\n\t\treturn;\n\t}\n\n\t/* zero block will be discarded through the prefree list */\n\tif (!se->valid_blocks || se->valid_blocks == max_blocks)\n\t\treturn;\n\n\t/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */\n\tfor (i = 0; i < entries; i++)\n\t\tdmap[i] = force ? ~ckpt_map[i] :\n\t\t\t\t(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];\n\n\twhile (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {\n\t\tstart = __find_rev_next_bit(dmap, max_blocks, end + 1);\n\t\tif (start >= max_blocks)\n\t\t\tbreak;\n\n\t\tend = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);\n\n\t\tif (end - start < cpc->trim_minlen)\n\t\t\tcontinue;\n\n\t\t__add_discard_entry(sbi, cpc, start, end);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "sit_i->dirty_sentries"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!list_empty(head)"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_sit_entry_set",
          "args": [
            "ses"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "release_sit_entry_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1644-1648",
          "snippet": "static void release_sit_entry_set(struct sit_entry_set *ses)\n{\n\tlist_del(&ses->set_list);\n\tkmem_cache_free(sit_entry_set_slab, ses);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sit_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *sit_entry_set_slab;\n\nstatic void release_sit_entry_set(struct sit_entry_set *ses)\n{\n\tlist_del(&ses->set_list);\n\tkmem_cache_free(sit_entry_set_slab, ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ses->entry_cnt"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "segno",
            "bitmap"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seg_info_to_raw_sit",
          "args": [
            "se",
            "&raw_sit->entries[sit_offset]"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "seg_info_to_raw_sit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "306-316",
          "snippet": "static inline void seg_info_to_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tunsigned short raw_vblocks = (se->type << SIT_VBLOCKS_SHIFT) |\n\t\t\t\t\tse->valid_blocks;\n\trs->vblocks = cpu_to_le16(raw_vblocks);\n\tmemcpy(rs->valid_map, se->cur_valid_map, SIT_VBLOCK_MAP_SIZE);\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tse->ckpt_valid_blocks = se->valid_blocks;\n\trs->mtime = cpu_to_le64(se->mtime);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void seg_info_to_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tunsigned short raw_vblocks = (se->type << SIT_VBLOCKS_SHIFT) |\n\t\t\t\t\tse->valid_blocks;\n\trs->vblocks = cpu_to_le16(raw_vblocks);\n\tmemcpy(rs->valid_map, se->cur_valid_map, SIT_VBLOCK_MAP_SIZE);\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tse->ckpt_valid_blocks = se->valid_blocks;\n\trs->mtime = cpu_to_le64(se->mtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_ENTRY_OFFSET",
          "args": [
            "sit_i",
            "segno"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sit_in_journal",
          "args": [
            "sum",
            "offset"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "segno"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segno_in_journal",
          "args": [
            "sum",
            "offset"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "offset < 0"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_journal_in_cursum",
          "args": [
            "sum",
            "SIT_JOURNAL",
            "segno",
            "1"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_journal_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1578-1598",
          "snippet": "int lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit_from",
          "args": [
            "segno",
            "bitmap",
            "end"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_sit_page",
          "args": [
            "sbi",
            "start_segno"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_sit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1606-1632",
          "snippet": "static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *src_page, *dst_page;\n\tpgoff_t src_off, dst_off;\n\tvoid *src_addr, *dst_addr;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\t/* get current sit block page without lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_sit(sit_i, start);\n\n\treturn dst_page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *src_page, *dst_page;\n\tpgoff_t src_off, dst_off;\n\tvoid *src_addr, *dst_addr;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\t/* get current sit block page without lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_sit(sit_i, start);\n\n\treturn dst_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__has_cursum_space",
          "args": [
            "sum",
            "ses->entry_cnt",
            "SIT_JOURNAL"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "__has_cursum_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "197-203",
          "snippet": "static inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "start_segno + SIT_ENTRY_PER_BLOCK",
            "(unsigned long)MAIN_SEGS(sbi)"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ses",
            "tmp",
            "head",
            "set_list"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_sits_in_journal",
          "args": [
            "sbi"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "remove_sits_in_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1696-1713",
          "snippet": "static void remove_sits_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tfor (i = sits_in_cursum(sum) - 1; i >= 0; i--) {\n\t\tunsigned int segno;\n\t\tbool dirtied;\n\n\t\tsegno = le32_to_cpu(segno_in_journal(sum, i));\n\t\tdirtied = __mark_sit_entry_dirty(sbi, segno);\n\n\t\tif (!dirtied)\n\t\t\tadd_sit_entry(segno, &SM_I(sbi)->sit_entry_set);\n\t}\n\tupdate_sits_in_cursum(sum, -sits_in_cursum(sum));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void remove_sits_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tfor (i = sits_in_cursum(sum) - 1; i >= 0; i--) {\n\t\tunsigned int segno;\n\t\tbool dirtied;\n\n\t\tsegno = le32_to_cpu(segno_in_journal(sum, i));\n\t\tdirtied = __mark_sit_entry_dirty(sbi, segno);\n\n\t\tif (!dirtied)\n\t\t\tadd_sit_entry(segno, &SM_I(sbi)->sit_entry_set);\n\t}\n\tupdate_sits_in_cursum(sum, -sits_in_cursum(sum));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_sits_in_set",
          "args": [
            "sbi"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "add_sits_in_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1685-1694",
          "snippet": "static void add_sits_in_set(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\tstruct list_head *set_list = &sm_info->sit_entry_set;\n\tunsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;\n\tunsigned int segno;\n\n\tfor_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))\n\t\tadd_sit_entry(segno, set_list);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_sits_in_set(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\tstruct list_head *set_list = &sm_info->sit_entry_set;\n\tunsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;\n\tunsigned int segno;\n\n\tfor_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))\n\t\tadd_sit_entry(segno, set_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_COLD_DATA"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned long *bitmap = sit_i->dirty_sentries_bitmap;\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct sit_entry_set *ses, *tmp;\n\tstruct list_head *head = &SM_I(sbi)->sit_entry_set;\n\tbool to_journal = true;\n\tstruct seg_entry *se;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\t/*\n\t * add and account sit entries of dirty bitmap in sit entry\n\t * set temporarily\n\t */\n\tadd_sits_in_set(sbi);\n\n\t/*\n\t * if there are no enough space in journal to store dirty sit\n\t * entries, remove all entries from journal and add and account\n\t * them in sit entry set.\n\t */\n\tif (!__has_cursum_space(sum, sit_i->dirty_sentries, SIT_JOURNAL))\n\t\tremove_sits_in_journal(sbi);\n\n\tif (!sit_i->dirty_sentries)\n\t\tgoto out;\n\n\t/*\n\t * there are two steps to flush sit entries:\n\t * #1, flush sit entries to journal in current cold data summary block.\n\t * #2, flush sit entries to sit page.\n\t */\n\tlist_for_each_entry_safe(ses, tmp, head, set_list) {\n\t\tstruct page *page = NULL;\n\t\tstruct f2fs_sit_block *raw_sit = NULL;\n\t\tunsigned int start_segno = ses->start_segno;\n\t\tunsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\t\tunsigned int segno = start_segno;\n\n\t\tif (to_journal &&\n\t\t\t!__has_cursum_space(sum, ses->entry_cnt, SIT_JOURNAL))\n\t\t\tto_journal = false;\n\n\t\tif (!to_journal) {\n\t\t\tpage = get_next_sit_page(sbi, start_segno);\n\t\t\traw_sit = page_address(page);\n\t\t}\n\n\t\t/* flush dirty sit entries in region of current sit set */\n\t\tfor_each_set_bit_from(segno, bitmap, end) {\n\t\t\tint offset, sit_offset;\n\n\t\t\tse = get_seg_entry(sbi, segno);\n\n\t\t\t/* add discard candidates */\n\t\t\tif (cpc->reason != CP_DISCARD) {\n\t\t\t\tcpc->trim_start = segno;\n\t\t\t\tadd_discard_addrs(sbi, cpc);\n\t\t\t}\n\n\t\t\tif (to_journal) {\n\t\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tSIT_JOURNAL, segno, 1);\n\t\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\t\tsegno_in_journal(sum, offset) =\n\t\t\t\t\t\t\tcpu_to_le32(segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&sit_in_journal(sum, offset));\n\t\t\t} else {\n\t\t\t\tsit_offset = SIT_ENTRY_OFFSET(sit_i, segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t}\n\n\t\t\t__clear_bit(segno, bitmap);\n\t\t\tsit_i->dirty_sentries--;\n\t\t\tses->entry_cnt--;\n\t\t}\n\n\t\tif (!to_journal)\n\t\t\tf2fs_put_page(page, 1);\n\n\t\tf2fs_bug_on(sbi, ses->entry_cnt);\n\t\trelease_sit_entry_set(ses);\n\t}\n\n\tf2fs_bug_on(sbi, !list_empty(head));\n\tf2fs_bug_on(sbi, sit_i->dirty_sentries);\nout:\n\tif (cpc->reason == CP_DISCARD) {\n\t\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)\n\t\t\tadd_discard_addrs(sbi, cpc);\n\t}\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tset_prefree_as_free_segments(sbi);\n}"
  },
  {
    "function_name": "remove_sits_in_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1696-1713",
    "snippet": "static void remove_sits_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tfor (i = sits_in_cursum(sum) - 1; i >= 0; i--) {\n\t\tunsigned int segno;\n\t\tbool dirtied;\n\n\t\tsegno = le32_to_cpu(segno_in_journal(sum, i));\n\t\tdirtied = __mark_sit_entry_dirty(sbi, segno);\n\n\t\tif (!dirtied)\n\t\t\tadd_sit_entry(segno, &SM_I(sbi)->sit_entry_set);\n\t}\n\tupdate_sits_in_cursum(sum, -sits_in_cursum(sum));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_sits_in_cursum",
          "args": [
            "sum",
            "-sits_in_cursum(sum)"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "update_sits_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "190-195",
          "snippet": "static inline int update_sits_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = sits_in_cursum(rs);\n\trs->n_sits = cpu_to_le16(before + i);\n\treturn before;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int update_sits_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = sits_in_cursum(rs);\n\trs->n_sits = cpu_to_le16(before + i);\n\treturn before;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sits_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sit_entry",
          "args": [
            "segno",
            "&SM_I(sbi)->sit_entry_set"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "add_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1665-1683",
          "snippet": "static void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_sit_entry_dirty",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_sit_entry_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "625-635",
          "snippet": "static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "segno_in_journal(sum, i)"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segno_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sits_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_COLD_DATA"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void remove_sits_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tfor (i = sits_in_cursum(sum) - 1; i >= 0; i--) {\n\t\tunsigned int segno;\n\t\tbool dirtied;\n\n\t\tsegno = le32_to_cpu(segno_in_journal(sum, i));\n\t\tdirtied = __mark_sit_entry_dirty(sbi, segno);\n\n\t\tif (!dirtied)\n\t\t\tadd_sit_entry(segno, &SM_I(sbi)->sit_entry_set);\n\t}\n\tupdate_sits_in_cursum(sum, -sits_in_cursum(sum));\n}"
  },
  {
    "function_name": "add_sits_in_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1685-1694",
    "snippet": "static void add_sits_in_set(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\tstruct list_head *set_list = &sm_info->sit_entry_set;\n\tunsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;\n\tunsigned int segno;\n\n\tfor_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))\n\t\tadd_sit_entry(segno, set_list);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_sit_entry",
          "args": [
            "segno",
            "set_list"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "add_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1665-1683",
          "snippet": "static void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "segno",
            "bitmap",
            "MAIN_SEGS(sbi)"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_sits_in_set(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\tstruct list_head *set_list = &sm_info->sit_entry_set;\n\tunsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;\n\tunsigned int segno;\n\n\tfor_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))\n\t\tadd_sit_entry(segno, set_list);\n}"
  },
  {
    "function_name": "add_sit_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1665-1683",
    "snippet": "static void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ses->set_list",
            "head"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_sit_entry_set",
          "args": [],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "grab_sit_entry_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1634-1642",
          "snippet": "static struct sit_entry_set *grab_sit_entry_set(void)\n{\n\tstruct sit_entry_set *ses =\n\t\t\tf2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_ATOMIC);\n\n\tses->entry_cnt = 0;\n\tINIT_LIST_HEAD(&ses->set_list);\n\treturn ses;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sit_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *sit_entry_set_slab;\n\nstatic struct sit_entry_set *grab_sit_entry_set(void)\n{\n\tstruct sit_entry_set *ses =\n\t\t\tf2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_ATOMIC);\n\n\tses->entry_cnt = 0;\n\tINIT_LIST_HEAD(&ses->set_list);\n\treturn ses;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_sit_entry_set",
          "args": [
            "ses",
            "head"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_sit_entry_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1650-1663",
          "snippet": "static void adjust_sit_entry_set(struct sit_entry_set *ses,\n\t\t\t\t\t\tstruct list_head *head)\n{\n\tstruct sit_entry_set *next = ses;\n\n\tif (list_is_last(&ses->set_list, head))\n\t\treturn;\n\n\tlist_for_each_entry_continue(next, head, set_list)\n\t\tif (ses->entry_cnt <= next->entry_cnt)\n\t\t\tbreak;\n\n\tlist_move_tail(&ses->set_list, &next->set_list);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void adjust_sit_entry_set(struct sit_entry_set *ses,\n\t\t\t\t\t\tstruct list_head *head)\n{\n\tstruct sit_entry_set *next = ses;\n\n\tif (list_is_last(&ses->set_list, head))\n\t\treturn;\n\n\tlist_for_each_entry_continue(next, head, set_list)\n\t\tif (ses->entry_cnt <= next->entry_cnt)\n\t\t\tbreak;\n\n\tlist_move_tail(&ses->set_list, &next->set_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ses",
            "head",
            "set_list"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_SEGNO",
          "args": [
            "segno"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}"
  },
  {
    "function_name": "adjust_sit_entry_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1650-1663",
    "snippet": "static void adjust_sit_entry_set(struct sit_entry_set *ses,\n\t\t\t\t\t\tstruct list_head *head)\n{\n\tstruct sit_entry_set *next = ses;\n\n\tif (list_is_last(&ses->set_list, head))\n\t\treturn;\n\n\tlist_for_each_entry_continue(next, head, set_list)\n\t\tif (ses->entry_cnt <= next->entry_cnt)\n\t\t\tbreak;\n\n\tlist_move_tail(&ses->set_list, &next->set_list);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ses->set_list",
            "&next->set_list"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "next",
            "head",
            "set_list"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&ses->set_list",
            "head"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void adjust_sit_entry_set(struct sit_entry_set *ses,\n\t\t\t\t\t\tstruct list_head *head)\n{\n\tstruct sit_entry_set *next = ses;\n\n\tif (list_is_last(&ses->set_list, head))\n\t\treturn;\n\n\tlist_for_each_entry_continue(next, head, set_list)\n\t\tif (ses->entry_cnt <= next->entry_cnt)\n\t\t\tbreak;\n\n\tlist_move_tail(&ses->set_list, &next->set_list);\n}"
  },
  {
    "function_name": "release_sit_entry_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1644-1648",
    "snippet": "static void release_sit_entry_set(struct sit_entry_set *ses)\n{\n\tlist_del(&ses->set_list);\n\tkmem_cache_free(sit_entry_set_slab, ses);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sit_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sit_entry_set_slab",
            "ses"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->set_list"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *sit_entry_set_slab;\n\nstatic void release_sit_entry_set(struct sit_entry_set *ses)\n{\n\tlist_del(&ses->set_list);\n\tkmem_cache_free(sit_entry_set_slab, ses);\n}"
  },
  {
    "function_name": "grab_sit_entry_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1634-1642",
    "snippet": "static struct sit_entry_set *grab_sit_entry_set(void)\n{\n\tstruct sit_entry_set *ses =\n\t\t\tf2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_ATOMIC);\n\n\tses->entry_cnt = 0;\n\tINIT_LIST_HEAD(&ses->set_list);\n\treturn ses;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sit_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ses->set_list"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "sit_entry_set_slab",
            "GFP_ATOMIC"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *sit_entry_set_slab;\n\nstatic struct sit_entry_set *grab_sit_entry_set(void)\n{\n\tstruct sit_entry_set *ses =\n\t\t\tf2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_ATOMIC);\n\n\tses->entry_cnt = 0;\n\tINIT_LIST_HEAD(&ses->set_list);\n\treturn ses;\n}"
  },
  {
    "function_name": "get_next_sit_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1606-1632",
    "snippet": "static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *src_page, *dst_page;\n\tpgoff_t src_off, dst_off;\n\tvoid *src_addr, *dst_addr;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\t/* get current sit block page without lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_sit(sit_i, start);\n\n\treturn dst_page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_to_next_sit",
          "args": [
            "sit_i",
            "start"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "set_to_next_sit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "657-662",
          "snippet": "static inline void set_to_next_sit(struct sit_info *sit_i, unsigned int start)\n{\n\tunsigned int block_off = SIT_BLOCK_OFFSET(start);\n\n\tf2fs_change_bit(block_off, sit_i->sit_bitmap);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void set_to_next_sit(struct sit_info *sit_i, unsigned int start)\n{\n\tunsigned int block_off = SIT_BLOCK_OFFSET(start);\n\n\tf2fs_change_bit(block_off, sit_i->sit_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "src_page",
            "1"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dst_page"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dst_page"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "src_page"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "PageDirty(src_page)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "src_page"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "dst_off"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "src_off"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_sit_addr",
          "args": [
            "sbi",
            "src_off"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "next_sit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "644-655",
          "snippet": "static inline pgoff_t next_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tpgoff_t block_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tblock_addr -= sit_i->sit_base_addr;\n\tif (block_addr < sit_i->sit_blocks)\n\t\tblock_addr += sit_i->sit_blocks;\n\telse\n\t\tblock_addr -= sit_i->sit_blocks;\n\n\treturn block_addr + sit_i->sit_base_addr;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline pgoff_t next_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tpgoff_t block_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tblock_addr -= sit_i->sit_base_addr;\n\tif (block_addr < sit_i->sit_blocks)\n\t\tblock_addr += sit_i->sit_blocks;\n\telse\n\t\tblock_addr -= sit_i->sit_blocks;\n\n\treturn block_addr + sit_i->sit_base_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sit_addr",
          "args": [
            "sbi",
            "start"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "current_sit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "628-642",
          "snippet": "static inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *src_page, *dst_page;\n\tpgoff_t src_off, dst_off;\n\tvoid *src_addr, *dst_addr;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\t/* get current sit block page without lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_sit(sit_i, start);\n\n\treturn dst_page;\n}"
  },
  {
    "function_name": "get_current_sit_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1600-1604",
    "snippet": "static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\treturn get_meta_page(sbi, current_sit_addr(sbi, segno));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "current_sit_addr(sbi, segno)"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sit_addr",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "current_sit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "628-642",
          "snippet": "static inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_current_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\treturn get_meta_page(sbi, current_sit_addr(sbi, segno));\n}"
  },
  {
    "function_name": "lookup_journal_in_cursum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1578-1598",
    "snippet": "int lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_sits_in_cursum",
          "args": [
            "sum",
            "1"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "update_sits_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "190-195",
          "snippet": "static inline int update_sits_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = sits_in_cursum(rs);\n\trs->n_sits = cpu_to_le16(before + i);\n\treturn before;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int update_sits_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = sits_in_cursum(rs);\n\trs->n_sits = cpu_to_le16(before + i);\n\treturn before;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sits_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "segno_in_journal(sum, i)"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segno_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sits_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_nats_in_cursum",
          "args": [
            "sum",
            "1"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "update_nats_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "183-188",
          "snippet": "static inline int update_nats_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = nats_in_cursum(rs);\n\trs->n_nats = cpu_to_le16(before + i);\n\treturn before;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int update_nats_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = nats_in_cursum(rs);\n\trs->n_nats = cpu_to_le16(before + i);\n\treturn before;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nats_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nid_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nats_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "write_node_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1573-1576",
    "snippet": "void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_normal_summaries",
          "args": [
            "sbi",
            "start_blk",
            "CURSEG_HOT_NODE"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "write_normal_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1548-1563",
          "snippet": "static void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}"
  },
  {
    "function_name": "write_data_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1565-1571",
    "snippet": "void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))\n\t\twrite_compacted_summaries(sbi, start_blk);\n\telse\n\t\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_normal_summaries",
          "args": [
            "sbi",
            "start_blk",
            "CURSEG_HOT_DATA"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "write_normal_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1548-1563",
          "snippet": "static void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_compacted_summaries",
          "args": [
            "sbi",
            "start_blk"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "write_compacted_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1491-1546",
          "snippet": "static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct page *page;\n\tunsigned char *kaddr;\n\tstruct f2fs_summary *summary;\n\tstruct curseg_info *seg_i;\n\tint written_size = 0;\n\tint i, j;\n\n\tpage = grab_meta_page(sbi, blkaddr++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: write nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(kaddr, &seg_i->sum_blk->n_nats, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 2: write sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(kaddr + written_size, &seg_i->sum_blk->n_sits,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 3: write summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blkoff;\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tblkoff = sbi->blocks_per_seg;\n\t\telse\n\t\t\tblkoff = curseg_blkoff(sbi, i);\n\n\t\tfor (j = 0; j < blkoff; j++) {\n\t\t\tif (!page) {\n\t\t\t\tpage = grab_meta_page(sbi, blkaddr++);\n\t\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\t\twritten_size = 0;\n\t\t\t}\n\t\t\tsummary = (struct f2fs_summary *)(kaddr + written_size);\n\t\t\t*summary = seg_i->sum_blk->entries[j];\n\t\t\twritten_size += SUMMARY_SIZE;\n\n\t\t\tif (written_size + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct page *page;\n\tunsigned char *kaddr;\n\tstruct f2fs_summary *summary;\n\tstruct curseg_info *seg_i;\n\tint written_size = 0;\n\tint i, j;\n\n\tpage = grab_meta_page(sbi, blkaddr++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: write nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(kaddr, &seg_i->sum_blk->n_nats, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 2: write sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(kaddr + written_size, &seg_i->sum_blk->n_sits,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 3: write summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blkoff;\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tblkoff = sbi->blocks_per_seg;\n\t\telse\n\t\t\tblkoff = curseg_blkoff(sbi, i);\n\n\t\tfor (j = 0; j < blkoff; j++) {\n\t\t\tif (!page) {\n\t\t\t\tpage = grab_meta_page(sbi, blkaddr++);\n\t\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\t\twritten_size = 0;\n\t\t\t}\n\t\t\tsummary = (struct f2fs_summary *)(kaddr + written_size);\n\t\t\t*summary = seg_i->sum_blk->entries[j];\n\t\t\twritten_size += SUMMARY_SIZE;\n\n\t\t\tif (written_size + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set_ckpt_flags",
          "args": [
            "F2FS_CKPT(sbi)",
            "CP_COMPACT_SUM_FLAG"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "is_set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "735-739",
          "snippet": "static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))\n\t\twrite_compacted_summaries(sbi, start_blk);\n\telse\n\t\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);\n}"
  },
  {
    "function_name": "write_normal_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1548-1563",
    "snippet": "static void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sum->curseg_mutex"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_sum_page",
          "args": [
            "sbi",
            "sum->sum_blk",
            "blkaddr + (i - type)"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "write_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "765-773",
          "snippet": "static void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sum->curseg_mutex"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DATASEG",
          "args": [
            "type"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++) {\n\t\tstruct curseg_info *sum = CURSEG_I(sbi, i);\n\t\tmutex_lock(&sum->curseg_mutex);\n\t\twrite_sum_page(sbi, sum->sum_blk, blkaddr + (i - type));\n\t\tmutex_unlock(&sum->curseg_mutex);\n\t}\n}"
  },
  {
    "function_name": "write_compacted_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1491-1546",
    "snippet": "static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct page *page;\n\tunsigned char *kaddr;\n\tstruct f2fs_summary *summary;\n\tstruct curseg_info *seg_i;\n\tint written_size = 0;\n\tint i, j;\n\n\tpage = grab_meta_page(sbi, blkaddr++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: write nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(kaddr, &seg_i->sum_blk->n_nats, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 2: write sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(kaddr + written_size, &seg_i->sum_blk->n_sits,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 3: write summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blkoff;\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tblkoff = sbi->blocks_per_seg;\n\t\telse\n\t\t\tblkoff = curseg_blkoff(sbi, i);\n\n\t\tfor (j = 0; j < blkoff; j++) {\n\t\t\tif (!page) {\n\t\t\t\tpage = grab_meta_page(sbi, blkaddr++);\n\t\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\t\twritten_size = 0;\n\t\t\t}\n\t\t\tsummary = (struct f2fs_summary *)(kaddr + written_size);\n\t\t\t*summary = seg_i->sum_blk->entries[j];\n\t\t\twritten_size += SUMMARY_SIZE;\n\n\t\t\tif (written_size + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "blkaddr++"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curseg_blkoff",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "curseg_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "549-553",
          "snippet": "static inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + written_size",
            "&seg_i->sum_blk->n_sits",
            "SUM_JOURNAL_SIZE"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "&seg_i->sum_blk->n_nats",
            "SUM_JOURNAL_SIZE"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct page *page;\n\tunsigned char *kaddr;\n\tstruct f2fs_summary *summary;\n\tstruct curseg_info *seg_i;\n\tint written_size = 0;\n\tint i, j;\n\n\tpage = grab_meta_page(sbi, blkaddr++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: write nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(kaddr, &seg_i->sum_blk->n_nats, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 2: write sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(kaddr + written_size, &seg_i->sum_blk->n_sits,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 3: write summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blkoff;\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tblkoff = sbi->blocks_per_seg;\n\t\telse\n\t\t\tblkoff = curseg_blkoff(sbi, i);\n\n\t\tfor (j = 0; j < blkoff; j++) {\n\t\t\tif (!page) {\n\t\t\t\tpage = grab_meta_page(sbi, blkaddr++);\n\t\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\t\twritten_size = 0;\n\t\t\t}\n\t\t\tsummary = (struct f2fs_summary *)(kaddr + written_size);\n\t\t\t*summary = seg_i->sum_blk->entries[j];\n\t\t\twritten_size += SUMMARY_SIZE;\n\n\t\t\tif (written_size + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
  },
  {
    "function_name": "restore_curseg_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1460-1489",
    "snippet": "static int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) {\n\t\tint npages = npages_for_summary_flush(sbi, true);\n\n\t\tif (npages >= 2)\n\t\t\tra_meta_pages(sbi, start_sum_block(sbi), npages,\n\t\t\t\t\t\t\t\tMETA_CP);\n\n\t\t/* restore for compacted data summary */\n\t\tif (read_compacted_summaries(sbi))\n\t\t\treturn -EINVAL;\n\t\ttype = CURSEG_HOT_NODE;\n\t}\n\n\tif (__exist_node_summaries(sbi))\n\t\tra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),\n\t\t\t\t\tNR_CURSEG_TYPE - type, META_CP);\n\n\tfor (; type <= CURSEG_COLD_NODE; type++) {\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_normal_summaries",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "read_normal_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1394-1458",
          "snippet": "static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\tmemcpy(curseg->sum_blk, sum, PAGE_CACHE_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\tmemcpy(curseg->sum_blk, sum, PAGE_CACHE_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "sum_blk_addr(sbi, NR_CURSEG_TYPE, type)",
            "NR_CURSEG_TYPE - type",
            "META_CP"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sum_blk_addr",
          "args": [
            "sbi",
            "NR_CURSEG_TYPE",
            "type"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "sum_blk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "685-690",
          "snippet": "static inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)\n\t\t\t\t- (base + 1) + type;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)\n\t\t\t\t- (base + 1) + type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__exist_node_summaries",
          "args": [
            "sbi"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "__exist_node_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "791-795",
          "snippet": "static inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)\n{\n\treturn (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG) ||\n\t\t\tis_set_ckpt_flags(F2FS_CKPT(sbi), CP_FASTBOOT_FLAG));\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)\n{\n\treturn (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG) ||\n\t\t\tis_set_ckpt_flags(F2FS_CKPT(sbi), CP_FASTBOOT_FLAG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_compacted_summaries",
          "args": [
            "sbi"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "read_compacted_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1333-1392",
          "snippet": "static int read_compacted_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *seg_i;\n\tunsigned char *kaddr;\n\tstruct page *page;\n\tblock_t start;\n\tint i, j, offset;\n\n\tstart = start_sum_block(sbi);\n\n\tpage = get_meta_page(sbi, start++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: restore nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(&seg_i->sum_blk->n_nats, kaddr, SUM_JOURNAL_SIZE);\n\n\t/* Step 2: restore sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(&seg_i->sum_blk->n_sits, kaddr + SUM_JOURNAL_SIZE,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\toffset = 2 * SUM_JOURNAL_SIZE;\n\n\t/* Step 3: restore summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blk_off;\n\t\tunsigned int segno;\n\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[i]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);\n\t\tseg_i->next_segno = segno;\n\t\treset_curseg(sbi, i, 0);\n\t\tseg_i->alloc_type = ckpt->alloc_type[i];\n\t\tseg_i->next_blkoff = blk_off;\n\n\t\tif (seg_i->alloc_type == SSR)\n\t\t\tblk_off = sbi->blocks_per_seg;\n\n\t\tfor (j = 0; j < blk_off; j++) {\n\t\t\tstruct f2fs_summary *s;\n\t\t\ts = (struct f2fs_summary *)(kaddr + offset);\n\t\t\tseg_i->sum_blk->entries[j] = *s;\n\t\t\toffset += SUMMARY_SIZE;\n\t\t\tif (offset + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\n\t\t\tpage = get_meta_page(sbi, start++);\n\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_compacted_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *seg_i;\n\tunsigned char *kaddr;\n\tstruct page *page;\n\tblock_t start;\n\tint i, j, offset;\n\n\tstart = start_sum_block(sbi);\n\n\tpage = get_meta_page(sbi, start++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: restore nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(&seg_i->sum_blk->n_nats, kaddr, SUM_JOURNAL_SIZE);\n\n\t/* Step 2: restore sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(&seg_i->sum_blk->n_sits, kaddr + SUM_JOURNAL_SIZE,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\toffset = 2 * SUM_JOURNAL_SIZE;\n\n\t/* Step 3: restore summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blk_off;\n\t\tunsigned int segno;\n\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[i]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);\n\t\tseg_i->next_segno = segno;\n\t\treset_curseg(sbi, i, 0);\n\t\tseg_i->alloc_type = ckpt->alloc_type[i];\n\t\tseg_i->next_blkoff = blk_off;\n\n\t\tif (seg_i->alloc_type == SSR)\n\t\t\tblk_off = sbi->blocks_per_seg;\n\n\t\tfor (j = 0; j < blk_off; j++) {\n\t\t\tstruct f2fs_summary *s;\n\t\t\ts = (struct f2fs_summary *)(kaddr + offset);\n\t\t\tseg_i->sum_blk->entries[j] = *s;\n\t\t\toffset += SUMMARY_SIZE;\n\t\t\tif (offset + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\n\t\t\tpage = get_meta_page(sbi, start++);\n\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_sum_block",
          "args": [
            "sbi"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "start_sum_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "679-683",
          "snippet": "static inline block_t start_sum_block(struct f2fs_sb_info *sbi)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline block_t start_sum_block(struct f2fs_sb_info *sbi)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "npages_for_summary_flush",
          "args": [
            "sbi",
            "true"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "npages_for_summary_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "730-755",
          "snippet": "int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set_ckpt_flags",
          "args": [
            "F2FS_CKPT(sbi)",
            "CP_COMPACT_SUM_FLAG"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "is_set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "735-739",
          "snippet": "static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) {\n\t\tint npages = npages_for_summary_flush(sbi, true);\n\n\t\tif (npages >= 2)\n\t\t\tra_meta_pages(sbi, start_sum_block(sbi), npages,\n\t\t\t\t\t\t\t\tMETA_CP);\n\n\t\t/* restore for compacted data summary */\n\t\tif (read_compacted_summaries(sbi))\n\t\t\treturn -EINVAL;\n\t\ttype = CURSEG_HOT_NODE;\n\t}\n\n\tif (__exist_node_summaries(sbi))\n\t\tra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),\n\t\t\t\t\tNR_CURSEG_TYPE - type, META_CP);\n\n\tfor (; type <= CURSEG_COLD_NODE; type++) {\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_normal_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1394-1458",
    "snippet": "static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\tmemcpy(curseg->sum_blk, sum, PAGE_CACHE_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "new",
            "1"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_curseg",
          "args": [
            "sbi",
            "type",
            "0"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "reset_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "879-896",
          "snippet": "static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "curseg->sum_blk",
            "sum",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_node_summary",
          "args": [
            "sbi",
            "segno",
            "sum"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "restore_node_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1731-1766",
          "snippet": "int restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, bio_blocks);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_meta_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, bio_blocks);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_meta_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__exist_node_summaries",
          "args": [
            "sbi"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__exist_node_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "791-795",
          "snippet": "static inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)\n{\n\treturn (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG) ||\n\t\t\tis_set_ckpt_flags(F2FS_CKPT(sbi), CP_FASTBOOT_FLAG));\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)\n{\n\treturn (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG) ||\n\t\t\tis_set_ckpt_flags(F2FS_CKPT(sbi), CP_FASTBOOT_FLAG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NODESEG",
          "args": [
            "type"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "new"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "blk_addr"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_blk_addr",
          "args": [
            "sbi",
            "NR_CURSEG_NODE_TYPE",
            "type - CURSEG_HOT_NODE"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "sum_blk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "685-690",
          "snippet": "static inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)\n\t\t\t\t- (base + 1) + type;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)\n\t\t\t\t- (base + 1) + type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DATASEG",
          "args": [
            "type"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\tmemcpy(curseg->sum_blk, sum, PAGE_CACHE_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_compacted_summaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1333-1392",
    "snippet": "static int read_compacted_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *seg_i;\n\tunsigned char *kaddr;\n\tstruct page *page;\n\tblock_t start;\n\tint i, j, offset;\n\n\tstart = start_sum_block(sbi);\n\n\tpage = get_meta_page(sbi, start++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: restore nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(&seg_i->sum_blk->n_nats, kaddr, SUM_JOURNAL_SIZE);\n\n\t/* Step 2: restore sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(&seg_i->sum_blk->n_sits, kaddr + SUM_JOURNAL_SIZE,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\toffset = 2 * SUM_JOURNAL_SIZE;\n\n\t/* Step 3: restore summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blk_off;\n\t\tunsigned int segno;\n\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[i]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);\n\t\tseg_i->next_segno = segno;\n\t\treset_curseg(sbi, i, 0);\n\t\tseg_i->alloc_type = ckpt->alloc_type[i];\n\t\tseg_i->next_blkoff = blk_off;\n\n\t\tif (seg_i->alloc_type == SSR)\n\t\t\tblk_off = sbi->blocks_per_seg;\n\n\t\tfor (j = 0; j < blk_off; j++) {\n\t\t\tstruct f2fs_summary *s;\n\t\t\ts = (struct f2fs_summary *)(kaddr + offset);\n\t\t\tseg_i->sum_blk->entries[j] = *s;\n\t\t\toffset += SUMMARY_SIZE;\n\t\t\tif (offset + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\n\t\t\tpage = get_meta_page(sbi, start++);\n\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "start++"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_curseg",
          "args": [
            "sbi",
            "i",
            "0"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "reset_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "879-896",
          "snippet": "static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ckpt->cur_data_blkoff[i]"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ckpt->cur_data_segno[i]"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&seg_i->sum_blk->n_sits",
            "kaddr + SUM_JOURNAL_SIZE",
            "SUM_JOURNAL_SIZE"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&seg_i->sum_blk->n_nats",
            "kaddr",
            "SUM_JOURNAL_SIZE"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_sum_block",
          "args": [
            "sbi"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "start_sum_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "679-683",
          "snippet": "static inline block_t start_sum_block(struct f2fs_sb_info *sbi)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline block_t start_sum_block(struct f2fs_sb_info *sbi)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_compacted_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *seg_i;\n\tunsigned char *kaddr;\n\tstruct page *page;\n\tblock_t start;\n\tint i, j, offset;\n\n\tstart = start_sum_block(sbi);\n\n\tpage = get_meta_page(sbi, start++);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: restore nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(&seg_i->sum_blk->n_nats, kaddr, SUM_JOURNAL_SIZE);\n\n\t/* Step 2: restore sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(&seg_i->sum_blk->n_sits, kaddr + SUM_JOURNAL_SIZE,\n\t\t\t\t\t\tSUM_JOURNAL_SIZE);\n\toffset = 2 * SUM_JOURNAL_SIZE;\n\n\t/* Step 3: restore summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blk_off;\n\t\tunsigned int segno;\n\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[i]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);\n\t\tseg_i->next_segno = segno;\n\t\treset_curseg(sbi, i, 0);\n\t\tseg_i->alloc_type = ckpt->alloc_type[i];\n\t\tseg_i->next_blkoff = blk_off;\n\n\t\tif (seg_i->alloc_type == SSR)\n\t\t\tblk_off = sbi->blocks_per_seg;\n\n\t\tfor (j = 0; j < blk_off; j++) {\n\t\t\tstruct f2fs_summary *s;\n\t\t\ts = (struct f2fs_summary *)(kaddr + offset);\n\t\t\tseg_i->sum_blk->entries[j] = *s;\n\t\t\toffset += SUMMARY_SIZE;\n\t\t\tif (offset + SUMMARY_SIZE <= PAGE_CACHE_SIZE -\n\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\n\t\t\tpage = get_meta_page(sbi, start++);\n\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_wait_on_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1321-1331",
    "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "type",
            "WRITE"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_merged_page",
          "args": [
            "sbi",
            "page",
            "type"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "is_merged_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1297-1319",
          "snippet": "static inline bool is_merged_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct page *page, enum page_type type)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io = &sbi->write_io[btype];\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tdown_read(&io->io_rwsem);\n\tif (!io->bio)\n\t\tgoto out;\n\n\tbio_for_each_segment_all(bvec, io->bio, i) {\n\t\tif (page == bvec->bv_page) {\n\t\t\tup_read(&io->io_rwsem);\n\t\t\treturn true;\n\t\t}\n\t}\n\nout:\n\tup_read(&io->io_rwsem);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline bool is_merged_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct page *page, enum page_type type)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io = &sbi->write_io[btype];\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tdown_read(&io->io_rwsem);\n\tif (!io->bio)\n\t\tgoto out;\n\n\tbio_for_each_segment_all(bvec, io->bio, i) {\n\t\tif (page == bvec->bv_page) {\n\t\t\tup_read(&io->io_rwsem);\n\t\t\treturn true;\n\t\t}\n\t}\n\nout:\n\tup_read(&io->io_rwsem);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
  },
  {
    "function_name": "is_merged_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1297-1319",
    "snippet": "static inline bool is_merged_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct page *page, enum page_type type)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io = &sbi->write_io[btype];\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tdown_read(&io->io_rwsem);\n\tif (!io->bio)\n\t\tgoto out;\n\n\tbio_for_each_segment_all(bvec, io->bio, i) {\n\t\tif (page == bvec->bv_page) {\n\t\t\tup_read(&io->io_rwsem);\n\t\t\treturn true;\n\t\t}\n\t}\n\nout:\n\tup_read(&io->io_rwsem);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "io->bio",
            "i"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_TYPE_OF_BIO",
          "args": [
            "type"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline bool is_merged_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct page *page, enum page_type type)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io = &sbi->write_io[btype];\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tdown_read(&io->io_rwsem);\n\tif (!io->bio)\n\t\tgoto out;\n\n\tbio_for_each_segment_all(bvec, io->bio, i) {\n\t\tif (page == bvec->bv_page) {\n\t\t\tup_read(&io->io_rwsem);\n\t\t\treturn true;\n\t\t}\n\t}\n\nout:\n\tup_read(&io->io_rwsem);\n\treturn false;\n}"
  },
  {
    "function_name": "recover_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1254-1295",
    "snippet": "void recover_data_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *page, struct f2fs_summary *sum,\n\t\t\tblock_t old_blkaddr, block_t new_blkaddr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tunsigned int segno, old_cursegno;\n\tstruct seg_entry *se;\n\tint type;\n\n\tsegno = GET_SEGNO(sbi, new_blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\ttype = se->type;\n\n\tif (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {\n\t\tif (old_blkaddr == NULL_ADDR)\n\t\t\ttype = CURSEG_COLD_DATA;\n\t\telse\n\t\t\ttype = CURSEG_WARM_DATA;\n\t}\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\told_cursegno = curseg->segno;\n\n\t/* change the current segment */\n\tif (segno != curseg->segno) {\n\t\tcurseg->next_segno = segno;\n\t\tchange_curseg(sbi, type, true);\n\t}\n\n\tcurseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);\n\t__add_sum_entry(sbi, type, sum);\n\n\trefresh_sit_entry(sbi, old_blkaddr, new_blkaddr);\n\tlocate_dirty_segment(sbi, old_cursegno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locate_dirty_segment",
          "args": [
            "sbi",
            "old_cursegno"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "432-455",
          "snippet": "static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refresh_sit_entry",
          "args": [
            "sbi",
            "old_blkaddr",
            "new_blkaddr"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "685-693",
          "snippet": "void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_sum_entry",
          "args": [
            "sbi",
            "type",
            "sum"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "__add_sum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "718-725",
          "snippet": "static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_BLKOFF_FROM_SEG0",
          "args": [
            "sbi",
            "new_blkaddr"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_curseg",
          "args": [
            "sbi",
            "type",
            "true"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "change_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "958-985",
          "snippet": "static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CURSEG",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "new_blkaddr"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_data_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *page, struct f2fs_summary *sum,\n\t\t\tblock_t old_blkaddr, block_t new_blkaddr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tunsigned int segno, old_cursegno;\n\tstruct seg_entry *se;\n\tint type;\n\n\tsegno = GET_SEGNO(sbi, new_blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\ttype = se->type;\n\n\tif (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {\n\t\tif (old_blkaddr == NULL_ADDR)\n\t\t\ttype = CURSEG_COLD_DATA;\n\t\telse\n\t\t\ttype = CURSEG_WARM_DATA;\n\t}\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\told_cursegno = curseg->segno;\n\n\t/* change the current segment */\n\tif (segno != curseg->segno) {\n\t\tcurseg->next_segno = segno;\n\t\tchange_curseg(sbi, type, true);\n\t}\n\n\tcurseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);\n\t__add_sum_entry(sbi, type, sum);\n\n\trefresh_sit_entry(sbi, old_blkaddr, new_blkaddr);\n\tlocate_dirty_segment(sbi, old_cursegno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
  },
  {
    "function_name": "rewrite_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1248-1252",
    "snippet": "void rewrite_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstat_inc_inplace_blocks(F2FS_P_SB(page));\n\tf2fs_submit_page_mbio(F2FS_P_SB(page), page, fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_page_mbio",
          "args": [
            "F2FS_P_SB(page)",
            "page",
            "fio"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_mbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "154-192",
          "snippet": "void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_inplace_blocks",
          "args": [
            "F2FS_P_SB(page)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid rewrite_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstat_inc_inplace_blocks(F2FS_P_SB(page));\n\tf2fs_submit_page_mbio(F2FS_P_SB(page), page, fio);\n}"
  },
  {
    "function_name": "write_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1234-1246",
    "snippet": "void write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_write_page",
          "args": [
            "sbi",
            "page",
            "&sum",
            "fio"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1202-1212",
          "snippet": "static void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_summary",
          "args": [
            "&sum",
            "dn->nid",
            "dn->ofs_in_node",
            "ni.version"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "set_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "671-677",
          "snippet": "static inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "dn->nid",
            "&ni"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "dn->data_blkaddr == NULL_ADDR"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}"
  },
  {
    "function_name": "write_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1226-1232",
    "snippet": "void write_node_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tunsigned int nid, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_summary sum;\n\tset_summary(&sum, nid, 0, 0);\n\tdo_write_page(sbi, page, &sum, fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_write_page",
          "args": [
            "sbi",
            "page",
            "&sum",
            "fio"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1202-1212",
          "snippet": "static void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_summary",
          "args": [
            "&sum",
            "nid",
            "0",
            "0"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "set_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "671-677",
          "snippet": "static inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_node_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tunsigned int nid, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_summary sum;\n\tset_summary(&sum, nid, 0, 0);\n\tdo_write_page(sbi, page, &sum, fio);\n}"
  },
  {
    "function_name": "write_meta_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1214-1224",
    "snippet": "void write_meta_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = WRITE_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = page->index,\n\t};\n\n\tset_page_writeback(page);\n\tf2fs_submit_page_mbio(sbi, page, &fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_page_mbio",
          "args": [
            "sbi",
            "page",
            "&fio"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_mbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "154-192",
          "snippet": "void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_meta_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = WRITE_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = page->index,\n\t};\n\n\tset_page_writeback(page);\n\tf2fs_submit_page_mbio(sbi, page, &fio);\n}"
  },
  {
    "function_name": "do_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1202-1212",
    "snippet": "static void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_page_mbio",
          "args": [
            "sbi",
            "page",
            "fio"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_mbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "154-192",
          "snippet": "void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_data_block",
          "args": [
            "sbi",
            "page",
            "fio->blk_addr",
            "&fio->blk_addr",
            "sum",
            "type"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1154-1200",
          "snippet": "void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_segment_type",
          "args": [
            "page",
            "fio->type"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "__get_segment_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1140-1152",
          "snippet": "static int __get_segment_type(struct page *page, enum page_type p_type)\n{\n\tswitch (F2FS_P_SB(page)->active_logs) {\n\tcase 2:\n\t\treturn __get_segment_type_2(page, p_type);\n\tcase 4:\n\t\treturn __get_segment_type_4(page, p_type);\n\t}\n\t/* NR_CURSEG_TYPE(6) logs by default */\n\tf2fs_bug_on(F2FS_P_SB(page),\n\t\tF2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);\n\treturn __get_segment_type_6(page, p_type);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type(struct page *page, enum page_type p_type)\n{\n\tswitch (F2FS_P_SB(page)->active_logs) {\n\tcase 2:\n\t\treturn __get_segment_type_2(page, p_type);\n\tcase 4:\n\t\treturn __get_segment_type_4(page, p_type);\n\t}\n\t/* NR_CURSEG_TYPE(6) logs by default */\n\tf2fs_bug_on(F2FS_P_SB(page),\n\t\tF2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);\n\treturn __get_segment_type_6(page, p_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void do_write_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tstruct f2fs_summary *sum,\n\t\t\tstruct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(page, fio->type);\n\n\tallocate_data_block(sbi, page, fio->blk_addr, &fio->blk_addr, sum, type);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_mbio(sbi, page, fio);\n}"
  },
  {
    "function_name": "allocate_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1154-1200",
    "snippet": "void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_node_footer_blkaddr",
          "args": [
            "page",
            "NEXT_FREE_BLKADDR(sbi, curseg)"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "fill_node_footer_blkaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "238-245",
          "snippet": "static inline void fill_node_footer_blkaddr(struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(F2FS_P_SB(page));\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\n\trn->footer.cp_ver = ckpt->checkpoint_ver;\n\trn->footer.next_blkaddr = cpu_to_le32(blkaddr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void fill_node_footer_blkaddr(struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(F2FS_P_SB(page));\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\n\trn->footer.cp_ver = ckpt->checkpoint_ver;\n\trn->footer.next_blkaddr = cpu_to_le32(blkaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NODESEG",
          "args": [
            "type"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_sit_entry",
          "args": [
            "sbi",
            "old_blkaddr",
            "*new_blkaddr"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "685-693",
          "snippet": "void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sit_i->s_ops->allocate_segment",
          "args": [
            "sbi",
            "type",
            "false"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__has_curseg_space",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "__has_curseg_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1087-1093",
          "snippet": "static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tif (curseg->next_blkoff < sbi->blocks_per_seg)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tif (curseg->next_blkoff < sbi->blocks_per_seg)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_block_count",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__refresh_next_blkoff",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "__refresh_next_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "945-952",
          "snippet": "static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_sum_entry",
          "args": [
            "sbi",
            "type",
            "sum"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "__add_sum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "718-725",
          "snippet": "static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__allocate_new_segments",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "__allocate_new_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1027-1035",
          "snippet": "static void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
  },
  {
    "function_name": "__get_segment_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1140-1152",
    "snippet": "static int __get_segment_type(struct page *page, enum page_type p_type)\n{\n\tswitch (F2FS_P_SB(page)->active_logs) {\n\tcase 2:\n\t\treturn __get_segment_type_2(page, p_type);\n\tcase 4:\n\t\treturn __get_segment_type_4(page, p_type);\n\t}\n\t/* NR_CURSEG_TYPE(6) logs by default */\n\tf2fs_bug_on(F2FS_P_SB(page),\n\t\tF2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);\n\treturn __get_segment_type_6(page, p_type);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_segment_type_6",
          "args": [
            "page",
            "p_type"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "__get_segment_type_6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1120-1138",
          "snippet": "static int __get_segment_type_6(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse if (is_cold_data(page) || file_is_cold(inode))\n\t\t\treturn CURSEG_COLD_DATA;\n\t\telse\n\t\t\treturn CURSEG_WARM_DATA;\n\t} else {\n\t\tif (IS_DNODE(page))\n\t\t\treturn is_cold_node(page) ? CURSEG_WARM_NODE :\n\t\t\t\t\t\tCURSEG_HOT_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_6(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse if (is_cold_data(page) || file_is_cold(inode))\n\t\t\treturn CURSEG_COLD_DATA;\n\t\telse\n\t\t\treturn CURSEG_WARM_DATA;\n\t} else {\n\t\tif (IS_DNODE(page))\n\t\t\treturn is_cold_node(page) ? CURSEG_WARM_NODE :\n\t\t\t\t\t\tCURSEG_HOT_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_P_SB(page)",
            "F2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_segment_type_4",
          "args": [
            "page",
            "p_type"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "__get_segment_type_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1103-1118",
          "snippet": "static int __get_segment_type_4(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse\n\t\t\treturn CURSEG_COLD_DATA;\n\t} else {\n\t\tif (IS_DNODE(page) && is_cold_node(page))\n\t\t\treturn CURSEG_WARM_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_4(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse\n\t\t\treturn CURSEG_COLD_DATA;\n\t} else {\n\t\tif (IS_DNODE(page) && is_cold_node(page))\n\t\t\treturn CURSEG_WARM_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_segment_type_2",
          "args": [
            "page",
            "p_type"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "__get_segment_type_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1095-1101",
          "snippet": "static int __get_segment_type_2(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA)\n\t\treturn CURSEG_HOT_DATA;\n\telse\n\t\treturn CURSEG_HOT_NODE;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_2(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA)\n\t\treturn CURSEG_HOT_DATA;\n\telse\n\t\treturn CURSEG_HOT_NODE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type(struct page *page, enum page_type p_type)\n{\n\tswitch (F2FS_P_SB(page)->active_logs) {\n\tcase 2:\n\t\treturn __get_segment_type_2(page, p_type);\n\tcase 4:\n\t\treturn __get_segment_type_4(page, p_type);\n\t}\n\t/* NR_CURSEG_TYPE(6) logs by default */\n\tf2fs_bug_on(F2FS_P_SB(page),\n\t\tF2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);\n\treturn __get_segment_type_6(page, p_type);\n}"
  },
  {
    "function_name": "__get_segment_type_6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1120-1138",
    "snippet": "static int __get_segment_type_6(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse if (is_cold_data(page) || file_is_cold(inode))\n\t\t\treturn CURSEG_COLD_DATA;\n\t\telse\n\t\t\treturn CURSEG_WARM_DATA;\n\t} else {\n\t\tif (IS_DNODE(page))\n\t\t\treturn is_cold_node(page) ? CURSEG_WARM_NODE :\n\t\t\t\t\t\tCURSEG_HOT_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_cold_node",
          "args": [
            "page"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DNODE",
          "args": [
            "page"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "IS_DNODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "299-315",
          "snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_is_cold",
          "args": [
            "inode"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cold_data",
          "args": [
            "page"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "is_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "367-370",
          "snippet": "static inline int is_cold_data(struct page *page)\n{\n\treturn PageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int is_cold_data(struct page *page)\n{\n\treturn PageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_6(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse if (is_cold_data(page) || file_is_cold(inode))\n\t\t\treturn CURSEG_COLD_DATA;\n\t\telse\n\t\t\treturn CURSEG_WARM_DATA;\n\t} else {\n\t\tif (IS_DNODE(page))\n\t\t\treturn is_cold_node(page) ? CURSEG_WARM_NODE :\n\t\t\t\t\t\tCURSEG_HOT_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}"
  },
  {
    "function_name": "__get_segment_type_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1103-1118",
    "snippet": "static int __get_segment_type_4(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse\n\t\t\treturn CURSEG_COLD_DATA;\n\t} else {\n\t\tif (IS_DNODE(page) && is_cold_node(page))\n\t\t\treturn CURSEG_WARM_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_cold_node",
          "args": [
            "page"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DNODE",
          "args": [
            "page"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "IS_DNODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "299-315",
          "snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_4(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA) {\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse\n\t\t\treturn CURSEG_COLD_DATA;\n\t} else {\n\t\tif (IS_DNODE(page) && is_cold_node(page))\n\t\t\treturn CURSEG_WARM_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}"
  },
  {
    "function_name": "__get_segment_type_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1095-1101",
    "snippet": "static int __get_segment_type_2(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA)\n\t\treturn CURSEG_HOT_DATA;\n\telse\n\t\treturn CURSEG_HOT_NODE;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_segment_type_2(struct page *page, enum page_type p_type)\n{\n\tif (p_type == DATA)\n\t\treturn CURSEG_HOT_DATA;\n\telse\n\t\treturn CURSEG_HOT_NODE;\n}"
  },
  {
    "function_name": "__has_curseg_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1087-1093",
    "snippet": "static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tif (curseg->next_blkoff < sbi->blocks_per_seg)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tif (curseg->next_blkoff < sbi->blocks_per_seg)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "f2fs_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1049-1085",
    "snippet": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\n\tif (range->minlen > SEGMENT_SIZE(sbi) || start >= MAX_BLKADDR(sbi) ||\n\t\t\t\t\t\trange->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = F2FS_BYTES_TO_BLK(range->minlen);\n\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tcpc.trim_end = min_t(unsigned int, rounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t}\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_BLK_TO_BYTES",
          "args": [
            "cpc.trimmed"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "sbi",
            "&cpc"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1046-1091",
          "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1",
            "end_segno"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi)",
            "sbi->segs_per_sec"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BATCHED_TRIM_SEGMENTS",
          "args": [
            "sbi"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "range->minlen"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "end"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "start"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEGMENT_SIZE",
          "args": [
            "sbi"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "range->len"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "range->start"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\n\tif (range->minlen > SEGMENT_SIZE(sbi) || start >= MAX_BLKADDR(sbi) ||\n\t\t\t\t\t\trange->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = F2FS_BYTES_TO_BLK(range->minlen);\n\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tcpc.trim_end = min_t(unsigned int, rounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t}\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn 0;\n}"
  },
  {
    "function_name": "allocate_new_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1037-1043",
    "snippet": "void allocate_new_segments(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++)\n\t\t__allocate_new_segments(sbi, i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__allocate_new_segments",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "__allocate_new_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1027-1035",
          "snippet": "static void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid allocate_new_segments(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++)\n\t\t__allocate_new_segments(sbi, i);\n}"
  },
  {
    "function_name": "__allocate_new_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1027-1035",
    "snippet": "static void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locate_dirty_segment",
          "args": [
            "sbi",
            "old_segno"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "432-455",
          "snippet": "static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi",
            "type",
            "true"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __allocate_new_segments(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}"
  },
  {
    "function_name": "allocate_segment_by_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "1008-1025",
    "snippet": "static void allocate_segment_by_default(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tint type, bool force)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tif (force)\n\t\tnew_curseg(sbi, type, true);\n\telse if (type == CURSEG_WARM_NODE)\n\t\tnew_curseg(sbi, type, false);\n\telse if (curseg->alloc_type == LFS && is_next_segment_free(sbi, type))\n\t\tnew_curseg(sbi, type, false);\n\telse if (need_SSR(sbi) && get_ssr_segment(sbi, type))\n\t\tchange_curseg(sbi, type, true);\n\telse\n\t\tnew_curseg(sbi, type, false);\n\n\tstat_inc_seg_type(sbi, curseg);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat_inc_seg_type",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_curseg",
          "args": [
            "sbi",
            "type",
            "false"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "new_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "902-920",
          "snippet": "static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = LFS;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = LFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_curseg",
          "args": [
            "sbi",
            "type",
            "true"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "change_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "958-985",
          "snippet": "static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ssr_segment",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "get_ssr_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "987-1002",
          "snippet": "static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tconst struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;\n\n\tif (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0))\n\t\treturn v_ops->get_victim(sbi,\n\t\t\t\t&(curseg)->next_segno, BG_GC, type, SSR);\n\n\t/* For data segments, let's do SSR more intensively */\n\tfor (; type >= CURSEG_HOT_DATA; type--)\n\t\tif (v_ops->get_victim(sbi, &(curseg)->next_segno,\n\t\t\t\t\t\tBG_GC, type, SSR))\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_ssr_segment(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tconst struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;\n\n\tif (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0))\n\t\treturn v_ops->get_victim(sbi,\n\t\t\t\t&(curseg)->next_segno, BG_GC, type, SSR);\n\n\t/* For data segments, let's do SSR more intensively */\n\tfor (; type >= CURSEG_HOT_DATA; type--)\n\t\tif (v_ops->get_victim(sbi, &(curseg)->next_segno,\n\t\t\t\t\t\tBG_GC, type, SSR))\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_SSR",
          "args": [
            "sbi"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "need_SSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "451-457",
          "snippet": "static inline bool need_SSR(struct f2fs_sb_info *sbi)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\treturn free_sections(sbi) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi) + 1);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool need_SSR(struct f2fs_sb_info *sbi)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\treturn free_sections(sbi) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_next_segment_free",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "is_next_segment_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "775-784",
          "snippet": "static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno + 1;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\n\tif (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)\n\t\treturn !test_bit(segno, free_i->free_segmap);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int is_next_segment_free(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno + 1;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\n\tif (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)\n\t\treturn !test_bit(segno, free_i->free_segmap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void allocate_segment_by_default(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tint type, bool force)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tif (force)\n\t\tnew_curseg(sbi, type, true);\n\telse if (type == CURSEG_WARM_NODE)\n\t\tnew_curseg(sbi, type, false);\n\telse if (curseg->alloc_type == LFS && is_next_segment_free(sbi, type))\n\t\tnew_curseg(sbi, type, false);\n\telse if (need_SSR(sbi) && get_ssr_segment(sbi, type))\n\t\tchange_curseg(sbi, type, true);\n\telse\n\t\tnew_curseg(sbi, type, false);\n\n\tstat_inc_seg_type(sbi, curseg);\n}"
  },
  {
    "function_name": "get_ssr_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "987-1002",
    "snippet": "static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tconst struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;\n\n\tif (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0))\n\t\treturn v_ops->get_victim(sbi,\n\t\t\t\t&(curseg)->next_segno, BG_GC, type, SSR);\n\n\t/* For data segments, let's do SSR more intensively */\n\tfor (; type >= CURSEG_HOT_DATA; type--)\n\t\tif (v_ops->get_victim(sbi, &(curseg)->next_segno,\n\t\t\t\t\t\tBG_GC, type, SSR))\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v_ops->get_victim",
          "args": [
            "sbi",
            "&(curseg)->next_segno",
            "BG_GC",
            "type",
            "SSR"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v_ops->get_victim",
          "args": [
            "sbi",
            "&(curseg)->next_segno",
            "BG_GC",
            "type",
            "SSR"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "0"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NODESEG",
          "args": [
            "type"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_ssr_segment(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tconst struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;\n\n\tif (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0))\n\t\treturn v_ops->get_victim(sbi,\n\t\t\t\t&(curseg)->next_segno, BG_GC, type, SSR);\n\n\t/* For data segments, let's do SSR more intensively */\n\tfor (; type >= CURSEG_HOT_DATA; type--)\n\t\tif (v_ops->get_victim(sbi, &(curseg)->next_segno,\n\t\t\t\t\t\tBG_GC, type, SSR))\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "change_curseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "958-985",
    "snippet": "static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "sum_page",
            "1"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "curseg->sum_blk",
            "sum_node",
            "SUM_ENTRY_SIZE"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sum_page"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sum_page",
          "args": [
            "sbi",
            "new_segno"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "get_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "760-763",
          "snippet": "struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__next_free_blkoff",
          "args": [
            "sbi",
            "curseg",
            "0"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "__next_free_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "922-938",
          "snippet": "static void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_curseg",
          "args": [
            "sbi",
            "type",
            "1"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "reset_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "879-896",
          "snippet": "static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_dirty_segment",
          "args": [
            "sbi",
            "new_segno",
            "DIRTY"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "406-425",
          "snippet": "static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_test_and_inuse",
          "args": [
            "sbi",
            "new_segno"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "__set_test_and_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "380-392",
          "snippet": "static inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tspin_lock(&free_i->segmap_lock);\n\tif (!test_and_set_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments--;\n\t\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\t\tfree_i->free_sections--;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tspin_lock(&free_i->segmap_lock);\n\tif (!test_and_set_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments--;\n\t\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\t\tfree_i->free_sections--;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sum_page",
          "args": [
            "sbi",
            "curseg->sum_blk",
            "GET_SUM_BLOCK(sbi, curseg->segno)"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "write_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "765-773",
          "snippet": "static void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "curseg->segno"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tif (reuse) {\n\t\tsum_page = get_sum_page(sbi, new_segno);\n\t\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\t\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\t\tf2fs_put_page(sum_page, 1);\n\t}\n}"
  },
  {
    "function_name": "__refresh_next_blkoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "945-952",
    "snippet": "static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next_free_blkoff",
          "args": [
            "sbi",
            "seg",
            "seg->next_blkoff + 1"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__next_free_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "922-938",
          "snippet": "static void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}"
  },
  {
    "function_name": "__next_free_blkoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "922-938",
    "snippet": "static void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_rev_next_zero_bit",
          "args": [
            "target_map",
            "sbi->blocks_per_seg",
            "start"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "__find_rev_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "126-176",
          "snippet": "static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "seg->segno"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}"
  },
  {
    "function_name": "new_curseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "902-920",
    "snippet": "static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = LFS;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_curseg",
          "args": [
            "sbi",
            "type",
            "1"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "reset_curseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "879-896",
          "snippet": "static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_new_segment",
          "args": [
            "sbi",
            "&segno",
            "new_sec",
            "dir"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "790-877",
          "snippet": "static void get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno, secno, zoneno;\n\tunsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;\n\tunsigned int hint = *newseg / sbi->segs_per_sec;\n\tunsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);\n\tunsigned int left_start = hint;\n\tbool init = true;\n\tint go_left = 0;\n\tint i;\n\n\tspin_lock(&free_i->segmap_lock);\n\n\tif (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {\n\t\tsegno = find_next_zero_bit(free_i->free_segmap,\n\t\t\t\t\tMAIN_SEGS(sbi), *newseg + 1);\n\t\tif (segno - *newseg < sbi->segs_per_sec -\n\t\t\t\t\t(*newseg % sbi->segs_per_sec))\n\t\t\tgoto got_it;\n\t}\nfind_other_zone:\n\tsecno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);\n\tif (secno >= MAIN_SECS(sbi)) {\n\t\tif (dir == ALLOC_RIGHT) {\n\t\t\tsecno = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\t\tf2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tgo_left = 1;\n\t\t\tleft_start = hint - 1;\n\t\t}\n\t}\n\tif (go_left == 0)\n\t\tgoto skip_left;\n\n\twhile (test_bit(left_start, free_i->free_secmap)) {\n\t\tif (left_start > 0) {\n\t\t\tleft_start--;\n\t\t\tcontinue;\n\t\t}\n\t\tleft_start = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\tf2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));\n\t\tbreak;\n\t}\n\tsecno = left_start;\nskip_left:\n\thint = secno;\n\tsegno = secno * sbi->segs_per_sec;\n\tzoneno = secno / sbi->secs_per_zone;\n\n\t/* give up on finding another zone */\n\tif (!init)\n\t\tgoto got_it;\n\tif (sbi->secs_per_zone == 1)\n\t\tgoto got_it;\n\tif (zoneno == old_zoneno)\n\t\tgoto got_it;\n\tif (dir == ALLOC_LEFT) {\n\t\tif (!go_left && zoneno + 1 >= total_zones)\n\t\t\tgoto got_it;\n\t\tif (go_left && zoneno == 0)\n\t\t\tgoto got_it;\n\t}\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tif (CURSEG_I(sbi, i)->zone == zoneno)\n\t\t\tbreak;\n\n\tif (i < NR_CURSEG_TYPE) {\n\t\t/* zone is in user, try another */\n\t\tif (go_left)\n\t\t\thint = zoneno * sbi->secs_per_zone - 1;\n\t\telse if (zoneno + 1 >= total_zones)\n\t\t\thint = 0;\n\t\telse\n\t\t\thint = (zoneno + 1) * sbi->secs_per_zone;\n\t\tinit = false;\n\t\tgoto find_other_zone;\n\t}\ngot_it:\n\t/* set it as dirty segment in free segmap */\n\tf2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));\n\t__set_inuse(sbi, segno);\n\t*newseg = segno;\n\tspin_unlock(&free_i->segmap_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno, secno, zoneno;\n\tunsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;\n\tunsigned int hint = *newseg / sbi->segs_per_sec;\n\tunsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);\n\tunsigned int left_start = hint;\n\tbool init = true;\n\tint go_left = 0;\n\tint i;\n\n\tspin_lock(&free_i->segmap_lock);\n\n\tif (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {\n\t\tsegno = find_next_zero_bit(free_i->free_segmap,\n\t\t\t\t\tMAIN_SEGS(sbi), *newseg + 1);\n\t\tif (segno - *newseg < sbi->segs_per_sec -\n\t\t\t\t\t(*newseg % sbi->segs_per_sec))\n\t\t\tgoto got_it;\n\t}\nfind_other_zone:\n\tsecno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);\n\tif (secno >= MAIN_SECS(sbi)) {\n\t\tif (dir == ALLOC_RIGHT) {\n\t\t\tsecno = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\t\tf2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tgo_left = 1;\n\t\t\tleft_start = hint - 1;\n\t\t}\n\t}\n\tif (go_left == 0)\n\t\tgoto skip_left;\n\n\twhile (test_bit(left_start, free_i->free_secmap)) {\n\t\tif (left_start > 0) {\n\t\t\tleft_start--;\n\t\t\tcontinue;\n\t\t}\n\t\tleft_start = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\tf2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));\n\t\tbreak;\n\t}\n\tsecno = left_start;\nskip_left:\n\thint = secno;\n\tsegno = secno * sbi->segs_per_sec;\n\tzoneno = secno / sbi->secs_per_zone;\n\n\t/* give up on finding another zone */\n\tif (!init)\n\t\tgoto got_it;\n\tif (sbi->secs_per_zone == 1)\n\t\tgoto got_it;\n\tif (zoneno == old_zoneno)\n\t\tgoto got_it;\n\tif (dir == ALLOC_LEFT) {\n\t\tif (!go_left && zoneno + 1 >= total_zones)\n\t\t\tgoto got_it;\n\t\tif (go_left && zoneno == 0)\n\t\t\tgoto got_it;\n\t}\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tif (CURSEG_I(sbi, i)->zone == zoneno)\n\t\t\tbreak;\n\n\tif (i < NR_CURSEG_TYPE) {\n\t\t/* zone is in user, try another */\n\t\tif (go_left)\n\t\t\thint = zoneno * sbi->secs_per_zone - 1;\n\t\telse if (zoneno + 1 >= total_zones)\n\t\t\thint = 0;\n\t\telse\n\t\t\thint = (zoneno + 1) * sbi->secs_per_zone;\n\t\tinit = false;\n\t\tgoto find_other_zone;\n\t}\ngot_it:\n\t/* set it as dirty segment in free segmap */\n\tf2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));\n\t__set_inuse(sbi, segno);\n\t*newseg = segno;\n\tspin_unlock(&free_i->segmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOHEAP"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_sum_page",
          "args": [
            "sbi",
            "curseg->sum_blk",
            "GET_SUM_BLOCK(sbi, segno)"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "write_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "765-773",
          "snippet": "static void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = LFS;\n}"
  },
  {
    "function_name": "reset_curseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "879-896",
    "snippet": "static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_sit_entry_type",
          "args": [
            "sbi",
            "type",
            "curseg->segno",
            "modified"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "__set_sit_entry_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "637-644",
          "snippet": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tse->type = type;\n\tif (modified)\n\t\t__mark_sit_entry_dirty(sbi, segno);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tse->type = type;\n\tif (modified)\n\t\t__mark_sit_entry_dirty(sbi, segno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_SUM_TYPE",
          "args": [
            "sum_footer",
            "SUM_TYPE_NODE"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NODESEG",
          "args": [
            "type"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_SUM_TYPE",
          "args": [
            "sum_footer",
            "SUM_TYPE_DATA"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DATASEG",
          "args": [
            "type"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sum_footer",
            "0",
            "sizeof(struct summary_footer)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_ZONENO_FROM_SEGNO",
          "args": [
            "sbi",
            "curseg->segno"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\tif (IS_DATASEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, type, curseg->segno, modified);\n}"
  },
  {
    "function_name": "get_new_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "790-877",
    "snippet": "static void get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno, secno, zoneno;\n\tunsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;\n\tunsigned int hint = *newseg / sbi->segs_per_sec;\n\tunsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);\n\tunsigned int left_start = hint;\n\tbool init = true;\n\tint go_left = 0;\n\tint i;\n\n\tspin_lock(&free_i->segmap_lock);\n\n\tif (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {\n\t\tsegno = find_next_zero_bit(free_i->free_segmap,\n\t\t\t\t\tMAIN_SEGS(sbi), *newseg + 1);\n\t\tif (segno - *newseg < sbi->segs_per_sec -\n\t\t\t\t\t(*newseg % sbi->segs_per_sec))\n\t\t\tgoto got_it;\n\t}\nfind_other_zone:\n\tsecno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);\n\tif (secno >= MAIN_SECS(sbi)) {\n\t\tif (dir == ALLOC_RIGHT) {\n\t\t\tsecno = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\t\tf2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tgo_left = 1;\n\t\t\tleft_start = hint - 1;\n\t\t}\n\t}\n\tif (go_left == 0)\n\t\tgoto skip_left;\n\n\twhile (test_bit(left_start, free_i->free_secmap)) {\n\t\tif (left_start > 0) {\n\t\t\tleft_start--;\n\t\t\tcontinue;\n\t\t}\n\t\tleft_start = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\tf2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));\n\t\tbreak;\n\t}\n\tsecno = left_start;\nskip_left:\n\thint = secno;\n\tsegno = secno * sbi->segs_per_sec;\n\tzoneno = secno / sbi->secs_per_zone;\n\n\t/* give up on finding another zone */\n\tif (!init)\n\t\tgoto got_it;\n\tif (sbi->secs_per_zone == 1)\n\t\tgoto got_it;\n\tif (zoneno == old_zoneno)\n\t\tgoto got_it;\n\tif (dir == ALLOC_LEFT) {\n\t\tif (!go_left && zoneno + 1 >= total_zones)\n\t\t\tgoto got_it;\n\t\tif (go_left && zoneno == 0)\n\t\t\tgoto got_it;\n\t}\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tif (CURSEG_I(sbi, i)->zone == zoneno)\n\t\t\tbreak;\n\n\tif (i < NR_CURSEG_TYPE) {\n\t\t/* zone is in user, try another */\n\t\tif (go_left)\n\t\t\thint = zoneno * sbi->secs_per_zone - 1;\n\t\telse if (zoneno + 1 >= total_zones)\n\t\t\thint = 0;\n\t\telse\n\t\t\thint = (zoneno + 1) * sbi->secs_per_zone;\n\t\tinit = false;\n\t\tgoto find_other_zone;\n\t}\ngot_it:\n\t/* set it as dirty segment in free segmap */\n\tf2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));\n\t__set_inuse(sbi, segno);\n\t*newseg = segno;\n\tspin_unlock(&free_i->segmap_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&free_i->segmap_lock"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_inuse",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__set_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "347-356",
          "snippet": "static inline void __set_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tset_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments--;\n\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\tfree_i->free_sections--;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void __set_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tset_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments--;\n\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\tfree_i->free_sections--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "test_bit(segno, free_i->free_segmap)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "segno",
            "free_i->free_segmap"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "left_start >= MAIN_SECS(sbi)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "free_i->free_secmap",
            "MAIN_SECS(sbi)",
            "0"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "secno >= MAIN_SECS(sbi)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&free_i->segmap_lock"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_ZONENO_FROM_SEGNO",
          "args": [
            "sbi",
            "*newseg"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_I",
          "args": [
            "sbi"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "FREE_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "695-698",
          "snippet": "static inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno, secno, zoneno;\n\tunsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;\n\tunsigned int hint = *newseg / sbi->segs_per_sec;\n\tunsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);\n\tunsigned int left_start = hint;\n\tbool init = true;\n\tint go_left = 0;\n\tint i;\n\n\tspin_lock(&free_i->segmap_lock);\n\n\tif (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {\n\t\tsegno = find_next_zero_bit(free_i->free_segmap,\n\t\t\t\t\tMAIN_SEGS(sbi), *newseg + 1);\n\t\tif (segno - *newseg < sbi->segs_per_sec -\n\t\t\t\t\t(*newseg % sbi->segs_per_sec))\n\t\t\tgoto got_it;\n\t}\nfind_other_zone:\n\tsecno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);\n\tif (secno >= MAIN_SECS(sbi)) {\n\t\tif (dir == ALLOC_RIGHT) {\n\t\t\tsecno = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\t\tf2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tgo_left = 1;\n\t\t\tleft_start = hint - 1;\n\t\t}\n\t}\n\tif (go_left == 0)\n\t\tgoto skip_left;\n\n\twhile (test_bit(left_start, free_i->free_secmap)) {\n\t\tif (left_start > 0) {\n\t\t\tleft_start--;\n\t\t\tcontinue;\n\t\t}\n\t\tleft_start = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\tf2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));\n\t\tbreak;\n\t}\n\tsecno = left_start;\nskip_left:\n\thint = secno;\n\tsegno = secno * sbi->segs_per_sec;\n\tzoneno = secno / sbi->secs_per_zone;\n\n\t/* give up on finding another zone */\n\tif (!init)\n\t\tgoto got_it;\n\tif (sbi->secs_per_zone == 1)\n\t\tgoto got_it;\n\tif (zoneno == old_zoneno)\n\t\tgoto got_it;\n\tif (dir == ALLOC_LEFT) {\n\t\tif (!go_left && zoneno + 1 >= total_zones)\n\t\t\tgoto got_it;\n\t\tif (go_left && zoneno == 0)\n\t\t\tgoto got_it;\n\t}\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tif (CURSEG_I(sbi, i)->zone == zoneno)\n\t\t\tbreak;\n\n\tif (i < NR_CURSEG_TYPE) {\n\t\t/* zone is in user, try another */\n\t\tif (go_left)\n\t\t\thint = zoneno * sbi->secs_per_zone - 1;\n\t\telse if (zoneno + 1 >= total_zones)\n\t\t\thint = 0;\n\t\telse\n\t\t\thint = (zoneno + 1) * sbi->secs_per_zone;\n\t\tinit = false;\n\t\tgoto find_other_zone;\n\t}\ngot_it:\n\t/* set it as dirty segment in free segmap */\n\tf2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));\n\t__set_inuse(sbi, segno);\n\t*newseg = segno;\n\tspin_unlock(&free_i->segmap_lock);\n}"
  },
  {
    "function_name": "is_next_segment_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "775-784",
    "snippet": "static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno + 1;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\n\tif (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)\n\t\treturn !test_bit(segno, free_i->free_segmap);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "segno",
            "free_i->free_segmap"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_I",
          "args": [
            "sbi"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "FREE_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "695-698",
          "snippet": "static inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int is_next_segment_free(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno = curseg->segno + 1;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\n\tif (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)\n\t\treturn !test_bit(segno, free_i->free_segmap);\n\treturn 0;\n}"
  },
  {
    "function_name": "write_sum_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "765-773",
    "snippet": "static void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "sum_blk",
            "PAGE_CACHE_SIZE"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "blk_addr"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tstruct page *page = grab_meta_page(sbi, blk_addr);\n\tvoid *kaddr = page_address(page);\n\tmemcpy(kaddr, sum_blk, PAGE_CACHE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}"
  },
  {
    "function_name": "get_sum_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "760-763",
    "snippet": "struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "GET_SUM_BLOCK(sbi, segno)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}"
  },
  {
    "function_name": "npages_for_summary_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "730-755",
    "snippet": "int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "curseg_blkoff",
          "args": [
            "sbi",
            "i"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "curseg_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "549-553",
          "snippet": "static inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "F2FS_CKPT(sbi)->cur_data_blkoff[i]"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}"
  },
  {
    "function_name": "__add_sum_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "718-725",
    "snippet": "static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "sum",
            "sizeof(struct f2fs_summary)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}"
  },
  {
    "function_name": "invalidate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "695-713",
    "snippet": "void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locate_dirty_segment",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "432-455",
          "snippet": "static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sit_entry",
          "args": [
            "sbi",
            "addr",
            "-1"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "update_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "646-683",
          "snippet": "static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "addr == NULL_ADDR"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "addr"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
  },
  {
    "function_name": "refresh_sit_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "685-693",
    "snippet": "void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locate_dirty_segment",
          "args": [
            "sbi",
            "GET_SEGNO(sbi, new)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "432-455",
          "snippet": "static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "new"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "old"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_sit_entry",
          "args": [
            "sbi",
            "old",
            "-1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "update_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "646-683",
          "snippet": "static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "old"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}"
  },
  {
    "function_name": "update_sit_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "646-683",
    "snippet": "static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_sec_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "get_sec_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "275-280",
          "snippet": "static inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sec_entries[GET_SECNO(sbi, segno)];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sec_entries[GET_SECNO(sbi, segno)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_sit_entry_dirty",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_sit_entry_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "625-635",
          "snippet": "static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_test_bit",
          "args": [
            "offset",
            "se->ckpt_valid_map"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "1"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_test_and_clear_bit",
          "args": [
            "offset",
            "se->cur_valid_map"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "1"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_test_and_set_bit",
          "args": [
            "offset",
            "se->cur_valid_map"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mtime",
          "args": [
            "sbi"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "get_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "664-669",
          "snippet": "static inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "(new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg))"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_BLKOFF_FROM_SEG0",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||\n\t\t\t\t(new_vblocks > sbi->blocks_per_seg)));\n\n\tse->valid_blocks = new_vblocks;\n\tse->mtime = get_mtime(sbi);\n\tSIT_I(sbi)->max_mtime = se->mtime;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\tif (f2fs_test_and_set_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t} else {\n\t\tif (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (sbi->segs_per_sec > 1)\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}"
  },
  {
    "function_name": "__set_sit_entry_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "637-644",
    "snippet": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tse->type = type;\n\tif (modified)\n\t\t__mark_sit_entry_dirty(sbi, segno);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_sit_entry_dirty",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_sit_entry_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "625-635",
          "snippet": "static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tse->type = type;\n\tif (modified)\n\t\t__mark_sit_entry_dirty(sbi, segno);\n}"
  },
  {
    "function_name": "__mark_sit_entry_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "625-635",
    "snippet": "static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "segno",
            "sit_i->dirty_sentries_bitmap"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "clear_prefree_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "585-623",
    "snippet": "void clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *discard_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "discard_entry_slab",
            "entry"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_issue_discard",
          "args": [
            "sbi",
            "entry->blkaddr",
            "entry->len"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "457-464",
          "snippet": "static int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "this",
            "head",
            "list"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_BLOCK",
          "args": [
            "sbi",
            "start"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISCARD"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "i",
            "prefree_map"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "prefree_map",
            "MAIN_SEGS(sbi)",
            "start + 1"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "prefree_map",
            "MAIN_SEGS(sbi)",
            "end + 1"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
  },
  {
    "function_name": "set_prefree_as_free_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "574-583",
    "snippet": "static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))\n\t\t__set_test_and_free(sbi, segno);\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_test_and_free",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "__set_test_and_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "358-378",
          "snippet": "static inline void __set_test_and_free(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tunsigned int start_segno = secno * sbi->segs_per_sec;\n\tunsigned int next;\n\n\tspin_lock(&free_i->segmap_lock);\n\tif (test_and_clear_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments++;\n\n\t\tnext = find_next_bit(free_i->free_segmap,\n\t\t\t\tstart_segno + sbi->segs_per_sec, start_segno);\n\t\tif (next >= start_segno + sbi->segs_per_sec) {\n\t\t\tif (test_and_clear_bit(secno, free_i->free_secmap))\n\t\t\t\tfree_i->free_sections++;\n\t\t}\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void __set_test_and_free(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = segno / sbi->segs_per_sec;\n\tunsigned int start_segno = secno * sbi->segs_per_sec;\n\tunsigned int next;\n\n\tspin_lock(&free_i->segmap_lock);\n\tif (test_and_clear_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments++;\n\n\t\tnext = find_next_bit(free_i->free_segmap,\n\t\t\t\tstart_segno + sbi->segs_per_sec, start_segno);\n\t\tif (next >= start_segno + sbi->segs_per_sec) {\n\t\t\tif (test_and_clear_bit(secno, free_i->free_secmap))\n\t\t\t\tfree_i->free_sections++;\n\t\t}\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "segno",
            "dirty_i->dirty_segmap[PRE]",
            "MAIN_SEGS(sbi)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))\n\t\t__set_test_and_free(sbi, segno);\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
  },
  {
    "function_name": "release_discard_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "559-569",
    "snippet": "void release_discard_addrs(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\n\t/* drop caches */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *discard_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "discard_entry_slab",
            "entry"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "this",
            "head",
            "list"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid release_discard_addrs(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\n\t/* drop caches */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
  },
  {
    "function_name": "add_discard_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "501-557",
    "snippet": "static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tint max_blocks = sbi->blocks_per_seg;\n\tstruct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *dmap = SIT_I(sbi)->tmp_map;\n\tunsigned int start = 0, end = -1;\n\tbool force = (cpc->reason == CP_DISCARD);\n\tint i;\n\n\tif (!force && (!test_opt(sbi, DISCARD) ||\n\t\t\tSM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards))\n\t\treturn;\n\n\tif (force && !se->valid_blocks) {\n\t\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\t\t/*\n\t\t * if this segment is registered in the prefree list, then\n\t\t * we should skip adding a discard candidate, and let the\n\t\t * checkpoint do that later.\n\t\t */\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\tif (test_bit(cpc->trim_start, dirty_i->dirty_segmap[PRE])) {\n\t\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t\t\tcpc->trimmed += sbi->blocks_per_seg;\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t\t__add_discard_entry(sbi, cpc, 0, sbi->blocks_per_seg);\n\t\treturn;\n\t}\n\n\t/* zero block will be discarded through the prefree list */\n\tif (!se->valid_blocks || se->valid_blocks == max_blocks)\n\t\treturn;\n\n\t/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */\n\tfor (i = 0; i < entries; i++)\n\t\tdmap[i] = force ? ~ckpt_map[i] :\n\t\t\t\t(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];\n\n\twhile (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {\n\t\tstart = __find_rev_next_bit(dmap, max_blocks, end + 1);\n\t\tif (start >= max_blocks)\n\t\t\tbreak;\n\n\t\tend = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);\n\n\t\tif (end - start < cpc->trim_minlen)\n\t\t\tcontinue;\n\n\t\t__add_discard_entry(sbi, cpc, start, end);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_discard_entry",
          "args": [
            "sbi",
            "cpc",
            "start",
            "end"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__add_discard_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "476-499",
          "snippet": "static void __add_discard_entry(struct f2fs_sb_info *sbi,\n\t\tstruct cp_control *cpc, unsigned int start, unsigned int end)\n{\n\tstruct list_head *head = &SM_I(sbi)->discard_list;\n\tstruct discard_entry *new, *last;\n\n\tif (!list_empty(head)) {\n\t\tlast = list_last_entry(head, struct discard_entry, list);\n\t\tif (START_BLOCK(sbi, cpc->trim_start) + start ==\n\t\t\t\t\t\tlast->blkaddr + last->len) {\n\t\t\tlast->len += end - start;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&new->list);\n\tnew->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;\n\tnew->len = end - start;\n\tlist_add_tail(&new->list, head);\ndone:\n\tSM_I(sbi)->nr_discards += end - start;\n\tcpc->trimmed += end - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nstatic void __add_discard_entry(struct f2fs_sb_info *sbi,\n\t\tstruct cp_control *cpc, unsigned int start, unsigned int end)\n{\n\tstruct list_head *head = &SM_I(sbi)->discard_list;\n\tstruct discard_entry *new, *last;\n\n\tif (!list_empty(head)) {\n\t\tlast = list_last_entry(head, struct discard_entry, list);\n\t\tif (START_BLOCK(sbi, cpc->trim_start) + start ==\n\t\t\t\t\t\tlast->blkaddr + last->len) {\n\t\t\tlast->len += end - start;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&new->list);\n\tnew->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;\n\tnew->len = end - start;\n\tlist_add_tail(&new->list, head);\ndone:\n\tSM_I(sbi)->nr_discards += end - start;\n\tcpc->trimmed += end - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_rev_next_zero_bit",
          "args": [
            "dmap",
            "max_blocks",
            "start + 1"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__find_rev_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "126-176",
          "snippet": "static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_rev_next_bit",
          "args": [
            "dmap",
            "max_blocks",
            "end + 1"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__find_rev_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "75-124",
          "snippet": "static unsigned long __find_rev_next_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~0UL << quot;\n\tsubmask = (unsigned char)(0xff << rest) >> rest;\n\tsubmask <<= quot;\n\tmask &= submask;\n\ttmp &= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG-1)) {\n\t\ttmp = *(p++);\n\t\tif (tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\nfound_first:\n\ttmp &= (~0UL >> (BITS_PER_LONG - size));\n\tif (tmp == 0UL)\t\t/* Are any bits set? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffs(tmp);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long __find_rev_next_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~0UL << quot;\n\tsubmask = (unsigned char)(0xff << rest) >> rest;\n\tsubmask <<= quot;\n\tmask &= submask;\n\ttmp &= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG-1)) {\n\t\ttmp = *(p++);\n\t\tif (tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\nfound_first:\n\ttmp &= (~0UL >> (BITS_PER_LONG - size));\n\tif (tmp == 0UL)\t\t/* Are any bits set? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffs(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "cpc->trim_start",
            "dirty_i->dirty_segmap[PRE]"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISCARD"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "cpc->trim_start"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tint max_blocks = sbi->blocks_per_seg;\n\tstruct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *dmap = SIT_I(sbi)->tmp_map;\n\tunsigned int start = 0, end = -1;\n\tbool force = (cpc->reason == CP_DISCARD);\n\tint i;\n\n\tif (!force && (!test_opt(sbi, DISCARD) ||\n\t\t\tSM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards))\n\t\treturn;\n\n\tif (force && !se->valid_blocks) {\n\t\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\t\t/*\n\t\t * if this segment is registered in the prefree list, then\n\t\t * we should skip adding a discard candidate, and let the\n\t\t * checkpoint do that later.\n\t\t */\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\tif (test_bit(cpc->trim_start, dirty_i->dirty_segmap[PRE])) {\n\t\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t\t\tcpc->trimmed += sbi->blocks_per_seg;\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t\t__add_discard_entry(sbi, cpc, 0, sbi->blocks_per_seg);\n\t\treturn;\n\t}\n\n\t/* zero block will be discarded through the prefree list */\n\tif (!se->valid_blocks || se->valid_blocks == max_blocks)\n\t\treturn;\n\n\t/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */\n\tfor (i = 0; i < entries; i++)\n\t\tdmap[i] = force ? ~ckpt_map[i] :\n\t\t\t\t(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];\n\n\twhile (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {\n\t\tstart = __find_rev_next_bit(dmap, max_blocks, end + 1);\n\t\tif (start >= max_blocks)\n\t\t\tbreak;\n\n\t\tend = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);\n\n\t\tif (end - start < cpc->trim_minlen)\n\t\t\tcontinue;\n\n\t\t__add_discard_entry(sbi, cpc, start, end);\n\t}\n}"
  },
  {
    "function_name": "__add_discard_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "476-499",
    "snippet": "static void __add_discard_entry(struct f2fs_sb_info *sbi,\n\t\tstruct cp_control *cpc, unsigned int start, unsigned int end)\n{\n\tstruct list_head *head = &SM_I(sbi)->discard_list;\n\tstruct discard_entry *new, *last;\n\n\tif (!list_empty(head)) {\n\t\tlast = list_last_entry(head, struct discard_entry, list);\n\t\tif (START_BLOCK(sbi, cpc->trim_start) + start ==\n\t\t\t\t\t\tlast->blkaddr + last->len) {\n\t\t\tlast->len += end - start;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&new->list);\n\tnew->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;\n\tnew->len = end - start;\n\tlist_add_tail(&new->list, head);\ndone:\n\tSM_I(sbi)->nr_discards += end - start;\n\tcpc->trimmed += end - start;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *discard_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "head"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_BLOCK",
          "args": [
            "sbi",
            "cpc->trim_start"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "discard_entry_slab",
            "GFP_NOFS"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "START_BLOCK",
          "args": [
            "sbi",
            "cpc->trim_start"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "head",
            "structdiscard_entry",
            "list"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nstatic void __add_discard_entry(struct f2fs_sb_info *sbi,\n\t\tstruct cp_control *cpc, unsigned int start, unsigned int end)\n{\n\tstruct list_head *head = &SM_I(sbi)->discard_list;\n\tstruct discard_entry *new, *last;\n\n\tif (!list_empty(head)) {\n\t\tlast = list_last_entry(head, struct discard_entry, list);\n\t\tif (START_BLOCK(sbi, cpc->trim_start) + start ==\n\t\t\t\t\t\tlast->blkaddr + last->len) {\n\t\t\tlast->len += end - start;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&new->list);\n\tnew->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;\n\tnew->len = end - start;\n\tlist_add_tail(&new->list, head);\ndone:\n\tSM_I(sbi)->nr_discards += end - start;\n\tcpc->trimmed += end - start;\n}"
  },
  {
    "function_name": "discard_next_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "466-474",
    "snippet": "void discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_issue_discard",
          "args": [
            "sbi",
            "blkaddr",
            "1"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "457-464",
          "snippet": "static int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
  },
  {
    "function_name": "f2fs_issue_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "457-464",
    "snippet": "static int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "sbi->sb->s_bdev",
            "start",
            "len",
            "GFP_NOFS",
            "0"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_issue_discard",
          "args": [
            "sbi->sb",
            "blkstart",
            "blklen"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SECTOR_FROM_BLOCK",
          "args": [
            "blklen"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SECTOR_FROM_BLOCK",
          "args": [
            "blkstart"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = SECTOR_FROM_BLOCK(blkstart);\n\tsector_t len = SECTOR_FROM_BLOCK(blklen);\n\ttrace_f2fs_issue_discard(sbi->sb, blkstart, blklen);\n\treturn blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);\n}"
  },
  {
    "function_name": "locate_dirty_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "432-455",
    "snippet": "static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_dirty_segment",
          "args": [
            "sbi",
            "segno",
            "DIRTY"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "406-425",
          "snippet": "static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locate_dirty_segment",
          "args": [
            "sbi",
            "segno",
            "DIRTY"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__locate_dirty_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "381-404",
          "snippet": "static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "0"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CURSEG",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, 0);\n\n\tif (valid_blocks == 0) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < sbi->blocks_per_seg) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}"
  },
  {
    "function_name": "__remove_dirty_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "406-425",
    "snippet": "static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GET_SECNO(sbi, segno)",
            "dirty_i->victim_secmap"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SECNO",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "sbi->segs_per_sec"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tif (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)\n\t\t\tclear_bit(GET_SECNO(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n\t}\n}"
  },
  {
    "function_name": "__locate_dirty_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "381-404",
    "snippet": "static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "segno",
            "dirty_i->dirty_segmap[t]"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t >= DIRTY"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CURSEG",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\t}\n}"
  },
  {
    "function_name": "destroy_flush_cmd_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "371-379",
    "snippet": "void destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fcc"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "fcc->f2fs_issue_flush"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}"
  },
  {
    "function_name": "create_flush_cmd_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "347-369",
    "snippet": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fcc"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fcc->f2fs_issue_flush"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fcc->f2fs_issue_flush"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "issue_flush_thread",
            "sbi",
            "\"f2fs_flush-%u:%u\"",
            "MAJOR(dev)",
            "MINOR(dev)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_llist_head",
          "args": [
            "&fcc->issue_list"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fcc->flush_wait_queue"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct flush_cmd_control)",
            "GFP_KERNEL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_issue_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "321-345",
    "snippet": "int f2fs_issue_flush(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\tstruct flush_cmd cmd;\n\n\ttrace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),\n\t\t\t\t\ttest_opt(sbi, FLUSH_MERGE));\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn blkdev_issue_flush(sbi->sb->s_bdev, GFP_KERNEL, NULL);\n\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\tif (!fcc->dispatch_list)\n\t\twake_up(&fcc->flush_wait_queue);\n\n\twait_for_completion(&cmd.wait);\n\n\treturn cmd.ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&cmd.wait"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fcc->flush_wait_queue"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&cmd.llnode",
            "&fcc->issue_list"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&cmd.wait"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "sbi->sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FLUSH_MERGE"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOBARRIER"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_issue_flush",
          "args": [
            "sbi->sb",
            "test_opt(sbi, NOBARRIER)",
            "test_opt(sbi, FLUSH_MERGE)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FLUSH_MERGE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOBARRIER"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_issue_flush(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\tstruct flush_cmd cmd;\n\n\ttrace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),\n\t\t\t\t\ttest_opt(sbi, FLUSH_MERGE));\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn blkdev_issue_flush(sbi->sb->s_bdev, GFP_KERNEL, NULL);\n\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\tif (!fcc->dispatch_list)\n\t\twake_up(&fcc->flush_wait_queue);\n\n\twait_for_completion(&cmd.wait);\n\n\treturn cmd.ret;\n}"
  },
  {
    "function_name": "issue_flush_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "287-319",
    "snippet": "static int issue_flush_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\twait_queue_head_t *q = &fcc->flush_wait_queue;\nrepeat:\n\tif (kthread_should_stop())\n\t\treturn 0;\n\n\tif (!llist_empty(&fcc->issue_list)) {\n\t\tstruct bio *bio = bio_alloc(GFP_NOIO, 0);\n\t\tstruct flush_cmd *cmd, *next;\n\t\tint ret;\n\n\t\tfcc->dispatch_list = llist_del_all(&fcc->issue_list);\n\t\tfcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);\n\n\t\tbio->bi_bdev = sbi->sb->s_bdev;\n\t\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\n\t\tllist_for_each_entry_safe(cmd, next,\n\t\t\t\t\t  fcc->dispatch_list, llnode) {\n\t\t\tcmd->ret = ret;\n\t\t\tcomplete(&cmd->wait);\n\t\t}\n\t\tbio_put(bio);\n\t\tfcc->dispatch_list = NULL;\n\t}\n\n\twait_event_interruptible(*q,\n\t\tkthread_should_stop() || !llist_empty(&fcc->issue_list));\n\tgoto repeat;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "*q",
            "kthread_should_stop() || !llist_empty(&fcc->issue_list)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "&fcc->issue_list"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&cmd->wait"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_complete_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1757-1852",
          "snippet": "static void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "cmd",
            "next",
            "fcc->dispatch_list",
            "llnode"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "WRITE_FLUSH",
            "bio"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_reverse_order",
          "args": [
            "fcc->dispatch_list"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&fcc->issue_list"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "0"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "&fcc->issue_list"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int issue_flush_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\twait_queue_head_t *q = &fcc->flush_wait_queue;\nrepeat:\n\tif (kthread_should_stop())\n\t\treturn 0;\n\n\tif (!llist_empty(&fcc->issue_list)) {\n\t\tstruct bio *bio = bio_alloc(GFP_NOIO, 0);\n\t\tstruct flush_cmd *cmd, *next;\n\t\tint ret;\n\n\t\tfcc->dispatch_list = llist_del_all(&fcc->issue_list);\n\t\tfcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);\n\n\t\tbio->bi_bdev = sbi->sb->s_bdev;\n\t\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\n\t\tllist_for_each_entry_safe(cmd, next,\n\t\t\t\t\t  fcc->dispatch_list, llnode) {\n\t\t\tcmd->ret = ret;\n\t\t\tcomplete(&cmd->wait);\n\t\t}\n\t\tbio_put(bio);\n\t\tfcc->dispatch_list = NULL;\n\t}\n\n\twait_event_interruptible(*q,\n\t\tkthread_should_stop() || !llist_empty(&fcc->issue_list));\n\tgoto repeat;\n}"
  },
  {
    "function_name": "f2fs_balance_fs_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "278-285",
    "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "true"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "INO_ENTRIES"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "excess_prefree_segs",
          "args": [
            "sbi"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "excess_prefree_segs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "471-474",
          "snippet": "static inline bool excess_prefree_segs(struct f2fs_sb_info *sbi)\n{\n\treturn prefree_segments(sbi) > SM_I(sbi)->rec_prefree_segments;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool excess_prefree_segs(struct f2fs_sb_info *sbi)\n{\n\treturn prefree_segments(sbi) > SM_I(sbi)->rec_prefree_segments;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_nats",
          "args": [
            "sbi",
            "NAT_ENTRY_PER_BLOCK"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_nats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "317-334",
          "snippet": "int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (available_free_memory(sbi, NAT_ENTRIES))\n\t\treturn 0;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr_shrink;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (available_free_memory(sbi, NAT_ENTRIES))\n\t\treturn 0;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr_shrink;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
  },
  {
    "function_name": "f2fs_balance_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "266-276",
    "snippet": "void f2fs_balance_fs(struct f2fs_sb_info *sbi)\n{\n\t/*\n\t * We should do GC or end up with checkpoint, if there are so many dirty\n\t * dir/node pages without enough free segments.\n\t */\n\tif (has_not_enough_free_secs(sbi, 0)) {\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\tf2fs_gc(sbi);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_gc",
          "args": [
            "sbi"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "689-741",
          "snippet": "int f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs(struct f2fs_sb_info *sbi)\n{\n\t/*\n\t * We should do GC or end up with checkpoint, if there are so many dirty\n\t * dir/node pages without enough free segments.\n\t */\n\tif (has_not_enough_free_secs(sbi, 0)) {\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\tf2fs_gc(sbi);\n\t}\n}"
  },
  {
    "function_name": "commit_inmem_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "210-260",
    "snippet": "void commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inmem_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "DATA",
            "WRITE"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "F2FS_I_SB(inode)",
            "F2FS_INMEM_PAGES"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inmem_entry_slab",
            "cur"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cur->list"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&fi->inmem_root",
            "cur->page->index"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "cur->page"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "cur->page",
            "1"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_write_data_page",
          "args": [
            "cur->page",
            "&fio"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "802-838",
          "snippet": "int do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "cur->page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "cur->page",
            "DATA"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "cur->page"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cur",
            "tmp",
            "&fi->inmem_pages",
            "list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}"
  },
  {
    "function_name": "register_inmem_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "178-208",
    "snippet": "void register_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *new;\n\tint err;\n\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n\n\tnew = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);\n\n\t/* add atomic page indices to the list */\n\tnew->page = page;\n\tINIT_LIST_HEAD(&new->list);\nretry:\n\t/* increase reference count with clean state */\n\tmutex_lock(&fi->inmem_lock);\n\terr = radix_tree_insert(&fi->inmem_root, page->index, new);\n\tif (err == -EEXIST) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tkmem_cache_free(inmem_entry_slab, new);\n\t\treturn;\n\t} else if (err) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tgoto retry;\n\t}\n\tget_page(page);\n\tlist_add_tail(&new->list, &fi->inmem_pages);\n\tinc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\tmutex_unlock(&fi->inmem_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inmem_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_page_count",
          "args": [
            "F2FS_I_SB(inode)",
            "F2FS_INMEM_PAGES"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "inc_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "858-862",
          "snippet": "static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "&fi->inmem_pages"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inmem_entry_slab",
            "new"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&fi->inmem_root",
            "page->index",
            "new"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "inmem_entry_slab",
            "GFP_NOFS"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_trace_pid",
          "args": [
            "page"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "55-81",
          "snippet": "void f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid register_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *new;\n\tint err;\n\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n\n\tnew = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);\n\n\t/* add atomic page indices to the list */\n\tnew->page = page;\n\tINIT_LIST_HEAD(&new->list);\nretry:\n\t/* increase reference count with clean state */\n\tmutex_lock(&fi->inmem_lock);\n\terr = radix_tree_insert(&fi->inmem_root, page->index, new);\n\tif (err == -EEXIST) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tkmem_cache_free(inmem_entry_slab, new);\n\t\treturn;\n\t} else if (err) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tgoto retry;\n\t}\n\tget_page(page);\n\tlist_add_tail(&new->list, &fi->inmem_pages);\n\tinc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\tmutex_unlock(&fi->inmem_lock);\n}"
  },
  {
    "function_name": "__find_rev_next_zero_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "126-176",
    "snippet": "static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reverse_ffz",
          "args": [
            "tmp"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_WORD",
          "args": [
            "offset"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~(~0UL << quot);\n\tsubmask = (unsigned char)~((unsigned char)(0xff << rest) >> rest);\n\tsubmask <<= quot;\n\tmask += submask;\n\ttmp |= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (~tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG - 1)) {\n\t\ttmp = *(p++);\n\t\tif (~tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\n\nfound_first:\n\ttmp |= ~0UL << size;\n\tif (tmp == ~0UL)        /* Are any bits zero? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffz(tmp);\n}"
  },
  {
    "function_name": "__find_rev_next_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "75-124",
    "snippet": "static unsigned long __find_rev_next_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~0UL << quot;\n\tsubmask = (unsigned char)(0xff << rest) >> rest;\n\tsubmask <<= quot;\n\tmask &= submask;\n\ttmp &= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG-1)) {\n\t\ttmp = *(p++);\n\t\tif (tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\nfound_first:\n\ttmp &= (~0UL >> (BITS_PER_LONG - size));\n\tif (tmp == 0UL)\t\t/* Are any bits set? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffs(tmp);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reverse_ffs",
          "args": [
            "tmp"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__reverse_ffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "36-65",
          "snippet": "static inline unsigned long __reverse_ffs(unsigned long word)\n{\n\tint num = 0;\n\n#if BITS_PER_LONG == 64\n\tif ((word & 0xffffffff) == 0) {\n\t\tnum += 32;\n\t\tword >>= 32;\n\t}\n#endif\n\tif ((word & 0xffff) == 0) {\n\t\tnum += 16;\n\t\tword >>= 16;\n\t}\n\tif ((word & 0xff) == 0) {\n\t\tnum += 8;\n\t\tword >>= 8;\n\t}\n\tif ((word & 0xf0) == 0)\n\t\tnum += 4;\n\telse\n\t\tword >>= 4;\n\tif ((word & 0xc) == 0)\n\t\tnum += 2;\n\telse\n\t\tword >>= 2;\n\tif ((word & 0x2) == 0)\n\t\tnum += 1;\n\treturn num;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long __reverse_ffs(unsigned long word)\n{\n\tint num = 0;\n\n#if BITS_PER_LONG == 64\n\tif ((word & 0xffffffff) == 0) {\n\t\tnum += 32;\n\t\tword >>= 32;\n\t}\n#endif\n\tif ((word & 0xffff) == 0) {\n\t\tnum += 16;\n\t\tword >>= 16;\n\t}\n\tif ((word & 0xff) == 0) {\n\t\tnum += 8;\n\t\tword >>= 8;\n\t}\n\tif ((word & 0xf0) == 0)\n\t\tnum += 4;\n\telse\n\t\tword >>= 4;\n\tif ((word & 0xc) == 0)\n\t\tnum += 2;\n\telse\n\t\tword >>= 2;\n\tif ((word & 0x2) == 0)\n\t\tnum += 1;\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT_WORD",
          "args": [
            "offset"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long __find_rev_next_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = offset & ~(BITS_PER_LONG - 1);\n\tunsigned long tmp;\n\tunsigned long mask, submask;\n\tunsigned long quot, rest;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= result;\n\toffset %= BITS_PER_LONG;\n\tif (!offset)\n\t\tgoto aligned;\n\n\ttmp = *(p++);\n\tquot = (offset >> 3) << 3;\n\trest = offset & 0x7;\n\tmask = ~0UL << quot;\n\tsubmask = (unsigned char)(0xff << rest) >> rest;\n\tsubmask <<= quot;\n\tmask &= submask;\n\ttmp &= mask;\n\tif (size < BITS_PER_LONG)\n\t\tgoto found_first;\n\tif (tmp)\n\t\tgoto found_middle;\n\n\tsize -= BITS_PER_LONG;\n\tresult += BITS_PER_LONG;\naligned:\n\twhile (size & ~(BITS_PER_LONG-1)) {\n\t\ttmp = *(p++);\n\t\tif (tmp)\n\t\t\tgoto found_middle;\n\t\tresult += BITS_PER_LONG;\n\t\tsize -= BITS_PER_LONG;\n\t}\n\tif (!size)\n\t\treturn result;\n\ttmp = *p;\nfound_first:\n\ttmp &= (~0UL >> (BITS_PER_LONG - size));\n\tif (tmp == 0UL)\t\t/* Are any bits set? */\n\t\treturn result + size;   /* Nope. */\nfound_middle:\n\treturn result + __reverse_ffs(tmp);\n}"
  },
  {
    "function_name": "__reverse_ffs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
    "lines": "36-65",
    "snippet": "static inline unsigned long __reverse_ffs(unsigned long word)\n{\n\tint num = 0;\n\n#if BITS_PER_LONG == 64\n\tif ((word & 0xffffffff) == 0) {\n\t\tnum += 32;\n\t\tword >>= 32;\n\t}\n#endif\n\tif ((word & 0xffff) == 0) {\n\t\tnum += 16;\n\t\tword >>= 16;\n\t}\n\tif ((word & 0xff) == 0) {\n\t\tnum += 8;\n\t\tword >>= 8;\n\t}\n\tif ((word & 0xf0) == 0)\n\t\tnum += 4;\n\telse\n\t\tword >>= 4;\n\tif ((word & 0xc) == 0)\n\t\tnum += 2;\n\telse\n\t\tword >>= 2;\n\tif ((word & 0x2) == 0)\n\t\tnum += 1;\n\treturn num;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"node.h\"",
      "#include \"segment.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kthread.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long __reverse_ffs(unsigned long word)\n{\n\tint num = 0;\n\n#if BITS_PER_LONG == 64\n\tif ((word & 0xffffffff) == 0) {\n\t\tnum += 32;\n\t\tword >>= 32;\n\t}\n#endif\n\tif ((word & 0xffff) == 0) {\n\t\tnum += 16;\n\t\tword >>= 16;\n\t}\n\tif ((word & 0xff) == 0) {\n\t\tnum += 8;\n\t\tword >>= 8;\n\t}\n\tif ((word & 0xf0) == 0)\n\t\tnum += 4;\n\telse\n\t\tword >>= 4;\n\tif ((word & 0xc) == 0)\n\t\tnum += 2;\n\telse\n\t\tword >>= 2;\n\tif ((word & 0x2) == 0)\n\t\tnum += 1;\n\treturn num;\n}"
  }
]