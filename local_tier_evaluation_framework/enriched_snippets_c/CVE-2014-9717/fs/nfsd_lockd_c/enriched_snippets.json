[
  {
    "function_name": "nfsd_lockd_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/lockd.c",
    "lines": "73-77",
    "snippet": "void\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/lockd/bind.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nvoid\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}"
  },
  {
    "function_name": "nfsd_lockd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/lockd.c",
    "lines": "66-71",
    "snippet": "void\nnfsd_lockd_init(void)\n{\n\tdprintk(\"nfsd: initializing lockd\\n\");\n\tnlmsvc_ops = &nfsd_nlm_ops;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/lockd/bind.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nlmsvc_binding\tnfsd_nlm_ops = {\n\t.fopen\t\t= nlm_fopen,\t\t/* open file for locking */\n\t.fclose\t\t= nlm_fclose,\t\t/* close file */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: initializing lockd\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nstatic struct nlmsvc_binding\tnfsd_nlm_ops = {\n\t.fopen\t\t= nlm_fopen,\t\t/* open file for locking */\n\t.fclose\t\t= nlm_fclose,\t\t/* close file */\n};\n\nvoid\nnfsd_lockd_init(void)\n{\n\tdprintk(\"nfsd: initializing lockd\\n\");\n\tnlmsvc_ops = &nfsd_nlm_ops;\n}"
  },
  {
    "function_name": "nlm_fclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/lockd.c",
    "lines": "55-59",
    "snippet": "static void\nnlm_fclose(struct file *filp)\n{\n\tfput(filp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/lockd/bind.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nstatic void\nnlm_fclose(struct file *filp)\n{\n\tfput(filp);\n}"
  },
  {
    "function_name": "nlm_fopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/lockd.c",
    "lines": "26-53",
    "snippet": "static __be32\nnlm_fopen(struct svc_rqst *rqstp, struct nfs_fh *f, struct file **filp)\n{\n\t__be32\t\tnfserr;\n\tstruct svc_fh\tfh;\n\n\t/* must initialize before using! but maxsize doesn't matter */\n\tfh_init(&fh,0);\n\tfh.fh_handle.fh_size = f->size;\n\tmemcpy((char*)&fh.fh_handle.fh_base, f->data, f->size);\n\tfh.fh_export = NULL;\n\n\tnfserr = nfsd_open(rqstp, &fh, S_IFREG, NFSD_MAY_LOCK, filp);\n\tfh_put(&fh);\n \t/* We return nlm error codes as nlm doesn't know\n\t * about nfsd, but nfsd does know about nlm..\n\t */\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\treturn 0;\n\tcase nfserr_dropit:\n\t\treturn nlm_drop_reply;\n\tcase nfserr_stale:\n\t\treturn nlm_stale_fh;\n\tdefault:\n\t\treturn nlm_failed;\n\t}\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/lockd/bind.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define nlm_failed\tnlm_lck_denied_nolocks",
      "#define nlm_stale_fh\tnlm_lck_denied_nolocks",
      "#define nlm_failed\tnlm4_failed",
      "#define nlm_stale_fh\tnlm4_stale_fh"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&fh"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "&fh",
            "S_IFREG",
            "NFSD_MAY_LOCK",
            "filp"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "677-762",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)&fh.fh_handle.fh_base",
            "f->data",
            "f->size"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&fh",
            "0"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\n#define nlm_failed\tnlm_lck_denied_nolocks\n#define nlm_stale_fh\tnlm_lck_denied_nolocks\n#define nlm_failed\tnlm4_failed\n#define nlm_stale_fh\tnlm4_stale_fh\n\nstatic __be32\nnlm_fopen(struct svc_rqst *rqstp, struct nfs_fh *f, struct file **filp)\n{\n\t__be32\t\tnfserr;\n\tstruct svc_fh\tfh;\n\n\t/* must initialize before using! but maxsize doesn't matter */\n\tfh_init(&fh,0);\n\tfh.fh_handle.fh_size = f->size;\n\tmemcpy((char*)&fh.fh_handle.fh_base, f->data, f->size);\n\tfh.fh_export = NULL;\n\n\tnfserr = nfsd_open(rqstp, &fh, S_IFREG, NFSD_MAY_LOCK, filp);\n\tfh_put(&fh);\n \t/* We return nlm error codes as nlm doesn't know\n\t * about nfsd, but nfsd does know about nlm..\n\t */\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\treturn 0;\n\tcase nfserr_dropit:\n\t\treturn nlm_drop_reply;\n\tcase nfserr_stale:\n\t\treturn nlm_stale_fh;\n\tdefault:\n\t\treturn nlm_failed;\n\t}\n}"
  }
]