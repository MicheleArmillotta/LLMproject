[
  {
    "function_name": "affs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "953-969",
    "snippet": "int affs_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret, err;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = write_inode_now(inode, 0);\n\terr = sync_blockdev(inode->i_sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "inode->i_sb->s_bdev"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "0"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nint affs_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret, err;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = write_inode_now(inode, 0);\n\terr = sync_blockdev(inode->i_sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "affs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "834-951",
    "snippet": "void\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_free_prealloc",
          "args": [
            "inode"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "819-830",
          "snippet": "void\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "ext_bh"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, ext_bh)->extension"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "ext_bh"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "ext_key"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_BLOCK(sb, ext_bh, i)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_BLOCK",
          "args": [
            "sb",
            "ext_bh",
            "i"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "ext_key"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "bh",
            "-tmp"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_DATA_HEAD(bh)->next"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"truncate\"",
            "\"unexpected read error for last block %u (%ld)\"",
            "ext",
            "PTR_ERR(bh)"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread_ino",
          "args": [
            "inode",
            "last_blk",
            "0"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "444-461",
          "snippet": "static inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "ext_bh",
            "inode"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "ext_bh"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "ext_bh"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_BLOCK",
          "args": [
            "sb",
            "ext_bh",
            "i"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_BLOCK(sb, ext_bh, i)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_BLOCK",
          "args": [
            "sb",
            "ext_bh",
            "i"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "ext_bh"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "ext_bh"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, ext_bh)->extension"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "ext_bh"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ext_bh"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ext_bh"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_get_extblock",
          "args": [
            "inode",
            "ext"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_extblock_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "168-291",
          "snippet": "static struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->write_end",
          "args": [
            "NULL",
            "mapping",
            "isize",
            "0",
            "0",
            "page",
            "fsdata"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->write_begin",
          "args": [
            "NULL",
            "mapping",
            "isize",
            "0",
            "0",
            "&page",
            "&fsdata"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\"",
            "inode->i_ino",
            "AFFS_I(inode)->mmu_private",
            "inode->i_size"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}"
  },
  {
    "function_name": "affs_free_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "819-830",
    "snippet": "void\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "++AFFS_I(inode)->i_lastalloc"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"free_prealloc(ino=%lu)\\n\"",
            "inode->i_ino"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}"
  },
  {
    "function_name": "affs_write_end_ofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "669-808",
    "snippet": "static int affs_write_end_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tchar *data;\n\tu32 bidx, boff, bsize;\n\tunsigned from, to;\n\tu32 tmp;\n\tint written;\n\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = pos + len;\n\t/*\n\t * XXX: not sure if this can handle short copies (len < copied), but\n\t * we don't have to, because the page should always be uptodate here,\n\t * due to write_begin.\n\t */\n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tdata = page_address(page);\n\n\tbh = NULL;\n\twritten = 0;\n\ttmp = (page->index << PAGE_CACHE_SHIFT) + from;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t\ttmp = min(bsize - boff, to - from);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh) + boff, data + from, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t}\n\twhile (from + bsize <= to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getemptyblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\tmemcpy(AFFS_DATA(bh), data + from, bsize);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(bsize);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t}\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += bsize;\n\t\tfrom += bsize;\n\t\tbidx++;\n\t}\n\tif (from < to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_bread_ino(inode, bidx, 1);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\ttmp = min(bsize, to - from);\n\t\tBUG_ON(tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh), data + from, tmp);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t} else if (be32_to_cpu(AFFS_DATA_HEAD(bh)->size) < tmp)\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t}\n\tSetPageUptodate(page);\n\ndone:\n\taffs_brelse(bh);\n\ttmp = (page->index << PAGE_CACHE_SHIFT) + from;\n\tif (tmp > inode->i_size)\n\t\tinode->i_size = AFFS_I(inode)->mmu_private = tmp;\n\nerr_first_bh:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn written;\n\nerr_bh:\n\tbh = prev_bh;\n\tif (!written)\n\t\twritten = PTR_ERR(bh);\n\tgoto done;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_DATA_HEAD(bh)->size"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "prev_bh",
            "bh->b_blocknr - tmp_next"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"commit_write_ofs\"",
            "\"next block already set for %d (%d)\"",
            "bidx",
            "tmp_next"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_DATA_HEAD(prev_bh)->next"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bidx"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "T_DATA"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "AFFS_DATA(bh)",
            "data + from",
            "tmp"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA",
          "args": [
            "bh"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp > bsize"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bsize",
            "to - from"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread_ino",
          "args": [
            "inode",
            "bidx",
            "1"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "444-461",
          "snippet": "static inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_DATA_HEAD(prev_bh)->next"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bsize"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bidx"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "T_DATA"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "AFFS_DATA(bh)",
            "data + from",
            "bsize"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA",
          "args": [
            "bh"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_getemptyblk_ino",
          "args": [
            "inode",
            "bidx"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getemptyblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "482-499",
          "snippet": "static inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&AFFS_DATA_HEAD(bh)->size",
            "tmp"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "AFFS_DATA(bh) + boff",
            "data + from",
            "tmp"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA",
          "args": [
            "bh"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "boff + tmp > bsize || tmp > bsize"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %llu, %llu)\\n\"",
            "__func__",
            "inode->i_ino",
            "pos",
            "pos + len"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int affs_write_end_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tchar *data;\n\tu32 bidx, boff, bsize;\n\tunsigned from, to;\n\tu32 tmp;\n\tint written;\n\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = pos + len;\n\t/*\n\t * XXX: not sure if this can handle short copies (len < copied), but\n\t * we don't have to, because the page should always be uptodate here,\n\t * due to write_begin.\n\t */\n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tdata = page_address(page);\n\n\tbh = NULL;\n\twritten = 0;\n\ttmp = (page->index << PAGE_CACHE_SHIFT) + from;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t\ttmp = min(bsize - boff, to - from);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh) + boff, data + from, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t}\n\twhile (from + bsize <= to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getemptyblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\tmemcpy(AFFS_DATA(bh), data + from, bsize);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(bsize);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t}\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += bsize;\n\t\tfrom += bsize;\n\t\tbidx++;\n\t}\n\tif (from < to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_bread_ino(inode, bidx, 1);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\ttmp = min(bsize, to - from);\n\t\tBUG_ON(tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh), data + from, tmp);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t} else if (be32_to_cpu(AFFS_DATA_HEAD(bh)->size) < tmp)\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t}\n\tSetPageUptodate(page);\n\ndone:\n\taffs_brelse(bh);\n\ttmp = (page->index << PAGE_CACHE_SHIFT) + from;\n\tif (tmp > inode->i_size)\n\t\tinode->i_size = AFFS_I(inode)->mmu_private = tmp;\n\nerr_first_bh:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn written;\n\nerr_bh:\n\tbh = prev_bh;\n\tif (!written)\n\t\twritten = PTR_ERR(bh);\n\tgoto done;\n}"
  },
  {
    "function_name": "affs_write_begin_ofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "631-667",
    "snippet": "static int affs_write_begin_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tpgoff_t index;\n\tint err = 0;\n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tif (pos > AFFS_I(inode)->mmu_private) {\n\t\t/* XXX: this probably leaves a too-big i_size in case of\n\t\t * failure. Should really be updating i_size at write_end time\n\t\t */\n\t\terr = affs_extent_file_ofs(inode, pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\t/* XXX: inefficient but safe in the face of short writes */\n\terr = affs_do_readpage_ofs(page, PAGE_CACHE_SIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_do_readpage_ofs",
          "args": [
            "page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "affs_do_readpage_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "501-537",
          "snippet": "static int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_extent_file_ofs",
          "args": [
            "inode",
            "pos"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "affs_extent_file_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "539-608",
          "snippet": "static int\naffs_extent_file_ofs(struct inode *inode, u32 newsize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tu32 bidx, boff;\n\tu32 size, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %d)\\n\", __func__, inode->i_ino, newsize);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tbh = NULL;\n\tsize = AFFS_I(inode)->mmu_private;\n\tbidx = size / bsize;\n\tboff = size % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, newsize - size);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemset(AFFS_DATA(bh) + boff, 0, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tsize += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t}\n\n\twhile (size < newsize) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getzeroblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto out;\n\t\ttmp = min(bsize, newsize - size);\n\t\tBUG_ON(tmp > bsize);\n\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tbh->b_state &= ~(1UL << BH_New);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tif (prev_bh) {\n\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\tif (tmp_next)\n\t\t\t\taffs_warning(sb, \"extent_file_ofs\",\n\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t     bidx, tmp_next);\n\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\taffs_brelse(prev_bh);\n\t\t}\n\t\tsize += bsize;\n\t\tbidx++;\n\t}\n\taffs_brelse(bh);\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn 0;\n\nout:\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn PTR_ERR(bh);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_extent_file_ofs(struct inode *inode, u32 newsize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tu32 bidx, boff;\n\tu32 size, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %d)\\n\", __func__, inode->i_ino, newsize);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tbh = NULL;\n\tsize = AFFS_I(inode)->mmu_private;\n\tbidx = size / bsize;\n\tboff = size % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, newsize - size);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemset(AFFS_DATA(bh) + boff, 0, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tsize += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t}\n\n\twhile (size < newsize) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getzeroblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto out;\n\t\ttmp = min(bsize, newsize - size);\n\t\tBUG_ON(tmp > bsize);\n\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tbh->b_state &= ~(1UL << BH_New);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tif (prev_bh) {\n\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\tif (tmp_next)\n\t\t\t\taffs_warning(sb, \"extent_file_ofs\",\n\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t     bidx, tmp_next);\n\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\taffs_brelse(prev_bh);\n\t\t}\n\t\tsize += bsize;\n\t\tbidx++;\n\t}\n\taffs_brelse(bh);\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn 0;\n\nout:\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn PTR_ERR(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %llu, %llu)\\n\"",
            "__func__",
            "inode->i_ino",
            "pos",
            "pos + len"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int affs_write_begin_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tpgoff_t index;\n\tint err = 0;\n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tif (pos > AFFS_I(inode)->mmu_private) {\n\t\t/* XXX: this probably leaves a too-big i_size in case of\n\t\t * failure. Should really be updating i_size at write_end time\n\t\t */\n\t\terr = affs_extent_file_ofs(inode, pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\t/* XXX: inefficient but safe in the face of short writes */\n\terr = affs_do_readpage_ofs(page, PAGE_CACHE_SIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "affs_readpage_ofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "610-629",
    "snippet": "static int\naffs_readpage_ofs(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu32 to;\n\tint err;\n\n\tpr_debug(\"%s(%lu, %ld)\\n\", __func__, inode->i_ino, page->index);\n\tto = PAGE_CACHE_SIZE;\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > inode->i_size) {\n\t\tto = inode->i_size & ~PAGE_CACHE_MASK;\n\t\tmemset(page_address(page) + to, 0, PAGE_CACHE_SIZE - to);\n\t}\n\n\terr = affs_do_readpage_ofs(page, to);\n\tif (!err)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_do_readpage_ofs",
          "args": [
            "page",
            "to"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "affs_do_readpage_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "501-537",
          "snippet": "static int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page) + to",
            "0",
            "PAGE_CACHE_SIZE - to"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %ld)\\n\"",
            "__func__",
            "inode->i_ino",
            "page->index"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_readpage_ofs(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu32 to;\n\tint err;\n\n\tpr_debug(\"%s(%lu, %ld)\\n\", __func__, inode->i_ino, page->index);\n\tto = PAGE_CACHE_SIZE;\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > inode->i_size) {\n\t\tto = inode->i_size & ~PAGE_CACHE_MASK;\n\t\tmemset(page_address(page) + to, 0, PAGE_CACHE_SIZE - to);\n\t}\n\n\terr = affs_do_readpage_ofs(page, to);\n\tif (!err)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "affs_extent_file_ofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "539-608",
    "snippet": "static int\naffs_extent_file_ofs(struct inode *inode, u32 newsize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tu32 bidx, boff;\n\tu32 size, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %d)\\n\", __func__, inode->i_ino, newsize);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tbh = NULL;\n\tsize = AFFS_I(inode)->mmu_private;\n\tbidx = size / bsize;\n\tboff = size % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, newsize - size);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemset(AFFS_DATA(bh) + boff, 0, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tsize += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t}\n\n\twhile (size < newsize) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getzeroblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto out;\n\t\ttmp = min(bsize, newsize - size);\n\t\tBUG_ON(tmp > bsize);\n\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tbh->b_state &= ~(1UL << BH_New);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tif (prev_bh) {\n\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\tif (tmp_next)\n\t\t\t\taffs_warning(sb, \"extent_file_ofs\",\n\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t     bidx, tmp_next);\n\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\taffs_brelse(prev_bh);\n\t\t}\n\t\tsize += bsize;\n\t\tbidx++;\n\t}\n\taffs_brelse(bh);\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn 0;\n\nout:\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn PTR_ERR(bh);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "prev_bh",
            "inode"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "prev_bh",
            "bh->b_blocknr - tmp_next"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"extent_file_ofs\"",
            "\"next block already set for %d (%d)\"",
            "bidx",
            "tmp_next"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_DATA_HEAD(prev_bh)->next"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "prev_bh"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bidx"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "T_DATA"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp > bsize"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bsize",
            "newsize - size"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_getzeroblk_ino",
          "args": [
            "inode",
            "bidx"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getzeroblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "463-480",
          "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread_ino",
          "args": [
            "inode",
            "bidx - 1",
            "0"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "444-461",
          "snippet": "static inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&AFFS_DATA_HEAD(bh)->size",
            "tmp"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA_HEAD",
          "args": [
            "bh"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "AFFS_DATA(bh) + boff",
            "0",
            "tmp"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA",
          "args": [
            "bh"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "boff + tmp > bsize || tmp > bsize"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %d)\\n\"",
            "__func__",
            "inode->i_ino",
            "newsize"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_extent_file_ofs(struct inode *inode, u32 newsize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tu32 bidx, boff;\n\tu32 size, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %d)\\n\", __func__, inode->i_ino, newsize);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tbh = NULL;\n\tsize = AFFS_I(inode)->mmu_private;\n\tbidx = size / bsize;\n\tboff = size % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, newsize - size);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemset(AFFS_DATA(bh) + boff, 0, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tsize += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t}\n\n\twhile (size < newsize) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getzeroblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto out;\n\t\ttmp = min(bsize, newsize - size);\n\t\tBUG_ON(tmp > bsize);\n\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tbh->b_state &= ~(1UL << BH_New);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tif (prev_bh) {\n\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\tif (tmp_next)\n\t\t\t\taffs_warning(sb, \"extent_file_ofs\",\n\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t     bidx, tmp_next);\n\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\taffs_brelse(prev_bh);\n\t\t}\n\t\tsize += bsize;\n\t\tbidx++;\n\t}\n\taffs_brelse(bh);\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn 0;\n\nout:\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn PTR_ERR(bh);\n}"
  },
  {
    "function_name": "affs_do_readpage_ofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "501-537",
    "snippet": "static int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + pos",
            "AFFS_DATA(bh) + boff",
            "tmp"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_DATA",
          "args": [
            "bh"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos + tmp > to || tmp > bsize"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bsize - boff",
            "to - pos"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread_ino",
          "args": [
            "inode",
            "bidx",
            "0"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "444-461",
          "snippet": "static inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to > PAGE_CACHE_SIZE"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %ld, 0, %d)\\n\"",
            "__func__",
            "inode->i_ino",
            "page->index",
            "to"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_do_readpage_ofs(struct page *page, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tchar *data;\n\tunsigned pos = 0;\n\tu32 bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %d)\\n\", __func__, inode->i_ino,\n\t\t page->index, to);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tkmap(page);\n\tdata = page_address(page);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = page->index << PAGE_CACHE_SHIFT;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy(data + pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_getemptyblk_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "482-499",
    "snippet": "static inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_getemptyblk",
          "args": [
            "inode->i_sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getemptyblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "482-499",
          "snippet": "static inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "affs_get_block",
          "args": [
            "inode",
            "block",
            "&tmp_bh",
            "1"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "293-369",
          "snippet": "static int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "affs_getzeroblk_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "463-480",
    "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_getzeroblk",
          "args": [
            "inode->i_sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getzeroblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "463-480",
          "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "affs_get_block",
          "args": [
            "inode",
            "block",
            "&tmp_bh",
            "1"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "293-369",
          "snippet": "static int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "affs_bread_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "444-461",
    "snippet": "static inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "inode->i_sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_get_block",
          "args": [
            "inode",
            "block",
            "&tmp_bh",
            "create"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "293-369",
          "snippet": "static int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "_affs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "430-433",
    "snippet": "static sector_t _affs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,affs_get_block);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "affs_get_block"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic sector_t _affs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,affs_get_block);\n}"
  },
  {
    "function_name": "affs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "414-428",
    "snippet": "static int affs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\taffs_get_block,\n\t\t\t\t&AFFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\taffs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "affs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "381-389",
          "snippet": "static void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "affs_get_block",
            "&AFFS_I(mapping->host)->mmu_private"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int affs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\taffs_get_block,\n\t\t\t\t&AFFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\taffs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "affs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "391-412",
    "snippet": "static ssize_t\naffs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t       loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (rw == WRITE) {\n\t\tloff_t size = offset + count;\n\n\t\tif (AFFS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, affs_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\taffs_write_failed(mapping, offset + count);\n\treturn ret;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_write_failed",
          "args": [
            "mapping",
            "offset + count"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "affs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "381-389",
          "snippet": "static void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "affs_get_block"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic ssize_t\naffs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t       loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (rw == WRITE) {\n\t\tloff_t size = offset + count;\n\n\t\tif (AFFS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, affs_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\taffs_write_failed(mapping, offset + count);\n\treturn ret;\n}"
  },
  {
    "function_name": "affs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "381-389",
    "snippet": "static void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_truncate",
          "args": [
            "inode"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "affs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "834-951",
          "snippet": "void\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "affs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "376-379",
    "snippet": "static int affs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, affs_get_block);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "affs_get_block"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int affs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, affs_get_block);\n}"
  },
  {
    "function_name": "affs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "371-374",
    "snippet": "static int affs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, affs_get_block, wbc);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "affs_get_block",
            "wbc"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int affs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, affs_get_block, wbc);\n}"
  },
  {
    "function_name": "affs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "293-369",
    "snippet": "static int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_unlock_ext",
          "args": [
            "inode"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "306-310",
          "snippet": "static inline void\naffs_unlock_ext(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_ext_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_ext(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_ext_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ext_bh"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ext_bh"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_error",
          "args": [
            "inode->i_sb",
            "\"get_block\"",
            "\"strange block request %llu\"",
            "(unsigned long long)block"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "affs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "442-456",
          "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "ext_bh",
            "blocknr - tmp"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blocknr"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "ext_bh"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"get_block\"",
            "\"first block already set (%d)\"",
            "tmp"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(ext_bh)->first_data"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "ext_bh"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "block + 1"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "ext_bh"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blocknr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_BLOCK",
          "args": [
            "sb",
            "ext_bh",
            "block"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_alloc_block",
          "args": [
            "inode",
            "ext_bh->b_blocknr"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "affs_alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "113-241",
          "snippet": "u32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "(sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block))"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_BLOCK(sb, ext_bh, block)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_BLOCK",
          "args": [
            "sb",
            "ext_bh",
            "block"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ext_bh"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_get_extblock",
          "args": [
            "inode",
            "ext"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_extblock_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "168-291",
          "snippet": "static struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_ext",
          "args": [
            "inode"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "301-305",
          "snippet": "static inline void\naffs_lock_ext(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_ext_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_ext(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_ext_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block > (sector_t)0x7fffffffUL"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %llu)\\n\"",
            "__func__",
            "inode->i_ino",
            "(unsigned long long)block"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t//lock cache\n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t/* store new block */\n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t/* insert first block into header block */\n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t//unlock cache\n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t// unlock cache\n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "affs_get_extblock_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "168-291",
    "snippet": "static struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "ext_key"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->extension"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_grow_extcache",
          "args": [
            "inode",
            "lc_idx"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "affs_grow_extcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "46-114",
          "snippet": "static int\naffs_grow_extcache(struct inode *inode, u32 lc_idx)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tu32 lc_max;\n\tint i, j, key;\n\n\tif (!AFFS_I(inode)->i_lc) {\n\t\tchar *ptr = (char *)get_zeroed_page(GFP_NOFS);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tAFFS_I(inode)->i_lc = (u32 *)ptr;\n\t\tAFFS_I(inode)->i_ac = (struct affs_ext_key *)(ptr + AFFS_CACHE_SIZE / 2);\n\t}\n\n\tlc_max = AFFS_LC_SIZE << AFFS_I(inode)->i_lc_shift;\n\n\tif (AFFS_I(inode)->i_extcnt > lc_max) {\n\t\tu32 lc_shift, lc_mask, tmp, off;\n\n\t\t/* need to recalculate linear cache, start from old size */\n\t\tlc_shift = AFFS_I(inode)->i_lc_shift;\n\t\ttmp = (AFFS_I(inode)->i_extcnt / AFFS_LC_SIZE) >> lc_shift;\n\t\tfor (; tmp; tmp >>= 1)\n\t\t\tlc_shift++;\n\t\tlc_mask = (1 << lc_shift) - 1;\n\n\t\t/* fix idx and old size to new shift */\n\t\tlc_idx >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tAFFS_I(inode)->i_lc_size >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\n\t\t/* first shrink old cache to make more space */\n\t\toff = 1 << (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tfor (i = 1, j = off; j < AFFS_LC_SIZE; i++, j += off)\n\t\t\tAFFS_I(inode)->i_ac[i] = AFFS_I(inode)->i_ac[j];\n\n\t\tAFFS_I(inode)->i_lc_shift = lc_shift;\n\t\tAFFS_I(inode)->i_lc_mask = lc_mask;\n\t}\n\n\t/* fill cache to the needed index */\n\ti = AFFS_I(inode)->i_lc_size;\n\tAFFS_I(inode)->i_lc_size = lc_idx + 1;\n\tfor (; i <= lc_idx; i++) {\n\t\tif (!i) {\n\t\t\tAFFS_I(inode)->i_lc[0] = inode->i_ino;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = AFFS_I(inode)->i_lc[i - 1];\n\t\tj = AFFS_I(inode)->i_lc_mask + 1;\n\t\t// unlock cache\n\t\tfor (; j > 0; j--) {\n\t\t\tbh = affs_bread(sb, key);\n\t\t\tif (!bh)\n\t\t\t\tgoto err;\n\t\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t\t// lock cache\n\t\tAFFS_I(inode)->i_lc[i] = key;\n\t}\n\n\treturn 0;\n\nerr:\n\t// lock cache\n\treturn -EIO;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_grow_extcache(struct inode *inode, u32 lc_idx)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tu32 lc_max;\n\tint i, j, key;\n\n\tif (!AFFS_I(inode)->i_lc) {\n\t\tchar *ptr = (char *)get_zeroed_page(GFP_NOFS);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tAFFS_I(inode)->i_lc = (u32 *)ptr;\n\t\tAFFS_I(inode)->i_ac = (struct affs_ext_key *)(ptr + AFFS_CACHE_SIZE / 2);\n\t}\n\n\tlc_max = AFFS_LC_SIZE << AFFS_I(inode)->i_lc_shift;\n\n\tif (AFFS_I(inode)->i_extcnt > lc_max) {\n\t\tu32 lc_shift, lc_mask, tmp, off;\n\n\t\t/* need to recalculate linear cache, start from old size */\n\t\tlc_shift = AFFS_I(inode)->i_lc_shift;\n\t\ttmp = (AFFS_I(inode)->i_extcnt / AFFS_LC_SIZE) >> lc_shift;\n\t\tfor (; tmp; tmp >>= 1)\n\t\t\tlc_shift++;\n\t\tlc_mask = (1 << lc_shift) - 1;\n\n\t\t/* fix idx and old size to new shift */\n\t\tlc_idx >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tAFFS_I(inode)->i_lc_size >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\n\t\t/* first shrink old cache to make more space */\n\t\toff = 1 << (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tfor (i = 1, j = off; j < AFFS_LC_SIZE; i++, j += off)\n\t\t\tAFFS_I(inode)->i_ac[i] = AFFS_I(inode)->i_ac[j];\n\n\t\tAFFS_I(inode)->i_lc_shift = lc_shift;\n\t\tAFFS_I(inode)->i_lc_mask = lc_mask;\n\t}\n\n\t/* fill cache to the needed index */\n\ti = AFFS_I(inode)->i_lc_size;\n\tAFFS_I(inode)->i_lc_size = lc_idx + 1;\n\tfor (; i <= lc_idx; i++) {\n\t\tif (!i) {\n\t\t\tAFFS_I(inode)->i_lc[0] = inode->i_ino;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = AFFS_I(inode)->i_lc[i - 1];\n\t\tj = AFFS_I(inode)->i_lc_mask + 1;\n\t\t// unlock cache\n\t\tfor (; j > 0; j--) {\n\t\t\tbh = affs_bread(sb, key);\n\t\t\tif (!bh)\n\t\t\t\tgoto err;\n\t\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t\t// lock cache\n\t\tAFFS_I(inode)->i_lc[i] = key;\n\t}\n\n\treturn 0;\n\nerr:\n\t// lock cache\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_alloc_extblock",
          "args": [
            "inode",
            "prev_bh",
            "ext"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "affs_alloc_extblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "116-152",
          "snippet": "static struct buffer_head *\naffs_alloc_extblock(struct inode *inode, struct buffer_head *bh, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh;\n\tu32 blocknr, tmp;\n\n\tblocknr = affs_alloc_block(inode, bh->b_blocknr);\n\tif (!blocknr)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_bh = affs_getzeroblk(sb, blocknr);\n\tif (!new_bh) {\n\t\taffs_free_block(sb, blocknr);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tAFFS_HEAD(new_bh)->ptype = cpu_to_be32(T_LIST);\n\tAFFS_HEAD(new_bh)->key = cpu_to_be32(blocknr);\n\tAFFS_TAIL(sb, new_bh)->stype = cpu_to_be32(ST_FILE);\n\tAFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);\n\taffs_fix_checksum(sb, new_bh);\n\n\tmark_buffer_dirty_inode(new_bh, inode);\n\n\ttmp = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\tif (tmp)\n\t\taffs_warning(sb, \"alloc_ext\", \"previous extension set (%x)\", tmp);\n\tAFFS_TAIL(sb, bh)->extension = cpu_to_be32(blocknr);\n\taffs_adjust_checksum(bh, blocknr - tmp);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\tAFFS_I(inode)->i_extcnt++;\n\tmark_inode_dirty(inode);\n\n\treturn new_bh;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_alloc_extblock(struct inode *inode, struct buffer_head *bh, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh;\n\tu32 blocknr, tmp;\n\n\tblocknr = affs_alloc_block(inode, bh->b_blocknr);\n\tif (!blocknr)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_bh = affs_getzeroblk(sb, blocknr);\n\tif (!new_bh) {\n\t\taffs_free_block(sb, blocknr);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tAFFS_HEAD(new_bh)->ptype = cpu_to_be32(T_LIST);\n\tAFFS_HEAD(new_bh)->key = cpu_to_be32(blocknr);\n\tAFFS_TAIL(sb, new_bh)->stype = cpu_to_be32(ST_FILE);\n\tAFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);\n\taffs_fix_checksum(sb, new_bh);\n\n\tmark_buffer_dirty_inode(new_bh, inode);\n\n\ttmp = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\tif (tmp)\n\t\taffs_warning(sb, \"alloc_ext\", \"previous extension set (%x)\", tmp);\n\tAFFS_TAIL(sb, bh)->extension = cpu_to_be32(blocknr);\n\taffs_adjust_checksum(bh, blocknr - tmp);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\tAFFS_I(inode)->i_extcnt++;\n\tmark_inode_dirty(inode);\n\n\treturn new_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prev_bh"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_get_extblock",
          "args": [
            "inode",
            "ext - 1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_extblock_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "168-291",
          "snippet": "static struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext > AFFS_I(inode)->i_extcnt"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext > AFFS_I(inode)->i_extcnt"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->extension"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "affs_get_extblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "154-166",
    "snippet": "static inline struct buffer_head *\naffs_get_extblock(struct inode *inode, u32 ext)\n{\n\t/* inline the simplest case: same extended block as last time */\n\tstruct buffer_head *bh = AFFS_I(inode)->i_ext_bh;\n\tif (ext == AFFS_I(inode)->i_ext_last)\n\t\tget_bh(bh);\n\telse\n\t\t/* we have to do more (not inlined) */\n\t\tbh = affs_get_extblock_slow(inode, ext);\n\n\treturn bh;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_get_extblock_slow",
          "args": [
            "inode",
            "ext"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_extblock_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "168-291",
          "snippet": "static struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t/* read the next extended block from the current one */\n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t/* we seek back to the file header block */\n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t/* allocate a new extended block */\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t/* get previous extended block */\n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t/* check if there is an extended cache and whether it's large enough */\n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t/* every n'th key we find in the linear cache */\n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t/* maybe it's still in the associative cache */\n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t/* try to find one of the previous extended blocks */\n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t/* fall back to the linear cache */\n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t/* read all extended blocks until we find the one we need */\n\t//unlock cache\n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t//lock cache\n\n\t/* store it in the associative cache */\n\t// recalculate ac_idx?\n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t/* finally read the right extended block */\n\t//unlock cache\n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t//lock cache\n\nstore_ext:\n\t/* release old cached extended block and store the new one */\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic inline struct buffer_head *\naffs_get_extblock(struct inode *inode, u32 ext)\n{\n\t/* inline the simplest case: same extended block as last time */\n\tstruct buffer_head *bh = AFFS_I(inode)->i_ext_bh;\n\tif (ext == AFFS_I(inode)->i_ext_last)\n\t\tget_bh(bh);\n\telse\n\t\t/* we have to do more (not inlined) */\n\t\tbh = affs_get_extblock_slow(inode, ext);\n\n\treturn bh;\n}"
  },
  {
    "function_name": "affs_alloc_extblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "116-152",
    "snippet": "static struct buffer_head *\naffs_alloc_extblock(struct inode *inode, struct buffer_head *bh, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh;\n\tu32 blocknr, tmp;\n\n\tblocknr = affs_alloc_block(inode, bh->b_blocknr);\n\tif (!blocknr)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_bh = affs_getzeroblk(sb, blocknr);\n\tif (!new_bh) {\n\t\taffs_free_block(sb, blocknr);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tAFFS_HEAD(new_bh)->ptype = cpu_to_be32(T_LIST);\n\tAFFS_HEAD(new_bh)->key = cpu_to_be32(blocknr);\n\tAFFS_TAIL(sb, new_bh)->stype = cpu_to_be32(ST_FILE);\n\tAFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);\n\taffs_fix_checksum(sb, new_bh);\n\n\tmark_buffer_dirty_inode(new_bh, inode);\n\n\ttmp = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\tif (tmp)\n\t\taffs_warning(sb, \"alloc_ext\", \"previous extension set (%x)\", tmp);\n\tAFFS_TAIL(sb, bh)->extension = cpu_to_be32(blocknr);\n\taffs_adjust_checksum(bh, blocknr - tmp);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\tAFFS_I(inode)->i_extcnt++;\n\tmark_inode_dirty(inode);\n\n\treturn new_bh;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "bh",
            "blocknr - tmp"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blocknr"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"alloc_ext\"",
            "\"previous extension set (%x)\"",
            "tmp"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->extension"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "new_bh"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "new_bh"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ST_FILE"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "new_bh"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blocknr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "new_bh"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "T_LIST"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "new_bh"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_getzeroblk",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getzeroblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "463-480",
          "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_alloc_block",
          "args": [
            "inode",
            "bh->b_blocknr"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "affs_alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "113-241",
          "snippet": "u32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic struct buffer_head *\naffs_alloc_extblock(struct inode *inode, struct buffer_head *bh, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh;\n\tu32 blocknr, tmp;\n\n\tblocknr = affs_alloc_block(inode, bh->b_blocknr);\n\tif (!blocknr)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_bh = affs_getzeroblk(sb, blocknr);\n\tif (!new_bh) {\n\t\taffs_free_block(sb, blocknr);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tAFFS_HEAD(new_bh)->ptype = cpu_to_be32(T_LIST);\n\tAFFS_HEAD(new_bh)->key = cpu_to_be32(blocknr);\n\tAFFS_TAIL(sb, new_bh)->stype = cpu_to_be32(ST_FILE);\n\tAFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);\n\taffs_fix_checksum(sb, new_bh);\n\n\tmark_buffer_dirty_inode(new_bh, inode);\n\n\ttmp = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\tif (tmp)\n\t\taffs_warning(sb, \"alloc_ext\", \"previous extension set (%x)\", tmp);\n\tAFFS_TAIL(sb, bh)->extension = cpu_to_be32(blocknr);\n\taffs_adjust_checksum(bh, blocknr - tmp);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\tAFFS_I(inode)->i_extcnt++;\n\tmark_inode_dirty(inode);\n\n\treturn new_bh;\n}"
  },
  {
    "function_name": "affs_grow_extcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "46-114",
    "snippet": "static int\naffs_grow_extcache(struct inode *inode, u32 lc_idx)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tu32 lc_max;\n\tint i, j, key;\n\n\tif (!AFFS_I(inode)->i_lc) {\n\t\tchar *ptr = (char *)get_zeroed_page(GFP_NOFS);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tAFFS_I(inode)->i_lc = (u32 *)ptr;\n\t\tAFFS_I(inode)->i_ac = (struct affs_ext_key *)(ptr + AFFS_CACHE_SIZE / 2);\n\t}\n\n\tlc_max = AFFS_LC_SIZE << AFFS_I(inode)->i_lc_shift;\n\n\tif (AFFS_I(inode)->i_extcnt > lc_max) {\n\t\tu32 lc_shift, lc_mask, tmp, off;\n\n\t\t/* need to recalculate linear cache, start from old size */\n\t\tlc_shift = AFFS_I(inode)->i_lc_shift;\n\t\ttmp = (AFFS_I(inode)->i_extcnt / AFFS_LC_SIZE) >> lc_shift;\n\t\tfor (; tmp; tmp >>= 1)\n\t\t\tlc_shift++;\n\t\tlc_mask = (1 << lc_shift) - 1;\n\n\t\t/* fix idx and old size to new shift */\n\t\tlc_idx >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tAFFS_I(inode)->i_lc_size >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\n\t\t/* first shrink old cache to make more space */\n\t\toff = 1 << (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tfor (i = 1, j = off; j < AFFS_LC_SIZE; i++, j += off)\n\t\t\tAFFS_I(inode)->i_ac[i] = AFFS_I(inode)->i_ac[j];\n\n\t\tAFFS_I(inode)->i_lc_shift = lc_shift;\n\t\tAFFS_I(inode)->i_lc_mask = lc_mask;\n\t}\n\n\t/* fill cache to the needed index */\n\ti = AFFS_I(inode)->i_lc_size;\n\tAFFS_I(inode)->i_lc_size = lc_idx + 1;\n\tfor (; i <= lc_idx; i++) {\n\t\tif (!i) {\n\t\t\tAFFS_I(inode)->i_lc[0] = inode->i_ino;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = AFFS_I(inode)->i_lc[i - 1];\n\t\tj = AFFS_I(inode)->i_lc_mask + 1;\n\t\t// unlock cache\n\t\tfor (; j > 0; j--) {\n\t\t\tbh = affs_bread(sb, key);\n\t\t\tif (!bh)\n\t\t\t\tgoto err;\n\t\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t\t// lock cache\n\t\tAFFS_I(inode)->i_lc[i] = key;\n\t}\n\n\treturn 0;\n\nerr:\n\t// lock cache\n\treturn -EIO;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->extension"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "key"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_grow_extcache(struct inode *inode, u32 lc_idx)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tu32 lc_max;\n\tint i, j, key;\n\n\tif (!AFFS_I(inode)->i_lc) {\n\t\tchar *ptr = (char *)get_zeroed_page(GFP_NOFS);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tAFFS_I(inode)->i_lc = (u32 *)ptr;\n\t\tAFFS_I(inode)->i_ac = (struct affs_ext_key *)(ptr + AFFS_CACHE_SIZE / 2);\n\t}\n\n\tlc_max = AFFS_LC_SIZE << AFFS_I(inode)->i_lc_shift;\n\n\tif (AFFS_I(inode)->i_extcnt > lc_max) {\n\t\tu32 lc_shift, lc_mask, tmp, off;\n\n\t\t/* need to recalculate linear cache, start from old size */\n\t\tlc_shift = AFFS_I(inode)->i_lc_shift;\n\t\ttmp = (AFFS_I(inode)->i_extcnt / AFFS_LC_SIZE) >> lc_shift;\n\t\tfor (; tmp; tmp >>= 1)\n\t\t\tlc_shift++;\n\t\tlc_mask = (1 << lc_shift) - 1;\n\n\t\t/* fix idx and old size to new shift */\n\t\tlc_idx >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tAFFS_I(inode)->i_lc_size >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\n\t\t/* first shrink old cache to make more space */\n\t\toff = 1 << (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tfor (i = 1, j = off; j < AFFS_LC_SIZE; i++, j += off)\n\t\t\tAFFS_I(inode)->i_ac[i] = AFFS_I(inode)->i_ac[j];\n\n\t\tAFFS_I(inode)->i_lc_shift = lc_shift;\n\t\tAFFS_I(inode)->i_lc_mask = lc_mask;\n\t}\n\n\t/* fill cache to the needed index */\n\ti = AFFS_I(inode)->i_lc_size;\n\tAFFS_I(inode)->i_lc_size = lc_idx + 1;\n\tfor (; i <= lc_idx; i++) {\n\t\tif (!i) {\n\t\t\tAFFS_I(inode)->i_lc[0] = inode->i_ino;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = AFFS_I(inode)->i_lc[i - 1];\n\t\tj = AFFS_I(inode)->i_lc_mask + 1;\n\t\t// unlock cache\n\t\tfor (; j > 0; j--) {\n\t\t\tbh = affs_bread(sb, key);\n\t\t\tif (!bh)\n\t\t\t\tgoto err;\n\t\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t\t// lock cache\n\t\tAFFS_I(inode)->i_lc[i] = key;\n\t}\n\n\treturn 0;\n\nerr:\n\t// lock cache\n\treturn -EIO;\n}"
  },
  {
    "function_name": "affs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "29-44",
    "snippet": "static int\naffs_file_release(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"release(%lu, %d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\n\tif (atomic_dec_and_test(&AFFS_I(inode)->i_opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (inode->i_size != AFFS_I(inode)->mmu_private)\n\t\t\taffs_truncate(inode);\n\t\taffs_free_prealloc(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_free_prealloc",
          "args": [
            "inode"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "819-830",
          "snippet": "void\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_truncate",
          "args": [
            "inode"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "affs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "834-951",
          "snippet": "void\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&AFFS_I(inode)->i_opencnt"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"release(%lu, %d)\\n\"",
            "inode->i_ino",
            "atomic_read(&AFFS_I(inode)->i_opencnt)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&AFFS_I(inode)->i_opencnt"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_file_release(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"release(%lu, %d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\n\tif (atomic_dec_and_test(&AFFS_I(inode)->i_opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (inode->i_size != AFFS_I(inode)->mmu_private)\n\t\t\taffs_truncate(inode);\n\t\taffs_free_prealloc(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
    "lines": "20-27",
    "snippet": "static int\naffs_file_open(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"open(%lu,%d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\tatomic_inc(&AFFS_I(inode)->i_opencnt);\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&AFFS_I(inode)->i_opencnt"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"open(%lu,%d)\\n\"",
            "inode->i_ino",
            "atomic_read(&AFFS_I(inode)->i_opencnt)"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&AFFS_I(inode)->i_opencnt"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic int\naffs_file_open(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"open(%lu,%d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\tatomic_inc(&AFFS_I(inode)->i_opencnt);\n\treturn 0;\n}"
  }
]