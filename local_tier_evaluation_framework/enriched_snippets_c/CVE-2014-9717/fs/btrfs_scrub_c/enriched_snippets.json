[
  {
    "function_name": "write_page_nocow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "4193-4231",
    "snippet": "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page)\n{\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tint ret;\n\n\tdev = sctx->wr_ctx.tgtdev;\n\tif (!dev)\n\t\treturn -EIO;\n\tif (!dev->bdev) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub write_page_nocow(bdev == NULL) is unexpected!\\n\");\n\t\treturn -EIO;\n\t}\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_iter.bi_sector = physical_for_dev_replace >> 9;\n\tbio->bi_bdev = dev->bdev;\n\tret = bio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tif (ret != PAGE_CACHE_SIZE) {\nleave_with_eio:\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio))\n\t\tgoto leave_with_eio;\n\n\tbio_put(bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio_wait",
          "args": [
            "WRITE_SYNC",
            "bio"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_WRITE_ERRS"
          ],
          "line": 4222
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING\n\t\t\t\"BTRFS: scrub write_page_nocow(bdev == NULL) is unexpected!\\n\""
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page)\n{\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tint ret;\n\n\tdev = sctx->wr_ctx.tgtdev;\n\tif (!dev)\n\t\treturn -EIO;\n\tif (!dev->bdev) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub write_page_nocow(bdev == NULL) is unexpected!\\n\");\n\t\treturn -EIO;\n\t}\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_iter.bi_sector = physical_for_dev_replace >> 9;\n\tbio->bi_bdev = dev->bdev;\n\tret = bio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tif (ret != PAGE_CACHE_SIZE) {\nleave_with_eio:\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio))\n\t\tgoto leave_with_eio;\n\n\tbio_put(bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_nocow_pages_for_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "4071-4191",
    "snippet": "static int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *nocow_ctx)\n{\n\tstruct btrfs_fs_info *fs_info = nocow_ctx->sctx->dev_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct btrfs_root *local_root;\n\tstruct extent_io_tree *io_tree;\n\tu64 physical_for_dev_replace;\n\tu64 nocow_ctx_logical;\n\tu64 len = nocow_ctx->len;\n\tunsigned long index;\n\tint srcu_index;\n\tint ret = 0;\n\tint err = 0;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\t/* Avoid truncate/dio/punch hole.. */\n\tmutex_lock(&inode->i_mutex);\n\tinode_dio_wait(inode);\n\n\tphysical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\tnocow_ctx_logical = nocow_ctx->logical;\n\n\tret = check_extent_to_block(inode, offset, len, nocow_ctx_logical);\n\tif (ret) {\n\t\tret = ret > 0 ? 0 : ret;\n\t\tgoto out;\n\t}\n\n\twhile (len >= PAGE_CACHE_SIZE) {\n\t\tindex = offset >> PAGE_CACHE_SHIFT;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tbtrfs_err(fs_info, \"find_or_create_page() failed\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (PageDirty(page))\n\t\t\t\tgoto next_page;\n\t\t} else {\n\t\t\tClearPageError(page);\n\t\t\terr = extent_read_full_page(io_tree, page,\n\t\t\t\t\t\t\t   btrfs_get_extent,\n\t\t\t\t\t\t\t   nocow_ctx->mirror_num);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page has been remove from the page cache,\n\t\t\t * the data on it is meaningless, because it may be\n\t\t\t * old one, the new data may be written into the new\n\t\t\t * page in the page cache.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t}\n\n\t\tret = check_extent_to_block(inode, offset, len,\n\t\t\t\t\t    nocow_ctx_logical);\n\t\tif (ret) {\n\t\t\tret = ret > 0 ? 0 : ret;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\terr = write_page_nocow(nocow_ctx->sctx,\n\t\t\t\t       physical_for_dev_replace, page);\n\t\tif (err)\n\t\t\tret = err;\nnext_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tphysical_for_dev_replace += PAGE_CACHE_SIZE;\n\t\tnocow_ctx_logical += PAGE_CACHE_SIZE;\n\t\tlen -= PAGE_CACHE_SIZE;\n\t}\n\tret = COPY_COMPLETE;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define COPY_COMPLETE 1"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_page_nocow",
          "args": [
            "nocow_ctx->sctx",
            "physical_for_dev_replace",
            "page"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "write_page_nocow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "4193-4231",
          "snippet": "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page)\n{\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tint ret;\n\n\tdev = sctx->wr_ctx.tgtdev;\n\tif (!dev)\n\t\treturn -EIO;\n\tif (!dev->bdev) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub write_page_nocow(bdev == NULL) is unexpected!\\n\");\n\t\treturn -EIO;\n\t}\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_iter.bi_sector = physical_for_dev_replace >> 9;\n\tbio->bi_bdev = dev->bdev;\n\tret = bio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tif (ret != PAGE_CACHE_SIZE) {\nleave_with_eio:\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio))\n\t\tgoto leave_with_eio;\n\n\tbio_put(bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page)\n{\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tint ret;\n\n\tdev = sctx->wr_ctx.tgtdev;\n\tif (!dev)\n\t\treturn -EIO;\n\tif (!dev->bdev) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub write_page_nocow(bdev == NULL) is unexpected!\\n\");\n\t\treturn -EIO;\n\t}\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_iter.bi_sector = physical_for_dev_replace >> 9;\n\tbio->bi_bdev = dev->bdev;\n\tret = bio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tif (ret != PAGE_CACHE_SIZE) {\nleave_with_eio:\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio))\n\t\tgoto leave_with_eio;\n\n\tbio_put(bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_extent_to_block",
          "args": [
            "inode",
            "offset",
            "len",
            "nocow_ctx_logical"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "check_extent_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "4027-4069",
          "snippet": "static int check_extent_to_block(struct inode *inode, u64 start, u64 len,\n\t\t\t\t u64 logical)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_io_tree *io_tree;\n\tstruct extent_map *em;\n\tu64 lockstart = start, lockend = start + len - 1;\n\tint ret = 0;\n\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\n\tlock_extent_bits(io_tree, lockstart, lockend, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_range(inode, lockstart, len);\n\tif (ordered) {\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extent does not actually cover the logical extent anymore,\n\t * move on to the next inode.\n\t */\n\tif (em->block_start > logical ||\n\t    em->block_start + em->block_len < logical + len) {\n\t\tfree_extent_map(em);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\tfree_extent_map(em);\n\nout_unlock:\n\tunlock_extent_cached(io_tree, lockstart, lockend, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int check_extent_to_block(struct inode *inode, u64 start, u64 len,\n\t\t\t\t u64 logical)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_io_tree *io_tree;\n\tstruct extent_map *em;\n\tu64 lockstart = start, lockend = start + len - 1;\n\tint ret = 0;\n\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\n\tlock_extent_bits(io_tree, lockstart, lockend, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_range(inode, lockstart, len);\n\tif (ordered) {\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extent does not actually cover the logical extent anymore,\n\t * move on to the next inode.\n\t */\n\tif (em->block_start > logical ||\n\t    em->block_start + em->block_len < logical + len) {\n\t\tfree_extent_map(em);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\tfree_extent_map(em);\n\nout_unlock:\n\tunlock_extent_cached(io_tree, lockstart, lockend, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_read_full_page",
          "args": [
            "io_tree",
            "page",
            "btrfs_get_extent",
            "nocow_ctx->mirror_num"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "extent_read_full_page_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3189-3201",
          "snippet": "int extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"find_or_create_page() failed\""
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "srcu_index"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "fs_info->sb",
            "&key",
            "local_root",
            "NULL"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "local_root"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "srcu_index"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "local_root"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&key"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define COPY_COMPLETE 1\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *nocow_ctx)\n{\n\tstruct btrfs_fs_info *fs_info = nocow_ctx->sctx->dev_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct btrfs_root *local_root;\n\tstruct extent_io_tree *io_tree;\n\tu64 physical_for_dev_replace;\n\tu64 nocow_ctx_logical;\n\tu64 len = nocow_ctx->len;\n\tunsigned long index;\n\tint srcu_index;\n\tint ret = 0;\n\tint err = 0;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\t/* Avoid truncate/dio/punch hole.. */\n\tmutex_lock(&inode->i_mutex);\n\tinode_dio_wait(inode);\n\n\tphysical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\tnocow_ctx_logical = nocow_ctx->logical;\n\n\tret = check_extent_to_block(inode, offset, len, nocow_ctx_logical);\n\tif (ret) {\n\t\tret = ret > 0 ? 0 : ret;\n\t\tgoto out;\n\t}\n\n\twhile (len >= PAGE_CACHE_SIZE) {\n\t\tindex = offset >> PAGE_CACHE_SHIFT;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tbtrfs_err(fs_info, \"find_or_create_page() failed\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (PageDirty(page))\n\t\t\t\tgoto next_page;\n\t\t} else {\n\t\t\tClearPageError(page);\n\t\t\terr = extent_read_full_page(io_tree, page,\n\t\t\t\t\t\t\t   btrfs_get_extent,\n\t\t\t\t\t\t\t   nocow_ctx->mirror_num);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page has been remove from the page cache,\n\t\t\t * the data on it is meaningless, because it may be\n\t\t\t * old one, the new data may be written into the new\n\t\t\t * page in the page cache.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t}\n\n\t\tret = check_extent_to_block(inode, offset, len,\n\t\t\t\t\t    nocow_ctx_logical);\n\t\tif (ret) {\n\t\t\tret = ret > 0 ? 0 : ret;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\terr = write_page_nocow(nocow_ctx->sctx,\n\t\t\t\t       physical_for_dev_replace, page);\n\t\tif (err)\n\t\t\tret = err;\nnext_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tphysical_for_dev_replace += PAGE_CACHE_SIZE;\n\t\tnocow_ctx_logical += PAGE_CACHE_SIZE;\n\t\tlen -= PAGE_CACHE_SIZE;\n\t}\n\tret = COPY_COMPLETE;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_extent_to_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "4027-4069",
    "snippet": "static int check_extent_to_block(struct inode *inode, u64 start, u64 len,\n\t\t\t\t u64 logical)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_io_tree *io_tree;\n\tstruct extent_map *em;\n\tu64 lockstart = start, lockend = start + len - 1;\n\tint ret = 0;\n\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\n\tlock_extent_bits(io_tree, lockstart, lockend, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_range(inode, lockstart, len);\n\tif (ordered) {\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extent does not actually cover the logical extent anymore,\n\t * move on to the next inode.\n\t */\n\tif (em->block_start > logical ||\n\t    em->block_start + em->block_len < logical + len) {\n\t\tfree_extent_map(em);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\tfree_extent_map(em);\n\nout_unlock:\n\tunlock_extent_cached(io_tree, lockstart, lockend, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "io_tree",
            "lockstart",
            "lockend",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "start",
            "len",
            "0"
          ],
          "line": 4047
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_range",
          "args": [
            "inode",
            "lockstart",
            "len"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "803-839",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "io_tree",
            "lockstart",
            "lockend",
            "0",
            "&cached_state"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int check_extent_to_block(struct inode *inode, u64 start, u64 len,\n\t\t\t\t u64 logical)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_io_tree *io_tree;\n\tstruct extent_map *em;\n\tu64 lockstart = start, lockend = start + len - 1;\n\tint ret = 0;\n\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\n\tlock_extent_bits(io_tree, lockstart, lockend, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_range(inode, lockstart, len);\n\tif (ordered) {\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extent does not actually cover the logical extent anymore,\n\t * move on to the next inode.\n\t */\n\tif (em->block_start > logical ||\n\t    em->block_start + em->block_len < logical + len) {\n\t\tfree_extent_map(em);\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\tfree_extent_map(em);\n\nout_unlock:\n\tunlock_extent_cached(io_tree, lockstart, lockend, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_nocow_pages_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3943-4025",
    "snippet": "static void copy_nocow_pages_worker(struct btrfs_work *work)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx =\n\t\tcontainer_of(work, struct scrub_copy_nocow_ctx, work);\n\tstruct scrub_ctx *sctx = nocow_ctx->sctx;\n\tu64 logical = nocow_ctx->logical;\n\tu64 len = nocow_ctx->len;\n\tint mirror_num = nocow_ctx->mirror_num;\n\tu64 physical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tint not_written = 0;\n\n\tfs_info = sctx->dev_root->fs_info;\n\troot = fs_info->extent_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(logical, fs_info, path,\n\t\t\t\t\t  record_inode_for_nocow, nocow_ctx);\n\tif (ret != 0 && ret != -ENOENT) {\n\t\tbtrfs_warn(fs_info, \"iterate_inodes_from_logical() failed: log %llu, \"\n\t\t\t\"phys %llu, len %llu, mir %u, ret %d\",\n\t\t\tlogical, physical_for_dev_replace, len, mirror_num,\n\t\t\tret);\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\tbtrfs_end_transaction(trans, root);\n\ttrans = NULL;\n\twhile (!list_empty(&nocow_ctx->inodes)) {\n\t\tstruct scrub_nocow_inode *entry;\n\t\tentry = list_first_entry(&nocow_ctx->inodes,\n\t\t\t\t\t struct scrub_nocow_inode,\n\t\t\t\t\t list);\n\t\tlist_del_init(&entry->list);\n\t\tret = copy_nocow_pages_for_inode(entry->inum, entry->offset,\n\t\t\t\t\t\t entry->root, nocow_ctx);\n\t\tkfree(entry);\n\t\tif (ret == COPY_COMPLETE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\twhile (!list_empty(&nocow_ctx->inodes)) {\n\t\tstruct scrub_nocow_inode *entry;\n\t\tentry = list_first_entry(&nocow_ctx->inodes,\n\t\t\t\t\t struct scrub_nocow_inode,\n\t\t\t\t\t list);\n\t\tlist_del_init(&entry->list);\n\t\tkfree(entry);\n\t}\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, root);\n\tif (not_written)\n\t\tbtrfs_dev_replace_stats_inc(&fs_info->dev_replace.\n\t\t\t\t\t    num_uncorrectable_read_errors);\n\n\tbtrfs_free_path(path);\n\tkfree(nocow_ctx);\n\n\tscrub_pending_trans_workers_dec(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define COPY_COMPLETE 1"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pending_trans_workers_dec",
          "args": [
            "sctx"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_trans_workers_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "384-400",
          "snippet": "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nocow_ctx"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&fs_info->dev_replace.\n\t\t\t\t\t    num_uncorrectable_read_errors"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->list"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&nocow_ctx->inodes",
            "structscrub_nocow_inode",
            "list"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nocow_ctx->inodes"
          ],
          "line": 4007
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_nocow_pages_for_inode",
          "args": [
            "entry->inum",
            "entry->offset",
            "entry->root",
            "nocow_ctx"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "copy_nocow_pages_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "4071-4191",
          "snippet": "static int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *nocow_ctx)\n{\n\tstruct btrfs_fs_info *fs_info = nocow_ctx->sctx->dev_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct btrfs_root *local_root;\n\tstruct extent_io_tree *io_tree;\n\tu64 physical_for_dev_replace;\n\tu64 nocow_ctx_logical;\n\tu64 len = nocow_ctx->len;\n\tunsigned long index;\n\tint srcu_index;\n\tint ret = 0;\n\tint err = 0;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\t/* Avoid truncate/dio/punch hole.. */\n\tmutex_lock(&inode->i_mutex);\n\tinode_dio_wait(inode);\n\n\tphysical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\tnocow_ctx_logical = nocow_ctx->logical;\n\n\tret = check_extent_to_block(inode, offset, len, nocow_ctx_logical);\n\tif (ret) {\n\t\tret = ret > 0 ? 0 : ret;\n\t\tgoto out;\n\t}\n\n\twhile (len >= PAGE_CACHE_SIZE) {\n\t\tindex = offset >> PAGE_CACHE_SHIFT;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tbtrfs_err(fs_info, \"find_or_create_page() failed\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (PageDirty(page))\n\t\t\t\tgoto next_page;\n\t\t} else {\n\t\t\tClearPageError(page);\n\t\t\terr = extent_read_full_page(io_tree, page,\n\t\t\t\t\t\t\t   btrfs_get_extent,\n\t\t\t\t\t\t\t   nocow_ctx->mirror_num);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page has been remove from the page cache,\n\t\t\t * the data on it is meaningless, because it may be\n\t\t\t * old one, the new data may be written into the new\n\t\t\t * page in the page cache.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t}\n\n\t\tret = check_extent_to_block(inode, offset, len,\n\t\t\t\t\t    nocow_ctx_logical);\n\t\tif (ret) {\n\t\t\tret = ret > 0 ? 0 : ret;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\terr = write_page_nocow(nocow_ctx->sctx,\n\t\t\t\t       physical_for_dev_replace, page);\n\t\tif (err)\n\t\t\tret = err;\nnext_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tphysical_for_dev_replace += PAGE_CACHE_SIZE;\n\t\tnocow_ctx_logical += PAGE_CACHE_SIZE;\n\t\tlen -= PAGE_CACHE_SIZE;\n\t}\n\tret = COPY_COMPLETE;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define COPY_COMPLETE 1"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_bio_end_io(struct bio *bio, int err);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define COPY_COMPLETE 1\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *nocow_ctx)\n{\n\tstruct btrfs_fs_info *fs_info = nocow_ctx->sctx->dev_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct btrfs_root *local_root;\n\tstruct extent_io_tree *io_tree;\n\tu64 physical_for_dev_replace;\n\tu64 nocow_ctx_logical;\n\tu64 len = nocow_ctx->len;\n\tunsigned long index;\n\tint srcu_index;\n\tint ret = 0;\n\tint err = 0;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\t/* Avoid truncate/dio/punch hole.. */\n\tmutex_lock(&inode->i_mutex);\n\tinode_dio_wait(inode);\n\n\tphysical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tio_tree = &BTRFS_I(inode)->io_tree;\n\tnocow_ctx_logical = nocow_ctx->logical;\n\n\tret = check_extent_to_block(inode, offset, len, nocow_ctx_logical);\n\tif (ret) {\n\t\tret = ret > 0 ? 0 : ret;\n\t\tgoto out;\n\t}\n\n\twhile (len >= PAGE_CACHE_SIZE) {\n\t\tindex = offset >> PAGE_CACHE_SHIFT;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tbtrfs_err(fs_info, \"find_or_create_page() failed\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (PageDirty(page))\n\t\t\t\tgoto next_page;\n\t\t} else {\n\t\t\tClearPageError(page);\n\t\t\terr = extent_read_full_page(io_tree, page,\n\t\t\t\t\t\t\t   btrfs_get_extent,\n\t\t\t\t\t\t\t   nocow_ctx->mirror_num);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page has been remove from the page cache,\n\t\t\t * the data on it is meaningless, because it may be\n\t\t\t * old one, the new data may be written into the new\n\t\t\t * page in the page cache.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t}\n\n\t\tret = check_extent_to_block(inode, offset, len,\n\t\t\t\t\t    nocow_ctx_logical);\n\t\tif (ret) {\n\t\t\tret = ret > 0 ? 0 : ret;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\terr = write_page_nocow(nocow_ctx->sctx,\n\t\t\t\t       physical_for_dev_replace, page);\n\t\tif (err)\n\t\t\tret = err;\nnext_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tphysical_for_dev_replace += PAGE_CACHE_SIZE;\n\t\tnocow_ctx_logical += PAGE_CACHE_SIZE;\n\t\tlen -= PAGE_CACHE_SIZE;\n\t}\n\tret = COPY_COMPLETE;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->list"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&nocow_ctx->inodes",
            "structscrub_nocow_inode",
            "list"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"iterate_inodes_from_logical() failed: log %llu, \"\n\t\t\t\"phys %llu, len %llu, mir %u, ret %d\"",
            "logical",
            "physical_for_dev_replace",
            "len",
            "mirror_num",
            "ret"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_inodes_from_logical",
          "args": [
            "logical",
            "fs_info",
            "path",
            "record_inode_for_nocow",
            "nocow_ctx"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inodes_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1667-1690",
          "snippet": "int iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structscrub_copy_nocow_ctx",
            "work"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define COPY_COMPLETE 1\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void copy_nocow_pages_worker(struct btrfs_work *work)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx =\n\t\tcontainer_of(work, struct scrub_copy_nocow_ctx, work);\n\tstruct scrub_ctx *sctx = nocow_ctx->sctx;\n\tu64 logical = nocow_ctx->logical;\n\tu64 len = nocow_ctx->len;\n\tint mirror_num = nocow_ctx->mirror_num;\n\tu64 physical_for_dev_replace = nocow_ctx->physical_for_dev_replace;\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tint not_written = 0;\n\n\tfs_info = sctx->dev_root->fs_info;\n\troot = fs_info->extent_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(logical, fs_info, path,\n\t\t\t\t\t  record_inode_for_nocow, nocow_ctx);\n\tif (ret != 0 && ret != -ENOENT) {\n\t\tbtrfs_warn(fs_info, \"iterate_inodes_from_logical() failed: log %llu, \"\n\t\t\t\"phys %llu, len %llu, mir %u, ret %d\",\n\t\t\tlogical, physical_for_dev_replace, len, mirror_num,\n\t\t\tret);\n\t\tnot_written = 1;\n\t\tgoto out;\n\t}\n\n\tbtrfs_end_transaction(trans, root);\n\ttrans = NULL;\n\twhile (!list_empty(&nocow_ctx->inodes)) {\n\t\tstruct scrub_nocow_inode *entry;\n\t\tentry = list_first_entry(&nocow_ctx->inodes,\n\t\t\t\t\t struct scrub_nocow_inode,\n\t\t\t\t\t list);\n\t\tlist_del_init(&entry->list);\n\t\tret = copy_nocow_pages_for_inode(entry->inum, entry->offset,\n\t\t\t\t\t\t entry->root, nocow_ctx);\n\t\tkfree(entry);\n\t\tif (ret == COPY_COMPLETE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\twhile (!list_empty(&nocow_ctx->inodes)) {\n\t\tstruct scrub_nocow_inode *entry;\n\t\tentry = list_first_entry(&nocow_ctx->inodes,\n\t\t\t\t\t struct scrub_nocow_inode,\n\t\t\t\t\t list);\n\t\tlist_del_init(&entry->list);\n\t\tkfree(entry);\n\t}\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, root);\n\tif (not_written)\n\t\tbtrfs_dev_replace_stats_inc(&fs_info->dev_replace.\n\t\t\t\t\t    num_uncorrectable_read_errors);\n\n\tbtrfs_free_path(path);\n\tkfree(nocow_ctx);\n\n\tscrub_pending_trans_workers_dec(sctx);\n}"
  },
  {
    "function_name": "record_inode_for_nocow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3926-3939",
    "snippet": "static int record_inode_for_nocow(u64 inum, u64 offset, u64 root, void *ctx)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx = ctx;\n\tstruct scrub_nocow_inode *nocow_inode;\n\n\tnocow_inode = kzalloc(sizeof(*nocow_inode), GFP_NOFS);\n\tif (!nocow_inode)\n\t\treturn -ENOMEM;\n\tnocow_inode->inum = inum;\n\tnocow_inode->offset = offset;\n\tnocow_inode->root = root;\n\tlist_add_tail(&nocow_inode->list, &nocow_ctx->inodes);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *ctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nocow_inode->list",
            "&nocow_ctx->inodes"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*nocow_inode)",
            "GFP_NOFS"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int copy_nocow_pages_for_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t      struct scrub_copy_nocow_ctx *ctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int record_inode_for_nocow(u64 inum, u64 offset, u64 root, void *ctx)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx = ctx;\n\tstruct scrub_nocow_inode *nocow_inode;\n\n\tnocow_inode = kzalloc(sizeof(*nocow_inode), GFP_NOFS);\n\tif (!nocow_inode)\n\t\treturn -ENOMEM;\n\tnocow_inode->inum = inum;\n\tnocow_inode->offset = offset;\n\tnocow_inode->root = root;\n\tlist_add_tail(&nocow_inode->list, &nocow_ctx->inodes);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_nocow_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3896-3924",
    "snippet": "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tnocow_ctx = kzalloc(sizeof(*nocow_ctx), GFP_NOFS);\n\tif (!nocow_ctx) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tscrub_pending_trans_workers_inc(sctx);\n\n\tnocow_ctx->sctx = sctx;\n\tnocow_ctx->logical = logical;\n\tnocow_ctx->len = len;\n\tnocow_ctx->mirror_num = mirror_num;\n\tnocow_ctx->physical_for_dev_replace = physical_for_dev_replace;\n\tbtrfs_init_work(&nocow_ctx->work, btrfs_scrubnc_helper,\n\t\t\tcopy_nocow_pages_worker, NULL, NULL);\n\tINIT_LIST_HEAD(&nocow_ctx->inodes);\n\tbtrfs_queue_work(fs_info->scrub_nocow_workers,\n\t\t\t &nocow_ctx->work);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->scrub_nocow_workers",
            "&nocow_ctx->work"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nocow_ctx->inodes"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&nocow_ctx->work",
            "btrfs_scrubnc_helper",
            "copy_nocow_pages_worker",
            "NULL",
            "NULL"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_pending_trans_workers_inc",
          "args": [
            "sctx"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_trans_workers_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "352-381",
          "snippet": "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3906
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3904
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*nocow_ctx)",
            "GFP_NOFS"
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tnocow_ctx = kzalloc(sizeof(*nocow_ctx), GFP_NOFS);\n\tif (!nocow_ctx) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tscrub_pending_trans_workers_inc(sctx);\n\n\tnocow_ctx->sctx = sctx;\n\tnocow_ctx->logical = logical;\n\tnocow_ctx->len = len;\n\tnocow_ctx->mirror_num = mirror_num;\n\tnocow_ctx->physical_for_dev_replace = physical_for_dev_replace;\n\tbtrfs_init_work(&nocow_ctx->work, btrfs_scrubnc_helper,\n\t\t\tcopy_nocow_pages_worker, NULL, NULL);\n\tINIT_LIST_HEAD(&nocow_ctx->inodes);\n\tbtrfs_queue_work(fs_info->scrub_nocow_workers,\n\t\t\t &nocow_ctx->work);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_free_wr_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3888-3894",
    "snippet": "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx)\n{\n\tmutex_lock(&wr_ctx->wr_lock);\n\tkfree(wr_ctx->wr_curr_bio);\n\twr_ctx->wr_curr_bio = NULL;\n\tmutex_unlock(&wr_ctx->wr_lock);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wr_ctx->wr_curr_bio"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx)\n{\n\tmutex_lock(&wr_ctx->wr_lock);\n\tkfree(wr_ctx->wr_curr_bio);\n\twr_ctx->wr_curr_bio = NULL;\n\tmutex_unlock(&wr_ctx->wr_lock);\n}"
  },
  {
    "function_name": "scrub_setup_wr_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3867-3886",
    "snippet": "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace)\n{\n\tWARN_ON(wr_ctx->wr_curr_bio != NULL);\n\n\tmutex_init(&wr_ctx->wr_lock);\n\twr_ctx->wr_curr_bio = NULL;\n\tif (!is_dev_replace)\n\t\treturn 0;\n\n\tWARN_ON(!dev->bdev);\n\twr_ctx->pages_per_wr_bio = min_t(int, SCRUB_PAGES_PER_WR_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\twr_ctx->tgtdev = dev;\n\tatomic_set(&wr_ctx->flush_all_writes, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wr_ctx->flush_all_writes",
            "0"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "SCRUB_PAGES_PER_WR_BIO",
            "bio_get_nr_vecs(dev->bdev)"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "dev->bdev"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dev->bdev"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wr_ctx->wr_curr_bio != NULL"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace)\n{\n\tWARN_ON(wr_ctx->wr_curr_bio != NULL);\n\n\tmutex_init(&wr_ctx->wr_lock);\n\twr_ctx->wr_curr_bio = NULL;\n\tif (!is_dev_replace)\n\t\treturn 0;\n\n\tWARN_ON(!dev->bdev);\n\twr_ctx->pages_per_wr_bio = min_t(int, SCRUB_PAGES_PER_WR_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\twr_ctx->tgtdev = dev;\n\tatomic_set(&wr_ctx->flush_all_writes, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_remap_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3842-3865",
    "snippet": "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_block",
          "args": [
            "fs_info",
            "READ",
            "extent_logical",
            "&mapped_length",
            "&bbio",
            "0"
          ],
          "line": 3853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5484-5490",
          "snippet": "int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}"
  },
  {
    "function_name": "btrfs_scrub_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3825-3840",
    "snippet": "int btrfs_scrub_progress(struct btrfs_root *root, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_device;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "progress",
            "&sctx->stat",
            "sizeof(*progress)"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "NULL",
            "NULL"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_progress(struct btrfs_root *root, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_device;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}"
  },
  {
    "function_name": "btrfs_scrub_cancel_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3802-3823",
    "snippet": "int btrfs_scrub_cancel_dev(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_device *dev)\n{\n\tstruct scrub_ctx *sctx;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tsctx = dev->scrub_device;\n\tif (!sctx) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\tatomic_inc(&sctx->cancel_req);\n\twhile (dev->scrub_device) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   dev->scrub_device == NULL);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->scrub_pause_wait",
            "dev->scrub_device == NULL"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sctx->cancel_req"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel_dev(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_device *dev)\n{\n\tstruct scrub_ctx *sctx;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tsctx = dev->scrub_device;\n\tif (!sctx) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\tatomic_inc(&sctx->cancel_req);\n\twhile (dev->scrub_device) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   dev->scrub_device == NULL);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_scrub_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3781-3800",
    "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrub_cancel_req"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->scrub_pause_wait",
            "atomic_read(&fs_info->scrubs_running) == 0"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrub_cancel_req"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_scrub_continue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3773-3779",
    "snippet": "void btrfs_scrub_continue(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tatomic_dec(&fs_info->scrub_pause_req);\n\twake_up(&fs_info->scrub_pause_wait);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrub_pause_req"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_scrub_continue(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tatomic_dec(&fs_info->scrub_pause_req);\n\twake_up(&fs_info->scrub_pause_wait);\n}"
  },
  {
    "function_name": "btrfs_scrub_pause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3756-3771",
    "snippet": "void btrfs_scrub_pause(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrub_pause_req);\n\twhile (atomic_read(&fs_info->scrubs_paused) !=\n\t       atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_paused) ==\n\t\t\t   atomic_read(&fs_info->scrubs_running));\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->scrub_pause_wait",
            "atomic_read(&fs_info->scrubs_paused) ==\n\t\t\t   atomic_read(&fs_info->scrubs_running)"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrub_pause_req"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_scrub_pause(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrub_pause_req);\n\twhile (atomic_read(&fs_info->scrubs_paused) !=\n\t       atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_paused) ==\n\t\t\t   atomic_read(&fs_info->scrubs_running));\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n}"
  },
  {
    "function_name": "btrfs_scrub_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3611-3754",
    "snippet": "int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_put_ctx",
          "args": [
            "sctx"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_put_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "445-449",
          "snippet": "static void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_workers_put",
          "args": [
            "fs_info"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_workers_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3601-3609",
          "snippet": "static noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_nocow_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_nocow_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "progress",
            "&sctx->stat",
            "sizeof(*progress)"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->workers_pending) == 0"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->workers_pending"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->bios_in_flight) == 0"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_enumerate_chunks",
          "args": [
            "sctx",
            "dev",
            "start",
            "end",
            "is_dev_replace"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_enumerate_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3368-3522",
          "snippet": "static noinline_for_stack\nint scrub_enumerate_chunks(struct scrub_ctx *sctx,\n\t\t\t   struct btrfs_device *scrub_dev, u64 start, u64 end,\n\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = scrub_dev->devid;\n\tkey.offset = 0ull;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.objectid != scrub_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tbreak;\n\n\t\tif (found_key.offset >= end)\n\t\t\tbreak;\n\n\t\tif (found_key.offset < key.offset)\n\t\t\tbreak;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (found_key.offset + length <= start)\n\t\t\tgoto skip;\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\n\t\t/*\n\t\t * get a reference on the corresponding block group to prevent\n\t\t * the chunk from going away while we scrub it\n\t\t */\n\t\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\n\t\t/* some chunks are removed but not committed to disk yet,\n\t\t * continue scrubbing */\n\t\tif (!cache)\n\t\t\tgoto skip;\n\n\t\tdev_replace->cursor_right = found_key.offset + length;\n\t\tdev_replace->cursor_left = found_key.offset;\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tret = scrub_chunk(sctx, scrub_dev, chunk_tree, chunk_objectid,\n\t\t\t\t  chunk_offset, length, found_key.offset,\n\t\t\t\t  is_dev_replace);\n\n\t\t/*\n\t\t * flush, submit all pending read and write bios, afterwards\n\t\t * wait for them.\n\t\t * Note that in the dev replace case, a read request causes\n\t\t * write requests that are submitted in the read completion\n\t\t * worker. Therefore in the current situation, it is required\n\t\t * that all write requests are flushed, so that all read and\n\t\t * write requests are really completed when bios_in_flight\n\t\t * changes to 0.\n\t\t */\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\tscrub_submit(sctx);\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\tatomic_inc(&fs_info->scrubs_paused);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\t/*\n\t\t * must be called before we decrease @scrub_paused.\n\t\t * make sure we don't block transaction commit while\n\t\t * we are waiting pending workers finished.\n\t\t */\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->workers_pending) == 0);\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t\t__scrub_blocked_if_needed(fs_info);\n\t\tatomic_dec(&fs_info->scrubs_paused);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\tbtrfs_put_block_group(cache);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (is_dev_replace &&\n\t\t    atomic64_read(&dev_replace->num_write_errors) > 0) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (sctx->stat.malloc_errors > 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_replace->cursor_left = dev_replace->cursor_right;\n\t\tdev_replace->item_needs_writeback = 1;\nskip:\n\t\tkey.offset = found_key.offset + length;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/*\n\t * ret can still be 1 from search_slot or next_leaf,\n\t * that's not an error\n\t */\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint scrub_enumerate_chunks(struct scrub_ctx *sctx,\n\t\t\t   struct btrfs_device *scrub_dev, u64 start, u64 end,\n\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = scrub_dev->devid;\n\tkey.offset = 0ull;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.objectid != scrub_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tbreak;\n\n\t\tif (found_key.offset >= end)\n\t\t\tbreak;\n\n\t\tif (found_key.offset < key.offset)\n\t\t\tbreak;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (found_key.offset + length <= start)\n\t\t\tgoto skip;\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\n\t\t/*\n\t\t * get a reference on the corresponding block group to prevent\n\t\t * the chunk from going away while we scrub it\n\t\t */\n\t\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\n\t\t/* some chunks are removed but not committed to disk yet,\n\t\t * continue scrubbing */\n\t\tif (!cache)\n\t\t\tgoto skip;\n\n\t\tdev_replace->cursor_right = found_key.offset + length;\n\t\tdev_replace->cursor_left = found_key.offset;\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tret = scrub_chunk(sctx, scrub_dev, chunk_tree, chunk_objectid,\n\t\t\t\t  chunk_offset, length, found_key.offset,\n\t\t\t\t  is_dev_replace);\n\n\t\t/*\n\t\t * flush, submit all pending read and write bios, afterwards\n\t\t * wait for them.\n\t\t * Note that in the dev replace case, a read request causes\n\t\t * write requests that are submitted in the read completion\n\t\t * worker. Therefore in the current situation, it is required\n\t\t * that all write requests are flushed, so that all read and\n\t\t * write requests are really completed when bios_in_flight\n\t\t * changes to 0.\n\t\t */\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\tscrub_submit(sctx);\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\tatomic_inc(&fs_info->scrubs_paused);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\t/*\n\t\t * must be called before we decrease @scrub_paused.\n\t\t * make sure we don't block transaction commit while\n\t\t * we are waiting pending workers finished.\n\t\t */\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->workers_pending) == 0);\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t\t__scrub_blocked_if_needed(fs_info);\n\t\tatomic_dec(&fs_info->scrubs_paused);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\tbtrfs_put_block_group(cache);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (is_dev_replace &&\n\t\t    atomic64_read(&dev_replace->num_write_errors) > 0) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (sctx->stat.malloc_errors > 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_replace->cursor_left = dev_replace->cursor_right;\n\t\tdev_replace->item_needs_writeback = 1;\nskip:\n\t\tkey.offset = found_key.offset + length;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/*\n\t * ret can still be 1 from search_slot or next_leaf,\n\t * that's not an error\n\t */\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_supers",
          "args": [
            "sctx",
            "dev"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3524-3557",
          "snippet": "static noinline_for_stack int scrub_supers(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct btrfs_device *scrub_dev)\n{\n\tint\ti;\n\tu64\tbytenr;\n\tu64\tgen;\n\tint\tret;\n\tstruct btrfs_root *root = sctx->dev_root;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EIO;\n\n\t/* Seed devices of a new filesystem has their own generation. */\n\tif (scrub_dev->fs_devices != root->fs_info->fs_devices)\n\t\tgen = scrub_dev->generation;\n\telse\n\t\tgen = root->fs_info->last_trans_committed;\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >\n\t\t    scrub_dev->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tret = scrub_pages(sctx, bytenr, BTRFS_SUPER_INFO_SIZE, bytenr,\n\t\t\t\t  scrub_dev, BTRFS_EXTENT_FLAG_SUPER, gen, i,\n\t\t\t\t  NULL, 1, bytenr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_supers(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct btrfs_device *scrub_dev)\n{\n\tint\ti;\n\tu64\tbytenr;\n\tu64\tgen;\n\tint\tret;\n\tstruct btrfs_root *root = sctx->dev_root;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EIO;\n\n\t/* Seed devices of a new filesystem has their own generation. */\n\tif (scrub_dev->fs_devices != root->fs_info->fs_devices)\n\t\tgen = scrub_dev->generation;\n\telse\n\t\tgen = root->fs_info->last_trans_committed;\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >\n\t\t    scrub_dev->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tret = scrub_pages(sctx, bytenr, BTRFS_SUPER_INFO_SIZE, bytenr,\n\t\t\t\t  scrub_dev, BTRFS_EXTENT_FLAG_SUPER, gen, i,\n\t\t\t\t  NULL, 1, bytenr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scrub_blocked_if_needed",
          "args": [
            "fs_info"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "__scrub_blocked_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "325-333",
          "snippet": "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sctx"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sctx"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_setup_ctx",
          "args": [
            "dev",
            "is_dev_replace"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_setup_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "452-523",
          "snippet": "scrub_ctx *scrub_setup_ctx(struct btrfs_device *dev, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint\t\ti;\n\tstruct btrfs_fs_info *fs_info = dev->dev_root->fs_info;\n\tint pages_per_rd_bio;\n\tint ret;\n\n\t/*\n\t * the setting of pages_per_rd_bio is correct for scrub but might\n\t * be wrong for the dev_replace code where we might read from\n\t * different devices in the initial huge bios. However, that\n\t * code is able to correctly handle the case when adding a page\n\t * to a bio fails.\n\t */\n\tif (dev->bdev)\n\t\tpages_per_rd_bio = min_t(int, SCRUB_PAGES_PER_RD_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\telse\n\t\tpages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;\n\tsctx = kzalloc(sizeof(*sctx), GFP_NOFS);\n\tif (!sctx)\n\t\tgoto nomem;\n\tatomic_set(&sctx->refs, 1);\n\tsctx->is_dev_replace = is_dev_replace;\n\tsctx->pages_per_rd_bio = pages_per_rd_bio;\n\tsctx->curr = -1;\n\tsctx->dev_root = dev->dev_root;\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio;\n\n\t\tsbio = kzalloc(sizeof(*sbio), GFP_NOFS);\n\t\tif (!sbio)\n\t\t\tgoto nomem;\n\t\tsctx->bios[i] = sbio;\n\n\t\tsbio->index = i;\n\t\tsbio->sctx = sctx;\n\t\tsbio->page_count = 0;\n\t\tbtrfs_init_work(&sbio->work, btrfs_scrub_helper,\n\t\t\t\tscrub_bio_end_io_worker, NULL, NULL);\n\n\t\tif (i != SCRUB_BIOS_PER_SCTX - 1)\n\t\t\tsctx->bios[i]->next_free = i + 1;\n\t\telse\n\t\t\tsctx->bios[i]->next_free = -1;\n\t}\n\tsctx->first_free = 0;\n\tsctx->nodesize = dev->dev_root->nodesize;\n\tsctx->sectorsize = dev->dev_root->sectorsize;\n\tatomic_set(&sctx->bios_in_flight, 0);\n\tatomic_set(&sctx->workers_pending, 0);\n\tatomic_set(&sctx->cancel_req, 0);\n\tsctx->csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tINIT_LIST_HEAD(&sctx->csum_list);\n\n\tspin_lock_init(&sctx->list_lock);\n\tspin_lock_init(&sctx->stat_lock);\n\tinit_waitqueue_head(&sctx->list_wait);\n\n\tret = scrub_setup_wr_ctx(sctx, &sctx->wr_ctx, fs_info,\n\t\t\t\t fs_info->dev_replace.tgtdev, is_dev_replace);\n\tif (ret) {\n\t\tscrub_free_ctx(sctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn sctx;\n\nnomem:\n\tscrub_free_ctx(sctx);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */",
            "#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void copy_nocow_pages_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */\n#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nscrub_ctx *scrub_setup_ctx(struct btrfs_device *dev, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint\t\ti;\n\tstruct btrfs_fs_info *fs_info = dev->dev_root->fs_info;\n\tint pages_per_rd_bio;\n\tint ret;\n\n\t/*\n\t * the setting of pages_per_rd_bio is correct for scrub but might\n\t * be wrong for the dev_replace code where we might read from\n\t * different devices in the initial huge bios. However, that\n\t * code is able to correctly handle the case when adding a page\n\t * to a bio fails.\n\t */\n\tif (dev->bdev)\n\t\tpages_per_rd_bio = min_t(int, SCRUB_PAGES_PER_RD_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\telse\n\t\tpages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;\n\tsctx = kzalloc(sizeof(*sctx), GFP_NOFS);\n\tif (!sctx)\n\t\tgoto nomem;\n\tatomic_set(&sctx->refs, 1);\n\tsctx->is_dev_replace = is_dev_replace;\n\tsctx->pages_per_rd_bio = pages_per_rd_bio;\n\tsctx->curr = -1;\n\tsctx->dev_root = dev->dev_root;\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio;\n\n\t\tsbio = kzalloc(sizeof(*sbio), GFP_NOFS);\n\t\tif (!sbio)\n\t\t\tgoto nomem;\n\t\tsctx->bios[i] = sbio;\n\n\t\tsbio->index = i;\n\t\tsbio->sctx = sctx;\n\t\tsbio->page_count = 0;\n\t\tbtrfs_init_work(&sbio->work, btrfs_scrub_helper,\n\t\t\t\tscrub_bio_end_io_worker, NULL, NULL);\n\n\t\tif (i != SCRUB_BIOS_PER_SCTX - 1)\n\t\t\tsctx->bios[i]->next_free = i + 1;\n\t\telse\n\t\t\tsctx->bios[i]->next_free = -1;\n\t}\n\tsctx->first_free = 0;\n\tsctx->nodesize = dev->dev_root->nodesize;\n\tsctx->sectorsize = dev->dev_root->sectorsize;\n\tatomic_set(&sctx->bios_in_flight, 0);\n\tatomic_set(&sctx->workers_pending, 0);\n\tatomic_set(&sctx->cancel_req, 0);\n\tsctx->csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tINIT_LIST_HEAD(&sctx->csum_list);\n\n\tspin_lock_init(&sctx->list_lock);\n\tspin_lock_init(&sctx->stat_lock);\n\tinit_waitqueue_head(&sctx->list_wait);\n\n\tret = scrub_setup_wr_ctx(sctx, &sctx->wr_ctx, fs_info,\n\t\t\t\t fs_info->dev_replace.tgtdev, is_dev_replace);\n\tif (ret) {\n\t\tscrub_free_ctx(sctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn sctx;\n\nnomem:\n\tscrub_free_ctx(sctx);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_workers_get",
          "args": [
            "fs_info",
            "is_dev_replace"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_workers_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3562-3599",
          "snippet": "static noinline_for_stack int scrub_workers_get(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tint is_dev_replace)\n{\n\tint ret = 0;\n\tint flags = WQ_FREEZABLE | WQ_UNBOUND;\n\tint max_active = fs_info->thread_pool_size;\n\n\tif (fs_info->scrub_workers_refcnt == 0) {\n\t\tif (is_dev_replace)\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      1, 4);\n\t\telse\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      max_active, 4);\n\t\tif (!fs_info->scrub_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_wr_completion_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubwrc\", flags,\n\t\t\t\t\t      max_active, 2);\n\t\tif (!fs_info->scrub_wr_completion_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_nocow_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubnc\", flags, 1, 0);\n\t\tif (!fs_info->scrub_nocow_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t++fs_info->scrub_workers_refcnt;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_workers_get(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tint is_dev_replace)\n{\n\tint ret = 0;\n\tint flags = WQ_FREEZABLE | WQ_UNBOUND;\n\tint max_active = fs_info->thread_pool_size;\n\n\tif (fs_info->scrub_workers_refcnt == 0) {\n\t\tif (is_dev_replace)\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      1, 4);\n\t\telse\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      max_active, 4);\n\t\tif (!fs_info->scrub_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_wr_completion_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubwrc\", flags,\n\t\t\t\t\t      max_active, 2);\n\t\tif (!fs_info->scrub_wr_completion_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_nocow_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubnc\", flags, 1, 0);\n\t\tif (!fs_info->scrub_nocow_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t++fs_info->scrub_workers_refcnt;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: device %s is not writable\"",
            "name->str"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "dev->name"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "fs_info",
            "devid",
            "NULL",
            "NULL"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\"",
            "fs_info->chunk_root->nodesize",
            "SCRUB_MAX_PAGES_PER_BLOCK",
            "fs_info->chunk_root->sectorsize",
            "SCRUB_MAX_PAGES_PER_BLOCK"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\"",
            "fs_info->chunk_root->sectorsize",
            "PAGE_SIZE"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\"",
            "fs_info->chunk_root->nodesize",
            "BTRFS_STRIPE_LEN"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "fs_info"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "scrub_workers_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3601-3609",
    "snippet": "static noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_nocow_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_info->scrub_workers_refcnt < 0"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_workqueue",
          "args": [
            "fs_info->scrub_nocow_workers"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_nocow_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}"
  },
  {
    "function_name": "scrub_workers_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3562-3599",
    "snippet": "static noinline_for_stack int scrub_workers_get(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tint is_dev_replace)\n{\n\tint ret = 0;\n\tint flags = WQ_FREEZABLE | WQ_UNBOUND;\n\tint max_active = fs_info->thread_pool_size;\n\n\tif (fs_info->scrub_workers_refcnt == 0) {\n\t\tif (is_dev_replace)\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      1, 4);\n\t\telse\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      max_active, 4);\n\t\tif (!fs_info->scrub_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_wr_completion_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubwrc\", flags,\n\t\t\t\t\t      max_active, 2);\n\t\tif (!fs_info->scrub_wr_completion_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_nocow_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubnc\", flags, 1, 0);\n\t\tif (!fs_info->scrub_nocow_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t++fs_info->scrub_workers_refcnt;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_alloc_workqueue",
          "args": [
            "\"btrfs-scrubnc\"",
            "flags",
            "1",
            "0"
          ],
          "line": 3590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "134-161",
          "snippet": "struct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstruct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_workers_get(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tint is_dev_replace)\n{\n\tint ret = 0;\n\tint flags = WQ_FREEZABLE | WQ_UNBOUND;\n\tint max_active = fs_info->thread_pool_size;\n\n\tif (fs_info->scrub_workers_refcnt == 0) {\n\t\tif (is_dev_replace)\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      1, 4);\n\t\telse\n\t\t\tfs_info->scrub_workers =\n\t\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrub\", flags,\n\t\t\t\t\t\t      max_active, 4);\n\t\tif (!fs_info->scrub_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_wr_completion_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubwrc\", flags,\n\t\t\t\t\t      max_active, 2);\n\t\tif (!fs_info->scrub_wr_completion_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfs_info->scrub_nocow_workers =\n\t\t\tbtrfs_alloc_workqueue(\"btrfs-scrubnc\", flags, 1, 0);\n\t\tif (!fs_info->scrub_nocow_workers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t++fs_info->scrub_workers_refcnt;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "scrub_supers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3524-3557",
    "snippet": "static noinline_for_stack int scrub_supers(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct btrfs_device *scrub_dev)\n{\n\tint\ti;\n\tu64\tbytenr;\n\tu64\tgen;\n\tint\tret;\n\tstruct btrfs_root *root = sctx->dev_root;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EIO;\n\n\t/* Seed devices of a new filesystem has their own generation. */\n\tif (scrub_dev->fs_devices != root->fs_info->fs_devices)\n\t\tgen = scrub_dev->generation;\n\telse\n\t\tgen = root->fs_info->last_trans_committed;\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >\n\t\t    scrub_dev->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tret = scrub_pages(sctx, bytenr, BTRFS_SUPER_INFO_SIZE, bytenr,\n\t\t\t\t  scrub_dev, BTRFS_EXTENT_FLAG_SUPER, gen, i,\n\t\t\t\t  NULL, 1, bytenr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->bios_in_flight) == 0"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_pages",
          "args": [
            "sctx",
            "bytenr",
            "BTRFS_SUPER_INFO_SIZE",
            "bytenr",
            "scrub_dev",
            "BTRFS_EXTENT_FLAG_SUPER",
            "gen",
            "i",
            "NULL",
            "1",
            "bytenr"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2182-2262",
          "snippet": "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "i"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_supers(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct btrfs_device *scrub_dev)\n{\n\tint\ti;\n\tu64\tbytenr;\n\tu64\tgen;\n\tint\tret;\n\tstruct btrfs_root *root = sctx->dev_root;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EIO;\n\n\t/* Seed devices of a new filesystem has their own generation. */\n\tif (scrub_dev->fs_devices != root->fs_info->fs_devices)\n\t\tgen = scrub_dev->generation;\n\telse\n\t\tgen = root->fs_info->last_trans_committed;\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >\n\t\t    scrub_dev->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tret = scrub_pages(sctx, bytenr, BTRFS_SUPER_INFO_SIZE, bytenr,\n\t\t\t\t  scrub_dev, BTRFS_EXTENT_FLAG_SUPER, gen, i,\n\t\t\t\t  NULL, 1, bytenr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_enumerate_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3368-3522",
    "snippet": "static noinline_for_stack\nint scrub_enumerate_chunks(struct scrub_ctx *sctx,\n\t\t\t   struct btrfs_device *scrub_dev, u64 start, u64 end,\n\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = scrub_dev->devid;\n\tkey.offset = 0ull;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.objectid != scrub_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tbreak;\n\n\t\tif (found_key.offset >= end)\n\t\t\tbreak;\n\n\t\tif (found_key.offset < key.offset)\n\t\t\tbreak;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (found_key.offset + length <= start)\n\t\t\tgoto skip;\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\n\t\t/*\n\t\t * get a reference on the corresponding block group to prevent\n\t\t * the chunk from going away while we scrub it\n\t\t */\n\t\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\n\t\t/* some chunks are removed but not committed to disk yet,\n\t\t * continue scrubbing */\n\t\tif (!cache)\n\t\t\tgoto skip;\n\n\t\tdev_replace->cursor_right = found_key.offset + length;\n\t\tdev_replace->cursor_left = found_key.offset;\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tret = scrub_chunk(sctx, scrub_dev, chunk_tree, chunk_objectid,\n\t\t\t\t  chunk_offset, length, found_key.offset,\n\t\t\t\t  is_dev_replace);\n\n\t\t/*\n\t\t * flush, submit all pending read and write bios, afterwards\n\t\t * wait for them.\n\t\t * Note that in the dev replace case, a read request causes\n\t\t * write requests that are submitted in the read completion\n\t\t * worker. Therefore in the current situation, it is required\n\t\t * that all write requests are flushed, so that all read and\n\t\t * write requests are really completed when bios_in_flight\n\t\t * changes to 0.\n\t\t */\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\tscrub_submit(sctx);\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\tatomic_inc(&fs_info->scrubs_paused);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\t/*\n\t\t * must be called before we decrease @scrub_paused.\n\t\t * make sure we don't block transaction commit while\n\t\t * we are waiting pending workers finished.\n\t\t */\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->workers_pending) == 0);\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t\t__scrub_blocked_if_needed(fs_info);\n\t\tatomic_dec(&fs_info->scrubs_paused);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\tbtrfs_put_block_group(cache);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (is_dev_replace &&\n\t\t    atomic64_read(&dev_replace->num_write_errors) > 0) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (sctx->stat.malloc_errors > 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_replace->cursor_left = dev_replace->cursor_right;\n\t\tdev_replace->item_needs_writeback = 1;\nskip:\n\t\tkey.offset = found_key.offset + length;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/*\n\t * ret can still be 1 from search_slot or next_leaf,\n\t * that's not an error\n\t */\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3512
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&dev_replace->num_write_errors"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "cache"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scrub_blocked_if_needed",
          "args": [
            "fs_info"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "__scrub_blocked_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "325-333",
          "snippet": "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->wr_ctx.flush_all_writes",
            "0"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->workers_pending) == 0"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->workers_pending"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->bios_in_flight) == 0"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_wr_submit",
          "args": [
            "sctx"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_wr_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1775-1792",
          "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_submit",
          "args": [
            "sctx"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2081-2106",
          "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->wr_ctx.flush_all_writes",
            "1"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_chunk",
          "args": [
            "sctx",
            "scrub_dev",
            "chunk_tree",
            "chunk_objectid",
            "chunk_offset",
            "length",
            "found_key.offset",
            "is_dev_replace"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3325-3366",
          "snippet": "static noinline_for_stack int scrub_chunk(struct scrub_ctx *sctx,\n\t\t\t\t\t  struct btrfs_device *scrub_dev,\n\t\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t\t  u64 chunk_offset, u64 length,\n\t\t\t\t\t  u64 dev_offset, int is_dev_replace)\n{\n\tstruct btrfs_mapping_tree *map_tree =\n\t\t&sctx->dev_root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tint i;\n\tint ret = 0;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\tif (!em)\n\t\treturn -EINVAL;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (em->start != chunk_offset)\n\t\tgoto out;\n\n\tif (em->len < length)\n\t\tgoto out;\n\n\tfor (i = 0; i < map->num_stripes; ++i) {\n\t\tif (map->stripes[i].dev->bdev == scrub_dev->bdev &&\n\t\t    map->stripes[i].physical == dev_offset) {\n\t\t\tret = scrub_stripe(sctx, map, scrub_dev, i,\n\t\t\t\t\t   chunk_offset, length,\n\t\t\t\t\t   is_dev_replace);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree_extent_map(em);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_chunk(struct scrub_ctx *sctx,\n\t\t\t\t\t  struct btrfs_device *scrub_dev,\n\t\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t\t  u64 chunk_offset, u64 length,\n\t\t\t\t\t  u64 dev_offset, int is_dev_replace)\n{\n\tstruct btrfs_mapping_tree *map_tree =\n\t\t&sctx->dev_root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tint i;\n\tint ret = 0;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\tif (!em)\n\t\treturn -EINVAL;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (em->start != chunk_offset)\n\t\tgoto out;\n\n\tif (em->len < length)\n\t\tgoto out;\n\n\tfor (i = 0; i < map->num_stripes; ++i) {\n\t\tif (map->stripes[i].dev->bdev == scrub_dev->bdev &&\n\t\t    map->stripes[i].physical == dev_offset) {\n\t\t\tret = scrub_stripe(sctx, map, scrub_dev, i,\n\t\t\t\t\t   chunk_offset, length,\n\t\t\t\t\t   is_dev_replace);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree_extent_map(em);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_block_group",
          "args": [
            "fs_info",
            "chunk_offset"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "669-678",
          "snippet": "struct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_offset",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_objectid",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_tree",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_dev_extent"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&found_key",
            "slot"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint scrub_enumerate_chunks(struct scrub_ctx *sctx,\n\t\t\t   struct btrfs_device *scrub_dev, u64 start, u64 end,\n\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = scrub_dev->devid;\n\tkey.offset = 0ull;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.objectid != scrub_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tbreak;\n\n\t\tif (found_key.offset >= end)\n\t\t\tbreak;\n\n\t\tif (found_key.offset < key.offset)\n\t\t\tbreak;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (found_key.offset + length <= start)\n\t\t\tgoto skip;\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\n\t\t/*\n\t\t * get a reference on the corresponding block group to prevent\n\t\t * the chunk from going away while we scrub it\n\t\t */\n\t\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\n\t\t/* some chunks are removed but not committed to disk yet,\n\t\t * continue scrubbing */\n\t\tif (!cache)\n\t\t\tgoto skip;\n\n\t\tdev_replace->cursor_right = found_key.offset + length;\n\t\tdev_replace->cursor_left = found_key.offset;\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tret = scrub_chunk(sctx, scrub_dev, chunk_tree, chunk_objectid,\n\t\t\t\t  chunk_offset, length, found_key.offset,\n\t\t\t\t  is_dev_replace);\n\n\t\t/*\n\t\t * flush, submit all pending read and write bios, afterwards\n\t\t * wait for them.\n\t\t * Note that in the dev replace case, a read request causes\n\t\t * write requests that are submitted in the read completion\n\t\t * worker. Therefore in the current situation, it is required\n\t\t * that all write requests are flushed, so that all read and\n\t\t * write requests are really completed when bios_in_flight\n\t\t * changes to 0.\n\t\t */\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\tscrub_submit(sctx);\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\tatomic_inc(&fs_info->scrubs_paused);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\t/*\n\t\t * must be called before we decrease @scrub_paused.\n\t\t * make sure we don't block transaction commit while\n\t\t * we are waiting pending workers finished.\n\t\t */\n\t\twait_event(sctx->list_wait,\n\t\t\t   atomic_read(&sctx->workers_pending) == 0);\n\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t\t__scrub_blocked_if_needed(fs_info);\n\t\tatomic_dec(&fs_info->scrubs_paused);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twake_up(&fs_info->scrub_pause_wait);\n\n\t\tbtrfs_put_block_group(cache);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (is_dev_replace &&\n\t\t    atomic64_read(&dev_replace->num_write_errors) > 0) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (sctx->stat.malloc_errors > 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_replace->cursor_left = dev_replace->cursor_right;\n\t\tdev_replace->item_needs_writeback = 1;\nskip:\n\t\tkey.offset = found_key.offset + length;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/*\n\t * ret can still be 1 from search_slot or next_leaf,\n\t * that's not an error\n\t */\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "scrub_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "3325-3366",
    "snippet": "static noinline_for_stack int scrub_chunk(struct scrub_ctx *sctx,\n\t\t\t\t\t  struct btrfs_device *scrub_dev,\n\t\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t\t  u64 chunk_offset, u64 length,\n\t\t\t\t\t  u64 dev_offset, int is_dev_replace)\n{\n\tstruct btrfs_mapping_tree *map_tree =\n\t\t&sctx->dev_root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tint i;\n\tint ret = 0;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\tif (!em)\n\t\treturn -EINVAL;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (em->start != chunk_offset)\n\t\tgoto out;\n\n\tif (em->len < length)\n\t\tgoto out;\n\n\tfor (i = 0; i < map->num_stripes; ++i) {\n\t\tif (map->stripes[i].dev->bdev == scrub_dev->bdev &&\n\t\t    map->stripes[i].physical == dev_offset) {\n\t\t\tret = scrub_stripe(sctx, map, scrub_dev, i,\n\t\t\t\t\t   chunk_offset, length,\n\t\t\t\t\t   is_dev_replace);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree_extent_map(em);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_stripe",
          "args": [
            "sctx",
            "map",
            "scrub_dev",
            "i",
            "chunk_offset",
            "length",
            "is_dev_replace"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2959-3323",
          "snippet": "static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct map_lookup *map,\n\t\t\t\t\t   struct btrfs_device *scrub_dev,\n\t\t\t\t\t   int num, u64 base, u64 length,\n\t\t\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_path *path, *ppath;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tstruct blk_plug plug;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tu64 nstripes;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 physical;\n\tu64 logical;\n\tu64 logic_end;\n\tu64 physical_end;\n\tu64 generation;\n\tint mirror_num;\n\tstruct reada_control *reada1;\n\tstruct reada_control *reada2;\n\tstruct btrfs_key key_start;\n\tstruct btrfs_key key_end;\n\tu64 increment = map->stripe_len;\n\tu64 offset;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tu64 stripe_logical;\n\tu64 stripe_end;\n\tstruct btrfs_device *extent_dev;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnstripes = length;\n\tphysical = map->stripes[num].physical;\n\toffset = 0;\n\tdo_div(nstripes, map->stripe_len);\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\toffset = map->stripe_len * num;\n\t\tincrement = map->stripe_len * map->num_stripes;\n\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\t\toffset = map->stripe_len * (num / map->sub_stripes);\n\t\tincrement = map->stripe_len * factor;\n\t\tmirror_num = num % map->sub_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical, num, map, &offset, NULL);\n\t\tincrement = map->stripe_len * nr_data_stripes(map);\n\t\tmirror_num = 1;\n\t} else {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tppath = btrfs_alloc_path();\n\tif (!ppath) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * work on commit root. The related disk blocks are static as\n\t * long as COW is applied. This means, it is save to rewrite\n\t * them to repair disk errors without any race conditions\n\t */\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tppath->search_commit_root = 1;\n\tppath->skip_locking = 1;\n\t/*\n\t * trigger the readahead for extent tree csum tree and wait for\n\t * completion. During readahead, the scrub is officially paused\n\t * to not hold off transaction commits\n\t */\n\tlogical = base + offset;\n\tphysical_end = physical + nstripes * map->stripe_len;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical_end, num,\n\t\t\t\t\tmap, &logic_end, NULL);\n\t\tlogic_end += base;\n\t} else {\n\t\tlogic_end = logical + increment * nstripes;\n\t}\n\twait_event(sctx->list_wait,\n\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\tscrub_blocked_if_needed(fs_info);\n\n\t/* FIXME it might be better to start readahead at commit root */\n\tkey_start.objectid = logical;\n\tkey_start.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey_start.offset = (u64)0;\n\tkey_end.objectid = logic_end;\n\tkey_end.type = BTRFS_METADATA_ITEM_KEY;\n\tkey_end.offset = (u64)-1;\n\treada1 = btrfs_reada_add(root, &key_start, &key_end);\n\n\tkey_start.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_start.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_start.offset = logical;\n\tkey_end.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_end.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_end.offset = logic_end;\n\treada2 = btrfs_reada_add(csum_root, &key_start, &key_end);\n\n\tif (!IS_ERR(reada1))\n\t\tbtrfs_reada_wait(reada1);\n\tif (!IS_ERR(reada2))\n\t\tbtrfs_reada_wait(reada2);\n\n\n\t/*\n\t * collect all data csums for the stripe to avoid seeking during\n\t * the scrub. This might currently (crc32) end up to be about 1MB\n\t */\n\tblk_start_plug(&plug);\n\n\t/*\n\t * now find all extents for each stripe and scrub them\n\t */\n\tret = 0;\n\twhile (physical < physical_end) {\n\t\t/* for raid56, we skip parity stripe */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = get_raid56_logic_offset(physical, num,\n\t\t\t\t\tmap, &logical, &stripe_logical);\n\t\t\tlogical += base;\n\t\t\tif (ret) {\n\t\t\t\tstripe_logical += base;\n\t\t\t\tstripe_end = stripe_logical + increment - 1;\n\t\t\t\tret = scrub_raid56_parity(sctx, map, scrub_dev,\n\t\t\t\t\t\tppath, stripe_logical,\n\t\t\t\t\t\tstripe_end);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * canceled?\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_cancel_req) ||\n\t\t    atomic_read(&sctx->cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * check to see if we have to pause\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_pause_req)) {\n\t\t\t/* push queued extents */\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\t\tscrub_submit(sctx);\n\t\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\t\tscrub_wr_submit(sctx);\n\t\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t\t\twait_event(sctx->list_wait,\n\t\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\t\t\tscrub_blocked_if_needed(fs_info);\n\t\t}\n\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logical;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\t/* there's no smaller item, so stick with the\n\t\t\t\t * larger one */\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logical)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid >= logical + map->stripe_len) {\n\t\t\t\t/* out of this device extent */\n\t\t\t\tif (key.objectid >= logic_end)\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logical &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t   \"scrub: tree block %llu spanning \"\n\t\t\t\t\t   \"stripes, ignored. logical=%llu\",\n\t\t\t\t       key.objectid, logical);\n\t\t\t\tgoto next;\n\t\t\t}\n\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\t/*\n\t\t\t * trim extent to this stripe\n\t\t\t */\n\t\t\tif (extent_logical < logical) {\n\t\t\t\textent_len -= logical - extent_logical;\n\t\t\t\textent_logical = logical;\n\t\t\t}\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logical + map->stripe_len) {\n\t\t\t\textent_len = logical + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\t\t\t}\n\n\t\t\textent_physical = extent_logical - logical + physical;\n\t\t\textent_dev = scrub_dev;\n\t\t\textent_mirror_num = mirror_num;\n\t\t\tif (is_dev_replace)\n\t\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root, logical,\n\t\t\t\t\t\tlogical + map->stripe_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent(sctx, extent_logical, extent_len,\n\t\t\t\t\t   extent_physical, extent_dev, flags,\n\t\t\t\t\t   generation, extent_mirror_num,\n\t\t\t\t\t   extent_logical - logical + physical);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * loop until we find next data stripe\n\t\t\t\t\t * or we have finished all stripes.\n\t\t\t\t\t */\nloop:\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tret = get_raid56_logic_offset(physical,\n\t\t\t\t\t\t\tnum, map, &logical,\n\t\t\t\t\t\t\t&stripe_logical);\n\t\t\t\t\tlogical += base;\n\n\t\t\t\t\tif (ret && physical < physical_end) {\n\t\t\t\t\t\tstripe_logical += base;\n\t\t\t\t\t\tstripe_end = stripe_logical +\n\t\t\t\t\t\t\t\tincrement - 1;\n\t\t\t\t\t\tret = scrub_raid56_parity(sctx,\n\t\t\t\t\t\t\tmap, scrub_dev, ppath,\n\t\t\t\t\t\t\tstripe_logical,\n\t\t\t\t\t\t\tstripe_end);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tgoto loop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tlogical += increment;\n\t\t\t\t}\n\t\t\t\tif (logical < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tif (physical >= physical_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_release_path(path);\nskip:\n\t\tlogical += increment;\n\t\tphysical += map->stripe_len;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tsctx->stat.last_physical = map->stripes[num].physical +\n\t\t\t\t\t\t   length;\n\t\telse\n\t\t\tsctx->stat.last_physical = physical;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tbreak;\n\t}\nout:\n\t/* push queued extents */\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tblk_finish_plug(&plug);\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(ppath);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static void copy_nocow_pages_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct map_lookup *map,\n\t\t\t\t\t   struct btrfs_device *scrub_dev,\n\t\t\t\t\t   int num, u64 base, u64 length,\n\t\t\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_path *path, *ppath;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tstruct blk_plug plug;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tu64 nstripes;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 physical;\n\tu64 logical;\n\tu64 logic_end;\n\tu64 physical_end;\n\tu64 generation;\n\tint mirror_num;\n\tstruct reada_control *reada1;\n\tstruct reada_control *reada2;\n\tstruct btrfs_key key_start;\n\tstruct btrfs_key key_end;\n\tu64 increment = map->stripe_len;\n\tu64 offset;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tu64 stripe_logical;\n\tu64 stripe_end;\n\tstruct btrfs_device *extent_dev;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnstripes = length;\n\tphysical = map->stripes[num].physical;\n\toffset = 0;\n\tdo_div(nstripes, map->stripe_len);\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\toffset = map->stripe_len * num;\n\t\tincrement = map->stripe_len * map->num_stripes;\n\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\t\toffset = map->stripe_len * (num / map->sub_stripes);\n\t\tincrement = map->stripe_len * factor;\n\t\tmirror_num = num % map->sub_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical, num, map, &offset, NULL);\n\t\tincrement = map->stripe_len * nr_data_stripes(map);\n\t\tmirror_num = 1;\n\t} else {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tppath = btrfs_alloc_path();\n\tif (!ppath) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * work on commit root. The related disk blocks are static as\n\t * long as COW is applied. This means, it is save to rewrite\n\t * them to repair disk errors without any race conditions\n\t */\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tppath->search_commit_root = 1;\n\tppath->skip_locking = 1;\n\t/*\n\t * trigger the readahead for extent tree csum tree and wait for\n\t * completion. During readahead, the scrub is officially paused\n\t * to not hold off transaction commits\n\t */\n\tlogical = base + offset;\n\tphysical_end = physical + nstripes * map->stripe_len;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical_end, num,\n\t\t\t\t\tmap, &logic_end, NULL);\n\t\tlogic_end += base;\n\t} else {\n\t\tlogic_end = logical + increment * nstripes;\n\t}\n\twait_event(sctx->list_wait,\n\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\tscrub_blocked_if_needed(fs_info);\n\n\t/* FIXME it might be better to start readahead at commit root */\n\tkey_start.objectid = logical;\n\tkey_start.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey_start.offset = (u64)0;\n\tkey_end.objectid = logic_end;\n\tkey_end.type = BTRFS_METADATA_ITEM_KEY;\n\tkey_end.offset = (u64)-1;\n\treada1 = btrfs_reada_add(root, &key_start, &key_end);\n\n\tkey_start.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_start.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_start.offset = logical;\n\tkey_end.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_end.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_end.offset = logic_end;\n\treada2 = btrfs_reada_add(csum_root, &key_start, &key_end);\n\n\tif (!IS_ERR(reada1))\n\t\tbtrfs_reada_wait(reada1);\n\tif (!IS_ERR(reada2))\n\t\tbtrfs_reada_wait(reada2);\n\n\n\t/*\n\t * collect all data csums for the stripe to avoid seeking during\n\t * the scrub. This might currently (crc32) end up to be about 1MB\n\t */\n\tblk_start_plug(&plug);\n\n\t/*\n\t * now find all extents for each stripe and scrub them\n\t */\n\tret = 0;\n\twhile (physical < physical_end) {\n\t\t/* for raid56, we skip parity stripe */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = get_raid56_logic_offset(physical, num,\n\t\t\t\t\tmap, &logical, &stripe_logical);\n\t\t\tlogical += base;\n\t\t\tif (ret) {\n\t\t\t\tstripe_logical += base;\n\t\t\t\tstripe_end = stripe_logical + increment - 1;\n\t\t\t\tret = scrub_raid56_parity(sctx, map, scrub_dev,\n\t\t\t\t\t\tppath, stripe_logical,\n\t\t\t\t\t\tstripe_end);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * canceled?\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_cancel_req) ||\n\t\t    atomic_read(&sctx->cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * check to see if we have to pause\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_pause_req)) {\n\t\t\t/* push queued extents */\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\t\tscrub_submit(sctx);\n\t\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\t\tscrub_wr_submit(sctx);\n\t\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t\t\twait_event(sctx->list_wait,\n\t\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\t\t\tscrub_blocked_if_needed(fs_info);\n\t\t}\n\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logical;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\t/* there's no smaller item, so stick with the\n\t\t\t\t * larger one */\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logical)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid >= logical + map->stripe_len) {\n\t\t\t\t/* out of this device extent */\n\t\t\t\tif (key.objectid >= logic_end)\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logical &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t   \"scrub: tree block %llu spanning \"\n\t\t\t\t\t   \"stripes, ignored. logical=%llu\",\n\t\t\t\t       key.objectid, logical);\n\t\t\t\tgoto next;\n\t\t\t}\n\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\t/*\n\t\t\t * trim extent to this stripe\n\t\t\t */\n\t\t\tif (extent_logical < logical) {\n\t\t\t\textent_len -= logical - extent_logical;\n\t\t\t\textent_logical = logical;\n\t\t\t}\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logical + map->stripe_len) {\n\t\t\t\textent_len = logical + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\t\t\t}\n\n\t\t\textent_physical = extent_logical - logical + physical;\n\t\t\textent_dev = scrub_dev;\n\t\t\textent_mirror_num = mirror_num;\n\t\t\tif (is_dev_replace)\n\t\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root, logical,\n\t\t\t\t\t\tlogical + map->stripe_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent(sctx, extent_logical, extent_len,\n\t\t\t\t\t   extent_physical, extent_dev, flags,\n\t\t\t\t\t   generation, extent_mirror_num,\n\t\t\t\t\t   extent_logical - logical + physical);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * loop until we find next data stripe\n\t\t\t\t\t * or we have finished all stripes.\n\t\t\t\t\t */\nloop:\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tret = get_raid56_logic_offset(physical,\n\t\t\t\t\t\t\tnum, map, &logical,\n\t\t\t\t\t\t\t&stripe_logical);\n\t\t\t\t\tlogical += base;\n\n\t\t\t\t\tif (ret && physical < physical_end) {\n\t\t\t\t\t\tstripe_logical += base;\n\t\t\t\t\t\tstripe_end = stripe_logical +\n\t\t\t\t\t\t\t\tincrement - 1;\n\t\t\t\t\t\tret = scrub_raid56_parity(sctx,\n\t\t\t\t\t\t\tmap, scrub_dev, ppath,\n\t\t\t\t\t\t\tstripe_logical,\n\t\t\t\t\t\t\tstripe_end);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tgoto loop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tlogical += increment;\n\t\t\t\t}\n\t\t\t\tif (logical < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tif (physical >= physical_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_release_path(path);\nskip:\n\t\tlogical += increment;\n\t\tphysical += map->stripe_len;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tsctx->stat.last_physical = map->stripes[num].physical +\n\t\t\t\t\t\t   length;\n\t\telse\n\t\t\tsctx->stat.last_physical = physical;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tbreak;\n\t}\nout:\n\t/* push queued extents */\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tblk_finish_plug(&plug);\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(ppath);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "&map_tree->map_tree",
            "chunk_offset",
            "1"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_chunk(struct scrub_ctx *sctx,\n\t\t\t\t\t  struct btrfs_device *scrub_dev,\n\t\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t\t  u64 chunk_offset, u64 length,\n\t\t\t\t\t  u64 dev_offset, int is_dev_replace)\n{\n\tstruct btrfs_mapping_tree *map_tree =\n\t\t&sctx->dev_root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tint i;\n\tint ret = 0;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\tif (!em)\n\t\treturn -EINVAL;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (em->start != chunk_offset)\n\t\tgoto out;\n\n\tif (em->len < length)\n\t\tgoto out;\n\n\tfor (i = 0; i < map->num_stripes; ++i) {\n\t\tif (map->stripes[i].dev->bdev == scrub_dev->bdev &&\n\t\t    map->stripes[i].physical == dev_offset) {\n\t\t\tret = scrub_stripe(sctx, map, scrub_dev, i,\n\t\t\t\t\t   chunk_offset, length,\n\t\t\t\t\t   is_dev_replace);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree_extent_map(em);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "scrub_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2959-3323",
    "snippet": "static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct map_lookup *map,\n\t\t\t\t\t   struct btrfs_device *scrub_dev,\n\t\t\t\t\t   int num, u64 base, u64 length,\n\t\t\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_path *path, *ppath;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tstruct blk_plug plug;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tu64 nstripes;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 physical;\n\tu64 logical;\n\tu64 logic_end;\n\tu64 physical_end;\n\tu64 generation;\n\tint mirror_num;\n\tstruct reada_control *reada1;\n\tstruct reada_control *reada2;\n\tstruct btrfs_key key_start;\n\tstruct btrfs_key key_end;\n\tu64 increment = map->stripe_len;\n\tu64 offset;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tu64 stripe_logical;\n\tu64 stripe_end;\n\tstruct btrfs_device *extent_dev;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnstripes = length;\n\tphysical = map->stripes[num].physical;\n\toffset = 0;\n\tdo_div(nstripes, map->stripe_len);\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\toffset = map->stripe_len * num;\n\t\tincrement = map->stripe_len * map->num_stripes;\n\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\t\toffset = map->stripe_len * (num / map->sub_stripes);\n\t\tincrement = map->stripe_len * factor;\n\t\tmirror_num = num % map->sub_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical, num, map, &offset, NULL);\n\t\tincrement = map->stripe_len * nr_data_stripes(map);\n\t\tmirror_num = 1;\n\t} else {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tppath = btrfs_alloc_path();\n\tif (!ppath) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * work on commit root. The related disk blocks are static as\n\t * long as COW is applied. This means, it is save to rewrite\n\t * them to repair disk errors without any race conditions\n\t */\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tppath->search_commit_root = 1;\n\tppath->skip_locking = 1;\n\t/*\n\t * trigger the readahead for extent tree csum tree and wait for\n\t * completion. During readahead, the scrub is officially paused\n\t * to not hold off transaction commits\n\t */\n\tlogical = base + offset;\n\tphysical_end = physical + nstripes * map->stripe_len;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical_end, num,\n\t\t\t\t\tmap, &logic_end, NULL);\n\t\tlogic_end += base;\n\t} else {\n\t\tlogic_end = logical + increment * nstripes;\n\t}\n\twait_event(sctx->list_wait,\n\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\tscrub_blocked_if_needed(fs_info);\n\n\t/* FIXME it might be better to start readahead at commit root */\n\tkey_start.objectid = logical;\n\tkey_start.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey_start.offset = (u64)0;\n\tkey_end.objectid = logic_end;\n\tkey_end.type = BTRFS_METADATA_ITEM_KEY;\n\tkey_end.offset = (u64)-1;\n\treada1 = btrfs_reada_add(root, &key_start, &key_end);\n\n\tkey_start.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_start.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_start.offset = logical;\n\tkey_end.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_end.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_end.offset = logic_end;\n\treada2 = btrfs_reada_add(csum_root, &key_start, &key_end);\n\n\tif (!IS_ERR(reada1))\n\t\tbtrfs_reada_wait(reada1);\n\tif (!IS_ERR(reada2))\n\t\tbtrfs_reada_wait(reada2);\n\n\n\t/*\n\t * collect all data csums for the stripe to avoid seeking during\n\t * the scrub. This might currently (crc32) end up to be about 1MB\n\t */\n\tblk_start_plug(&plug);\n\n\t/*\n\t * now find all extents for each stripe and scrub them\n\t */\n\tret = 0;\n\twhile (physical < physical_end) {\n\t\t/* for raid56, we skip parity stripe */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = get_raid56_logic_offset(physical, num,\n\t\t\t\t\tmap, &logical, &stripe_logical);\n\t\t\tlogical += base;\n\t\t\tif (ret) {\n\t\t\t\tstripe_logical += base;\n\t\t\t\tstripe_end = stripe_logical + increment - 1;\n\t\t\t\tret = scrub_raid56_parity(sctx, map, scrub_dev,\n\t\t\t\t\t\tppath, stripe_logical,\n\t\t\t\t\t\tstripe_end);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * canceled?\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_cancel_req) ||\n\t\t    atomic_read(&sctx->cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * check to see if we have to pause\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_pause_req)) {\n\t\t\t/* push queued extents */\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\t\tscrub_submit(sctx);\n\t\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\t\tscrub_wr_submit(sctx);\n\t\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t\t\twait_event(sctx->list_wait,\n\t\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\t\t\tscrub_blocked_if_needed(fs_info);\n\t\t}\n\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logical;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\t/* there's no smaller item, so stick with the\n\t\t\t\t * larger one */\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logical)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid >= logical + map->stripe_len) {\n\t\t\t\t/* out of this device extent */\n\t\t\t\tif (key.objectid >= logic_end)\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logical &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t   \"scrub: tree block %llu spanning \"\n\t\t\t\t\t   \"stripes, ignored. logical=%llu\",\n\t\t\t\t       key.objectid, logical);\n\t\t\t\tgoto next;\n\t\t\t}\n\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\t/*\n\t\t\t * trim extent to this stripe\n\t\t\t */\n\t\t\tif (extent_logical < logical) {\n\t\t\t\textent_len -= logical - extent_logical;\n\t\t\t\textent_logical = logical;\n\t\t\t}\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logical + map->stripe_len) {\n\t\t\t\textent_len = logical + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\t\t\t}\n\n\t\t\textent_physical = extent_logical - logical + physical;\n\t\t\textent_dev = scrub_dev;\n\t\t\textent_mirror_num = mirror_num;\n\t\t\tif (is_dev_replace)\n\t\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root, logical,\n\t\t\t\t\t\tlogical + map->stripe_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent(sctx, extent_logical, extent_len,\n\t\t\t\t\t   extent_physical, extent_dev, flags,\n\t\t\t\t\t   generation, extent_mirror_num,\n\t\t\t\t\t   extent_logical - logical + physical);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * loop until we find next data stripe\n\t\t\t\t\t * or we have finished all stripes.\n\t\t\t\t\t */\nloop:\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tret = get_raid56_logic_offset(physical,\n\t\t\t\t\t\t\tnum, map, &logical,\n\t\t\t\t\t\t\t&stripe_logical);\n\t\t\t\t\tlogical += base;\n\n\t\t\t\t\tif (ret && physical < physical_end) {\n\t\t\t\t\t\tstripe_logical += base;\n\t\t\t\t\t\tstripe_end = stripe_logical +\n\t\t\t\t\t\t\t\tincrement - 1;\n\t\t\t\t\t\tret = scrub_raid56_parity(sctx,\n\t\t\t\t\t\t\tmap, scrub_dev, ppath,\n\t\t\t\t\t\t\tstripe_logical,\n\t\t\t\t\t\t\tstripe_end);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tgoto loop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tlogical += increment;\n\t\t\t\t}\n\t\t\t\tif (logical < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tif (physical >= physical_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_release_path(path);\nskip:\n\t\tlogical += increment;\n\t\tphysical += map->stripe_len;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tsctx->stat.last_physical = map->stripes[num].physical +\n\t\t\t\t\t\t   length;\n\t\telse\n\t\t\tsctx->stat.last_physical = physical;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tbreak;\n\t}\nout:\n\t/* push queued extents */\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tblk_finish_plug(&plug);\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(ppath);\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "ppath"
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_wr_submit",
          "args": [
            "sctx"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_wr_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1775-1792",
          "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_submit",
          "args": [
            "sctx"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2081-2106",
          "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_raid56_parity",
          "args": [
            "sctx",
            "map",
            "scrub_dev",
            "ppath",
            "stripe_logical",
            "stripe_end"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_raid56_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2756-2957",
          "snippet": "static noinline_for_stack int scrub_raid56_parity(struct scrub_ctx *sctx,\n\t\t\t\t\t\t  struct map_lookup *map,\n\t\t\t\t\t\t  struct btrfs_device *sdev,\n\t\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t\t  u64 logic_start,\n\t\t\t\t\t\t  u64 logic_end)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 generation;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tstruct btrfs_device *extent_dev;\n\tstruct scrub_parity *sparity;\n\tint nsectors;\n\tint bitmap_len;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnsectors = map->stripe_len / root->sectorsize;\n\tbitmap_len = scrub_calc_parity_bitmap_len(nsectors);\n\tsparity = kzalloc(sizeof(struct scrub_parity) + 2 * bitmap_len,\n\t\t\t  GFP_NOFS);\n\tif (!sparity) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsparity->stripe_len = map->stripe_len;\n\tsparity->nsectors = nsectors;\n\tsparity->sctx = sctx;\n\tsparity->scrub_dev = sdev;\n\tsparity->logic_start = logic_start;\n\tsparity->logic_end = logic_end;\n\tatomic_set(&sparity->refs, 1);\n\tINIT_LIST_HEAD(&sparity->spages);\n\tsparity->dbitmap = sparity->bitmap;\n\tsparity->ebitmap = (void *)sparity->bitmap + bitmap_len;\n\n\tret = 0;\n\twhile (logic_start < logic_end) {\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logic_start;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logic_start)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid > logic_end) {\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (key.objectid >= logic_start + map->stripe_len)\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logic_start &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t  \"scrub: tree block %llu spanning stripes, ignored. logical=%llu\",\n\t\t\t\t\t   key.objectid, logic_start);\n\t\t\t\tgoto next;\n\t\t\t}\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\tif (extent_logical < logic_start) {\n\t\t\t\textent_len -= logic_start - extent_logical;\n\t\t\t\textent_logical = logic_start;\n\t\t\t}\n\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logic_start + map->stripe_len)\n\t\t\t\textent_len = logic_start + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\n\t\t\tscrub_parity_mark_sectors_data(sparity, extent_logical,\n\t\t\t\t\t\t       extent_len);\n\n\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root,\n\t\t\t\t\t\textent_logical,\n\t\t\t\t\t\textent_logical + extent_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent_for_parity(sparity, extent_logical,\n\t\t\t\t\t\t      extent_len,\n\t\t\t\t\t\t      extent_physical,\n\t\t\t\t\t\t      extent_dev, flags,\n\t\t\t\t\t\t      generation,\n\t\t\t\t\t\t      extent_mirror_num);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\t\tif (logic_start >= logic_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (logic_start < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\tif (stop_loop)\n\t\t\tbreak;\n\n\t\tlogic_start += map->stripe_len;\n\t}\nout:\n\tif (ret < 0)\n\t\tscrub_parity_mark_sectors_error(sparity, logic_start,\n\t\t\t\t\t\tlogic_end - logic_start + 1);\n\tscrub_parity_put(sparity);\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tbtrfs_release_path(path);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_raid56_parity(struct scrub_ctx *sctx,\n\t\t\t\t\t\t  struct map_lookup *map,\n\t\t\t\t\t\t  struct btrfs_device *sdev,\n\t\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t\t  u64 logic_start,\n\t\t\t\t\t\t  u64 logic_end)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 generation;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tstruct btrfs_device *extent_dev;\n\tstruct scrub_parity *sparity;\n\tint nsectors;\n\tint bitmap_len;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnsectors = map->stripe_len / root->sectorsize;\n\tbitmap_len = scrub_calc_parity_bitmap_len(nsectors);\n\tsparity = kzalloc(sizeof(struct scrub_parity) + 2 * bitmap_len,\n\t\t\t  GFP_NOFS);\n\tif (!sparity) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsparity->stripe_len = map->stripe_len;\n\tsparity->nsectors = nsectors;\n\tsparity->sctx = sctx;\n\tsparity->scrub_dev = sdev;\n\tsparity->logic_start = logic_start;\n\tsparity->logic_end = logic_end;\n\tatomic_set(&sparity->refs, 1);\n\tINIT_LIST_HEAD(&sparity->spages);\n\tsparity->dbitmap = sparity->bitmap;\n\tsparity->ebitmap = (void *)sparity->bitmap + bitmap_len;\n\n\tret = 0;\n\twhile (logic_start < logic_end) {\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logic_start;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logic_start)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid > logic_end) {\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (key.objectid >= logic_start + map->stripe_len)\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logic_start &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t  \"scrub: tree block %llu spanning stripes, ignored. logical=%llu\",\n\t\t\t\t\t   key.objectid, logic_start);\n\t\t\t\tgoto next;\n\t\t\t}\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\tif (extent_logical < logic_start) {\n\t\t\t\textent_len -= logic_start - extent_logical;\n\t\t\t\textent_logical = logic_start;\n\t\t\t}\n\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logic_start + map->stripe_len)\n\t\t\t\textent_len = logic_start + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\n\t\t\tscrub_parity_mark_sectors_data(sparity, extent_logical,\n\t\t\t\t\t\t       extent_len);\n\n\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root,\n\t\t\t\t\t\textent_logical,\n\t\t\t\t\t\textent_logical + extent_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent_for_parity(sparity, extent_logical,\n\t\t\t\t\t\t      extent_len,\n\t\t\t\t\t\t      extent_physical,\n\t\t\t\t\t\t      extent_dev, flags,\n\t\t\t\t\t\t      generation,\n\t\t\t\t\t\t      extent_mirror_num);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\t\tif (logic_start >= logic_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (logic_start < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\tif (stop_loop)\n\t\t\tbreak;\n\n\t\tlogic_start += map->stripe_len;\n\t}\nout:\n\tif (ret < 0)\n\t\tscrub_parity_mark_sectors_error(sparity, logic_start,\n\t\t\t\t\t\tlogic_end - logic_start + 1);\n\tscrub_parity_put(sparity);\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tbtrfs_release_path(path);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_raid56_logic_offset",
          "args": [
            "physical",
            "num",
            "map",
            "&logical",
            "&stripe_logical"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "get_raid56_logic_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2607-2643",
          "snippet": "static int get_raid56_logic_offset(u64 physical, int num,\n\t\t\t\t   struct map_lookup *map, u64 *offset,\n\t\t\t\t   u64 *stripe_start)\n{\n\tint i;\n\tint j = 0;\n\tu64 stripe_nr;\n\tu64 last_offset;\n\tint stripe_index;\n\tint rot;\n\n\tlast_offset = (physical - map->stripes[num].physical) *\n\t\t      nr_data_stripes(map);\n\tif (stripe_start)\n\t\t*stripe_start = last_offset;\n\n\t*offset = last_offset;\n\tfor (i = 0; i < nr_data_stripes(map); i++) {\n\t\t*offset = last_offset + i * map->stripe_len;\n\n\t\tstripe_nr = *offset;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\t\tdo_div(stripe_nr, nr_data_stripes(map));\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\trot = do_div(stripe_nr, map->num_stripes);\n\t\t/* calculate which stripe this data locates */\n\t\trot += i;\n\t\tstripe_index = rot % map->num_stripes;\n\t\tif (stripe_index == num)\n\t\t\treturn 0;\n\t\tif (stripe_index < num)\n\t\t\tj++;\n\t}\n\t*offset = last_offset + j * map->stripe_len;\n\treturn 1;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_raid56_logic_offset(u64 physical, int num,\n\t\t\t\t   struct map_lookup *map, u64 *offset,\n\t\t\t\t   u64 *stripe_start)\n{\n\tint i;\n\tint j = 0;\n\tu64 stripe_nr;\n\tu64 last_offset;\n\tint stripe_index;\n\tint rot;\n\n\tlast_offset = (physical - map->stripes[num].physical) *\n\t\t      nr_data_stripes(map);\n\tif (stripe_start)\n\t\t*stripe_start = last_offset;\n\n\t*offset = last_offset;\n\tfor (i = 0; i < nr_data_stripes(map); i++) {\n\t\t*offset = last_offset + i * map->stripe_len;\n\n\t\tstripe_nr = *offset;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\t\tdo_div(stripe_nr, nr_data_stripes(map));\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\trot = do_div(stripe_nr, map->num_stripes);\n\t\t/* calculate which stripe this data locates */\n\t\trot += i;\n\t\tstripe_index = rot % map->num_stripes;\n\t\tif (stripe_index == num)\n\t\t\treturn 0;\n\t\tif (stripe_index < num)\n\t\t\tj++;\n\t}\n\t*offset = last_offset + j * map->stripe_len;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_free_csums",
          "args": [
            "sctx"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_csums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "402-411",
          "snippet": "static void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_extent",
          "args": [
            "sctx",
            "extent_logical",
            "extent_len",
            "extent_physical",
            "extent_dev",
            "flags",
            "generation",
            "extent_mirror_num",
            "extent_logical - logical + physical"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2419-2472",
          "snippet": "static int scrub_extent(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\tu64 physical, struct btrfs_device *dev, u64 flags,\n\t\t\tu64 gen, int mirror_num, u64 physical_for_dev_replace)\n{\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.data_extents_scrubbed++;\n\t\tsctx->stat.data_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.tree_extents_scrubbed++;\n\t\tsctx->stat.tree_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\t++sctx->stat.no_csum;\n\t\t\tif (sctx->is_dev_replace && !have_csum) {\n\t\t\t\tret = copy_nocow_pages(sctx, logical, l,\n\t\t\t\t\t\t       mirror_num,\n\t\t\t\t\t\t      physical_for_dev_replace);\n\t\t\t\tgoto behind_scrub_pages;\n\t\t\t}\n\t\t}\n\t\tret = scrub_pages(sctx, logical, l, physical, dev, flags, gen,\n\t\t\t\t  mirror_num, have_csum ? csum : NULL, 0,\n\t\t\t\t  physical_for_dev_replace);\nbehind_scrub_pages:\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_extent(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\tu64 physical, struct btrfs_device *dev, u64 flags,\n\t\t\tu64 gen, int mirror_num, u64 physical_for_dev_replace)\n{\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.data_extents_scrubbed++;\n\t\tsctx->stat.data_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.tree_extents_scrubbed++;\n\t\tsctx->stat.tree_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\t++sctx->stat.no_csum;\n\t\t\tif (sctx->is_dev_replace && !have_csum) {\n\t\t\t\tret = copy_nocow_pages(sctx, logical, l,\n\t\t\t\t\t\t       mirror_num,\n\t\t\t\t\t\t      physical_for_dev_replace);\n\t\t\t\tgoto behind_scrub_pages;\n\t\t\t}\n\t\t}\n\t\tret = scrub_pages(sctx, logical, l, physical, dev, flags, gen,\n\t\t\t\t  mirror_num, have_csum ? csum : NULL, 0,\n\t\t\t\t  physical_for_dev_replace);\nbehind_scrub_pages:\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "csum_root",
            "logical",
            "logical + map->stripe_len - 1",
            "&sctx->csum_list",
            "1"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_remap_extent",
          "args": [
            "fs_info",
            "extent_logical",
            "extent_len",
            "&extent_physical",
            "&extent_dev",
            "&extent_mirror_num"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_remap_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3842-3865",
          "snippet": "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: tree block %llu spanning \"\n\t\t\t\t\t   \"stripes, ignored. logical=%llu\"",
            "key.objectid",
            "logical"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_generation",
          "args": [
            "l",
            "extent"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "l",
            "extent"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_extent_item"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "slot"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_extent_item",
          "args": [
            "root",
            "path",
            "0"
          ],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_extent_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5873-5908",
          "snippet": "int btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "fs_info",
            "SKINNY_METADATA"
          ],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_blocked_if_needed",
          "args": [
            "fs_info"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_blocked_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "335-346",
          "snippet": "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\tatomic_inc(&fs_info->scrubs_paused);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tmutex_lock(&fs_info->scrub_lock);\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\twake_up(&fs_info->scrub_pause_wait);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\tatomic_inc(&fs_info->scrubs_paused);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tmutex_lock(&fs_info->scrub_lock);\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\twake_up(&fs_info->scrub_pause_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->wr_ctx.flush_all_writes",
            "0"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->bios_in_flight) == 0"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->wr_ctx.flush_all_writes",
            "1"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrub_pause_req"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->cancel_req"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrub_cancel_req"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_reada_wait",
          "args": [
            "reada2"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_reada_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "973-984",
          "snippet": "int btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event(rc->wait, atomic_read(&rc->elems) == 0);\n\t}\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nint btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event(rc->wait, atomic_read(&rc->elems) == 0);\n\t}\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reada2"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reada1"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_reada_add",
          "args": [
            "csum_root",
            "&key_start",
            "&key_end"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_reada_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "912-952",
          "snippet": "struct reada_control *btrfs_reada_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_key *key_start, struct btrfs_key *key_end)\n{\n\tstruct reada_control *rc;\n\tu64 start;\n\tu64 generation;\n\tint level;\n\tstruct extent_buffer *node;\n\tstatic struct btrfs_key max_key = {\n\t\t.objectid = (u64)-1,\n\t\t.type = (u8)-1,\n\t\t.offset = (u64)-1\n\t};\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc->root = root;\n\trc->key_start = *key_start;\n\trc->key_end = *key_end;\n\tatomic_set(&rc->elems, 0);\n\tinit_waitqueue_head(&rc->wait);\n\tkref_init(&rc->refcnt);\n\tkref_get(&rc->refcnt); /* one ref for having elements */\n\n\tnode = btrfs_root_node(root);\n\tstart = node->start;\n\tlevel = btrfs_header_level(node);\n\tgeneration = btrfs_header_generation(node);\n\tfree_extent_buffer(node);\n\n\tif (reada_add_block(rc, start, &max_key, level, generation)) {\n\t\tkfree(rc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treada_start_machine(root->fs_info);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstruct reada_control *btrfs_reada_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_key *key_start, struct btrfs_key *key_end)\n{\n\tstruct reada_control *rc;\n\tu64 start;\n\tu64 generation;\n\tint level;\n\tstruct extent_buffer *node;\n\tstatic struct btrfs_key max_key = {\n\t\t.objectid = (u64)-1,\n\t\t.type = (u8)-1,\n\t\t.offset = (u64)-1\n\t};\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc->root = root;\n\trc->key_start = *key_start;\n\trc->key_end = *key_end;\n\tatomic_set(&rc->elems, 0);\n\tinit_waitqueue_head(&rc->wait);\n\tkref_init(&rc->refcnt);\n\tkref_get(&rc->refcnt); /* one ref for having elements */\n\n\tnode = btrfs_root_node(root);\n\tstart = node->start;\n\tlevel = btrfs_header_level(node);\n\tgeneration = btrfs_header_generation(node);\n\tfree_extent_buffer(node);\n\n\tif (reada_add_block(rc, start, &max_key, level, generation)) {\n\t\tkfree(rc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treada_start_machine(root->fs_info);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "atomic_read(&sctx->bios_in_flight) == 0"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_data_stripes",
          "args": [
            "map"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "nr_data_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "32-35",
          "snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nstripes",
            "map->stripe_len"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,\n\t\t\t\t\t   struct map_lookup *map,\n\t\t\t\t\t   struct btrfs_device *scrub_dev,\n\t\t\t\t\t   int num, u64 base, u64 length,\n\t\t\t\t\t   int is_dev_replace)\n{\n\tstruct btrfs_path *path, *ppath;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tstruct blk_plug plug;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tu64 nstripes;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 physical;\n\tu64 logical;\n\tu64 logic_end;\n\tu64 physical_end;\n\tu64 generation;\n\tint mirror_num;\n\tstruct reada_control *reada1;\n\tstruct reada_control *reada2;\n\tstruct btrfs_key key_start;\n\tstruct btrfs_key key_end;\n\tu64 increment = map->stripe_len;\n\tu64 offset;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tu64 stripe_logical;\n\tu64 stripe_end;\n\tstruct btrfs_device *extent_dev;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnstripes = length;\n\tphysical = map->stripes[num].physical;\n\toffset = 0;\n\tdo_div(nstripes, map->stripe_len);\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\toffset = map->stripe_len * num;\n\t\tincrement = map->stripe_len * map->num_stripes;\n\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\t\toffset = map->stripe_len * (num / map->sub_stripes);\n\t\tincrement = map->stripe_len * factor;\n\t\tmirror_num = num % map->sub_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = num % map->num_stripes + 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical, num, map, &offset, NULL);\n\t\tincrement = map->stripe_len * nr_data_stripes(map);\n\t\tmirror_num = 1;\n\t} else {\n\t\tincrement = map->stripe_len;\n\t\tmirror_num = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tppath = btrfs_alloc_path();\n\tif (!ppath) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * work on commit root. The related disk blocks are static as\n\t * long as COW is applied. This means, it is save to rewrite\n\t * them to repair disk errors without any race conditions\n\t */\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tppath->search_commit_root = 1;\n\tppath->skip_locking = 1;\n\t/*\n\t * trigger the readahead for extent tree csum tree and wait for\n\t * completion. During readahead, the scrub is officially paused\n\t * to not hold off transaction commits\n\t */\n\tlogical = base + offset;\n\tphysical_end = physical + nstripes * map->stripe_len;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tget_raid56_logic_offset(physical_end, num,\n\t\t\t\t\tmap, &logic_end, NULL);\n\t\tlogic_end += base;\n\t} else {\n\t\tlogic_end = logical + increment * nstripes;\n\t}\n\twait_event(sctx->list_wait,\n\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\tscrub_blocked_if_needed(fs_info);\n\n\t/* FIXME it might be better to start readahead at commit root */\n\tkey_start.objectid = logical;\n\tkey_start.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey_start.offset = (u64)0;\n\tkey_end.objectid = logic_end;\n\tkey_end.type = BTRFS_METADATA_ITEM_KEY;\n\tkey_end.offset = (u64)-1;\n\treada1 = btrfs_reada_add(root, &key_start, &key_end);\n\n\tkey_start.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_start.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_start.offset = logical;\n\tkey_end.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey_end.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey_end.offset = logic_end;\n\treada2 = btrfs_reada_add(csum_root, &key_start, &key_end);\n\n\tif (!IS_ERR(reada1))\n\t\tbtrfs_reada_wait(reada1);\n\tif (!IS_ERR(reada2))\n\t\tbtrfs_reada_wait(reada2);\n\n\n\t/*\n\t * collect all data csums for the stripe to avoid seeking during\n\t * the scrub. This might currently (crc32) end up to be about 1MB\n\t */\n\tblk_start_plug(&plug);\n\n\t/*\n\t * now find all extents for each stripe and scrub them\n\t */\n\tret = 0;\n\twhile (physical < physical_end) {\n\t\t/* for raid56, we skip parity stripe */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = get_raid56_logic_offset(physical, num,\n\t\t\t\t\tmap, &logical, &stripe_logical);\n\t\t\tlogical += base;\n\t\t\tif (ret) {\n\t\t\t\tstripe_logical += base;\n\t\t\t\tstripe_end = stripe_logical + increment - 1;\n\t\t\t\tret = scrub_raid56_parity(sctx, map, scrub_dev,\n\t\t\t\t\t\tppath, stripe_logical,\n\t\t\t\t\t\tstripe_end);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * canceled?\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_cancel_req) ||\n\t\t    atomic_read(&sctx->cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * check to see if we have to pause\n\t\t */\n\t\tif (atomic_read(&fs_info->scrub_pause_req)) {\n\t\t\t/* push queued extents */\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 1);\n\t\t\tscrub_submit(sctx);\n\t\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\t\tscrub_wr_submit(sctx);\n\t\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t\t\twait_event(sctx->list_wait,\n\t\t\t\t   atomic_read(&sctx->bios_in_flight) == 0);\n\t\t\tatomic_set(&sctx->wr_ctx.flush_all_writes, 0);\n\t\t\tscrub_blocked_if_needed(fs_info);\n\t\t}\n\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logical;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\t/* there's no smaller item, so stick with the\n\t\t\t\t * larger one */\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logical)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid >= logical + map->stripe_len) {\n\t\t\t\t/* out of this device extent */\n\t\t\t\tif (key.objectid >= logic_end)\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logical &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t   \"scrub: tree block %llu spanning \"\n\t\t\t\t\t   \"stripes, ignored. logical=%llu\",\n\t\t\t\t       key.objectid, logical);\n\t\t\t\tgoto next;\n\t\t\t}\n\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\t/*\n\t\t\t * trim extent to this stripe\n\t\t\t */\n\t\t\tif (extent_logical < logical) {\n\t\t\t\textent_len -= logical - extent_logical;\n\t\t\t\textent_logical = logical;\n\t\t\t}\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logical + map->stripe_len) {\n\t\t\t\textent_len = logical + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\t\t\t}\n\n\t\t\textent_physical = extent_logical - logical + physical;\n\t\t\textent_dev = scrub_dev;\n\t\t\textent_mirror_num = mirror_num;\n\t\t\tif (is_dev_replace)\n\t\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root, logical,\n\t\t\t\t\t\tlogical + map->stripe_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent(sctx, extent_logical, extent_len,\n\t\t\t\t\t   extent_physical, extent_dev, flags,\n\t\t\t\t\t   generation, extent_mirror_num,\n\t\t\t\t\t   extent_logical - logical + physical);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * loop until we find next data stripe\n\t\t\t\t\t * or we have finished all stripes.\n\t\t\t\t\t */\nloop:\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tret = get_raid56_logic_offset(physical,\n\t\t\t\t\t\t\tnum, map, &logical,\n\t\t\t\t\t\t\t&stripe_logical);\n\t\t\t\t\tlogical += base;\n\n\t\t\t\t\tif (ret && physical < physical_end) {\n\t\t\t\t\t\tstripe_logical += base;\n\t\t\t\t\t\tstripe_end = stripe_logical +\n\t\t\t\t\t\t\t\tincrement - 1;\n\t\t\t\t\t\tret = scrub_raid56_parity(sctx,\n\t\t\t\t\t\t\tmap, scrub_dev, ppath,\n\t\t\t\t\t\t\tstripe_logical,\n\t\t\t\t\t\t\tstripe_end);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tgoto loop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphysical += map->stripe_len;\n\t\t\t\t\tlogical += increment;\n\t\t\t\t}\n\t\t\t\tif (logical < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tif (physical >= physical_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_release_path(path);\nskip:\n\t\tlogical += increment;\n\t\tphysical += map->stripe_len;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tsctx->stat.last_physical = map->stripes[num].physical +\n\t\t\t\t\t\t   length;\n\t\telse\n\t\t\tsctx->stat.last_physical = physical;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (stop_loop)\n\t\t\tbreak;\n\t}\nout:\n\t/* push queued extents */\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tblk_finish_plug(&plug);\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(ppath);\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "scrub_raid56_parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2756-2957",
    "snippet": "static noinline_for_stack int scrub_raid56_parity(struct scrub_ctx *sctx,\n\t\t\t\t\t\t  struct map_lookup *map,\n\t\t\t\t\t\t  struct btrfs_device *sdev,\n\t\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t\t  u64 logic_start,\n\t\t\t\t\t\t  u64 logic_end)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 generation;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tstruct btrfs_device *extent_dev;\n\tstruct scrub_parity *sparity;\n\tint nsectors;\n\tint bitmap_len;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnsectors = map->stripe_len / root->sectorsize;\n\tbitmap_len = scrub_calc_parity_bitmap_len(nsectors);\n\tsparity = kzalloc(sizeof(struct scrub_parity) + 2 * bitmap_len,\n\t\t\t  GFP_NOFS);\n\tif (!sparity) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsparity->stripe_len = map->stripe_len;\n\tsparity->nsectors = nsectors;\n\tsparity->sctx = sctx;\n\tsparity->scrub_dev = sdev;\n\tsparity->logic_start = logic_start;\n\tsparity->logic_end = logic_end;\n\tatomic_set(&sparity->refs, 1);\n\tINIT_LIST_HEAD(&sparity->spages);\n\tsparity->dbitmap = sparity->bitmap;\n\tsparity->ebitmap = (void *)sparity->bitmap + bitmap_len;\n\n\tret = 0;\n\twhile (logic_start < logic_end) {\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logic_start;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logic_start)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid > logic_end) {\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (key.objectid >= logic_start + map->stripe_len)\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logic_start &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t  \"scrub: tree block %llu spanning stripes, ignored. logical=%llu\",\n\t\t\t\t\t   key.objectid, logic_start);\n\t\t\t\tgoto next;\n\t\t\t}\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\tif (extent_logical < logic_start) {\n\t\t\t\textent_len -= logic_start - extent_logical;\n\t\t\t\textent_logical = logic_start;\n\t\t\t}\n\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logic_start + map->stripe_len)\n\t\t\t\textent_len = logic_start + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\n\t\t\tscrub_parity_mark_sectors_data(sparity, extent_logical,\n\t\t\t\t\t\t       extent_len);\n\n\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root,\n\t\t\t\t\t\textent_logical,\n\t\t\t\t\t\textent_logical + extent_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent_for_parity(sparity, extent_logical,\n\t\t\t\t\t\t      extent_len,\n\t\t\t\t\t\t      extent_physical,\n\t\t\t\t\t\t      extent_dev, flags,\n\t\t\t\t\t\t      generation,\n\t\t\t\t\t\t      extent_mirror_num);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\t\tif (logic_start >= logic_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (logic_start < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\tif (stop_loop)\n\t\t\tbreak;\n\n\t\tlogic_start += map->stripe_len;\n\t}\nout:\n\tif (ret < 0)\n\t\tscrub_parity_mark_sectors_error(sparity, logic_start,\n\t\t\t\t\t\tlogic_end - logic_start + 1);\n\tscrub_parity_put(sparity);\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tbtrfs_release_path(path);\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_wr_submit",
          "args": [
            "sctx"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_wr_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1775-1792",
          "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_submit",
          "args": [
            "sctx"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2081-2106",
          "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_parity_put",
          "args": [
            "sparity"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2748-2754",
          "snippet": "static void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_parity_mark_sectors_error",
          "args": [
            "sparity",
            "logic_start",
            "logic_end - logic_start + 1"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_mark_sectors_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2345-2349",
          "snippet": "static inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_free_csums",
          "args": [
            "sctx"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_csums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "402-411",
          "snippet": "static void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_extent_for_parity",
          "args": [
            "sparity",
            "extent_logical",
            "extent_len",
            "extent_physical",
            "extent_dev",
            "flags",
            "generation",
            "extent_mirror_num"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_extent_for_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2558-2598",
          "snippet": "static int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "csum_root",
            "extent_logical",
            "extent_logical + extent_len - 1",
            "&sctx->csum_list",
            "1"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_remap_extent",
          "args": [
            "fs_info",
            "extent_logical",
            "extent_len",
            "&extent_physical",
            "&extent_dev",
            "&extent_mirror_num"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_remap_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3842-3865",
          "snippet": "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num)\n{\n\tu64 mapped_length;\n\tstruct btrfs_bio *bbio = NULL;\n\tint ret;\n\n\tmapped_length = extent_len;\n\tret = btrfs_map_block(fs_info, READ, extent_logical,\n\t\t\t      &mapped_length, &bbio, 0);\n\tif (ret || !bbio || mapped_length < extent_len ||\n\t    !bbio->stripes[0].dev->bdev) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn;\n\t}\n\n\t*extent_physical = bbio->stripes[0].physical;\n\t*extent_mirror_num = bbio->mirror_num;\n\t*extent_dev = bbio->stripes[0].dev;\n\tbtrfs_put_bbio(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_parity_mark_sectors_data",
          "args": [
            "sparity",
            "extent_logical",
            "extent_len"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_mark_sectors_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2351-2355",
          "snippet": "static inline void scrub_parity_mark_sectors_data(struct scrub_parity *sparity,\n\t\t\t\t\t\t  u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->dbitmap, start, len);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_parity_mark_sectors_data(struct scrub_parity *sparity,\n\t\t\t\t\t\t  u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->dbitmap, start, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"scrub: tree block %llu spanning stripes, ignored. logical=%llu\"",
            "key.objectid",
            "logic_start"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_generation",
          "args": [
            "l",
            "extent"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "l",
            "extent"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_extent_item"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "slot"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_extent_item",
          "args": [
            "root",
            "path",
            "0"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_extent_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5873-5908",
          "snippet": "int btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "fs_info",
            "SKINNY_METADATA"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sparity->spages"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sparity->refs",
            "1"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct scrub_parity) + 2 * bitmap_len",
            "GFP_NOFS"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_calc_parity_bitmap_len",
          "args": [
            "nsectors"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_calc_parity_bitmap_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2738-2741",
          "snippet": "static inline int scrub_calc_parity_bitmap_len(int nsectors)\n{\n\treturn DIV_ROUND_UP(nsectors, BITS_PER_LONG) * (BITS_PER_LONG / 8);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic inline int scrub_calc_parity_bitmap_len(int nsectors)\n{\n\treturn DIV_ROUND_UP(nsectors, BITS_PER_LONG) * (BITS_PER_LONG / 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_remap_extent(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 extent_logical, u64 extent_len,\n\t\t\t       u64 *extent_physical,\n\t\t\t       struct btrfs_device **extent_dev,\n\t\t\t       int *extent_mirror_num);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int scrub_raid56_parity(struct scrub_ctx *sctx,\n\t\t\t\t\t\t  struct map_lookup *map,\n\t\t\t\t\t\t  struct btrfs_device *sdev,\n\t\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t\t  u64 logic_start,\n\t\t\t\t\t\t  u64 logic_end)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_root *csum_root = fs_info->csum_root;\n\tstruct btrfs_extent_item *extent;\n\tu64 flags;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tu64 generation;\n\tu64 extent_logical;\n\tu64 extent_physical;\n\tu64 extent_len;\n\tstruct btrfs_device *extent_dev;\n\tstruct scrub_parity *sparity;\n\tint nsectors;\n\tint bitmap_len;\n\tint extent_mirror_num;\n\tint stop_loop = 0;\n\n\tnsectors = map->stripe_len / root->sectorsize;\n\tbitmap_len = scrub_calc_parity_bitmap_len(nsectors);\n\tsparity = kzalloc(sizeof(struct scrub_parity) + 2 * bitmap_len,\n\t\t\t  GFP_NOFS);\n\tif (!sparity) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsparity->stripe_len = map->stripe_len;\n\tsparity->nsectors = nsectors;\n\tsparity->sctx = sctx;\n\tsparity->scrub_dev = sdev;\n\tsparity->logic_start = logic_start;\n\tsparity->logic_end = logic_end;\n\tatomic_set(&sparity->refs, 1);\n\tINIT_LIST_HEAD(&sparity->spages);\n\tsparity->dbitmap = sparity->bitmap;\n\tsparity->ebitmap = (void *)sparity->bitmap + bitmap_len;\n\n\tret = 0;\n\twhile (logic_start < logic_end) {\n\t\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\telse\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.objectid = logic_start;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret > 0) {\n\t\t\tret = btrfs_previous_extent_item(root, path, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_search_slot(NULL, root, &key,\n\t\t\t\t\t\t\tpath, 0, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tstop_loop = 0;\n\t\twhile (1) {\n\t\t\tu64 bytes;\n\n\t\t\tl = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tbytes = root->nodesize;\n\t\t\telse\n\t\t\t\tbytes = key.offset;\n\n\t\t\tif (key.objectid + bytes <= logic_start)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tgoto next;\n\n\t\t\tif (key.objectid > logic_end) {\n\t\t\t\tstop_loop = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (key.objectid >= logic_start + map->stripe_len)\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\textent = btrfs_item_ptr(l, slot,\n\t\t\t\t\t\tstruct btrfs_extent_item);\n\t\t\tflags = btrfs_extent_flags(l, extent);\n\t\t\tgeneration = btrfs_extent_generation(l, extent);\n\n\t\t\tif (key.objectid < logic_start &&\n\t\t\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t  \"scrub: tree block %llu spanning stripes, ignored. logical=%llu\",\n\t\t\t\t\t   key.objectid, logic_start);\n\t\t\t\tgoto next;\n\t\t\t}\nagain:\n\t\t\textent_logical = key.objectid;\n\t\t\textent_len = bytes;\n\n\t\t\tif (extent_logical < logic_start) {\n\t\t\t\textent_len -= logic_start - extent_logical;\n\t\t\t\textent_logical = logic_start;\n\t\t\t}\n\n\t\t\tif (extent_logical + extent_len >\n\t\t\t    logic_start + map->stripe_len)\n\t\t\t\textent_len = logic_start + map->stripe_len -\n\t\t\t\t\t     extent_logical;\n\n\t\t\tscrub_parity_mark_sectors_data(sparity, extent_logical,\n\t\t\t\t\t\t       extent_len);\n\n\t\t\tscrub_remap_extent(fs_info, extent_logical,\n\t\t\t\t\t   extent_len, &extent_physical,\n\t\t\t\t\t   &extent_dev,\n\t\t\t\t\t   &extent_mirror_num);\n\n\t\t\tret = btrfs_lookup_csums_range(csum_root,\n\t\t\t\t\t\textent_logical,\n\t\t\t\t\t\textent_logical + extent_len - 1,\n\t\t\t\t\t\t&sctx->csum_list, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = scrub_extent_for_parity(sparity, extent_logical,\n\t\t\t\t\t\t      extent_len,\n\t\t\t\t\t\t      extent_physical,\n\t\t\t\t\t\t      extent_dev, flags,\n\t\t\t\t\t\t      generation,\n\t\t\t\t\t\t      extent_mirror_num);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tscrub_free_csums(sctx);\n\t\t\tif (extent_logical + extent_len <\n\t\t\t    key.objectid + bytes) {\n\t\t\t\tlogic_start += map->stripe_len;\n\n\t\t\t\tif (logic_start >= logic_end) {\n\t\t\t\t\tstop_loop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (logic_start < key.objectid + bytes) {\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tpath->slots[0]++;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\tif (stop_loop)\n\t\t\tbreak;\n\n\t\tlogic_start += map->stripe_len;\n\t}\nout:\n\tif (ret < 0)\n\t\tscrub_parity_mark_sectors_error(sparity, logic_start,\n\t\t\t\t\t\tlogic_end - logic_start + 1);\n\tscrub_parity_put(sparity);\n\tscrub_submit(sctx);\n\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\tscrub_wr_submit(sctx);\n\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\n\tbtrfs_release_path(path);\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "scrub_parity_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2748-2754",
    "snippet": "static void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_parity_check_and_repair",
          "args": [
            "sparity"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_check_and_repair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2681-2736",
          "snippet": "static void scrub_parity_check_and_repair(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct bio *bio;\n\tstruct btrfs_raid_bio *rbio;\n\tstruct scrub_page *spage;\n\tstruct btrfs_bio *bbio = NULL;\n\tu64 length;\n\tint ret;\n\n\tif (!bitmap_andnot(sparity->dbitmap, sparity->dbitmap, sparity->ebitmap,\n\t\t\t   sparity->nsectors))\n\t\tgoto out;\n\n\tlength = sparity->logic_end - sparity->logic_start + 1;\n\tret = btrfs_map_sblock(sctx->dev_root->fs_info, WRITE,\n\t\t\t       sparity->logic_start,\n\t\t\t       &length, &bbio, 0, 1);\n\tif (ret || !bbio || !bbio->raid_map)\n\t\tgoto bbio_out;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\tgoto bbio_out;\n\n\tbio->bi_iter.bi_sector = sparity->logic_start >> 9;\n\tbio->bi_private = sparity;\n\tbio->bi_end_io = scrub_parity_bio_endio;\n\n\trbio = raid56_parity_alloc_scrub_rbio(sctx->dev_root, bio, bbio,\n\t\t\t\t\t      length, sparity->scrub_dev,\n\t\t\t\t\t      sparity->dbitmap,\n\t\t\t\t\t      sparity->nsectors);\n\tif (!rbio)\n\t\tgoto rbio_out;\n\n\tlist_for_each_entry(spage, &sparity->spages, list)\n\t\traid56_parity_add_scrub_pages(rbio, spage->page,\n\t\t\t\t\t      spage->logical);\n\n\tscrub_pending_bio_inc(sctx);\n\traid56_parity_submit_scrub_rbio(rbio);\n\treturn;\n\nrbio_out:\n\tbio_put(bio);\nbbio_out:\n\tbtrfs_put_bbio(bbio);\n\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t  sparity->nsectors);\n\tspin_lock(&sctx->stat_lock);\n\tsctx->stat.malloc_errors++;\n\tspin_unlock(&sctx->stat_lock);\nout:\n\tscrub_free_parity(sparity);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_check_and_repair(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct bio *bio;\n\tstruct btrfs_raid_bio *rbio;\n\tstruct scrub_page *spage;\n\tstruct btrfs_bio *bbio = NULL;\n\tu64 length;\n\tint ret;\n\n\tif (!bitmap_andnot(sparity->dbitmap, sparity->dbitmap, sparity->ebitmap,\n\t\t\t   sparity->nsectors))\n\t\tgoto out;\n\n\tlength = sparity->logic_end - sparity->logic_start + 1;\n\tret = btrfs_map_sblock(sctx->dev_root->fs_info, WRITE,\n\t\t\t       sparity->logic_start,\n\t\t\t       &length, &bbio, 0, 1);\n\tif (ret || !bbio || !bbio->raid_map)\n\t\tgoto bbio_out;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\tgoto bbio_out;\n\n\tbio->bi_iter.bi_sector = sparity->logic_start >> 9;\n\tbio->bi_private = sparity;\n\tbio->bi_end_io = scrub_parity_bio_endio;\n\n\trbio = raid56_parity_alloc_scrub_rbio(sctx->dev_root, bio, bbio,\n\t\t\t\t\t      length, sparity->scrub_dev,\n\t\t\t\t\t      sparity->dbitmap,\n\t\t\t\t\t      sparity->nsectors);\n\tif (!rbio)\n\t\tgoto rbio_out;\n\n\tlist_for_each_entry(spage, &sparity->spages, list)\n\t\traid56_parity_add_scrub_pages(rbio, spage->page,\n\t\t\t\t\t      spage->logical);\n\n\tscrub_pending_bio_inc(sctx);\n\traid56_parity_submit_scrub_rbio(rbio);\n\treturn;\n\nrbio_out:\n\tbio_put(bio);\nbbio_out:\n\tbtrfs_put_bbio(bbio);\n\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t  sparity->nsectors);\n\tspin_lock(&sctx->stat_lock);\n\tsctx->stat.malloc_errors++;\n\tspin_unlock(&sctx->stat_lock);\nout:\n\tscrub_free_parity(sparity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sparity->refs"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}"
  },
  {
    "function_name": "scrub_parity_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2743-2746",
    "snippet": "static void scrub_parity_get(struct scrub_parity *sparity)\n{\n\tatomic_inc(&sparity->refs);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sparity->refs"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_get(struct scrub_parity *sparity)\n{\n\tatomic_inc(&sparity->refs);\n}"
  },
  {
    "function_name": "scrub_calc_parity_bitmap_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2738-2741",
    "snippet": "static inline int scrub_calc_parity_bitmap_len(int nsectors)\n{\n\treturn DIV_ROUND_UP(nsectors, BITS_PER_LONG) * (BITS_PER_LONG / 8);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nsectors",
            "BITS_PER_LONG"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic inline int scrub_calc_parity_bitmap_len(int nsectors)\n{\n\treturn DIV_ROUND_UP(nsectors, BITS_PER_LONG) * (BITS_PER_LONG / 8);\n}"
  },
  {
    "function_name": "scrub_parity_check_and_repair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2681-2736",
    "snippet": "static void scrub_parity_check_and_repair(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct bio *bio;\n\tstruct btrfs_raid_bio *rbio;\n\tstruct scrub_page *spage;\n\tstruct btrfs_bio *bbio = NULL;\n\tu64 length;\n\tint ret;\n\n\tif (!bitmap_andnot(sparity->dbitmap, sparity->dbitmap, sparity->ebitmap,\n\t\t\t   sparity->nsectors))\n\t\tgoto out;\n\n\tlength = sparity->logic_end - sparity->logic_start + 1;\n\tret = btrfs_map_sblock(sctx->dev_root->fs_info, WRITE,\n\t\t\t       sparity->logic_start,\n\t\t\t       &length, &bbio, 0, 1);\n\tif (ret || !bbio || !bbio->raid_map)\n\t\tgoto bbio_out;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\tgoto bbio_out;\n\n\tbio->bi_iter.bi_sector = sparity->logic_start >> 9;\n\tbio->bi_private = sparity;\n\tbio->bi_end_io = scrub_parity_bio_endio;\n\n\trbio = raid56_parity_alloc_scrub_rbio(sctx->dev_root, bio, bbio,\n\t\t\t\t\t      length, sparity->scrub_dev,\n\t\t\t\t\t      sparity->dbitmap,\n\t\t\t\t\t      sparity->nsectors);\n\tif (!rbio)\n\t\tgoto rbio_out;\n\n\tlist_for_each_entry(spage, &sparity->spages, list)\n\t\traid56_parity_add_scrub_pages(rbio, spage->page,\n\t\t\t\t\t      spage->logical);\n\n\tscrub_pending_bio_inc(sctx);\n\traid56_parity_submit_scrub_rbio(rbio);\n\treturn;\n\nrbio_out:\n\tbio_put(bio);\nbbio_out:\n\tbtrfs_put_bbio(bbio);\n\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t  sparity->nsectors);\n\tspin_lock(&sctx->stat_lock);\n\tsctx->stat.malloc_errors++;\n\tspin_unlock(&sctx->stat_lock);\nout:\n\tscrub_free_parity(sparity);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_free_parity",
          "args": [
            "sparity"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2645-2665",
          "snippet": "static void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_or",
          "args": [
            "sparity->ebitmap",
            "sparity->ebitmap",
            "sparity->dbitmap",
            "sparity->nsectors"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid56_parity_submit_scrub_rbio",
          "args": [
            "rbio"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_submit_scrub_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2674-2678",
          "snippet": "void raid56_parity_submit_scrub_rbio(struct btrfs_raid_bio *rbio)\n{\n\tif (!lock_stripe_add(rbio))\n\t\tasync_scrub_parity(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nvoid raid56_parity_submit_scrub_rbio(struct btrfs_raid_bio *rbio)\n{\n\tif (!lock_stripe_add(rbio))\n\t\tasync_scrub_parity(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_pending_bio_inc",
          "args": [
            "sctx"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "312-316",
          "snippet": "static void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raid56_parity_add_scrub_pages",
          "args": [
            "rbio",
            "spage->page",
            "spage->logical"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_add_scrub_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2243-2255",
          "snippet": "void raid56_parity_add_scrub_pages(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct page *page, u64 logical)\n{\n\tint stripe_offset;\n\tint index;\n\n\tASSERT(logical >= rbio->bbio->raid_map[0]);\n\tASSERT(logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\n\t\t\t\trbio->stripe_len * rbio->nr_data);\n\tstripe_offset = (int)(logical - rbio->bbio->raid_map[0]);\n\tindex = stripe_offset >> PAGE_CACHE_SHIFT;\n\trbio->bio_pages[index] = page;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nvoid raid56_parity_add_scrub_pages(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct page *page, u64 logical)\n{\n\tint stripe_offset;\n\tint index;\n\n\tASSERT(logical >= rbio->bbio->raid_map[0]);\n\tASSERT(logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\n\t\t\t\trbio->stripe_len * rbio->nr_data);\n\tstripe_offset = (int)(logical - rbio->bbio->raid_map[0]);\n\tindex = stripe_offset >> PAGE_CACHE_SHIFT;\n\trbio->bio_pages[index] = page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "spage",
            "&sparity->spages",
            "list"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid56_parity_alloc_scrub_rbio",
          "args": [
            "sctx->dev_root",
            "bio",
            "bbio",
            "length",
            "sparity->scrub_dev",
            "sparity->dbitmap",
            "sparity->nsectors"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_alloc_scrub_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2208-2241",
          "snippet": "struct btrfs_raid_bio *\nraid56_parity_alloc_scrub_rbio(struct btrfs_root *root, struct bio *bio,\n\t\t\t       struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t       struct btrfs_device *scrub_dev,\n\t\t\t       unsigned long *dbitmap, int stripe_nsectors)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint i;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio))\n\t\treturn NULL;\n\tbio_list_add(&rbio->bio_list, bio);\n\t/*\n\t * This is a special bio which is used to hold the completion handler\n\t * and make the scrub rbio is similar to the other types\n\t */\n\tASSERT(!bio->bi_iter.bi_size);\n\trbio->operation = BTRFS_RBIO_PARITY_SCRUB;\n\n\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\tif (bbio->stripes[i].dev == scrub_dev) {\n\t\t\trbio->scrubp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now we just support the sectorsize equals to page size */\n\tASSERT(root->sectorsize == PAGE_SIZE);\n\tASSERT(rbio->stripe_npages == stripe_nsectors);\n\tbitmap_copy(rbio->dbitmap, dbitmap, stripe_nsectors);\n\n\treturn rbio;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstruct btrfs_raid_bio *\nraid56_parity_alloc_scrub_rbio(struct btrfs_root *root, struct bio *bio,\n\t\t\t       struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t       struct btrfs_device *scrub_dev,\n\t\t\t       unsigned long *dbitmap, int stripe_nsectors)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint i;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio))\n\t\treturn NULL;\n\tbio_list_add(&rbio->bio_list, bio);\n\t/*\n\t * This is a special bio which is used to hold the completion handler\n\t * and make the scrub rbio is similar to the other types\n\t */\n\tASSERT(!bio->bi_iter.bi_size);\n\trbio->operation = BTRFS_RBIO_PARITY_SCRUB;\n\n\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\tif (bbio->stripes[i].dev == scrub_dev) {\n\t\t\trbio->scrubp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now we just support the sectorsize equals to page size */\n\tASSERT(root->sectorsize == PAGE_SIZE);\n\tASSERT(rbio->stripe_npages == stripe_nsectors);\n\tbitmap_copy(rbio->dbitmap, dbitmap, stripe_nsectors);\n\n\treturn rbio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "0"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_sblock",
          "args": [
            "sctx->dev_root->fs_info",
            "WRITE",
            "sparity->logic_start",
            "&length",
            "&bbio",
            "0",
            "1"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_sblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5493-5500",
          "snippet": "int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_andnot",
          "args": [
            "sparity->dbitmap",
            "sparity->dbitmap",
            "sparity->ebitmap",
            "sparity->nsectors"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_check_and_repair(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct bio *bio;\n\tstruct btrfs_raid_bio *rbio;\n\tstruct scrub_page *spage;\n\tstruct btrfs_bio *bbio = NULL;\n\tu64 length;\n\tint ret;\n\n\tif (!bitmap_andnot(sparity->dbitmap, sparity->dbitmap, sparity->ebitmap,\n\t\t\t   sparity->nsectors))\n\t\tgoto out;\n\n\tlength = sparity->logic_end - sparity->logic_start + 1;\n\tret = btrfs_map_sblock(sctx->dev_root->fs_info, WRITE,\n\t\t\t       sparity->logic_start,\n\t\t\t       &length, &bbio, 0, 1);\n\tif (ret || !bbio || !bbio->raid_map)\n\t\tgoto bbio_out;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\tgoto bbio_out;\n\n\tbio->bi_iter.bi_sector = sparity->logic_start >> 9;\n\tbio->bi_private = sparity;\n\tbio->bi_end_io = scrub_parity_bio_endio;\n\n\trbio = raid56_parity_alloc_scrub_rbio(sctx->dev_root, bio, bbio,\n\t\t\t\t\t      length, sparity->scrub_dev,\n\t\t\t\t\t      sparity->dbitmap,\n\t\t\t\t\t      sparity->nsectors);\n\tif (!rbio)\n\t\tgoto rbio_out;\n\n\tlist_for_each_entry(spage, &sparity->spages, list)\n\t\traid56_parity_add_scrub_pages(rbio, spage->page,\n\t\t\t\t\t      spage->logical);\n\n\tscrub_pending_bio_inc(sctx);\n\traid56_parity_submit_scrub_rbio(rbio);\n\treturn;\n\nrbio_out:\n\tbio_put(bio);\nbbio_out:\n\tbtrfs_put_bbio(bbio);\n\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t  sparity->nsectors);\n\tspin_lock(&sctx->stat_lock);\n\tsctx->stat.malloc_errors++;\n\tspin_unlock(&sctx->stat_lock);\nout:\n\tscrub_free_parity(sparity);\n}"
  },
  {
    "function_name": "scrub_parity_bio_endio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2667-2679",
    "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_pending_bio_dec",
          "args": [
            "sctx"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "318-323",
          "snippet": "static void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_free_parity",
          "args": [
            "sparity"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2645-2665",
          "snippet": "static void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_or",
          "args": [
            "sparity->ebitmap",
            "sparity->ebitmap",
            "sparity->dbitmap",
            "sparity->nsectors"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "scrub_free_parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2645-2665",
    "snippet": "static void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sparity"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_put",
          "args": [
            "curr"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2072-2079",
          "snippet": "static void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&curr->list"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "&sparity->spages",
            "list"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "sparity->ebitmap",
            "sparity->nsectors"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_parity(struct scrub_parity *sparity)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_page *curr, *next;\n\tint nbits;\n\n\tnbits = bitmap_weight(sparity->ebitmap, sparity->nsectors);\n\tif (nbits) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors += nbits;\n\t\tsctx->stat.uncorrectable_errors += nbits;\n\t\tspin_unlock(&sctx->stat_lock);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, &sparity->spages, list) {\n\t\tlist_del_init(&curr->list);\n\t\tscrub_page_put(curr);\n\t}\n\n\tkfree(sparity);\n}"
  },
  {
    "function_name": "get_raid56_logic_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2607-2643",
    "snippet": "static int get_raid56_logic_offset(u64 physical, int num,\n\t\t\t\t   struct map_lookup *map, u64 *offset,\n\t\t\t\t   u64 *stripe_start)\n{\n\tint i;\n\tint j = 0;\n\tu64 stripe_nr;\n\tu64 last_offset;\n\tint stripe_index;\n\tint rot;\n\n\tlast_offset = (physical - map->stripes[num].physical) *\n\t\t      nr_data_stripes(map);\n\tif (stripe_start)\n\t\t*stripe_start = last_offset;\n\n\t*offset = last_offset;\n\tfor (i = 0; i < nr_data_stripes(map); i++) {\n\t\t*offset = last_offset + i * map->stripe_len;\n\n\t\tstripe_nr = *offset;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\t\tdo_div(stripe_nr, nr_data_stripes(map));\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\trot = do_div(stripe_nr, map->num_stripes);\n\t\t/* calculate which stripe this data locates */\n\t\trot += i;\n\t\tstripe_index = rot % map->num_stripes;\n\t\tif (stripe_index == num)\n\t\t\treturn 0;\n\t\tif (stripe_index < num)\n\t\t\tj++;\n\t}\n\t*offset = last_offset + j * map->stripe_len;\n\treturn 1;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->num_stripes"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "nr_data_stripes(map)"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_data_stripes",
          "args": [
            "map"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "nr_data_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "32-35",
          "snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->stripe_len"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_raid56_logic_offset(u64 physical, int num,\n\t\t\t\t   struct map_lookup *map, u64 *offset,\n\t\t\t\t   u64 *stripe_start)\n{\n\tint i;\n\tint j = 0;\n\tu64 stripe_nr;\n\tu64 last_offset;\n\tint stripe_index;\n\tint rot;\n\n\tlast_offset = (physical - map->stripes[num].physical) *\n\t\t      nr_data_stripes(map);\n\tif (stripe_start)\n\t\t*stripe_start = last_offset;\n\n\t*offset = last_offset;\n\tfor (i = 0; i < nr_data_stripes(map); i++) {\n\t\t*offset = last_offset + i * map->stripe_len;\n\n\t\tstripe_nr = *offset;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\t\tdo_div(stripe_nr, nr_data_stripes(map));\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\trot = do_div(stripe_nr, map->num_stripes);\n\t\t/* calculate which stripe this data locates */\n\t\trot += i;\n\t\tstripe_index = rot % map->num_stripes;\n\t\tif (stripe_index == num)\n\t\t\treturn 0;\n\t\tif (stripe_index < num)\n\t\t\tj++;\n\t}\n\t*offset = last_offset + j * map->stripe_len;\n\treturn 1;\n}"
  },
  {
    "function_name": "scrub_extent_for_parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2558-2598",
    "snippet": "static int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pages_for_parity",
          "args": [
            "sparity",
            "logical",
            "l",
            "physical",
            "dev",
            "flags",
            "gen",
            "mirror_num",
            "have_csum ? csum : NULL"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pages_for_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2474-2556",
          "snippet": "static int scrub_pages_for_parity(struct scrub_parity *sparity,\n\t\t\t\t  u64 logical, u64 len,\n\t\t\t\t  u64 physical, struct btrfs_device *dev,\n\t\t\t\t  u64 flags, u64 gen, int mirror_num, u8 *csum)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\tsblock->sparity = sparity;\n\tscrub_parity_get(sparity);\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\t/* For scrub block */\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\t/* For scrub parity */\n\t\tscrub_page_get(spage);\n\t\tlist_add_tail(&spage->list, &sparity->spages);\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_pages_for_parity(struct scrub_parity *sparity,\n\t\t\t\t  u64 logical, u64 len,\n\t\t\t\t  u64 physical, struct btrfs_device *dev,\n\t\t\t\t  u64 flags, u64 gen, int mirror_num, u8 *csum)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\tsblock->sparity = sparity;\n\tscrub_parity_get(sparity);\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\t/* For scrub block */\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\t/* For scrub parity */\n\t\tscrub_page_get(spage);\n\t\tlist_add_tail(&spage->list, &sparity->spages);\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_find_csum",
          "args": [
            "sctx",
            "logical",
            "l",
            "csum"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_find_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2385-2416",
          "snippet": "static int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "blocksize"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_pages_for_parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2474-2556",
    "snippet": "static int scrub_pages_for_parity(struct scrub_parity *sparity,\n\t\t\t\t  u64 logical, u64 len,\n\t\t\t\t  u64 physical, struct btrfs_device *dev,\n\t\t\t\t  u64 flags, u64 gen, int mirror_num, u8 *csum)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\tsblock->sparity = sparity;\n\tscrub_parity_get(sparity);\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\t/* For scrub block */\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\t/* For scrub parity */\n\t\tscrub_page_get(spage);\n\t\tlist_add_tail(&spage->list, &sparity->spages);\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_block_put",
          "args": [
            "sblock"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2053-2065",
          "snippet": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_add_page_to_rd_bio",
          "args": [
            "sctx",
            "spage"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_add_page_to_rd_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2108-2180",
          "snippet": "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_bio_end_io(struct bio *bio, int err);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sblock->page_count == 0"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "spage->csum",
            "csum",
            "sctx->csum_size"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&spage->list",
            "&sparity->spages"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_get",
          "args": [
            "spage"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2067-2070",
          "snippet": "static void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= SCRUB_MAX_PAGES_PER_BLOCK"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*spage)",
            "GFP_NOFS"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "PAGE_SIZE"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_parity_get",
          "args": [
            "sparity"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2743-2746",
          "snippet": "static void scrub_parity_get(struct scrub_parity *sparity)\n{\n\tatomic_inc(&sparity->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_get(struct scrub_parity *sparity)\n{\n\tatomic_inc(&sparity->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sblock->refs",
            "1"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sblock)",
            "GFP_NOFS"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_pages_for_parity(struct scrub_parity *sparity,\n\t\t\t\t  u64 logical, u64 len,\n\t\t\t\t  u64 physical, struct btrfs_device *dev,\n\t\t\t\t  u64 flags, u64 gen, int mirror_num, u8 *csum)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\tsblock->sparity = sparity;\n\tscrub_parity_get(sparity);\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\t/* For scrub block */\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\t/* For scrub parity */\n\t\tscrub_page_get(spage);\n\t\tlist_add_tail(&spage->list, &sparity->spages);\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2419-2472",
    "snippet": "static int scrub_extent(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\tu64 physical, struct btrfs_device *dev, u64 flags,\n\t\t\tu64 gen, int mirror_num, u64 physical_for_dev_replace)\n{\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.data_extents_scrubbed++;\n\t\tsctx->stat.data_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.tree_extents_scrubbed++;\n\t\tsctx->stat.tree_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\t++sctx->stat.no_csum;\n\t\t\tif (sctx->is_dev_replace && !have_csum) {\n\t\t\t\tret = copy_nocow_pages(sctx, logical, l,\n\t\t\t\t\t\t       mirror_num,\n\t\t\t\t\t\t      physical_for_dev_replace);\n\t\t\t\tgoto behind_scrub_pages;\n\t\t\t}\n\t\t}\n\t\tret = scrub_pages(sctx, logical, l, physical, dev, flags, gen,\n\t\t\t\t  mirror_num, have_csum ? csum : NULL, 0,\n\t\t\t\t  physical_for_dev_replace);\nbehind_scrub_pages:\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pages",
          "args": [
            "sctx",
            "logical",
            "l",
            "physical",
            "dev",
            "flags",
            "gen",
            "mirror_num",
            "have_csum ? csum : NULL",
            "0",
            "physical_for_dev_replace"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2182-2262",
          "snippet": "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_nocow_pages",
          "args": [
            "sctx",
            "logical",
            "l",
            "mirror_num",
            "physical_for_dev_replace"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "copy_nocow_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3896-3924",
          "snippet": "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tnocow_ctx = kzalloc(sizeof(*nocow_ctx), GFP_NOFS);\n\tif (!nocow_ctx) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tscrub_pending_trans_workers_inc(sctx);\n\n\tnocow_ctx->sctx = sctx;\n\tnocow_ctx->logical = logical;\n\tnocow_ctx->len = len;\n\tnocow_ctx->mirror_num = mirror_num;\n\tnocow_ctx->physical_for_dev_replace = physical_for_dev_replace;\n\tbtrfs_init_work(&nocow_ctx->work, btrfs_scrubnc_helper,\n\t\t\tcopy_nocow_pages_worker, NULL, NULL);\n\tINIT_LIST_HEAD(&nocow_ctx->inodes);\n\tbtrfs_queue_work(fs_info->scrub_nocow_workers,\n\t\t\t &nocow_ctx->work);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void copy_nocow_pages_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace)\n{\n\tstruct scrub_copy_nocow_ctx *nocow_ctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tnocow_ctx = kzalloc(sizeof(*nocow_ctx), GFP_NOFS);\n\tif (!nocow_ctx) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tscrub_pending_trans_workers_inc(sctx);\n\n\tnocow_ctx->sctx = sctx;\n\tnocow_ctx->logical = logical;\n\tnocow_ctx->len = len;\n\tnocow_ctx->mirror_num = mirror_num;\n\tnocow_ctx->physical_for_dev_replace = physical_for_dev_replace;\n\tbtrfs_init_work(&nocow_ctx->work, btrfs_scrubnc_helper,\n\t\t\tcopy_nocow_pages_worker, NULL, NULL);\n\tINIT_LIST_HEAD(&nocow_ctx->inodes);\n\tbtrfs_queue_work(fs_info->scrub_nocow_workers,\n\t\t\t &nocow_ctx->work);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_find_csum",
          "args": [
            "sctx",
            "logical",
            "l",
            "csum"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_find_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2385-2416",
          "snippet": "static int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "blocksize"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_extent(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\tu64 physical, struct btrfs_device *dev, u64 flags,\n\t\t\tu64 gen, int mirror_num, u64 physical_for_dev_replace)\n{\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sctx->sectorsize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.data_extents_scrubbed++;\n\t\tsctx->stat.data_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sctx->nodesize;\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.tree_extents_scrubbed++;\n\t\tsctx->stat.tree_bytes_scrubbed += len;\n\t\tspin_unlock(&sctx->stat_lock);\n\t} else {\n\t\tblocksize = sctx->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\t/* push csums to sbio */\n\t\t\thave_csum = scrub_find_csum(sctx, logical, l, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\t++sctx->stat.no_csum;\n\t\t\tif (sctx->is_dev_replace && !have_csum) {\n\t\t\t\tret = copy_nocow_pages(sctx, logical, l,\n\t\t\t\t\t\t       mirror_num,\n\t\t\t\t\t\t      physical_for_dev_replace);\n\t\t\t\tgoto behind_scrub_pages;\n\t\t\t}\n\t\t}\n\t\tret = scrub_pages(sctx, logical, l, physical, dev, flags, gen,\n\t\t\t\t  mirror_num, have_csum ? csum : NULL, 0,\n\t\t\t\t  physical_for_dev_replace);\nbehind_scrub_pages:\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_find_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2385-2416",
    "snippet": "static int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sum"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sum->list"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "csum",
            "sum->sums + index",
            "sctx->csum_size"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "logical - sum->bytenr"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sum"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sctx->csum_list",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sctx->csum_list"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_find_csum(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t   u8 *csum)\n{\n\tstruct btrfs_ordered_sum *sum = NULL;\n\tunsigned long index;\n\tunsigned long num_sectors;\n\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tif (sum->bytenr > logical)\n\t\t\treturn 0;\n\t\tif (sum->bytenr + sum->len > logical)\n\t\t\tbreak;\n\n\t\t++sctx->stat.csum_discards;\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t\tsum = NULL;\n\t}\n\tif (!sum)\n\t\treturn 0;\n\n\tindex = ((u32)(logical - sum->bytenr)) / sctx->sectorsize;\n\tnum_sectors = sum->len / sctx->sectorsize;\n\tmemcpy(csum, sum->sums + index, sctx->csum_size);\n\tif (index == num_sectors - 1) {\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "scrub_block_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2357-2383",
    "snippet": "static void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_parity_mark_sectors_error",
          "args": [
            "sblock->sparity",
            "start",
            "end - start"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_mark_sectors_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2345-2349",
          "snippet": "static inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_write_block_to_dev_replace",
          "args": [
            "sblock"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_write_block_to_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1666-1686",
          "snippet": "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_checksum",
          "args": [
            "sblock"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_checksum_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1972-2046",
          "snippet": "static int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_handle_errored_block",
          "args": [
            "sblock"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_handle_errored_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "888-1276",
          "snippet": "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check);",
            "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void copy_nocow_pages_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check);\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}"
  },
  {
    "function_name": "scrub_parity_mark_sectors_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2351-2355",
    "snippet": "static inline void scrub_parity_mark_sectors_data(struct scrub_parity *sparity,\n\t\t\t\t\t\t  u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->dbitmap, start, len);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scrub_mark_bitmap",
          "args": [
            "sparity",
            "sparity->dbitmap",
            "start",
            "len"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "__scrub_mark_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2318-2343",
          "snippet": "static inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_parity_mark_sectors_data(struct scrub_parity *sparity,\n\t\t\t\t\t\t  u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->dbitmap, start, len);\n}"
  },
  {
    "function_name": "scrub_parity_mark_sectors_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2345-2349",
    "snippet": "static inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scrub_mark_bitmap",
          "args": [
            "sparity",
            "sparity->ebitmap",
            "start",
            "len"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "__scrub_mark_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2318-2343",
          "snippet": "static inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_parity_mark_sectors_error(struct scrub_parity *sparity,\n\t\t\t\t\t\t   u64 start, u64 len)\n{\n\t__scrub_mark_bitmap(sparity, sparity->ebitmap, start, len);\n}"
  },
  {
    "function_name": "__scrub_mark_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2318-2343",
    "snippet": "static inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "bitmap",
            "0",
            "nsectors - (sparity->nsectors - offset)"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "65-69",
          "snippet": "static inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "start",
            "sparity->stripe_len"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic inline void __scrub_mark_bitmap(struct scrub_parity *sparity,\n\t\t\t\t       unsigned long *bitmap,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint offset;\n\tint nsectors;\n\tint sectorsize = sparity->sctx->dev_root->sectorsize;\n\n\tif (len >= sparity->stripe_len) {\n\t\tbitmap_set(bitmap, 0, sparity->nsectors);\n\t\treturn;\n\t}\n\n\tstart -= sparity->logic_start;\n\toffset = (int)do_div(start, sparity->stripe_len);\n\toffset /= sectorsize;\n\tnsectors = (int)len / sectorsize;\n\n\tif (offset + nsectors <= sparity->nsectors) {\n\t\tbitmap_set(bitmap, offset, nsectors);\n\t\treturn;\n\t}\n\n\tbitmap_set(bitmap, offset, sparity->nsectors - offset);\n\tbitmap_set(bitmap, 0, nsectors - (sparity->nsectors - offset));\n}"
  },
  {
    "function_name": "scrub_bio_end_io_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2275-2316",
    "snippet": "static void scrub_bio_end_io_worker(struct btrfs_work *work)\n{\n\tstruct scrub_bio *sbio = container_of(work, struct scrub_bio, work);\n\tstruct scrub_ctx *sctx = sbio->sctx;\n\tint i;\n\n\tBUG_ON(sbio->page_count > SCRUB_PAGES_PER_RD_BIO);\n\tif (sbio->err) {\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tstruct scrub_page *spage = sbio->pagev[i];\n\n\t\t\tspage->io_error = 1;\n\t\t\tspage->sblock->no_io_error_seen = 0;\n\t\t}\n\t}\n\n\t/* now complete the scrub_block items that have all pages completed */\n\tfor (i = 0; i < sbio->page_count; i++) {\n\t\tstruct scrub_page *spage = sbio->pagev[i];\n\t\tstruct scrub_block *sblock = spage->sblock;\n\n\t\tif (atomic_dec_and_test(&sblock->outstanding_pages))\n\t\t\tscrub_block_complete(sblock);\n\t\tscrub_block_put(sblock);\n\t}\n\n\tbio_put(sbio->bio);\n\tsbio->bio = NULL;\n\tspin_lock(&sctx->list_lock);\n\tsbio->next_free = sctx->first_free;\n\tsctx->first_free = sbio->index;\n\tspin_unlock(&sctx->list_lock);\n\n\tif (sctx->is_dev_replace &&\n\t    atomic_read(&sctx->wr_ctx.flush_all_writes)) {\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t}\n\n\tscrub_pending_bio_dec(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pending_bio_dec",
          "args": [
            "sctx"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "318-323",
          "snippet": "static void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_wr_submit",
          "args": [
            "sctx"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_wr_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1775-1792",
          "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sctx->wr_ctx.wr_lock"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sctx->wr_ctx.flush_all_writes"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->list_lock"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->list_lock"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "sbio->bio"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_block_put",
          "args": [
            "sblock"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2053-2065",
          "snippet": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_block_complete",
          "args": [
            "sblock"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2357-2383",
          "snippet": "static void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sblock->outstanding_pages"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sbio->page_count > SCRUB_PAGES_PER_RD_BIO"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structscrub_bio",
            "work"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work)\n{\n\tstruct scrub_bio *sbio = container_of(work, struct scrub_bio, work);\n\tstruct scrub_ctx *sctx = sbio->sctx;\n\tint i;\n\n\tBUG_ON(sbio->page_count > SCRUB_PAGES_PER_RD_BIO);\n\tif (sbio->err) {\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tstruct scrub_page *spage = sbio->pagev[i];\n\n\t\t\tspage->io_error = 1;\n\t\t\tspage->sblock->no_io_error_seen = 0;\n\t\t}\n\t}\n\n\t/* now complete the scrub_block items that have all pages completed */\n\tfor (i = 0; i < sbio->page_count; i++) {\n\t\tstruct scrub_page *spage = sbio->pagev[i];\n\t\tstruct scrub_block *sblock = spage->sblock;\n\n\t\tif (atomic_dec_and_test(&sblock->outstanding_pages))\n\t\t\tscrub_block_complete(sblock);\n\t\tscrub_block_put(sblock);\n\t}\n\n\tbio_put(sbio->bio);\n\tsbio->bio = NULL;\n\tspin_lock(&sctx->list_lock);\n\tsbio->next_free = sctx->first_free;\n\tsctx->first_free = sbio->index;\n\tspin_unlock(&sctx->list_lock);\n\n\tif (sctx->is_dev_replace &&\n\t    atomic_read(&sctx->wr_ctx.flush_all_writes)) {\n\t\tmutex_lock(&sctx->wr_ctx.wr_lock);\n\t\tscrub_wr_submit(sctx);\n\t\tmutex_unlock(&sctx->wr_ctx.wr_lock);\n\t}\n\n\tscrub_pending_bio_dec(sctx);\n}"
  },
  {
    "function_name": "scrub_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2264-2273",
    "snippet": "static void scrub_bio_end_io(struct bio *bio, int err)\n{\n\tstruct scrub_bio *sbio = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sbio->dev->dev_root->fs_info;\n\n\tsbio->err = err;\n\tsbio->bio = bio;\n\n\tbtrfs_queue_work(fs_info->scrub_workers, &sbio->work);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->scrub_workers",
            "&sbio->work"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_bio_end_io(struct bio *bio, int err)\n{\n\tstruct scrub_bio *sbio = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sbio->dev->dev_root->fs_info;\n\n\tsbio->err = err;\n\tsbio->bio = bio;\n\n\tbtrfs_queue_work(fs_info->scrub_workers, &sbio->work);\n}"
  },
  {
    "function_name": "scrub_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2182-2262",
    "snippet": "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_block_put",
          "args": [
            "sblock"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2053-2065",
          "snippet": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_submit",
          "args": [
            "sctx"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2081-2106",
          "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_add_page_to_rd_bio",
          "args": [
            "sctx",
            "spage"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_add_page_to_rd_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2108-2180",
          "snippet": "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_bio_end_io(struct bio *bio, int err);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sblock->page_count == 0"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "spage->csum",
            "csum",
            "sctx->csum_size"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_get",
          "args": [
            "spage"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2067-2070",
          "snippet": "static void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= SCRUB_MAX_PAGES_PER_BLOCK"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*spage)",
            "GFP_NOFS"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "PAGE_SIZE"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sblock->refs",
            "1"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sblock)",
            "GFP_NOFS"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace)\n{\n\tstruct scrub_block *sblock;\n\tint index;\n\n\tsblock = kzalloc(sizeof(*sblock), GFP_NOFS);\n\tif (!sblock) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* one ref inside this function, plus one for each page added to\n\t * a bio later on */\n\tatomic_set(&sblock->refs, 1);\n\tsblock->sctx = sctx;\n\tsblock->no_io_error_seen = 1;\n\n\tfor (index = 0; len > 0; index++) {\n\t\tstruct scrub_page *spage;\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tspage = kzalloc(sizeof(*spage), GFP_NOFS);\n\t\tif (!spage) {\nleave_nomem:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.malloc_errors++;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tBUG_ON(index >= SCRUB_MAX_PAGES_PER_BLOCK);\n\t\tscrub_page_get(spage);\n\t\tsblock->pagev[index] = spage;\n\t\tspage->sblock = sblock;\n\t\tspage->dev = dev;\n\t\tspage->flags = flags;\n\t\tspage->generation = gen;\n\t\tspage->logical = logical;\n\t\tspage->physical = physical;\n\t\tspage->physical_for_dev_replace = physical_for_dev_replace;\n\t\tspage->mirror_num = mirror_num;\n\t\tif (csum) {\n\t\t\tspage->have_csum = 1;\n\t\t\tmemcpy(spage->csum, csum, sctx->csum_size);\n\t\t} else {\n\t\t\tspage->have_csum = 0;\n\t\t}\n\t\tsblock->page_count++;\n\t\tspage->page = alloc_page(GFP_NOFS);\n\t\tif (!spage->page)\n\t\t\tgoto leave_nomem;\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t\tphysical_for_dev_replace += l;\n\t}\n\n\tWARN_ON(sblock->page_count == 0);\n\tfor (index = 0; index < sblock->page_count; index++) {\n\t\tstruct scrub_page *spage = sblock->pagev[index];\n\t\tint ret;\n\n\t\tret = scrub_add_page_to_rd_bio(sctx, spage);\n\t\tif (ret) {\n\t\t\tscrub_block_put(sblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (force)\n\t\tscrub_submit(sctx);\n\n\t/* last one frees, either here or in bio completion for last page */\n\tscrub_block_put(sblock);\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_add_page_to_rd_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2108-2180",
    "snippet": "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_submit",
          "args": [
            "sctx"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2081-2106",
          "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sblock->outstanding_pages"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_block_get",
          "args": [
            "sblock"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2048-2051",
          "snippet": "static void scrub_block_get(struct scrub_block *sblock)\n{\n\tatomic_inc(&sblock->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_get(struct scrub_block *sblock)\n{\n\tatomic_inc(&sblock->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "sbio->bio"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "sbio->bio",
            "spage->page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "sctx->pages_per_rd_bio"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sctx->list_wait",
            "sctx->first_free != -1"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->list_lock"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->list_lock"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_block *sblock = spage->sblock;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\nagain:\n\t/*\n\t * grab a fresh bio or wait for one to become available\n\t */\n\twhile (sctx->curr == -1) {\n\t\tspin_lock(&sctx->list_lock);\n\t\tsctx->curr = sctx->first_free;\n\t\tif (sctx->curr != -1) {\n\t\t\tsctx->first_free = sctx->bios[sctx->curr]->next_free;\n\t\t\tsctx->bios[sctx->curr]->next_free = -1;\n\t\t\tsctx->bios[sctx->curr]->page_count = 0;\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t} else {\n\t\t\tspin_unlock(&sctx->list_lock);\n\t\t\twait_event(sctx->list_wait, sctx->first_free != -1);\n\t\t}\n\t}\n\tsbio = sctx->bios[sctx->curr];\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = spage->dev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, sctx->pages_per_rd_bio);\n\t\t\tif (!bio)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical ||\n\t\t   sbio->dev != spage->dev) {\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tscrub_block_get(sblock); /* one for the page added to the bio */\n\tatomic_inc(&sblock->outstanding_pages);\n\tsbio->page_count++;\n\tif (sbio->page_count == sctx->pages_per_rd_bio)\n\t\tscrub_submit(sctx);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2081-2106",
    "snippet": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "READ",
            "sbio->bio"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "sbio->bio",
            "-EIO"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\""
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_pending_bio_inc",
          "args": [
            "sctx"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "312-316",
          "snippet": "static void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\n\tif (!sbio->bio->bi_bdev) {\n\t\t/*\n\t\t * this case should not happen. If btrfs_map_block() is\n\t\t * wrong, it could happen for dev-replace operations on\n\t\t * missing devices when no mirrors are available, but in\n\t\t * this case it should already fail the mount.\n\t\t * This case is handled correctly (but _very_ slowly).\n\t\t */\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"BTRFS: scrub_submit(bio bdev == NULL) is unexpected!\\n\");\n\t\tbio_endio(sbio->bio, -EIO);\n\t} else {\n\t\tbtrfsic_submit_bio(READ, sbio->bio);\n\t}\n}"
  },
  {
    "function_name": "scrub_page_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2072-2079",
    "snippet": "static void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spage"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "spage->page"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&spage->refs"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}"
  },
  {
    "function_name": "scrub_page_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2067-2070",
    "snippet": "static void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&spage->refs"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}"
  },
  {
    "function_name": "scrub_block_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2053-2065",
    "snippet": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sblock"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_put",
          "args": [
            "sblock->pagev[i]"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2072-2079",
          "snippet": "static void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_parity_put",
          "args": [
            "sblock->sparity"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2748-2754",
          "snippet": "static void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!atomic_dec_and_test(&sparity->refs))\n\t\treturn;\n\n\tscrub_parity_check_and_repair(sparity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sblock->refs"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}"
  },
  {
    "function_name": "scrub_block_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "2048-2051",
    "snippet": "static void scrub_block_get(struct scrub_block *sblock)\n{\n\tatomic_inc(&sblock->refs);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sblock->refs"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_get(struct scrub_block *sblock)\n{\n\tatomic_inc(&sblock->refs);\n}"
  },
  {
    "function_name": "scrub_checksum_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1972-2046",
    "snippet": "static int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "sblock->pagev[0]->dev",
            "BTRFS_DEV_STAT_GENERATION_ERRS"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "calculated_csum",
            "on_disk_csum",
            "sctx->csum_size"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "calculated_csum"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sblock->pagev[index]->page"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= sblock->page_count"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_buffer"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "p",
            "crc",
            "l"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "mapped_size"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_check_fsid",
          "args": [
            "s->fsid",
            "sblock->pagev[0]"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_check_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1532-1540",
          "snippet": "static inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "s"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "s"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "on_disk_csum",
            "s->csum",
            "sctx->csum_size"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sblock->page_count < 1"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}"
  },
  {
    "function_name": "scrub_checksum_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1901-1970",
    "snippet": "static int scrub_checksum_tree_block(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tstruct btrfs_header *h;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tint crc_fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\th = (struct btrfs_header *)mapped_buffer;\n\tmemcpy(on_disk_csum, h->csum, sctx->csum_size);\n\n\t/*\n\t * we don't use the getter functions here, as we\n\t * a) don't have an extent buffer and\n\t * b) the page is already kmapped\n\t */\n\n\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h))\n\t\t++fail;\n\n\tif (sblock->pagev[0]->generation != btrfs_stack_header_generation(h))\n\t\t++fail;\n\n\tif (!scrub_check_fsid(h->fsid, sblock->pagev[0]))\n\t\t++fail;\n\n\tif (memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t   BTRFS_UUID_SIZE))\n\t\t++fail;\n\n\tlen = sctx->nodesize - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++crc_fail;\n\n\treturn fail || crc_fail;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "calculated_csum",
            "on_disk_csum",
            "sctx->csum_size"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "calculated_csum"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sblock->pagev[index]->page"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= sblock->page_count"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_buffer"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "p",
            "crc",
            "l"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "mapped_size"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "h->chunk_tree_uuid",
            "fs_info->chunk_tree_uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_check_fsid",
          "args": [
            "h->fsid",
            "sblock->pagev[0]"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_check_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1532-1540",
          "snippet": "static inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "h"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_bytenr",
          "args": [
            "h"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "on_disk_csum",
            "h->csum",
            "sctx->csum_size"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sblock->page_count < 1"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tstruct btrfs_header *h;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tint crc_fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\th = (struct btrfs_header *)mapped_buffer;\n\tmemcpy(on_disk_csum, h->csum, sctx->csum_size);\n\n\t/*\n\t * we don't use the getter functions here, as we\n\t * a) don't have an extent buffer and\n\t * b) the page is already kmapped\n\t */\n\n\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h))\n\t\t++fail;\n\n\tif (sblock->pagev[0]->generation != btrfs_stack_header_generation(h))\n\t\t++fail;\n\n\tif (!scrub_check_fsid(h->fsid, sblock->pagev[0]))\n\t\t++fail;\n\n\tif (memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t   BTRFS_UUID_SIZE))\n\t\t++fail;\n\n\tlen = sctx->nodesize - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++crc_fail;\n\n\treturn fail || crc_fail;\n}"
  },
  {
    "function_name": "scrub_checksum_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1857-1899",
    "snippet": "static int scrub_checksum_data(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu8 *on_disk_csum;\n\tstruct page *page;\n\tvoid *buffer;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tif (!sblock->pagev[0]->have_csum)\n\t\treturn 0;\n\n\ton_disk_csum = sblock->pagev[0]->csum;\n\tpage = sblock->pagev[0]->page;\n\tbuffer = kmap_atomic(page);\n\n\tlen = sctx->sectorsize;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tcrc = btrfs_csum_data(buffer, crc, l);\n\t\tkunmap_atomic(buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tbuffer = kmap_atomic(page);\n\t}\n\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, on_disk_csum, sctx->csum_size))\n\t\tfail = 1;\n\n\treturn fail;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "csum",
            "on_disk_csum",
            "sctx->csum_size"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "csum"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sblock->pagev[index]->page"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= sblock->page_count"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "buffer"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "buffer",
            "crc",
            "l"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "PAGE_SIZE"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sblock->page_count < 1"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_data(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu8 *on_disk_csum;\n\tstruct page *page;\n\tvoid *buffer;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tif (!sblock->pagev[0]->have_csum)\n\t\treturn 0;\n\n\ton_disk_csum = sblock->pagev[0]->csum;\n\tpage = sblock->pagev[0]->page;\n\tbuffer = kmap_atomic(page);\n\n\tlen = sctx->sectorsize;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tcrc = btrfs_csum_data(buffer, crc, l);\n\t\tkunmap_atomic(buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tbuffer = kmap_atomic(page);\n\t}\n\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, on_disk_csum, sctx->csum_size))\n\t\tfail = 1;\n\n\treturn fail;\n}"
  },
  {
    "function_name": "scrub_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1835-1855",
    "snippet": "static int scrub_checksum(struct scrub_block *sblock)\n{\n\tu64 flags;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tflags = sblock->pagev[0]->flags;\n\tret = 0;\n\tif (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\tret = scrub_checksum_data(sblock);\n\telse if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\tret = scrub_checksum_tree_block(sblock);\n\telse if (flags & BTRFS_EXTENT_FLAG_SUPER)\n\t\t(void)scrub_checksum_super(sblock);\n\telse\n\t\tWARN_ON(1);\n\tif (ret)\n\t\tscrub_handle_errored_block(sblock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_handle_errored_block",
          "args": [
            "sblock"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_handle_errored_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "888-1276",
          "snippet": "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check);",
            "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void copy_nocow_pages_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check);\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_checksum_super",
          "args": [
            "sblock"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_checksum_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1972-2046",
          "snippet": "static int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_super(struct scrub_block *sblock)\n{\n\tstruct btrfs_super_block *s;\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail_gen = 0;\n\tint fail_cor = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\ts = (struct btrfs_super_block *)mapped_buffer;\n\tmemcpy(on_disk_csum, s->csum, sctx->csum_size);\n\n\tif (sblock->pagev[0]->logical != btrfs_super_bytenr(s))\n\t\t++fail_cor;\n\n\tif (sblock->pagev[0]->generation != btrfs_super_generation(s))\n\t\t++fail_gen;\n\n\tif (!scrub_check_fsid(s->fsid, sblock->pagev[0]))\n\t\t++fail_cor;\n\n\tlen = BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++fail_cor;\n\n\tif (fail_cor + fail_gen) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (fail_cor)\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(sblock->pagev[0]->dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t}\n\n\treturn fail_cor + fail_gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_checksum_tree_block",
          "args": [
            "sblock"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_checksum_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1901-1970",
          "snippet": "static int scrub_checksum_tree_block(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tstruct btrfs_header *h;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tint crc_fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\th = (struct btrfs_header *)mapped_buffer;\n\tmemcpy(on_disk_csum, h->csum, sctx->csum_size);\n\n\t/*\n\t * we don't use the getter functions here, as we\n\t * a) don't have an extent buffer and\n\t * b) the page is already kmapped\n\t */\n\n\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h))\n\t\t++fail;\n\n\tif (sblock->pagev[0]->generation != btrfs_stack_header_generation(h))\n\t\t++fail;\n\n\tif (!scrub_check_fsid(h->fsid, sblock->pagev[0]))\n\t\t++fail;\n\n\tif (memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t   BTRFS_UUID_SIZE))\n\t\t++fail;\n\n\tlen = sctx->nodesize - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++crc_fail;\n\n\treturn fail || crc_fail;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tstruct btrfs_header *h;\n\tstruct btrfs_root *root = sctx->dev_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu8 on_disk_csum[BTRFS_CSUM_SIZE];\n\tstruct page *page;\n\tvoid *mapped_buffer;\n\tu64 mapped_size;\n\tvoid *p;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tint crc_fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tpage = sblock->pagev[0]->page;\n\tmapped_buffer = kmap_atomic(page);\n\th = (struct btrfs_header *)mapped_buffer;\n\tmemcpy(on_disk_csum, h->csum, sctx->csum_size);\n\n\t/*\n\t * we don't use the getter functions here, as we\n\t * a) don't have an extent buffer and\n\t * b) the page is already kmapped\n\t */\n\n\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h))\n\t\t++fail;\n\n\tif (sblock->pagev[0]->generation != btrfs_stack_header_generation(h))\n\t\t++fail;\n\n\tif (!scrub_check_fsid(h->fsid, sblock->pagev[0]))\n\t\t++fail;\n\n\tif (memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t   BTRFS_UUID_SIZE))\n\t\t++fail;\n\n\tlen = sctx->nodesize - BTRFS_CSUM_SIZE;\n\tmapped_size = PAGE_SIZE - BTRFS_CSUM_SIZE;\n\tp = ((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, mapped_size);\n\n\t\tcrc = btrfs_csum_data(p, crc, l);\n\t\tkunmap_atomic(mapped_buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tmapped_buffer = kmap_atomic(page);\n\t\tmapped_size = PAGE_SIZE;\n\t\tp = mapped_buffer;\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))\n\t\t++crc_fail;\n\n\treturn fail || crc_fail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_checksum_data",
          "args": [
            "sblock"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_checksum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1857-1899",
          "snippet": "static int scrub_checksum_data(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu8 *on_disk_csum;\n\tstruct page *page;\n\tvoid *buffer;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tif (!sblock->pagev[0]->have_csum)\n\t\treturn 0;\n\n\ton_disk_csum = sblock->pagev[0]->csum;\n\tpage = sblock->pagev[0]->page;\n\tbuffer = kmap_atomic(page);\n\n\tlen = sctx->sectorsize;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tcrc = btrfs_csum_data(buffer, crc, l);\n\t\tkunmap_atomic(buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tbuffer = kmap_atomic(page);\n\t}\n\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, on_disk_csum, sctx->csum_size))\n\t\tfail = 1;\n\n\treturn fail;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum_data(struct scrub_block *sblock)\n{\n\tstruct scrub_ctx *sctx = sblock->sctx;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu8 *on_disk_csum;\n\tstruct page *page;\n\tvoid *buffer;\n\tu32 crc = ~(u32)0;\n\tint fail = 0;\n\tu64 len;\n\tint index;\n\n\tBUG_ON(sblock->page_count < 1);\n\tif (!sblock->pagev[0]->have_csum)\n\t\treturn 0;\n\n\ton_disk_csum = sblock->pagev[0]->csum;\n\tpage = sblock->pagev[0]->page;\n\tbuffer = kmap_atomic(page);\n\n\tlen = sctx->sectorsize;\n\tindex = 0;\n\tfor (;;) {\n\t\tu64 l = min_t(u64, len, PAGE_SIZE);\n\n\t\tcrc = btrfs_csum_data(buffer, crc, l);\n\t\tkunmap_atomic(buffer);\n\t\tlen -= l;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tindex++;\n\t\tBUG_ON(index >= sblock->page_count);\n\t\tBUG_ON(!sblock->pagev[index]->page);\n\t\tpage = sblock->pagev[index]->page;\n\t\tbuffer = kmap_atomic(page);\n\t}\n\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, on_disk_csum, sctx->csum_size))\n\t\tfail = 1;\n\n\treturn fail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sblock->page_count < 1"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_checksum(struct scrub_block *sblock)\n{\n\tu64 flags;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tflags = sblock->pagev[0]->flags;\n\tret = 0;\n\tif (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\tret = scrub_checksum_data(sblock);\n\telse if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\tret = scrub_checksum_tree_block(sblock);\n\telse if (flags & BTRFS_EXTENT_FLAG_SUPER)\n\t\t(void)scrub_checksum_super(sblock);\n\telse\n\t\tWARN_ON(1);\n\tif (ret)\n\t\tscrub_handle_errored_block(sblock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "scrub_wr_bio_end_io_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1807-1833",
    "snippet": "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work)\n{\n\tstruct scrub_bio *sbio = container_of(work, struct scrub_bio, work);\n\tstruct scrub_ctx *sctx = sbio->sctx;\n\tint i;\n\n\tWARN_ON(sbio->page_count > SCRUB_PAGES_PER_WR_BIO);\n\tif (sbio->err) {\n\t\tstruct btrfs_dev_replace *dev_replace =\n\t\t\t&sbio->sctx->dev_root->fs_info->dev_replace;\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tstruct scrub_page *spage = sbio->pagev[i];\n\n\t\t\tspage->io_error = 1;\n\t\t\tbtrfs_dev_replace_stats_inc(&dev_replace->\n\t\t\t\t\t\t    num_write_errors);\n\t\t}\n\t}\n\n\tfor (i = 0; i < sbio->page_count; i++)\n\t\tscrub_page_put(sbio->pagev[i]);\n\n\tbio_put(sbio->bio);\n\tkfree(sbio);\n\tscrub_pending_bio_dec(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pending_bio_dec",
          "args": [
            "sctx"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "318-323",
          "snippet": "static void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbio"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "sbio->bio"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_put",
          "args": [
            "sbio->pagev[i]"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2072-2079",
          "snippet": "static void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&dev_replace->\n\t\t\t\t\t\t    num_write_errors"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sbio->page_count > SCRUB_PAGES_PER_WR_BIO"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structscrub_bio",
            "work"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work)\n{\n\tstruct scrub_bio *sbio = container_of(work, struct scrub_bio, work);\n\tstruct scrub_ctx *sctx = sbio->sctx;\n\tint i;\n\n\tWARN_ON(sbio->page_count > SCRUB_PAGES_PER_WR_BIO);\n\tif (sbio->err) {\n\t\tstruct btrfs_dev_replace *dev_replace =\n\t\t\t&sbio->sctx->dev_root->fs_info->dev_replace;\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tstruct scrub_page *spage = sbio->pagev[i];\n\n\t\t\tspage->io_error = 1;\n\t\t\tbtrfs_dev_replace_stats_inc(&dev_replace->\n\t\t\t\t\t\t    num_write_errors);\n\t\t}\n\t}\n\n\tfor (i = 0; i < sbio->page_count; i++)\n\t\tscrub_page_put(sbio->pagev[i]);\n\n\tbio_put(sbio->bio);\n\tkfree(sbio);\n\tscrub_pending_bio_dec(sctx);\n}"
  },
  {
    "function_name": "scrub_wr_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1794-1805",
    "snippet": "static void scrub_wr_bio_end_io(struct bio *bio, int err)\n{\n\tstruct scrub_bio *sbio = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sbio->dev->dev_root->fs_info;\n\n\tsbio->err = err;\n\tsbio->bio = bio;\n\n\tbtrfs_init_work(&sbio->work, btrfs_scrubwrc_helper,\n\t\t\t scrub_wr_bio_end_io_worker, NULL, NULL);\n\tbtrfs_queue_work(fs_info->scrub_wr_completion_workers, &sbio->work);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->scrub_wr_completion_workers",
            "&sbio->work"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&sbio->work",
            "btrfs_scrubwrc_helper",
            "scrub_wr_bio_end_io_worker",
            "NULL",
            "NULL"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err)\n{\n\tstruct scrub_bio *sbio = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sbio->dev->dev_root->fs_info;\n\n\tsbio->err = err;\n\tsbio->bio = bio;\n\n\tbtrfs_init_work(&sbio->work, btrfs_scrubwrc_helper,\n\t\t\t scrub_wr_bio_end_io_worker, NULL, NULL);\n\tbtrfs_queue_work(fs_info->scrub_wr_completion_workers, &sbio->work);\n}"
  },
  {
    "function_name": "scrub_wr_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1775-1792",
    "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "WRITE",
            "sbio->bio"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_pending_bio_inc",
          "args": [
            "sctx"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_bio_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "312-316",
          "snippet": "static void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sbio->bio->bi_bdev"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
  },
  {
    "function_name": "scrub_add_page_to_wr_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1704-1773",
    "snippet": "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\n\tmutex_lock(&wr_ctx->wr_lock);\nagain:\n\tif (!wr_ctx->wr_curr_bio) {\n\t\twr_ctx->wr_curr_bio = kzalloc(sizeof(*wr_ctx->wr_curr_bio),\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!wr_ctx->wr_curr_bio) {\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twr_ctx->wr_curr_bio->sctx = sctx;\n\t\twr_ctx->wr_curr_bio->page_count = 0;\n\t}\n\tsbio = wr_ctx->wr_curr_bio;\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical_for_dev_replace;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = wr_ctx->tgtdev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, wr_ctx->pages_per_wr_bio);\n\t\t\tif (!bio) {\n\t\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_wr_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical_for_dev_replace ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical) {\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tscrub_page_get(spage);\n\tsbio->page_count++;\n\tif (sbio->page_count == wr_ctx->pages_per_wr_bio)\n\t\tscrub_wr_submit(sctx);\n\tmutex_unlock(&wr_ctx->wr_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_wr_submit",
          "args": [
            "sctx"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_wr_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1775-1792",
          "snippet": "static void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_wr_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\n\tif (!wr_ctx->wr_curr_bio)\n\t\treturn;\n\n\tsbio = wr_ctx->wr_curr_bio;\n\twr_ctx->wr_curr_bio = NULL;\n\tWARN_ON(!sbio->bio->bi_bdev);\n\tscrub_pending_bio_inc(sctx);\n\t/* process all writes in a single worker thread. Then the block layer\n\t * orders the requests before sending them to the driver which\n\t * doubled the write performance on spinning disks when measured\n\t * with Linux 3.5 */\n\tbtrfsic_submit_bio(WRITE, sbio->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_page_get",
          "args": [
            "spage"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2067-2070",
          "snippet": "static void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "sbio->bio"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "sbio->bio",
            "spage->page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "wr_ctx->pages_per_wr_bio"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wr_ctx->wr_curr_bio)",
            "GFP_NOFS"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wr_ctx->wr_lock"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\n\tmutex_lock(&wr_ctx->wr_lock);\nagain:\n\tif (!wr_ctx->wr_curr_bio) {\n\t\twr_ctx->wr_curr_bio = kzalloc(sizeof(*wr_ctx->wr_curr_bio),\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!wr_ctx->wr_curr_bio) {\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twr_ctx->wr_curr_bio->sctx = sctx;\n\t\twr_ctx->wr_curr_bio->page_count = 0;\n\t}\n\tsbio = wr_ctx->wr_curr_bio;\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical_for_dev_replace;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = wr_ctx->tgtdev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, wr_ctx->pages_per_wr_bio);\n\t\t\tif (!bio) {\n\t\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_wr_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical_for_dev_replace ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical) {\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tscrub_page_get(spage);\n\tsbio->page_count++;\n\tif (sbio->page_count == wr_ctx->pages_per_wr_bio)\n\t\tscrub_wr_submit(sctx);\n\tmutex_unlock(&wr_ctx->wr_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_write_page_to_dev_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1688-1702",
    "snippet": "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_add_page_to_wr_bio",
          "args": [
            "sblock->sctx",
            "spage"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_add_page_to_wr_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1704-1773",
          "snippet": "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\n\tmutex_lock(&wr_ctx->wr_lock);\nagain:\n\tif (!wr_ctx->wr_curr_bio) {\n\t\twr_ctx->wr_curr_bio = kzalloc(sizeof(*wr_ctx->wr_curr_bio),\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!wr_ctx->wr_curr_bio) {\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twr_ctx->wr_curr_bio->sctx = sctx;\n\t\twr_ctx->wr_curr_bio->page_count = 0;\n\t}\n\tsbio = wr_ctx->wr_curr_bio;\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical_for_dev_replace;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = wr_ctx->tgtdev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, wr_ctx->pages_per_wr_bio);\n\t\t\tif (!bio) {\n\t\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_wr_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical_for_dev_replace ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical) {\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tscrub_page_get(spage);\n\tsbio->page_count++;\n\tif (sbio->page_count == wr_ctx->pages_per_wr_bio)\n\t\tscrub_wr_submit(sctx);\n\tmutex_unlock(&wr_ctx->wr_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_bio_end_io(struct bio *bio, int err);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage)\n{\n\tstruct scrub_wr_ctx *wr_ctx = &sctx->wr_ctx;\n\tstruct scrub_bio *sbio;\n\tint ret;\n\n\tmutex_lock(&wr_ctx->wr_lock);\nagain:\n\tif (!wr_ctx->wr_curr_bio) {\n\t\twr_ctx->wr_curr_bio = kzalloc(sizeof(*wr_ctx->wr_curr_bio),\n\t\t\t\t\t      GFP_NOFS);\n\t\tif (!wr_ctx->wr_curr_bio) {\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twr_ctx->wr_curr_bio->sctx = sctx;\n\t\twr_ctx->wr_curr_bio->page_count = 0;\n\t}\n\tsbio = wr_ctx->wr_curr_bio;\n\tif (sbio->page_count == 0) {\n\t\tstruct bio *bio;\n\n\t\tsbio->physical = spage->physical_for_dev_replace;\n\t\tsbio->logical = spage->logical;\n\t\tsbio->dev = wr_ctx->tgtdev;\n\t\tbio = sbio->bio;\n\t\tif (!bio) {\n\t\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, wr_ctx->pages_per_wr_bio);\n\t\t\tif (!bio) {\n\t\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsbio->bio = bio;\n\t\t}\n\n\t\tbio->bi_private = sbio;\n\t\tbio->bi_end_io = scrub_wr_bio_end_io;\n\t\tbio->bi_bdev = sbio->dev->bdev;\n\t\tbio->bi_iter.bi_sector = sbio->physical >> 9;\n\t\tsbio->err = 0;\n\t} else if (sbio->physical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->physical_for_dev_replace ||\n\t\t   sbio->logical + sbio->page_count * PAGE_SIZE !=\n\t\t   spage->logical) {\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tret = bio_add_page(sbio->bio, spage->page, PAGE_SIZE, 0);\n\tif (ret != PAGE_SIZE) {\n\t\tif (sbio->page_count < 1) {\n\t\t\tbio_put(sbio->bio);\n\t\t\tsbio->bio = NULL;\n\t\t\tmutex_unlock(&wr_ctx->wr_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tscrub_wr_submit(sctx);\n\t\tgoto again;\n\t}\n\n\tsbio->pagev[sbio->page_count] = spage;\n\tscrub_page_get(spage);\n\tsbio->page_count++;\n\tif (sbio->page_count == wr_ctx->pages_per_wr_bio)\n\t\tscrub_wr_submit(sctx);\n\tmutex_unlock(&wr_ctx->wr_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_buffer"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "spage->page"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mapped_buffer",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "spage->page"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "spage->page == NULL"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}"
  },
  {
    "function_name": "scrub_write_block_to_dev_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1666-1686",
    "snippet": "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_parity_get(struct scrub_parity *sparity);",
      "static void scrub_parity_put(struct scrub_parity *sparity);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_write_page_to_dev_replace",
          "args": [
            "sblock",
            "page_num"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_write_page_to_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1688-1702",
          "snippet": "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}"
  },
  {
    "function_name": "scrub_repair_page_from_good_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1618-1664",
    "snippet": "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);",
      "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "page_bad->dev",
            "BTRFS_DEV_STAT_WRITE_ERRS"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio_wait",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page_good->page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\""
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_good->page == NULL"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_bad->page == NULL"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_repair_block_from_good_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1599-1616",
    "snippet": "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good)\n{\n\tint page_num;\n\tint ret = 0;\n\n\tfor (page_num = 0; page_num < sblock_bad->page_count; page_num++) {\n\t\tint ret_sub;\n\n\t\tret_sub = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t   sblock_good,\n\t\t\t\t\t\t\t   page_num, 1);\n\t\tif (ret_sub)\n\t\t\tret = ret_sub;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_repair_page_from_good_copy",
          "args": [
            "sblock_bad",
            "sblock_good",
            "page_num",
            "1"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_repair_page_from_good_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1618-1664",
          "snippet": "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);",
            "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good)\n{\n\tint page_num;\n\tint ret = 0;\n\n\tfor (page_num = 0; page_num < sblock_bad->page_count; page_num++) {\n\t\tint ret_sub;\n\n\t\tret_sub = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t   sblock_good,\n\t\t\t\t\t\t\t   page_num, 1);\n\t\tif (ret_sub)\n\t\t\tret = ret_sub;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "scrub_recheck_block_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1542-1597",
    "snippet": "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size)\n{\n\tint page_num;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tvoid *mapped_buffer;\n\n\tWARN_ON(!sblock->pagev[0]->page);\n\tif (is_metadata) {\n\t\tstruct btrfs_header *h;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t\th = (struct btrfs_header *)mapped_buffer;\n\n\t\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h) ||\n\t\t    !scrub_check_fsid(h->fsid, sblock->pagev[0]) ||\n\t\t    memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t\t   BTRFS_UUID_SIZE)) {\n\t\t\tsblock->header_error = 1;\n\t\t} else if (generation != btrfs_stack_header_generation(h)) {\n\t\t\tsblock->header_error = 1;\n\t\t\tsblock->generation_error = 1;\n\t\t}\n\t\tcsum = h->csum;\n\t} else {\n\t\tif (!have_csum)\n\t\t\treturn;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t}\n\n\tfor (page_num = 0;;) {\n\t\tif (page_num == 0 && is_metadata)\n\t\t\tcrc = btrfs_csum_data(\n\t\t\t\t((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, PAGE_SIZE - BTRFS_CSUM_SIZE);\n\t\telse\n\t\t\tcrc = btrfs_csum_data(mapped_buffer, crc, PAGE_SIZE);\n\n\t\tkunmap_atomic(mapped_buffer);\n\t\tpage_num++;\n\t\tif (page_num >= sblock->page_count)\n\t\t\tbreak;\n\t\tWARN_ON(!sblock->pagev[page_num]->page);\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[page_num]->page);\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, csum, csum_size))\n\t\tsblock->checksum_error = 1;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "calculated_csum",
            "csum",
            "csum_size"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "calculated_csum"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "sblock->pagev[page_num]->page"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sblock->pagev[page_num]->page"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_buffer"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "mapped_buffer",
            "crc",
            "PAGE_SIZE"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "sblock->pagev[0]->page"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "h"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "h->chunk_tree_uuid",
            "fs_info->chunk_tree_uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_check_fsid",
          "args": [
            "h->fsid",
            "sblock->pagev[0]"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_check_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1532-1540",
          "snippet": "static inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_bytenr",
          "args": [
            "h"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "sblock->pagev[0]->page"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sblock->pagev[0]->page"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size)\n{\n\tint page_num;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tvoid *mapped_buffer;\n\n\tWARN_ON(!sblock->pagev[0]->page);\n\tif (is_metadata) {\n\t\tstruct btrfs_header *h;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t\th = (struct btrfs_header *)mapped_buffer;\n\n\t\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h) ||\n\t\t    !scrub_check_fsid(h->fsid, sblock->pagev[0]) ||\n\t\t    memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t\t   BTRFS_UUID_SIZE)) {\n\t\t\tsblock->header_error = 1;\n\t\t} else if (generation != btrfs_stack_header_generation(h)) {\n\t\t\tsblock->header_error = 1;\n\t\t\tsblock->generation_error = 1;\n\t\t}\n\t\tcsum = h->csum;\n\t} else {\n\t\tif (!have_csum)\n\t\t\treturn;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t}\n\n\tfor (page_num = 0;;) {\n\t\tif (page_num == 0 && is_metadata)\n\t\t\tcrc = btrfs_csum_data(\n\t\t\t\t((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, PAGE_SIZE - BTRFS_CSUM_SIZE);\n\t\telse\n\t\t\tcrc = btrfs_csum_data(mapped_buffer, crc, PAGE_SIZE);\n\n\t\tkunmap_atomic(mapped_buffer);\n\t\tpage_num++;\n\t\tif (page_num >= sblock->page_count)\n\t\t\tbreak;\n\t\tWARN_ON(!sblock->pagev[page_num]->page);\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[page_num]->page);\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, csum, csum_size))\n\t\tsblock->checksum_error = 1;\n}"
  },
  {
    "function_name": "scrub_check_fsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1532-1540",
    "snippet": "static inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_page_get(struct scrub_page *spage);",
      "static void scrub_page_put(struct scrub_page *spage);",
      "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fsid",
            "fs_devices->fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_check_fsid(u8 fsid[],\n\t\t\t\t   struct scrub_page *spage)\n{\n\tstruct btrfs_fs_devices *fs_devices = spage->dev->fs_devices;\n\tint ret;\n\n\tret = memcmp(fsid, fs_devices->fsid, BTRFS_UUID_SIZE);\n\treturn !ret;\n}"
  },
  {
    "function_name": "scrub_recheck_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1480-1530",
    "snippet": "static void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror)\n{\n\tint page_num;\n\n\tsblock->no_io_error_seen = 1;\n\tsblock->header_error = 0;\n\tsblock->checksum_error = 0;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tstruct bio *bio;\n\t\tstruct scrub_page *page = sblock->pagev[page_num];\n\n\t\tif (page->dev->bdev == NULL) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(!page->page);\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbio->bi_bdev = page->dev->bdev;\n\n\t\tbio_add_page(bio, page->page, PAGE_SIZE, 0);\n\t\tif (!retry_failed_mirror && scrub_is_page_on_raid56(page)) {\n\t\t\tif (scrub_submit_raid56_bio_wait(fs_info, bio, page))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t} else {\n\t\t\tbio->bi_iter.bi_sector = page->physical >> 9;\n\n\t\t\tif (btrfsic_submit_bio_wait(READ, bio))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t}\n\n\t\tbio_put(bio);\n\t}\n\n\tif (sblock->no_io_error_seen)\n\t\tscrub_recheck_block_checksum(fs_info, sblock, is_metadata,\n\t\t\t\t\t     have_csum, csum, generation,\n\t\t\t\t\t     csum_size);\n\n\treturn;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_recheck_block_checksum",
          "args": [
            "fs_info",
            "sblock",
            "is_metadata",
            "have_csum",
            "csum",
            "generation",
            "csum_size"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_recheck_block_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1542-1597",
          "snippet": "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size)\n{\n\tint page_num;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tvoid *mapped_buffer;\n\n\tWARN_ON(!sblock->pagev[0]->page);\n\tif (is_metadata) {\n\t\tstruct btrfs_header *h;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t\th = (struct btrfs_header *)mapped_buffer;\n\n\t\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h) ||\n\t\t    !scrub_check_fsid(h->fsid, sblock->pagev[0]) ||\n\t\t    memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t\t   BTRFS_UUID_SIZE)) {\n\t\t\tsblock->header_error = 1;\n\t\t} else if (generation != btrfs_stack_header_generation(h)) {\n\t\t\tsblock->header_error = 1;\n\t\t\tsblock->generation_error = 1;\n\t\t}\n\t\tcsum = h->csum;\n\t} else {\n\t\tif (!have_csum)\n\t\t\treturn;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t}\n\n\tfor (page_num = 0;;) {\n\t\tif (page_num == 0 && is_metadata)\n\t\t\tcrc = btrfs_csum_data(\n\t\t\t\t((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, PAGE_SIZE - BTRFS_CSUM_SIZE);\n\t\telse\n\t\t\tcrc = btrfs_csum_data(mapped_buffer, crc, PAGE_SIZE);\n\n\t\tkunmap_atomic(mapped_buffer);\n\t\tpage_num++;\n\t\tif (page_num >= sblock->page_count)\n\t\t\tbreak;\n\t\tWARN_ON(!sblock->pagev[page_num]->page);\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[page_num]->page);\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, csum, csum_size))\n\t\tsblock->checksum_error = 1;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size)\n{\n\tint page_num;\n\tu8 calculated_csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tvoid *mapped_buffer;\n\n\tWARN_ON(!sblock->pagev[0]->page);\n\tif (is_metadata) {\n\t\tstruct btrfs_header *h;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t\th = (struct btrfs_header *)mapped_buffer;\n\n\t\tif (sblock->pagev[0]->logical != btrfs_stack_header_bytenr(h) ||\n\t\t    !scrub_check_fsid(h->fsid, sblock->pagev[0]) ||\n\t\t    memcmp(h->chunk_tree_uuid, fs_info->chunk_tree_uuid,\n\t\t\t   BTRFS_UUID_SIZE)) {\n\t\t\tsblock->header_error = 1;\n\t\t} else if (generation != btrfs_stack_header_generation(h)) {\n\t\t\tsblock->header_error = 1;\n\t\t\tsblock->generation_error = 1;\n\t\t}\n\t\tcsum = h->csum;\n\t} else {\n\t\tif (!have_csum)\n\t\t\treturn;\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[0]->page);\n\t}\n\n\tfor (page_num = 0;;) {\n\t\tif (page_num == 0 && is_metadata)\n\t\t\tcrc = btrfs_csum_data(\n\t\t\t\t((u8 *)mapped_buffer) + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, PAGE_SIZE - BTRFS_CSUM_SIZE);\n\t\telse\n\t\t\tcrc = btrfs_csum_data(mapped_buffer, crc, PAGE_SIZE);\n\n\t\tkunmap_atomic(mapped_buffer);\n\t\tpage_num++;\n\t\tif (page_num >= sblock->page_count)\n\t\t\tbreak;\n\t\tWARN_ON(!sblock->pagev[page_num]->page);\n\n\t\tmapped_buffer = kmap_atomic(sblock->pagev[page_num]->page);\n\t}\n\n\tbtrfs_csum_final(crc, calculated_csum);\n\tif (memcmp(calculated_csum, csum, csum_size))\n\t\tsblock->checksum_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio_wait",
          "args": [
            "READ",
            "bio"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_submit_raid56_bio_wait",
          "args": [
            "fs_info",
            "bio",
            "page"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_submit_raid56_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1447-1471",
          "snippet": "static int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct bio *bio,\n\t\t\t\t\tstruct scrub_page *page)\n{\n\tstruct scrub_bio_ret done;\n\tint ret;\n\n\tinit_completion(&done.event);\n\tdone.error = 0;\n\tbio->bi_iter.bi_sector = page->logical >> 9;\n\tbio->bi_private = &done;\n\tbio->bi_end_io = scrub_bio_wait_endio;\n\n\tret = raid56_parity_recover(fs_info->fs_root, bio, page->recover->bbio,\n\t\t\t\t    page->recover->map_length,\n\t\t\t\t    page->mirror_num, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&done.event);\n\tif (done.error)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct bio *bio,\n\t\t\t\t\tstruct scrub_page *page)\n{\n\tstruct scrub_bio_ret done;\n\tint ret;\n\n\tinit_completion(&done.event);\n\tdone.error = 0;\n\tbio->bi_iter.bi_sector = page->logical >> 9;\n\tbio->bi_private = &done;\n\tbio->bi_end_io = scrub_bio_wait_endio;\n\n\tret = raid56_parity_recover(fs_info->fs_root, bio, page->recover->bbio,\n\t\t\t\t    page->recover->map_length,\n\t\t\t\t    page->mirror_num, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&done.event);\n\tif (done.error)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_is_page_on_raid56",
          "args": [
            "page"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_is_page_on_raid56",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1441-1445",
          "snippet": "static inline int scrub_is_page_on_raid56(struct scrub_page *page)\n{\n\treturn page->recover &&\n\t       (page->recover->bbio->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_is_page_on_raid56(struct scrub_page *page)\n{\n\treturn page->recover &&\n\t       (page->recover->bbio->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page->page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!page->page"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror)\n{\n\tint page_num;\n\n\tsblock->no_io_error_seen = 1;\n\tsblock->header_error = 0;\n\tsblock->checksum_error = 0;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tstruct bio *bio;\n\t\tstruct scrub_page *page = sblock->pagev[page_num];\n\n\t\tif (page->dev->bdev == NULL) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(!page->page);\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbio->bi_bdev = page->dev->bdev;\n\n\t\tbio_add_page(bio, page->page, PAGE_SIZE, 0);\n\t\tif (!retry_failed_mirror && scrub_is_page_on_raid56(page)) {\n\t\t\tif (scrub_submit_raid56_bio_wait(fs_info, bio, page))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t} else {\n\t\t\tbio->bi_iter.bi_sector = page->physical >> 9;\n\n\t\t\tif (btrfsic_submit_bio_wait(READ, bio))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t}\n\n\t\tbio_put(bio);\n\t}\n\n\tif (sblock->no_io_error_seen)\n\t\tscrub_recheck_block_checksum(fs_info, sblock, is_metadata,\n\t\t\t\t\t     have_csum, csum, generation,\n\t\t\t\t\t     csum_size);\n\n\treturn;\n}"
  },
  {
    "function_name": "scrub_submit_raid56_bio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1447-1471",
    "snippet": "static int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct bio *bio,\n\t\t\t\t\tstruct scrub_page *page)\n{\n\tstruct scrub_bio_ret done;\n\tint ret;\n\n\tinit_completion(&done.event);\n\tdone.error = 0;\n\tbio->bi_iter.bi_sector = page->logical >> 9;\n\tbio->bi_private = &done;\n\tbio->bi_end_io = scrub_bio_wait_endio;\n\n\tret = raid56_parity_recover(fs_info->fs_root, bio, page->recover->bbio,\n\t\t\t\t    page->recover->map_length,\n\t\t\t\t    page->mirror_num, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&done.event);\n\tif (done.error)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done.event"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2798-2814",
          "snippet": "int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raid56_parity_recover",
          "args": [
            "fs_info->fs_root",
            "bio",
            "page->recover->bbio",
            "page->recover->map_length",
            "page->mirror_num",
            "0"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2123-2182",
          "snippet": "int raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nint raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&done.event"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct bio *bio,\n\t\t\t\t\tstruct scrub_page *page)\n{\n\tstruct scrub_bio_ret done;\n\tint ret;\n\n\tinit_completion(&done.event);\n\tdone.error = 0;\n\tbio->bi_iter.bi_sector = page->logical >> 9;\n\tbio->bi_private = &done;\n\tbio->bi_end_io = scrub_bio_wait_endio;\n\n\tret = raid56_parity_recover(fs_info->fs_root, bio, page->recover->bbio,\n\t\t\t\t    page->recover->map_length,\n\t\t\t\t    page->mirror_num, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&done.event);\n\tif (done.error)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_is_page_on_raid56",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1441-1445",
    "snippet": "static inline int scrub_is_page_on_raid56(struct scrub_page *page)\n{\n\treturn page->recover &&\n\t       (page->recover->bbio->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_is_page_on_raid56(struct scrub_page *page)\n{\n\treturn page->recover &&\n\t       (page->recover->bbio->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK);\n}"
  },
  {
    "function_name": "scrub_bio_wait_endio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1433-1439",
    "snippet": "static void scrub_bio_wait_endio(struct bio *bio, int error)\n{\n\tstruct scrub_bio_ret *ret = bio->bi_private;\n\n\tret->error = error;\n\tcomplete(&ret->event);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ret->event"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2357-2383",
          "snippet": "static void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_bio_wait_endio(struct bio *bio, int error)\n{\n\tstruct scrub_bio_ret *ret = bio->bi_private;\n\n\tret->error = error;\n\tcomplete(&ret->event);\n}"
  },
  {
    "function_name": "scrub_setup_recheck_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1318-1426",
    "snippet": "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck)\n{\n\tstruct scrub_ctx *sctx = original_sblock->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tu64 length = original_sblock->page_count * PAGE_SIZE;\n\tu64 logical = original_sblock->pagev[0]->logical;\n\tstruct scrub_recover *recover;\n\tstruct btrfs_bio *bbio;\n\tu64 sublen;\n\tu64 mapped_length;\n\tu64 stripe_offset;\n\tint stripe_index;\n\tint page_index = 0;\n\tint mirror_index;\n\tint nmirrors;\n\tint ret;\n\n\t/*\n\t * note: the two members refs and outstanding_pages\n\t * are not used (and not set) in the blocks that are used for\n\t * the recheck procedure\n\t */\n\n\twhile (length > 0) {\n\t\tsublen = min_t(u64, length, PAGE_SIZE);\n\t\tmapped_length = sublen;\n\t\tbbio = NULL;\n\n\t\t/*\n\t\t * with a length of PAGE_SIZE, each returned stripe\n\t\t * represents one mirror\n\t\t */\n\t\tret = btrfs_map_sblock(fs_info, REQ_GET_READ_MIRRORS, logical,\n\t\t\t\t       &mapped_length, &bbio, 0, 1);\n\t\tif (ret || !bbio || mapped_length < sublen) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trecover = kzalloc(sizeof(struct scrub_recover), GFP_NOFS);\n\t\tif (!recover) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&recover->refs, 1);\n\t\trecover->bbio = bbio;\n\t\trecover->map_length = mapped_length;\n\n\t\tBUG_ON(page_index >= SCRUB_PAGES_PER_RD_BIO);\n\n\t\tnmirrors = min(scrub_nr_raid_mirrors(bbio), BTRFS_MAX_MIRRORS);\n\n\t\tfor (mirror_index = 0; mirror_index < nmirrors;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock;\n\t\t\tstruct scrub_page *page;\n\n\t\t\tsblock = sblocks_for_recheck + mirror_index;\n\t\t\tsblock->sctx = sctx;\n\t\t\tpage = kzalloc(sizeof(*page), GFP_NOFS);\n\t\t\tif (!page) {\nleave_nomem:\n\t\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\t\tsctx->stat.malloc_errors++;\n\t\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\t\tscrub_put_recover(recover);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tscrub_page_get(page);\n\t\t\tsblock->pagev[page_index] = page;\n\t\t\tpage->logical = logical;\n\n\t\t\tscrub_stripe_index_and_offset(logical,\n\t\t\t\t\t\t      bbio->map_type,\n\t\t\t\t\t\t      bbio->raid_map,\n\t\t\t\t\t\t      mapped_length,\n\t\t\t\t\t\t      bbio->num_stripes -\n\t\t\t\t\t\t      bbio->num_tgtdevs,\n\t\t\t\t\t\t      mirror_index,\n\t\t\t\t\t\t      &stripe_index,\n\t\t\t\t\t\t      &stripe_offset);\n\t\t\tpage->physical = bbio->stripes[stripe_index].physical +\n\t\t\t\t\t stripe_offset;\n\t\t\tpage->dev = bbio->stripes[stripe_index].dev;\n\n\t\t\tBUG_ON(page_index >= original_sblock->page_count);\n\t\t\tpage->physical_for_dev_replace =\n\t\t\t\toriginal_sblock->pagev[page_index]->\n\t\t\t\tphysical_for_dev_replace;\n\t\t\t/* for missing devices, dev->bdev is NULL */\n\t\t\tpage->mirror_num = mirror_index + 1;\n\t\t\tsblock->page_count++;\n\t\t\tpage->page = alloc_page(GFP_NOFS);\n\t\t\tif (!page->page)\n\t\t\t\tgoto leave_nomem;\n\n\t\t\tscrub_get_recover(recover);\n\t\t\tpage->recover = recover;\n\t\t}\n\t\tscrub_put_recover(recover);\n\t\tlength -= sublen;\n\t\tlogical += sublen;\n\t\tpage_index++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_put_recover",
          "args": [
            "recover"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_put_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "872-878",
          "snippet": "static inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_get_recover",
          "args": [
            "recover"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_get_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "867-870",
          "snippet": "static inline void scrub_get_recover(struct scrub_recover *recover)\n{\n\tatomic_inc(&recover->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_get_recover(struct scrub_recover *recover)\n{\n\tatomic_inc(&recover->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_index >= original_sblock->page_count"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_stripe_index_and_offset",
          "args": [
            "logical",
            "bbio->map_type",
            "bbio->raid_map",
            "mapped_length",
            "bbio->num_stripes -\n\t\t\t\t\t\t      bbio->num_tgtdevs",
            "mirror_index",
            "&stripe_index",
            "&stripe_offset"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_stripe_index_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1288-1316",
          "snippet": "static inline void scrub_stripe_index_and_offset(u64 logical, u64 map_type,\n\t\t\t\t\t\t u64 *raid_map,\n\t\t\t\t\t\t u64 mapped_length,\n\t\t\t\t\t\t int nstripes, int mirror,\n\t\t\t\t\t\t int *stripe_index,\n\t\t\t\t\t\t u64 *stripe_offset)\n{\n\tint i;\n\n\tif (map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t/* RAID5/6 */\n\t\tfor (i = 0; i < nstripes; i++) {\n\t\t\tif (raid_map[i] == RAID6_Q_STRIPE ||\n\t\t\t    raid_map[i] == RAID5_P_STRIPE)\n\t\t\t\tcontinue;\n\n\t\t\tif (logical >= raid_map[i] &&\n\t\t\t    logical < raid_map[i] + mapped_length)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*stripe_index = i;\n\t\t*stripe_offset = logical - raid_map[i];\n\t} else {\n\t\t/* The other RAID type */\n\t\t*stripe_index = mirror;\n\t\t*stripe_offset = 0;\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic inline void scrub_stripe_index_and_offset(u64 logical, u64 map_type,\n\t\t\t\t\t\t u64 *raid_map,\n\t\t\t\t\t\t u64 mapped_length,\n\t\t\t\t\t\t int nstripes, int mirror,\n\t\t\t\t\t\t int *stripe_index,\n\t\t\t\t\t\t u64 *stripe_offset)\n{\n\tint i;\n\n\tif (map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t/* RAID5/6 */\n\t\tfor (i = 0; i < nstripes; i++) {\n\t\t\tif (raid_map[i] == RAID6_Q_STRIPE ||\n\t\t\t    raid_map[i] == RAID5_P_STRIPE)\n\t\t\t\tcontinue;\n\n\t\t\tif (logical >= raid_map[i] &&\n\t\t\t    logical < raid_map[i] + mapped_length)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*stripe_index = i;\n\t\t*stripe_offset = logical - raid_map[i];\n\t} else {\n\t\t/* The other RAID type */\n\t\t*stripe_index = mirror;\n\t\t*stripe_offset = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_page_get",
          "args": [
            "page"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2067-2070",
          "snippet": "static void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_get(struct scrub_page *spage)\n{\n\tatomic_inc(&spage->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*page)",
            "GFP_NOFS"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "scrub_nr_raid_mirrors(bbio)",
            "BTRFS_MAX_MIRRORS"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_nr_raid_mirrors",
          "args": [
            "bbio"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_nr_raid_mirrors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1278-1286",
          "snippet": "static inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)\n{\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 2;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 3;\n\telse\n\t\treturn (int)bbio->num_stripes;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)\n{\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 2;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 3;\n\telse\n\t\treturn (int)bbio->num_stripes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_index >= SCRUB_PAGES_PER_RD_BIO"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&recover->refs",
            "1"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct scrub_recover)",
            "GFP_NOFS"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_map_sblock",
          "args": [
            "fs_info",
            "REQ_GET_READ_MIRRORS",
            "logical",
            "&mapped_length",
            "&bbio",
            "0",
            "1"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_sblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5493-5500",
          "snippet": "int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "length",
            "PAGE_SIZE"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck)\n{\n\tstruct scrub_ctx *sctx = original_sblock->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tu64 length = original_sblock->page_count * PAGE_SIZE;\n\tu64 logical = original_sblock->pagev[0]->logical;\n\tstruct scrub_recover *recover;\n\tstruct btrfs_bio *bbio;\n\tu64 sublen;\n\tu64 mapped_length;\n\tu64 stripe_offset;\n\tint stripe_index;\n\tint page_index = 0;\n\tint mirror_index;\n\tint nmirrors;\n\tint ret;\n\n\t/*\n\t * note: the two members refs and outstanding_pages\n\t * are not used (and not set) in the blocks that are used for\n\t * the recheck procedure\n\t */\n\n\twhile (length > 0) {\n\t\tsublen = min_t(u64, length, PAGE_SIZE);\n\t\tmapped_length = sublen;\n\t\tbbio = NULL;\n\n\t\t/*\n\t\t * with a length of PAGE_SIZE, each returned stripe\n\t\t * represents one mirror\n\t\t */\n\t\tret = btrfs_map_sblock(fs_info, REQ_GET_READ_MIRRORS, logical,\n\t\t\t\t       &mapped_length, &bbio, 0, 1);\n\t\tif (ret || !bbio || mapped_length < sublen) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trecover = kzalloc(sizeof(struct scrub_recover), GFP_NOFS);\n\t\tif (!recover) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&recover->refs, 1);\n\t\trecover->bbio = bbio;\n\t\trecover->map_length = mapped_length;\n\n\t\tBUG_ON(page_index >= SCRUB_PAGES_PER_RD_BIO);\n\n\t\tnmirrors = min(scrub_nr_raid_mirrors(bbio), BTRFS_MAX_MIRRORS);\n\n\t\tfor (mirror_index = 0; mirror_index < nmirrors;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock;\n\t\t\tstruct scrub_page *page;\n\n\t\t\tsblock = sblocks_for_recheck + mirror_index;\n\t\t\tsblock->sctx = sctx;\n\t\t\tpage = kzalloc(sizeof(*page), GFP_NOFS);\n\t\t\tif (!page) {\nleave_nomem:\n\t\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\t\tsctx->stat.malloc_errors++;\n\t\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\t\tscrub_put_recover(recover);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tscrub_page_get(page);\n\t\t\tsblock->pagev[page_index] = page;\n\t\t\tpage->logical = logical;\n\n\t\t\tscrub_stripe_index_and_offset(logical,\n\t\t\t\t\t\t      bbio->map_type,\n\t\t\t\t\t\t      bbio->raid_map,\n\t\t\t\t\t\t      mapped_length,\n\t\t\t\t\t\t      bbio->num_stripes -\n\t\t\t\t\t\t      bbio->num_tgtdevs,\n\t\t\t\t\t\t      mirror_index,\n\t\t\t\t\t\t      &stripe_index,\n\t\t\t\t\t\t      &stripe_offset);\n\t\t\tpage->physical = bbio->stripes[stripe_index].physical +\n\t\t\t\t\t stripe_offset;\n\t\t\tpage->dev = bbio->stripes[stripe_index].dev;\n\n\t\t\tBUG_ON(page_index >= original_sblock->page_count);\n\t\t\tpage->physical_for_dev_replace =\n\t\t\t\toriginal_sblock->pagev[page_index]->\n\t\t\t\tphysical_for_dev_replace;\n\t\t\t/* for missing devices, dev->bdev is NULL */\n\t\t\tpage->mirror_num = mirror_index + 1;\n\t\t\tsblock->page_count++;\n\t\t\tpage->page = alloc_page(GFP_NOFS);\n\t\t\tif (!page->page)\n\t\t\t\tgoto leave_nomem;\n\n\t\t\tscrub_get_recover(recover);\n\t\t\tpage->recover = recover;\n\t\t}\n\t\tscrub_put_recover(recover);\n\t\tlength -= sublen;\n\t\tlogical += sublen;\n\t\tpage_index++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_stripe_index_and_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1288-1316",
    "snippet": "static inline void scrub_stripe_index_and_offset(u64 logical, u64 map_type,\n\t\t\t\t\t\t u64 *raid_map,\n\t\t\t\t\t\t u64 mapped_length,\n\t\t\t\t\t\t int nstripes, int mirror,\n\t\t\t\t\t\t int *stripe_index,\n\t\t\t\t\t\t u64 *stripe_offset)\n{\n\tint i;\n\n\tif (map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t/* RAID5/6 */\n\t\tfor (i = 0; i < nstripes; i++) {\n\t\t\tif (raid_map[i] == RAID6_Q_STRIPE ||\n\t\t\t    raid_map[i] == RAID5_P_STRIPE)\n\t\t\t\tcontinue;\n\n\t\t\tif (logical >= raid_map[i] &&\n\t\t\t    logical < raid_map[i] + mapped_length)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*stripe_index = i;\n\t\t*stripe_offset = logical - raid_map[i];\n\t} else {\n\t\t/* The other RAID type */\n\t\t*stripe_index = mirror;\n\t\t*stripe_offset = 0;\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic inline void scrub_stripe_index_and_offset(u64 logical, u64 map_type,\n\t\t\t\t\t\t u64 *raid_map,\n\t\t\t\t\t\t u64 mapped_length,\n\t\t\t\t\t\t int nstripes, int mirror,\n\t\t\t\t\t\t int *stripe_index,\n\t\t\t\t\t\t u64 *stripe_offset)\n{\n\tint i;\n\n\tif (map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t/* RAID5/6 */\n\t\tfor (i = 0; i < nstripes; i++) {\n\t\t\tif (raid_map[i] == RAID6_Q_STRIPE ||\n\t\t\t    raid_map[i] == RAID5_P_STRIPE)\n\t\t\t\tcontinue;\n\n\t\t\tif (logical >= raid_map[i] &&\n\t\t\t    logical < raid_map[i] + mapped_length)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*stripe_index = i;\n\t\t*stripe_offset = logical - raid_map[i];\n\t} else {\n\t\t/* The other RAID type */\n\t\t*stripe_index = mirror;\n\t\t*stripe_offset = 0;\n\t}\n}"
  },
  {
    "function_name": "scrub_nr_raid_mirrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "1278-1286",
    "snippet": "static inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)\n{\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 2;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 3;\n\telse\n\t\treturn (int)bbio->num_stripes;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)\n{\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 2;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 3;\n\telse\n\t\treturn (int)bbio->num_stripes;\n}"
  },
  {
    "function_name": "scrub_handle_errored_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "888-1276",
    "snippet": "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static int scrub_handle_errored_block(struct scrub_block *sblock_to_check);",
      "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sblocks_for_recheck"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_page_put",
          "args": [
            "sblock->pagev[page_index]"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_page_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2072-2079",
          "snippet": "static void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_page_put(struct scrub_page *spage)\n{\n\tif (atomic_dec_and_test(&spage->refs)) {\n\t\tif (spage->page)\n\t\t\t__free_page(spage->page);\n\t\tkfree(spage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_put_recover",
          "args": [
            "recover"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_put_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "872-878",
          "snippet": "static inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\"",
            "logical",
            "rcu_str_deref(dev->name)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\"",
            "logical",
            "rcu_str_deref(dev->name)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_recheck_block",
          "args": [
            "fs_info",
            "sblock_bad",
            "is_metadata",
            "have_csum",
            "csum",
            "generation",
            "sctx->csum_size",
            "1"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_recheck_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1480-1530",
          "snippet": "static void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror)\n{\n\tint page_num;\n\n\tsblock->no_io_error_seen = 1;\n\tsblock->header_error = 0;\n\tsblock->checksum_error = 0;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tstruct bio *bio;\n\t\tstruct scrub_page *page = sblock->pagev[page_num];\n\n\t\tif (page->dev->bdev == NULL) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(!page->page);\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbio->bi_bdev = page->dev->bdev;\n\n\t\tbio_add_page(bio, page->page, PAGE_SIZE, 0);\n\t\tif (!retry_failed_mirror && scrub_is_page_on_raid56(page)) {\n\t\t\tif (scrub_submit_raid56_bio_wait(fs_info, bio, page))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t} else {\n\t\t\tbio->bi_iter.bi_sector = page->physical >> 9;\n\n\t\t\tif (btrfsic_submit_bio_wait(READ, bio))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t}\n\n\t\tbio_put(bio);\n\t}\n\n\tif (sblock->no_io_error_seen)\n\t\tscrub_recheck_block_checksum(fs_info, sblock, is_metadata,\n\t\t\t\t\t     have_csum, csum, generation,\n\t\t\t\t\t     csum_size);\n\n\treturn;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror);",
            "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_recheck_block(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct scrub_block *sblock, int is_metadata,\n\t\t\t\tint have_csum, u8 *csum, u64 generation,\n\t\t\t\tu16 csum_size, int retry_failed_mirror)\n{\n\tint page_num;\n\n\tsblock->no_io_error_seen = 1;\n\tsblock->header_error = 0;\n\tsblock->checksum_error = 0;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tstruct bio *bio;\n\t\tstruct scrub_page *page = sblock->pagev[page_num];\n\n\t\tif (page->dev->bdev == NULL) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(!page->page);\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio) {\n\t\t\tpage->io_error = 1;\n\t\t\tsblock->no_io_error_seen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbio->bi_bdev = page->dev->bdev;\n\n\t\tbio_add_page(bio, page->page, PAGE_SIZE, 0);\n\t\tif (!retry_failed_mirror && scrub_is_page_on_raid56(page)) {\n\t\t\tif (scrub_submit_raid56_bio_wait(fs_info, bio, page))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t} else {\n\t\t\tbio->bi_iter.bi_sector = page->physical >> 9;\n\n\t\t\tif (btrfsic_submit_bio_wait(READ, bio))\n\t\t\t\tsblock->no_io_error_seen = 0;\n\t\t}\n\n\t\tbio_put(bio);\n\t}\n\n\tif (sblock->no_io_error_seen)\n\t\tscrub_recheck_block_checksum(fs_info, sblock, is_metadata,\n\t\t\t\t\t     have_csum, csum, generation,\n\t\t\t\t\t     csum_size);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_repair_page_from_good_copy",
          "args": [
            "sblock_bad",
            "sblock_other",
            "page_num",
            "0"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_repair_page_from_good_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1618-1664",
          "snippet": "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);",
            "static int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_repair_page_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t    struct scrub_block *sblock_good,\n\t\t\t\t\t    int page_num, int force_write)\n{\n\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\tstruct scrub_page *page_good = sblock_good->pagev[page_num];\n\n\tBUG_ON(page_bad->page == NULL);\n\tBUG_ON(page_good->page == NULL);\n\tif (force_write || sblock_bad->header_error ||\n\t    sblock_bad->checksum_error || page_bad->io_error) {\n\t\tstruct bio *bio;\n\t\tint ret;\n\n\t\tif (!page_bad->dev->bdev) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"scrub_repair_page_from_good_copy(bdev == NULL) \"\n\t\t\t\t\"is unexpected!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\t\tif (!bio)\n\t\t\treturn -EIO;\n\t\tbio->bi_bdev = page_bad->dev->bdev;\n\t\tbio->bi_iter.bi_sector = page_bad->physical >> 9;\n\n\t\tret = bio_add_page(bio, page_good->page, PAGE_SIZE, 0);\n\t\tif (PAGE_SIZE != ret) {\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (btrfsic_submit_bio_wait(WRITE, bio)) {\n\t\t\tbtrfs_dev_stat_inc_and_print(page_bad->dev,\n\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock_bad->sctx->dev_root->fs_info->\n\t\t\t\tdev_replace.num_write_errors);\n\t\t\tbio_put(bio);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_write_page_to_dev_replace",
          "args": [
            "sblock_other",
            "page_num"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_write_page_to_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1688-1702",
          "snippet": "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_page_get(struct scrub_page *spage);",
            "static void scrub_page_put(struct scrub_page *spage);",
            "static int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_page_get(struct scrub_page *spage);\nstatic void scrub_page_put(struct scrub_page *spage);\nstatic int scrub_add_page_to_rd_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_add_page_to_wr_bio(struct scrub_ctx *sctx,\n\t\t\t\t    struct scrub_page *spage);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num)\n{\n\tstruct scrub_page *spage = sblock->pagev[page_num];\n\n\tBUG_ON(spage->page == NULL);\n\tif (spage->io_error) {\n\t\tvoid *mapped_buffer = kmap_atomic(spage->page);\n\n\t\tmemset(mapped_buffer, 0, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(spage->page);\n\t\tkunmap_atomic(mapped_buffer);\n\t}\n\treturn scrub_add_page_to_wr_bio(sblock->sctx, spage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_repair_block_from_good_copy",
          "args": [
            "sblock_bad",
            "sblock_other"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_repair_block_from_good_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1599-1616",
          "snippet": "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good)\n{\n\tint page_num;\n\tint ret = 0;\n\n\tfor (page_num = 0; page_num < sblock_bad->page_count; page_num++) {\n\t\tint ret_sub;\n\n\t\tret_sub = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t   sblock_good,\n\t\t\t\t\t\t\t   page_num, 1);\n\t\tif (ret_sub)\n\t\t\tret = ret_sub;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_repair_block_from_good_copy(struct scrub_block *sblock_bad,\n\t\t\t\t\t     struct scrub_block *sblock_good)\n{\n\tint page_num;\n\tint ret = 0;\n\n\tfor (page_num = 0; page_num < sblock_bad->page_count; page_num++) {\n\t\tint ret_sub;\n\n\t\tret_sub = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t   sblock_good,\n\t\t\t\t\t\t\t   page_num, 1);\n\t\tif (ret_sub)\n\t\t\tret = ret_sub;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_write_block_to_dev_replace",
          "args": [
            "sblock_other"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_write_block_to_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1666-1686",
          "snippet": "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock)\n{\n\tint page_num;\n\n\t/*\n\t * This block is used for the check of the parity on the source device,\n\t * so the data needn't be written into the destination device.\n\t */\n\tif (sblock->sparity)\n\t\treturn;\n\n\tfor (page_num = 0; page_num < sblock->page_count; page_num++) {\n\t\tint ret;\n\n\t\tret = scrub_write_page_to_dev_replace(sblock, page_num);\n\t\tif (ret)\n\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t&sblock->sctx->dev_root->fs_info->dev_replace.\n\t\t\t\tnum_write_errors);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->scrub_workers",
            "&fixup_nodatasum->work"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&fixup_nodatasum->work",
            "btrfs_scrub_helper",
            "scrub_fixup_nodatasum",
            "NULL",
            "NULL"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_pending_trans_workers_inc",
          "args": [
            "sctx"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_trans_workers_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "352-381",
          "snippet": "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fixup_nodatasum)",
            "GFP_NOFS"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sctx->is_dev_replace"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!sctx->is_dev_replace"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_CORRUPTION_ERRS"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrub_print_warning",
          "args": [
            "\"checksum/header error\"",
            "sblock_to_check"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_print_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "608-677",
          "snippet": "static void scrub_print_warning(const char *errstr, struct scrub_block *sblock)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct scrub_warning swarn;\n\tunsigned long ptr = 0;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tu64 ref_root;\n\tu32 item_size;\n\tu8 ref_level;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tdev = sblock->pagev[0]->dev;\n\tfs_info = sblock->sctx->dev_root->fs_info;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn;\n\n\tswarn.sector = (sblock->pagev[0]->physical) >> 9;\n\tswarn.logical = sblock->pagev[0]->logical;\n\tswarn.errstr = errstr;\n\tswarn.dev = NULL;\n\n\tret = extent_from_logical(fs_info, swarn.logical, path, &found_key,\n\t\t\t\t  &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\textent_item_pos = swarn.logical - found_key.objectid;\n\tswarn.extent_item_size = found_key.offset;\n\n\teb = path->nodes[0];\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tdo {\n\t\t\tret = tree_backref_for_extent(&ptr, eb, &found_key, ei,\n\t\t\t\t\t\t      item_size, &ref_root,\n\t\t\t\t\t\t      &ref_level);\n\t\t\tprintk_in_rcu(KERN_WARNING\n\t\t\t\t\"BTRFS: %s at logical %llu on dev %s, \"\n\t\t\t\t\"sector %llu: metadata %s (level %d) in tree \"\n\t\t\t\t\"%llu\\n\", errstr, swarn.logical,\n\t\t\t\trcu_str_deref(dev->name),\n\t\t\t\t(unsigned long long)swarn.sector,\n\t\t\t\tref_level ? \"node\" : \"leaf\",\n\t\t\t\tret < 0 ? -1 : ref_level,\n\t\t\t\tret < 0 ? -1 : ref_root);\n\t\t} while (ret != 1);\n\t\tbtrfs_release_path(path);\n\t} else {\n\t\tbtrfs_release_path(path);\n\t\tswarn.path = path;\n\t\tswarn.dev = dev;\n\t\titerate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, 1,\n\t\t\t\t\tscrub_print_warning_inode, &swarn);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_print_warning(const char *errstr, struct scrub_block *sblock)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct scrub_warning swarn;\n\tunsigned long ptr = 0;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tu64 ref_root;\n\tu32 item_size;\n\tu8 ref_level;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tdev = sblock->pagev[0]->dev;\n\tfs_info = sblock->sctx->dev_root->fs_info;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn;\n\n\tswarn.sector = (sblock->pagev[0]->physical) >> 9;\n\tswarn.logical = sblock->pagev[0]->logical;\n\tswarn.errstr = errstr;\n\tswarn.dev = NULL;\n\n\tret = extent_from_logical(fs_info, swarn.logical, path, &found_key,\n\t\t\t\t  &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\textent_item_pos = swarn.logical - found_key.objectid;\n\tswarn.extent_item_size = found_key.offset;\n\n\teb = path->nodes[0];\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tdo {\n\t\t\tret = tree_backref_for_extent(&ptr, eb, &found_key, ei,\n\t\t\t\t\t\t      item_size, &ref_root,\n\t\t\t\t\t\t      &ref_level);\n\t\t\tprintk_in_rcu(KERN_WARNING\n\t\t\t\t\"BTRFS: %s at logical %llu on dev %s, \"\n\t\t\t\t\"sector %llu: metadata %s (level %d) in tree \"\n\t\t\t\t\"%llu\\n\", errstr, swarn.logical,\n\t\t\t\trcu_str_deref(dev->name),\n\t\t\t\t(unsigned long long)swarn.sector,\n\t\t\t\tref_level ? \"node\" : \"leaf\",\n\t\t\t\tret < 0 ? -1 : ref_level,\n\t\t\t\tret < 0 ? -1 : ref_root);\n\t\t} while (ret != 1);\n\t\tbtrfs_release_path(path);\n\t} else {\n\t\tbtrfs_release_path(path);\n\t\tswarn.path = path;\n\t\tswarn.dev = dev;\n\t\titerate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, 1,\n\t\t\t\t\tscrub_print_warning_inode, &swarn);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&_rs"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&_rs"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&_rs"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "failed_mirror_index >= BTRFS_MAX_MIRRORS"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_setup_recheck_block",
          "args": [
            "sblock_to_check",
            "sblocks_for_recheck"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_setup_recheck_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "1318-1426",
          "snippet": "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck)\n{\n\tstruct scrub_ctx *sctx = original_sblock->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tu64 length = original_sblock->page_count * PAGE_SIZE;\n\tu64 logical = original_sblock->pagev[0]->logical;\n\tstruct scrub_recover *recover;\n\tstruct btrfs_bio *bbio;\n\tu64 sublen;\n\tu64 mapped_length;\n\tu64 stripe_offset;\n\tint stripe_index;\n\tint page_index = 0;\n\tint mirror_index;\n\tint nmirrors;\n\tint ret;\n\n\t/*\n\t * note: the two members refs and outstanding_pages\n\t * are not used (and not set) in the blocks that are used for\n\t * the recheck procedure\n\t */\n\n\twhile (length > 0) {\n\t\tsublen = min_t(u64, length, PAGE_SIZE);\n\t\tmapped_length = sublen;\n\t\tbbio = NULL;\n\n\t\t/*\n\t\t * with a length of PAGE_SIZE, each returned stripe\n\t\t * represents one mirror\n\t\t */\n\t\tret = btrfs_map_sblock(fs_info, REQ_GET_READ_MIRRORS, logical,\n\t\t\t\t       &mapped_length, &bbio, 0, 1);\n\t\tif (ret || !bbio || mapped_length < sublen) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trecover = kzalloc(sizeof(struct scrub_recover), GFP_NOFS);\n\t\tif (!recover) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&recover->refs, 1);\n\t\trecover->bbio = bbio;\n\t\trecover->map_length = mapped_length;\n\n\t\tBUG_ON(page_index >= SCRUB_PAGES_PER_RD_BIO);\n\n\t\tnmirrors = min(scrub_nr_raid_mirrors(bbio), BTRFS_MAX_MIRRORS);\n\n\t\tfor (mirror_index = 0; mirror_index < nmirrors;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock;\n\t\t\tstruct scrub_page *page;\n\n\t\t\tsblock = sblocks_for_recheck + mirror_index;\n\t\t\tsblock->sctx = sctx;\n\t\t\tpage = kzalloc(sizeof(*page), GFP_NOFS);\n\t\t\tif (!page) {\nleave_nomem:\n\t\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\t\tsctx->stat.malloc_errors++;\n\t\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\t\tscrub_put_recover(recover);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tscrub_page_get(page);\n\t\t\tsblock->pagev[page_index] = page;\n\t\t\tpage->logical = logical;\n\n\t\t\tscrub_stripe_index_and_offset(logical,\n\t\t\t\t\t\t      bbio->map_type,\n\t\t\t\t\t\t      bbio->raid_map,\n\t\t\t\t\t\t      mapped_length,\n\t\t\t\t\t\t      bbio->num_stripes -\n\t\t\t\t\t\t      bbio->num_tgtdevs,\n\t\t\t\t\t\t      mirror_index,\n\t\t\t\t\t\t      &stripe_index,\n\t\t\t\t\t\t      &stripe_offset);\n\t\t\tpage->physical = bbio->stripes[stripe_index].physical +\n\t\t\t\t\t stripe_offset;\n\t\t\tpage->dev = bbio->stripes[stripe_index].dev;\n\n\t\t\tBUG_ON(page_index >= original_sblock->page_count);\n\t\t\tpage->physical_for_dev_replace =\n\t\t\t\toriginal_sblock->pagev[page_index]->\n\t\t\t\tphysical_for_dev_replace;\n\t\t\t/* for missing devices, dev->bdev is NULL */\n\t\t\tpage->mirror_num = mirror_index + 1;\n\t\t\tsblock->page_count++;\n\t\t\tpage->page = alloc_page(GFP_NOFS);\n\t\t\tif (!page->page)\n\t\t\t\tgoto leave_nomem;\n\n\t\t\tscrub_get_recover(recover);\n\t\t\tpage->recover = recover;\n\t\t}\n\t\tscrub_put_recover(recover);\n\t\tlength -= sublen;\n\t\tlogical += sublen;\n\t\tpage_index++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic int scrub_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t       u64 physical, struct btrfs_device *dev, u64 flags,\n\t\t       u64 gen, int mirror_num, u8 *csum, int force,\n\t\t       u64 physical_for_dev_replace);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic int copy_nocow_pages(struct scrub_ctx *sctx, u64 logical, u64 len,\n\t\t\t    int mirror_num, u64 physical_for_dev_replace);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck)\n{\n\tstruct scrub_ctx *sctx = original_sblock->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\tu64 length = original_sblock->page_count * PAGE_SIZE;\n\tu64 logical = original_sblock->pagev[0]->logical;\n\tstruct scrub_recover *recover;\n\tstruct btrfs_bio *bbio;\n\tu64 sublen;\n\tu64 mapped_length;\n\tu64 stripe_offset;\n\tint stripe_index;\n\tint page_index = 0;\n\tint mirror_index;\n\tint nmirrors;\n\tint ret;\n\n\t/*\n\t * note: the two members refs and outstanding_pages\n\t * are not used (and not set) in the blocks that are used for\n\t * the recheck procedure\n\t */\n\n\twhile (length > 0) {\n\t\tsublen = min_t(u64, length, PAGE_SIZE);\n\t\tmapped_length = sublen;\n\t\tbbio = NULL;\n\n\t\t/*\n\t\t * with a length of PAGE_SIZE, each returned stripe\n\t\t * represents one mirror\n\t\t */\n\t\tret = btrfs_map_sblock(fs_info, REQ_GET_READ_MIRRORS, logical,\n\t\t\t\t       &mapped_length, &bbio, 0, 1);\n\t\tif (ret || !bbio || mapped_length < sublen) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trecover = kzalloc(sizeof(struct scrub_recover), GFP_NOFS);\n\t\tif (!recover) {\n\t\t\tbtrfs_put_bbio(bbio);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&recover->refs, 1);\n\t\trecover->bbio = bbio;\n\t\trecover->map_length = mapped_length;\n\n\t\tBUG_ON(page_index >= SCRUB_PAGES_PER_RD_BIO);\n\n\t\tnmirrors = min(scrub_nr_raid_mirrors(bbio), BTRFS_MAX_MIRRORS);\n\n\t\tfor (mirror_index = 0; mirror_index < nmirrors;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock;\n\t\t\tstruct scrub_page *page;\n\n\t\t\tsblock = sblocks_for_recheck + mirror_index;\n\t\t\tsblock->sctx = sctx;\n\t\t\tpage = kzalloc(sizeof(*page), GFP_NOFS);\n\t\t\tif (!page) {\nleave_nomem:\n\t\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\t\tsctx->stat.malloc_errors++;\n\t\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\t\tscrub_put_recover(recover);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tscrub_page_get(page);\n\t\t\tsblock->pagev[page_index] = page;\n\t\t\tpage->logical = logical;\n\n\t\t\tscrub_stripe_index_and_offset(logical,\n\t\t\t\t\t\t      bbio->map_type,\n\t\t\t\t\t\t      bbio->raid_map,\n\t\t\t\t\t\t      mapped_length,\n\t\t\t\t\t\t      bbio->num_stripes -\n\t\t\t\t\t\t      bbio->num_tgtdevs,\n\t\t\t\t\t\t      mirror_index,\n\t\t\t\t\t\t      &stripe_index,\n\t\t\t\t\t\t      &stripe_offset);\n\t\t\tpage->physical = bbio->stripes[stripe_index].physical +\n\t\t\t\t\t stripe_offset;\n\t\t\tpage->dev = bbio->stripes[stripe_index].dev;\n\n\t\t\tBUG_ON(page_index >= original_sblock->page_count);\n\t\t\tpage->physical_for_dev_replace =\n\t\t\t\toriginal_sblock->pagev[page_index]->\n\t\t\t\tphysical_for_dev_replace;\n\t\t\t/* for missing devices, dev->bdev is NULL */\n\t\t\tpage->mirror_num = mirror_index + 1;\n\t\t\tsblock->page_count++;\n\t\t\tpage->page = alloc_page(GFP_NOFS);\n\t\t\tif (!page->page)\n\t\t\t\tgoto leave_nomem;\n\n\t\t\tscrub_get_recover(recover);\n\t\t\tpage->recover = recover;\n\t\t}\n\t\tscrub_put_recover(recover);\n\t\tlength -= sublen;\n\t\tlogical += sublen;\n\t\tpage_index++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck)",
            "GFP_NOFS"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sblock_to_check->pagev[0]->mirror_num < 1"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sblock_to_check->page_count < 1"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check);\nstatic int scrub_setup_recheck_block(struct scrub_block *original_sblock,\n\t\t\t\t     struct scrub_block *sblocks_for_recheck);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_write_page_to_dev_replace(struct scrub_block *sblock,\n\t\t\t\t\t   int page_num);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_handle_errored_block(struct scrub_block *sblock_to_check)\n{\n\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tu64 generation;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tu8 *csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->dev_root->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tgeneration = sblock_to_check->pagev[0]->generation;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tcsum = sblock_to_check->pagev[0]->csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kzalloc(BTRFS_MAX_MIRRORS *\n\t\t\t\t     sizeof(*sblocks_for_recheck),\n\t\t\t\t     GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, is_metadata, have_csum,\n\t\t\t    csum, generation, sctx->csum_size, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"i/o error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum error\", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning(\"checksum/header error\",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COW'ed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, is_metadata,\n\t\t\t\t    have_csum, csum, generation,\n\t\t\t\t    sctx->csum_size, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeedes. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&sctx->dev_root->\n\t\t\t\t\tfs_info->dev_replace.\n\t\t\t\t\tnum_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad,\n\t\t\t\t\t    is_metadata, have_csum, csum,\n\t\t\t\t\t    generation, sctx->csum_size, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\t\"BTRFS: fixed up error at logical %llu on dev %s\\n\",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR\n\t\t\t\"BTRFS: unable to fixup (regular) error at logical %llu on dev %s\\n\",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_put_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "872-878",
    "snippet": "static inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "recover"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "recover->bbio"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&recover->refs"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_put_recover(struct scrub_recover *recover)\n{\n\tif (atomic_dec_and_test(&recover->refs)) {\n\t\tbtrfs_put_bbio(recover->bbio);\n\t\tkfree(recover);\n\t}\n}"
  },
  {
    "function_name": "scrub_get_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "867-870",
    "snippet": "static inline void scrub_get_recover(struct scrub_recover *recover)\n{\n\tatomic_inc(&recover->refs);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&recover->refs"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic inline void scrub_get_recover(struct scrub_recover *recover)\n{\n\tatomic_inc(&recover->refs);\n}"
  },
  {
    "function_name": "scrub_fixup_nodatasum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "797-865",
    "snippet": "static void scrub_fixup_nodatasum(struct btrfs_work *work)\n{\n\tint ret;\n\tstruct scrub_fixup_nodatasum *fixup;\n\tstruct scrub_ctx *sctx;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tint uncorrectable = 0;\n\n\tfixup = container_of(work, struct scrub_fixup_nodatasum, work);\n\tsctx = fixup->sctx;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.malloc_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(fixup->root);\n\tif (IS_ERR(trans)) {\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * the idea is to trigger a regular read through the standard path. we\n\t * read a page from the (failed) logical address by specifying the\n\t * corresponding copynum of the failed sector. thus, that readpage is\n\t * expected to fail.\n\t * that is the point where on-the-fly error correction will kick in\n\t * (once it's finished) and rewrite the failed sector if a good copy\n\t * can be found.\n\t */\n\tret = iterate_inodes_from_logical(fixup->logical, fixup->root->fs_info,\n\t\t\t\t\t\tpath, scrub_fixup_readpage,\n\t\t\t\t\t\tfixup);\n\tif (ret < 0) {\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(ret != 1);\n\n\tspin_lock(&sctx->stat_lock);\n\t++sctx->stat.corrected_errors;\n\tspin_unlock(&sctx->stat_lock);\n\nout:\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fixup->root);\n\tif (uncorrectable) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.uncorrectable_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t&sctx->dev_root->fs_info->dev_replace.\n\t\t\tnum_uncorrectable_read_errors);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t    \"unable to fixup (nodatasum) error at logical %llu on dev %s\\n\",\n\t\t\tfixup->logical, rcu_str_deref(fixup->dev->name));\n\t}\n\n\tbtrfs_free_path(path);\n\tkfree(fixup);\n\n\tscrub_pending_trans_workers_dec(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_pending_trans_workers_dec",
          "args": [
            "sctx"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_pending_trans_workers_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "384-400",
          "snippet": "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fixup"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_ERR \"BTRFS: \"\n\t\t    \"unable to fixup (nodatasum) error at logical %llu on dev %s\\n\"",
            "fixup->logical",
            "rcu_str_deref(fixup->dev->name)"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "fixup->dev->name"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_stats_inc",
          "args": [
            "&sctx->dev_root->fs_info->dev_replace.\n\t\t\tnum_uncorrectable_read_errors"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_stats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.h",
          "lines": "40-43",
          "snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_dev_replace_stats_inc(atomic64_t *stat_value)\n{\n\tatomic64_inc(stat_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "fixup->root"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret != 1"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_inodes_from_logical",
          "args": [
            "fixup->logical",
            "fixup->root->fs_info",
            "path",
            "scrub_fixup_readpage",
            "fixup"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inodes_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1667-1690",
          "snippet": "int iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "fixup->root"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structscrub_fixup_nodatasum",
            "work"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_fixup_nodatasum(struct btrfs_work *work)\n{\n\tint ret;\n\tstruct scrub_fixup_nodatasum *fixup;\n\tstruct scrub_ctx *sctx;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tint uncorrectable = 0;\n\n\tfixup = container_of(work, struct scrub_fixup_nodatasum, work);\n\tsctx = fixup->sctx;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.malloc_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(fixup->root);\n\tif (IS_ERR(trans)) {\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * the idea is to trigger a regular read through the standard path. we\n\t * read a page from the (failed) logical address by specifying the\n\t * corresponding copynum of the failed sector. thus, that readpage is\n\t * expected to fail.\n\t * that is the point where on-the-fly error correction will kick in\n\t * (once it's finished) and rewrite the failed sector if a good copy\n\t * can be found.\n\t */\n\tret = iterate_inodes_from_logical(fixup->logical, fixup->root->fs_info,\n\t\t\t\t\t\tpath, scrub_fixup_readpage,\n\t\t\t\t\t\tfixup);\n\tif (ret < 0) {\n\t\tuncorrectable = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(ret != 1);\n\n\tspin_lock(&sctx->stat_lock);\n\t++sctx->stat.corrected_errors;\n\tspin_unlock(&sctx->stat_lock);\n\nout:\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fixup->root);\n\tif (uncorrectable) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.uncorrectable_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t&sctx->dev_root->fs_info->dev_replace.\n\t\t\tnum_uncorrectable_read_errors);\n\t\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t    \"unable to fixup (nodatasum) error at logical %llu on dev %s\\n\",\n\t\t\tfixup->logical, rcu_str_deref(fixup->dev->name));\n\t}\n\n\tbtrfs_free_path(path);\n\tkfree(fixup);\n\n\tscrub_pending_trans_workers_dec(sctx);\n}"
  },
  {
    "function_name": "scrub_fixup_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "679-795",
    "snippet": "static int scrub_fixup_readpage(u64 inum, u64 offset, u64 root, void *fixup_ctx)\n{\n\tstruct page *page = NULL;\n\tunsigned long index;\n\tstruct scrub_fixup_nodatasum *fixup = fixup_ctx;\n\tint ret;\n\tint corrected = 0;\n\tstruct btrfs_key key;\n\tstruct inode *inode = NULL;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 end = offset + PAGE_SIZE - 1;\n\tstruct btrfs_root *local_root;\n\tint srcu_index;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tfs_info = fixup->root->fs_info;\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tindex = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * we need to write the data to the defect sector. the\n\t\t\t * data that was in that sector is not in memory,\n\t\t\t * because the page was modified. we must not write the\n\t\t\t * modified page to that sector.\n\t\t\t *\n\t\t\t * TODO: what could be done here: wait for the delalloc\n\t\t\t *       runner to write out that page (might involve\n\t\t\t *       COW) and see whether the sector is still\n\t\t\t *       referenced afterwards.\n\t\t\t *\n\t\t\t * For the meantime, we'll treat this error\n\t\t\t * incorrectable, although there is a chance that a\n\t\t\t * later scrub will find the bad sector again and that\n\t\t\t * there's no dirty page in memory, then.\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tret = repair_io_failure(inode, offset, PAGE_SIZE,\n\t\t\t\t\tfixup->logical, page,\n\t\t\t\t\toffset - page_offset(page),\n\t\t\t\t\tfixup->mirror_num);\n\t\tunlock_page(page);\n\t\tcorrected = !ret;\n\t} else {\n\t\t/*\n\t\t * we need to get good data first. the general readpage path\n\t\t * will call repair_io_failure for us, we just have to make\n\t\t * sure we read the bad mirror.\n\t\t */\n\t\tret = set_extent_bits(&BTRFS_I(inode)->io_tree, offset, end,\n\t\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\t\tif (ret) {\n\t\t\t/* set_extent_bits should give proper error */\n\t\t\tWARN_ON(ret > 0);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = extent_read_full_page(&BTRFS_I(inode)->io_tree, page,\n\t\t\t\t\t\tbtrfs_get_extent,\n\t\t\t\t\t\tfixup->mirror_num);\n\t\twait_on_page_locked(page);\n\n\t\tcorrected = !test_range_bit(&BTRFS_I(inode)->io_tree, offset,\n\t\t\t\t\t\tend, EXTENT_DAMAGED, 0, NULL);\n\t\tif (!corrected)\n\t\t\tclear_extent_bits(&BTRFS_I(inode)->io_tree, offset, end,\n\t\t\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\t}\n\nout:\n\tif (page)\n\t\tput_page(page);\n\n\tiput(inode);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0 && corrected) {\n\t\t/*\n\t\t * we only need to call readpage for one of the inodes belonging\n\t\t * to this extent. so make iterate_extent_inodes stop\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn -EIO;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "offset",
            "end",
            "EXTENT_DAMAGED",
            "GFP_NOFS"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "offset",
            "end",
            "EXTENT_DAMAGED",
            "0",
            "NULL"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_read_full_page",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page",
            "btrfs_get_extent",
            "fixup->mirror_num"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "extent_read_full_page_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3189-3201",
          "snippet": "int extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret > 0"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "offset",
            "end",
            "EXTENT_DAMAGED",
            "GFP_NOFS"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1270-1275",
          "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repair_io_failure",
          "args": [
            "inode",
            "offset",
            "PAGE_SIZE",
            "fixup->logical",
            "page",
            "offset - page_offset(page)",
            "fixup->mirror_num"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "repair_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2026-2082",
          "snippet": "int repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "srcu_index"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "fs_info->sb",
            "&key",
            "local_root",
            "NULL"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "local_root"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "srcu_index"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "local_root"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&key"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_fixup_readpage(u64 inum, u64 offset, u64 root, void *fixup_ctx)\n{\n\tstruct page *page = NULL;\n\tunsigned long index;\n\tstruct scrub_fixup_nodatasum *fixup = fixup_ctx;\n\tint ret;\n\tint corrected = 0;\n\tstruct btrfs_key key;\n\tstruct inode *inode = NULL;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 end = offset + PAGE_SIZE - 1;\n\tstruct btrfs_root *local_root;\n\tint srcu_index;\n\n\tkey.objectid = root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tfs_info = fixup->root->fs_info;\n\tsrcu_index = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(local_root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\t\treturn PTR_ERR(local_root);\n\t}\n\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.objectid = inum;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, local_root, NULL);\n\tsrcu_read_unlock(&fs_info->subvol_srcu, srcu_index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tindex = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * we need to write the data to the defect sector. the\n\t\t\t * data that was in that sector is not in memory,\n\t\t\t * because the page was modified. we must not write the\n\t\t\t * modified page to that sector.\n\t\t\t *\n\t\t\t * TODO: what could be done here: wait for the delalloc\n\t\t\t *       runner to write out that page (might involve\n\t\t\t *       COW) and see whether the sector is still\n\t\t\t *       referenced afterwards.\n\t\t\t *\n\t\t\t * For the meantime, we'll treat this error\n\t\t\t * incorrectable, although there is a chance that a\n\t\t\t * later scrub will find the bad sector again and that\n\t\t\t * there's no dirty page in memory, then.\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tret = repair_io_failure(inode, offset, PAGE_SIZE,\n\t\t\t\t\tfixup->logical, page,\n\t\t\t\t\toffset - page_offset(page),\n\t\t\t\t\tfixup->mirror_num);\n\t\tunlock_page(page);\n\t\tcorrected = !ret;\n\t} else {\n\t\t/*\n\t\t * we need to get good data first. the general readpage path\n\t\t * will call repair_io_failure for us, we just have to make\n\t\t * sure we read the bad mirror.\n\t\t */\n\t\tret = set_extent_bits(&BTRFS_I(inode)->io_tree, offset, end,\n\t\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\t\tif (ret) {\n\t\t\t/* set_extent_bits should give proper error */\n\t\t\tWARN_ON(ret > 0);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = extent_read_full_page(&BTRFS_I(inode)->io_tree, page,\n\t\t\t\t\t\tbtrfs_get_extent,\n\t\t\t\t\t\tfixup->mirror_num);\n\t\twait_on_page_locked(page);\n\n\t\tcorrected = !test_range_bit(&BTRFS_I(inode)->io_tree, offset,\n\t\t\t\t\t\tend, EXTENT_DAMAGED, 0, NULL);\n\t\tif (!corrected)\n\t\t\tclear_extent_bits(&BTRFS_I(inode)->io_tree, offset, end,\n\t\t\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\t}\n\nout:\n\tif (page)\n\t\tput_page(page);\n\n\tiput(inode);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0 && corrected) {\n\t\t/*\n\t\t * we only need to call readpage for one of the inodes belonging\n\t\t * to this extent. so make iterate_extent_inodes stop\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "scrub_print_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "608-677",
    "snippet": "static void scrub_print_warning(const char *errstr, struct scrub_block *sblock)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct scrub_warning swarn;\n\tunsigned long ptr = 0;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tu64 ref_root;\n\tu32 item_size;\n\tu8 ref_level;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tdev = sblock->pagev[0]->dev;\n\tfs_info = sblock->sctx->dev_root->fs_info;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn;\n\n\tswarn.sector = (sblock->pagev[0]->physical) >> 9;\n\tswarn.logical = sblock->pagev[0]->logical;\n\tswarn.errstr = errstr;\n\tswarn.dev = NULL;\n\n\tret = extent_from_logical(fs_info, swarn.logical, path, &found_key,\n\t\t\t\t  &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\textent_item_pos = swarn.logical - found_key.objectid;\n\tswarn.extent_item_size = found_key.offset;\n\n\teb = path->nodes[0];\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tdo {\n\t\t\tret = tree_backref_for_extent(&ptr, eb, &found_key, ei,\n\t\t\t\t\t\t      item_size, &ref_root,\n\t\t\t\t\t\t      &ref_level);\n\t\t\tprintk_in_rcu(KERN_WARNING\n\t\t\t\t\"BTRFS: %s at logical %llu on dev %s, \"\n\t\t\t\t\"sector %llu: metadata %s (level %d) in tree \"\n\t\t\t\t\"%llu\\n\", errstr, swarn.logical,\n\t\t\t\trcu_str_deref(dev->name),\n\t\t\t\t(unsigned long long)swarn.sector,\n\t\t\t\tref_level ? \"node\" : \"leaf\",\n\t\t\t\tret < 0 ? -1 : ref_level,\n\t\t\t\tret < 0 ? -1 : ref_root);\n\t\t} while (ret != 1);\n\t\tbtrfs_release_path(path);\n\t} else {\n\t\tbtrfs_release_path(path);\n\t\tswarn.path = path;\n\t\tswarn.dev = dev;\n\t\titerate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, 1,\n\t\t\t\t\tscrub_print_warning_inode, &swarn);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_extent_inodes",
          "args": [
            "fs_info",
            "found_key.objectid",
            "extent_item_pos",
            "1",
            "scrub_print_warning_inode",
            "&swarn"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_extent_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1602-1665",
          "snippet": "int iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"BTRFS: %s at logical %llu on dev %s, \"\n\t\t\t\t\"sector %llu: metadata %s (level %d) in tree \"\n\t\t\t\t\"%llu\\n\"",
            "errstr",
            "swarn.logical",
            "rcu_str_deref(dev->name)",
            "(unsigned long long)swarn.sector",
            "ref_level ? \"node\" : \"leaf\"",
            "ret < 0 ? -1 : ref_level",
            "ret < 0 ? -1 : ref_root"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_backref_for_extent",
          "args": [
            "&ptr",
            "eb",
            "&found_key",
            "ei",
            "item_size",
            "&ref_root",
            "&ref_level"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "tree_backref_for_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1531-1573",
          "snippet": "int tree_backref_for_extent(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t    struct btrfs_key *key, struct btrfs_extent_item *ei,\n\t\t\t    u32 item_size, u64 *out_root, u8 *out_level)\n{\n\tint ret;\n\tint type;\n\tstruct btrfs_extent_inline_ref *eiref;\n\n\tif (*ptr == (unsigned long)-1)\n\t\treturn 1;\n\n\twhile (1) {\n\t\tret = __get_extent_inline_ref(ptr, eb, key, ei, item_size,\n\t\t\t\t\t      &eiref, &type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\t\tbreak;\n\n\t\tif (ret == 1)\n\t\t\treturn 1;\n\t}\n\n\t/* we can treat both ref types equally here */\n\t*out_root = btrfs_extent_inline_ref_offset(eb, eiref);\n\n\tif (key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*out_level = btrfs_tree_block_level(eb, info);\n\t} else {\n\t\tASSERT(key->type == BTRFS_METADATA_ITEM_KEY);\n\t\t*out_level = (u8)key->offset;\n\t}\n\n\tif (ret == 1)\n\t\t*ptr = (unsigned long)-1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint tree_backref_for_extent(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t    struct btrfs_key *key, struct btrfs_extent_item *ei,\n\t\t\t    u32 item_size, u64 *out_root, u8 *out_level)\n{\n\tint ret;\n\tint type;\n\tstruct btrfs_extent_inline_ref *eiref;\n\n\tif (*ptr == (unsigned long)-1)\n\t\treturn 1;\n\n\twhile (1) {\n\t\tret = __get_extent_inline_ref(ptr, eb, key, ei, item_size,\n\t\t\t\t\t      &eiref, &type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\t\tbreak;\n\n\t\tif (ret == 1)\n\t\t\treturn 1;\n\t}\n\n\t/* we can treat both ref types equally here */\n\t*out_root = btrfs_extent_inline_ref_offset(eb, eiref);\n\n\tif (key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*out_level = btrfs_tree_block_level(eb, info);\n\t} else {\n\t\tASSERT(key->type == BTRFS_METADATA_ITEM_KEY);\n\t\t*out_level = (u8)key->offset;\n\t}\n\n\tif (ret == 1)\n\t\t*ptr = (unsigned long)-1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "path->slots[0]"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_from_logical",
          "args": [
            "fs_info",
            "swarn.logical",
            "path",
            "&found_key",
            "&flags"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "extent_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1405-1470",
          "snippet": "int extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sblock->page_count < 1"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_print_warning(const char *errstr, struct scrub_block *sblock)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct scrub_warning swarn;\n\tunsigned long ptr = 0;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tu64 ref_root;\n\tu32 item_size;\n\tu8 ref_level;\n\tint ret;\n\n\tWARN_ON(sblock->page_count < 1);\n\tdev = sblock->pagev[0]->dev;\n\tfs_info = sblock->sctx->dev_root->fs_info;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn;\n\n\tswarn.sector = (sblock->pagev[0]->physical) >> 9;\n\tswarn.logical = sblock->pagev[0]->logical;\n\tswarn.errstr = errstr;\n\tswarn.dev = NULL;\n\n\tret = extent_from_logical(fs_info, swarn.logical, path, &found_key,\n\t\t\t\t  &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\textent_item_pos = swarn.logical - found_key.objectid;\n\tswarn.extent_item_size = found_key.offset;\n\n\teb = path->nodes[0];\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tdo {\n\t\t\tret = tree_backref_for_extent(&ptr, eb, &found_key, ei,\n\t\t\t\t\t\t      item_size, &ref_root,\n\t\t\t\t\t\t      &ref_level);\n\t\t\tprintk_in_rcu(KERN_WARNING\n\t\t\t\t\"BTRFS: %s at logical %llu on dev %s, \"\n\t\t\t\t\"sector %llu: metadata %s (level %d) in tree \"\n\t\t\t\t\"%llu\\n\", errstr, swarn.logical,\n\t\t\t\trcu_str_deref(dev->name),\n\t\t\t\t(unsigned long long)swarn.sector,\n\t\t\t\tref_level ? \"node\" : \"leaf\",\n\t\t\t\tret < 0 ? -1 : ref_level,\n\t\t\t\tret < 0 ? -1 : ref_root);\n\t\t} while (ret != 1);\n\t\tbtrfs_release_path(path);\n\t} else {\n\t\tbtrfs_release_path(path);\n\t\tswarn.path = path;\n\t\tswarn.dev = dev;\n\t\titerate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, 1,\n\t\t\t\t\tscrub_print_warning_inode, &swarn);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n}"
  },
  {
    "function_name": "scrub_print_warning_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "525-606",
    "snippet": "static int scrub_print_warning_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t     void *warn_ctx)\n{\n\tu64 isize;\n\tu32 nlink;\n\tint ret;\n\tint i;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct scrub_warning *swarn = warn_ctx;\n\tstruct btrfs_fs_info *fs_info = swarn->dev->dev_root->fs_info;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_root *local_root;\n\tstruct btrfs_key root_key;\n\tstruct btrfs_key key;\n\n\troot_key.objectid = root;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &root_key);\n\tif (IS_ERR(local_root)) {\n\t\tret = PTR_ERR(local_root);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * this makes the path point to (inum INODE_ITEM ioff)\n\t */\n\tkey.objectid = inum;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, local_root, &key, swarn->path, 0, 0);\n\tif (ret) {\n\t\tbtrfs_release_path(swarn->path);\n\t\tgoto err;\n\t}\n\n\teb = swarn->path->nodes[0];\n\tinode_item = btrfs_item_ptr(eb, swarn->path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_item);\n\tisize = btrfs_inode_size(eb, inode_item);\n\tnlink = btrfs_inode_nlink(eb, inode_item);\n\tbtrfs_release_path(swarn->path);\n\n\tipath = init_ipath(4096, local_root, swarn->path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto err;\n\t}\n\tret = paths_from_inode(inum, ipath);\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\t/*\n\t * we deliberately ignore the bit ipath might have been too small to\n\t * hold all of the paths here\n\t */\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i)\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu, \"\n\t\t\t\"length %llu, links %u (path: %s)\\n\", swarn->errstr,\n\t\t\tswarn->logical, rcu_str_deref(swarn->dev->name),\n\t\t\t(unsigned long long)swarn->sector, root, inum, offset,\n\t\t\tmin(isize - offset, (u64)PAGE_SIZE), nlink,\n\t\t\t(char *)(unsigned long)ipath->fspath->val[i]);\n\n\tfree_ipath(ipath);\n\treturn 0;\n\nerr:\n\tprintk_in_rcu(KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu: path \"\n\t\t\"resolving failed with ret=%d\\n\", swarn->errstr,\n\t\tswarn->logical, rcu_str_deref(swarn->dev->name),\n\t\t(unsigned long long)swarn->sector, root, inum, offset, ret);\n\n\tfree_ipath(ipath);\n\treturn 0;\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_bio_end_io(struct bio *bio, int err);",
      "static void scrub_wr_bio_end_io(struct bio *bio, int err);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ipath",
          "args": [
            "ipath"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "free_ipath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1955-1961",
          "snippet": "void free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nvoid free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu: path \"\n\t\t\"resolving failed with ret=%d\\n\"",
            "swarn->errstr",
            "swarn->logical",
            "rcu_str_deref(swarn->dev->name)",
            "(unsigned long long)swarn->sector",
            "root",
            "inum",
            "offset",
            "ret"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "swarn->dev->name"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu, \"\n\t\t\t\"length %llu, links %u (path: %s)\\n\"",
            "swarn->errstr",
            "swarn->logical",
            "rcu_str_deref(swarn->dev->name)",
            "(unsigned long long)swarn->sector",
            "root",
            "inum",
            "offset",
            "min(isize - offset, (u64)PAGE_SIZE)",
            "nlink",
            "(char *)(unsigned long)ipath->fspath->val[i]"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "isize - offset",
            "(u64)PAGE_SIZE"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "swarn->dev->name"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paths_from_inode",
          "args": [
            "inum",
            "ipath"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "paths_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1896-1900",
          "snippet": "int paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipath"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipath"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_ipath",
          "args": [
            "4096",
            "local_root",
            "swarn->path"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "init_ipath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1932-1953",
          "snippet": "struct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "swarn->path"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_nlink",
          "args": [
            "eb",
            "inode_item"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "eb",
            "inode_item"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "swarn->path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "local_root",
            "&key",
            "swarn->path",
            "0",
            "0"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "local_root"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "local_root"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&root_key"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_bio_end_io(struct bio *bio, int err);\nstatic void scrub_wr_bio_end_io(struct bio *bio, int err);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_print_warning_inode(u64 inum, u64 offset, u64 root,\n\t\t\t\t     void *warn_ctx)\n{\n\tu64 isize;\n\tu32 nlink;\n\tint ret;\n\tint i;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct scrub_warning *swarn = warn_ctx;\n\tstruct btrfs_fs_info *fs_info = swarn->dev->dev_root->fs_info;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_root *local_root;\n\tstruct btrfs_key root_key;\n\tstruct btrfs_key key;\n\n\troot_key.objectid = root;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\tlocal_root = btrfs_read_fs_root_no_name(fs_info, &root_key);\n\tif (IS_ERR(local_root)) {\n\t\tret = PTR_ERR(local_root);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * this makes the path point to (inum INODE_ITEM ioff)\n\t */\n\tkey.objectid = inum;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, local_root, &key, swarn->path, 0, 0);\n\tif (ret) {\n\t\tbtrfs_release_path(swarn->path);\n\t\tgoto err;\n\t}\n\n\teb = swarn->path->nodes[0];\n\tinode_item = btrfs_item_ptr(eb, swarn->path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_item);\n\tisize = btrfs_inode_size(eb, inode_item);\n\tnlink = btrfs_inode_nlink(eb, inode_item);\n\tbtrfs_release_path(swarn->path);\n\n\tipath = init_ipath(4096, local_root, swarn->path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto err;\n\t}\n\tret = paths_from_inode(inum, ipath);\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\t/*\n\t * we deliberately ignore the bit ipath might have been too small to\n\t * hold all of the paths here\n\t */\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i)\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu, \"\n\t\t\t\"length %llu, links %u (path: %s)\\n\", swarn->errstr,\n\t\t\tswarn->logical, rcu_str_deref(swarn->dev->name),\n\t\t\t(unsigned long long)swarn->sector, root, inum, offset,\n\t\t\tmin(isize - offset, (u64)PAGE_SIZE), nlink,\n\t\t\t(char *)(unsigned long)ipath->fspath->val[i]);\n\n\tfree_ipath(ipath);\n\treturn 0;\n\nerr:\n\tprintk_in_rcu(KERN_WARNING \"BTRFS: %s at logical %llu on dev \"\n\t\t\"%s, sector %llu, root %llu, inode %llu, offset %llu: path \"\n\t\t\"resolving failed with ret=%d\\n\", swarn->errstr,\n\t\tswarn->logical, rcu_str_deref(swarn->dev->name),\n\t\t(unsigned long long)swarn->sector, root, inum, offset, ret);\n\n\tfree_ipath(ipath);\n\treturn 0;\n}"
  },
  {
    "function_name": "scrub_setup_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "452-523",
    "snippet": "scrub_ctx *scrub_setup_ctx(struct btrfs_device *dev, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint\t\ti;\n\tstruct btrfs_fs_info *fs_info = dev->dev_root->fs_info;\n\tint pages_per_rd_bio;\n\tint ret;\n\n\t/*\n\t * the setting of pages_per_rd_bio is correct for scrub but might\n\t * be wrong for the dev_replace code where we might read from\n\t * different devices in the initial huge bios. However, that\n\t * code is able to correctly handle the case when adding a page\n\t * to a bio fails.\n\t */\n\tif (dev->bdev)\n\t\tpages_per_rd_bio = min_t(int, SCRUB_PAGES_PER_RD_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\telse\n\t\tpages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;\n\tsctx = kzalloc(sizeof(*sctx), GFP_NOFS);\n\tif (!sctx)\n\t\tgoto nomem;\n\tatomic_set(&sctx->refs, 1);\n\tsctx->is_dev_replace = is_dev_replace;\n\tsctx->pages_per_rd_bio = pages_per_rd_bio;\n\tsctx->curr = -1;\n\tsctx->dev_root = dev->dev_root;\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio;\n\n\t\tsbio = kzalloc(sizeof(*sbio), GFP_NOFS);\n\t\tif (!sbio)\n\t\t\tgoto nomem;\n\t\tsctx->bios[i] = sbio;\n\n\t\tsbio->index = i;\n\t\tsbio->sctx = sctx;\n\t\tsbio->page_count = 0;\n\t\tbtrfs_init_work(&sbio->work, btrfs_scrub_helper,\n\t\t\t\tscrub_bio_end_io_worker, NULL, NULL);\n\n\t\tif (i != SCRUB_BIOS_PER_SCTX - 1)\n\t\t\tsctx->bios[i]->next_free = i + 1;\n\t\telse\n\t\t\tsctx->bios[i]->next_free = -1;\n\t}\n\tsctx->first_free = 0;\n\tsctx->nodesize = dev->dev_root->nodesize;\n\tsctx->sectorsize = dev->dev_root->sectorsize;\n\tatomic_set(&sctx->bios_in_flight, 0);\n\tatomic_set(&sctx->workers_pending, 0);\n\tatomic_set(&sctx->cancel_req, 0);\n\tsctx->csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tINIT_LIST_HEAD(&sctx->csum_list);\n\n\tspin_lock_init(&sctx->list_lock);\n\tspin_lock_init(&sctx->stat_lock);\n\tinit_waitqueue_head(&sctx->list_wait);\n\n\tret = scrub_setup_wr_ctx(sctx, &sctx->wr_ctx, fs_info,\n\t\t\t\t fs_info->dev_replace.tgtdev, is_dev_replace);\n\tif (ret) {\n\t\tscrub_free_ctx(sctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn sctx;\n\nnomem:\n\tscrub_free_ctx(sctx);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */",
      "#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);",
      "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
      "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void copy_nocow_pages_worker(struct btrfs_work *work);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_free_ctx",
          "args": [
            "sctx"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "413-443",
          "snippet": "static noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_setup_wr_ctx",
          "args": [
            "sctx",
            "&sctx->wr_ctx",
            "fs_info",
            "fs_info->dev_replace.tgtdev",
            "is_dev_replace"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_setup_wr_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3867-3886",
          "snippet": "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace)\n{\n\tWARN_ON(wr_ctx->wr_curr_bio != NULL);\n\n\tmutex_init(&wr_ctx->wr_lock);\n\twr_ctx->wr_curr_bio = NULL;\n\tif (!is_dev_replace)\n\t\treturn 0;\n\n\tWARN_ON(!dev->bdev);\n\twr_ctx->pages_per_wr_bio = min_t(int, SCRUB_PAGES_PER_WR_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\twr_ctx->tgtdev = dev;\n\tatomic_set(&wr_ctx->flush_all_writes, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_PAGES_PER_WR_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace)\n{\n\tWARN_ON(wr_ctx->wr_curr_bio != NULL);\n\n\tmutex_init(&wr_ctx->wr_lock);\n\twr_ctx->wr_curr_bio = NULL;\n\tif (!is_dev_replace)\n\t\treturn 0;\n\n\tWARN_ON(!dev->bdev);\n\twr_ctx->pages_per_wr_bio = min_t(int, SCRUB_PAGES_PER_WR_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\twr_ctx->tgtdev = dev;\n\tatomic_set(&wr_ctx->flush_all_writes, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sctx->list_wait"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sctx->stat_lock"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sctx->list_lock"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sctx->csum_list"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->cancel_req",
            "0"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->workers_pending",
            "0"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->bios_in_flight",
            "0"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&sbio->work",
            "btrfs_scrub_helper",
            "scrub_bio_end_io_worker",
            "NULL",
            "NULL"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbio)",
            "GFP_NOFS"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sctx->refs",
            "1"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sctx)",
            "GFP_NOFS"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "SCRUB_PAGES_PER_RD_BIO",
            "bio_get_nr_vecs(dev->bdev)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "dev->bdev"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */\n#define SCRUB_PAGES_PER_RD_BIO\t32\t/* 128k per bio */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_recheck_block_checksum(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct scrub_block *sblock,\n\t\t\t\t\t int is_metadata, int have_csum,\n\t\t\t\t\t const u8 *csum, u64 generation,\n\t\t\t\t\t u16 csum_size);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void copy_nocow_pages_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nscrub_ctx *scrub_setup_ctx(struct btrfs_device *dev, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint\t\ti;\n\tstruct btrfs_fs_info *fs_info = dev->dev_root->fs_info;\n\tint pages_per_rd_bio;\n\tint ret;\n\n\t/*\n\t * the setting of pages_per_rd_bio is correct for scrub but might\n\t * be wrong for the dev_replace code where we might read from\n\t * different devices in the initial huge bios. However, that\n\t * code is able to correctly handle the case when adding a page\n\t * to a bio fails.\n\t */\n\tif (dev->bdev)\n\t\tpages_per_rd_bio = min_t(int, SCRUB_PAGES_PER_RD_BIO,\n\t\t\t\t\t bio_get_nr_vecs(dev->bdev));\n\telse\n\t\tpages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;\n\tsctx = kzalloc(sizeof(*sctx), GFP_NOFS);\n\tif (!sctx)\n\t\tgoto nomem;\n\tatomic_set(&sctx->refs, 1);\n\tsctx->is_dev_replace = is_dev_replace;\n\tsctx->pages_per_rd_bio = pages_per_rd_bio;\n\tsctx->curr = -1;\n\tsctx->dev_root = dev->dev_root;\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio;\n\n\t\tsbio = kzalloc(sizeof(*sbio), GFP_NOFS);\n\t\tif (!sbio)\n\t\t\tgoto nomem;\n\t\tsctx->bios[i] = sbio;\n\n\t\tsbio->index = i;\n\t\tsbio->sctx = sctx;\n\t\tsbio->page_count = 0;\n\t\tbtrfs_init_work(&sbio->work, btrfs_scrub_helper,\n\t\t\t\tscrub_bio_end_io_worker, NULL, NULL);\n\n\t\tif (i != SCRUB_BIOS_PER_SCTX - 1)\n\t\t\tsctx->bios[i]->next_free = i + 1;\n\t\telse\n\t\t\tsctx->bios[i]->next_free = -1;\n\t}\n\tsctx->first_free = 0;\n\tsctx->nodesize = dev->dev_root->nodesize;\n\tsctx->sectorsize = dev->dev_root->sectorsize;\n\tatomic_set(&sctx->bios_in_flight, 0);\n\tatomic_set(&sctx->workers_pending, 0);\n\tatomic_set(&sctx->cancel_req, 0);\n\tsctx->csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tINIT_LIST_HEAD(&sctx->csum_list);\n\n\tspin_lock_init(&sctx->list_lock);\n\tspin_lock_init(&sctx->stat_lock);\n\tinit_waitqueue_head(&sctx->list_wait);\n\n\tret = scrub_setup_wr_ctx(sctx, &sctx->wr_ctx, fs_info,\n\t\t\t\t fs_info->dev_replace.tgtdev, is_dev_replace);\n\tif (ret) {\n\t\tscrub_free_ctx(sctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn sctx;\n\nnomem:\n\tscrub_free_ctx(sctx);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "scrub_put_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "445-449",
    "snippet": "static void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_free_ctx",
          "args": [
            "sctx"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "413-443",
          "snippet": "static noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sctx->refs"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}"
  },
  {
    "function_name": "scrub_free_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "413-443",
    "snippet": "static noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */"
    ],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
      "static int scrub_checksum_data(struct scrub_block *sblock);",
      "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
      "static int scrub_checksum_super(struct scrub_block *sblock);",
      "static void scrub_block_get(struct scrub_block *sblock);",
      "static void scrub_block_put(struct scrub_block *sblock);",
      "static void scrub_block_complete(struct scrub_block *sblock);",
      "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sctx"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_free_csums",
          "args": [
            "sctx"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_csums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "402-411",
          "snippet": "static void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbio"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "sbio->bio"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_block_put",
          "args": [
            "sbio->pagev[i]->sblock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2053-2065",
          "snippet": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (atomic_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sbio->pagev[i]->page"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrub_free_wr_ctx",
          "args": [
            "&sctx->wr_ctx"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_free_wr_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3888-3894",
          "snippet": "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx)\n{\n\tmutex_lock(&wr_ctx->wr_lock);\n\tkfree(wr_ctx->wr_curr_bio);\n\twr_ctx->wr_curr_bio = NULL;\n\tmutex_unlock(&wr_ctx->wr_lock);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx)\n{\n\tmutex_lock(&wr_ctx->wr_lock);\n\tkfree(wr_ctx->wr_curr_bio);\n\twr_ctx->wr_curr_bio = NULL;\n\tmutex_unlock(&wr_ctx->wr_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_BIOS_PER_SCTX\t64\t/* 8MB per device in flight */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic void scrub_free_wr_ctx(struct scrub_wr_ctx *wr_ctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic int write_page_nocow(struct scrub_ctx *sctx,\n\t\t\t    u64 physical_for_dev_replace, struct page *page);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack void scrub_free_ctx(struct scrub_ctx *sctx)\n{\n\tint i;\n\n\tif (!sctx)\n\t\treturn;\n\n\tscrub_free_wr_ctx(&sctx->wr_ctx);\n\n\t/* this can happen when scrub is cancelled */\n\tif (sctx->curr != -1) {\n\t\tstruct scrub_bio *sbio = sctx->bios[sctx->curr];\n\n\t\tfor (i = 0; i < sbio->page_count; i++) {\n\t\t\tWARN_ON(!sbio->pagev[i]->page);\n\t\t\tscrub_block_put(sbio->pagev[i]->sblock);\n\t\t}\n\t\tbio_put(sbio->bio);\n\t}\n\n\tfor (i = 0; i < SCRUB_BIOS_PER_SCTX; ++i) {\n\t\tstruct scrub_bio *sbio = sctx->bios[i];\n\n\t\tif (!sbio)\n\t\t\tbreak;\n\t\tkfree(sbio);\n\t}\n\n\tscrub_free_csums(sctx);\n\tkfree(sctx);\n}"
  },
  {
    "function_name": "scrub_free_csums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "402-411",
    "snippet": "static void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sum"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sum->list"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sctx->csum_list",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sctx->csum_list"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_free_csums(struct scrub_ctx *sctx)\n{\n\twhile (!list_empty(&sctx->csum_list)) {\n\t\tstruct btrfs_ordered_sum *sum;\n\t\tsum = list_first_entry(&sctx->csum_list,\n\t\t\t\t       struct btrfs_ordered_sum, list);\n\t\tlist_del(&sum->list);\n\t\tkfree(sum);\n\t}\n}"
  },
  {
    "function_name": "scrub_pending_trans_workers_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "384-400",
    "snippet": "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_put_ctx",
          "args": [
            "sctx"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_put_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "445-449",
          "snippet": "static void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sctx->list_wait"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sctx->workers_pending"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\t/*\n\t * see scrub_pending_trans_workers_inc() why we're pretending\n\t * to be paused in the scrub counters\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_dec(&fs_info->scrubs_running);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\tatomic_dec(&sctx->workers_pending);\n\twake_up(&fs_info->scrub_pause_wait);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
  },
  {
    "function_name": "scrub_pending_trans_workers_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "352-381",
    "snippet": "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sctx->workers_pending"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrubs_running"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sctx->refs"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;\n\n\tatomic_inc(&sctx->refs);\n\t/*\n\t * increment scrubs_running to prevent cancel requests from\n\t * completing as long as a worker is running. we must also\n\t * increment scrubs_paused to prevent deadlocking on pause\n\t * requests used for transactions commits (as the worker uses a\n\t * transaction context). it is safe to regard the worker\n\t * as paused for all matters practical. effectively, we only\n\t * avoid cancellation requests from completing.\n\t */\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrubs_running);\n\tatomic_inc(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * check if @scrubs_running=@scrubs_paused condition\n\t * inside wait_event() is not an atomic operation.\n\t * which means we may inc/dec @scrub_running/paused\n\t * at any time. Let's wake up @scrub_pause_wait as\n\t * much as we can to let commit transaction blocked less.\n\t */\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tatomic_inc(&sctx->workers_pending);\n}"
  },
  {
    "function_name": "scrub_blocked_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "335-346",
    "snippet": "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\tatomic_inc(&fs_info->scrubs_paused);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tmutex_lock(&fs_info->scrub_lock);\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\twake_up(&fs_info->scrub_pause_wait);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scrub_blocked_if_needed",
          "args": [
            "fs_info"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__scrub_blocked_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "325-333",
          "snippet": "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->scrubs_paused"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\tatomic_inc(&fs_info->scrubs_paused);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\tmutex_lock(&fs_info->scrub_lock);\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_dec(&fs_info->scrubs_paused);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\twake_up(&fs_info->scrub_pause_wait);\n}"
  },
  {
    "function_name": "__scrub_blocked_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "325-333",
    "snippet": "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->scrub_pause_wait",
            "atomic_read(&fs_info->scrub_pause_req) == 0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrub_pause_req"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->scrub_pause_req"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\twhile (atomic_read(&fs_info->scrub_pause_req)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t   atomic_read(&fs_info->scrub_pause_req) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n}"
  },
  {
    "function_name": "scrub_pending_bio_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "318-323",
    "snippet": "static void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrub_put_ctx",
          "args": [
            "sctx"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_put_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "445-449",
          "snippet": "static void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (atomic_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sctx->list_wait"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx)\n{\n\tatomic_dec(&sctx->bios_in_flight);\n\twake_up(&sctx->list_wait);\n\tscrub_put_ctx(sctx);\n}"
  },
  {
    "function_name": "scrub_pending_bio_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
    "lines": "312-316",
    "snippet": "static void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}",
    "includes": [
      "#include \"raid56.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"dev-replace.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"transaction.h\"",
      "#include \"ordered-data.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
      "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
      "static void scrub_wr_submit(struct scrub_ctx *sctx);",
      "static void scrub_put_ctx(struct scrub_ctx *sctx);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sctx->bios_in_flight"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sctx->refs"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx)\n{\n\tatomic_inc(&sctx->refs);\n\tatomic_inc(&sctx->bios_in_flight);\n}"
  }
]