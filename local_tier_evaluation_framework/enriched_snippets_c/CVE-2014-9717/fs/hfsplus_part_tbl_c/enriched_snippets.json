[
  {
    "function_name": "hfs_part_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
    "lines": "128-157",
    "snippet": "int hfs_part_find(struct super_block *sb,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tvoid *buf, *data;\n\tint res;\n\n\tbuf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = hfsplus_submit_bio(sb, *part_start + HFS_PMAP_BLK,\n\t\t\t\t buf, &data, READ);\n\tif (res)\n\t\tgoto out;\n\n\tswitch (be16_to_cpu(*((__be16 *)data))) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t\tres = hfs_parse_old_pmap(sb, data, part_start, part_size);\n\t\tbreak;\n\tcase HFS_NEW_PMAP_MAGIC:\n\t\tres = hfs_parse_new_pmap(sb, buf, data, part_start, part_size);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENOENT;\n\t\tbreak;\n\t}\nout:\n\tkfree(buf);\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */",
      "#define HFS_OLD_PMAP_MAGIC\t0x5453 /* \"TS\": old-type partition map */",
      "#define HFS_PMAP_BLK\t\t1 /* First block of partition map */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_parse_new_pmap",
          "args": [
            "sb",
            "buf",
            "data",
            "part_start",
            "part_size"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_parse_new_pmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
          "lines": "91-122",
          "snippet": "static int hfs_parse_new_pmap(struct super_block *sb, void *buf,\n\t\tstruct new_pmap *pm, sector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint size = be32_to_cpu(pm->pmMapBlkCnt);\n\tint buf_size = hfsplus_min_io_size(sb);\n\tint res;\n\tint i = 0;\n\n\tdo {\n\t\tif (!memcmp(pm->pmPartType, \"Apple_HFS\", 9) &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++i >= size)\n\t\t\treturn -ENOENT;\n\n\t\tpm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);\n\t\tif ((u8 *)pm - (u8 *)buf >= buf_size) {\n\t\t\tres = hfsplus_submit_bio(sb,\n\t\t\t\t\t\t *part_start + HFS_PMAP_BLK + i,\n\t\t\t\t\t\t buf, (void **)&pm, READ);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));\n\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */",
            "#define HFS_PMAP_BLK\t\t1 /* First block of partition map */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\n#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */\n#define HFS_PMAP_BLK\t\t1 /* First block of partition map */\n\nstatic int hfs_parse_new_pmap(struct super_block *sb, void *buf,\n\t\tstruct new_pmap *pm, sector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint size = be32_to_cpu(pm->pmMapBlkCnt);\n\tint buf_size = hfsplus_min_io_size(sb);\n\tint res;\n\tint i = 0;\n\n\tdo {\n\t\tif (!memcmp(pm->pmPartType, \"Apple_HFS\", 9) &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++i >= size)\n\t\t\treturn -ENOENT;\n\n\t\tpm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);\n\t\tif ((u8 *)pm - (u8 *)buf >= buf_size) {\n\t\t\tres = hfsplus_submit_bio(sb,\n\t\t\t\t\t\t *part_start + HFS_PMAP_BLK + i,\n\t\t\t\t\t\t buf, (void **)&pm, READ);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));\n\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_parse_old_pmap",
          "args": [
            "sb",
            "data",
            "part_start",
            "part_size"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_parse_old_pmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
          "lines": "70-89",
          "snippet": "static int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint i;\n\n\tfor (i = 0; i < 42; i++) {\n\t\tstruct old_pmap_entry *p = &pm->pdEntry[i];\n\n\t\tif (p->pdStart && p->pdSize &&\n\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct old_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nstruct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct old_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;\n\nstatic int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint i;\n\n\tfor (i = 0; i < 42; i++) {\n\t\tstruct old_pmap_entry *p = &pm->pdEntry[i];\n\n\t\tif (p->pdStart && p->pdSize &&\n\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*((__be16 *)data)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_submit_bio",
          "args": [
            "sb",
            "*part_start + HFS_PMAP_BLK",
            "buf",
            "&data",
            "READ"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "46-90",
          "snippet": "int hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hfsplus_min_io_size(sb)",
            "GFP_KERNEL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_min_io_size",
          "args": [
            "sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_min_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "304-308",
          "snippet": "static inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\n#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */\n#define HFS_OLD_PMAP_MAGIC\t0x5453 /* \"TS\": old-type partition map */\n#define HFS_PMAP_BLK\t\t1 /* First block of partition map */\n\nint hfs_part_find(struct super_block *sb,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tvoid *buf, *data;\n\tint res;\n\n\tbuf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = hfsplus_submit_bio(sb, *part_start + HFS_PMAP_BLK,\n\t\t\t\t buf, &data, READ);\n\tif (res)\n\t\tgoto out;\n\n\tswitch (be16_to_cpu(*((__be16 *)data))) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t\tres = hfs_parse_old_pmap(sb, data, part_start, part_size);\n\t\tbreak;\n\tcase HFS_NEW_PMAP_MAGIC:\n\t\tres = hfs_parse_new_pmap(sb, buf, data, part_start, part_size);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENOENT;\n\t\tbreak;\n\t}\nout:\n\tkfree(buf);\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_parse_new_pmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
    "lines": "91-122",
    "snippet": "static int hfs_parse_new_pmap(struct super_block *sb, void *buf,\n\t\tstruct new_pmap *pm, sector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint size = be32_to_cpu(pm->pmMapBlkCnt);\n\tint buf_size = hfsplus_min_io_size(sb);\n\tint res;\n\tint i = 0;\n\n\tdo {\n\t\tif (!memcmp(pm->pmPartType, \"Apple_HFS\", 9) &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++i >= size)\n\t\t\treturn -ENOENT;\n\n\t\tpm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);\n\t\tif ((u8 *)pm - (u8 *)buf >= buf_size) {\n\t\t\tres = hfsplus_submit_bio(sb,\n\t\t\t\t\t\t *part_start + HFS_PMAP_BLK + i,\n\t\t\t\t\t\t buf, (void **)&pm, READ);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */",
      "#define HFS_PMAP_BLK\t\t1 /* First block of partition map */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_NEW_PMAP_MAGIC"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_submit_bio",
          "args": [
            "sb",
            "*part_start + HFS_PMAP_BLK + i",
            "buf",
            "(void **)&pm",
            "READ"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "46-90",
          "snippet": "int hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pm->pmPartBlkCnt"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pm->pmPyPartStart"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "pm->pmPartType",
            "\"Apple_HFS\"",
            "9"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_min_io_size",
          "args": [
            "sb"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_min_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "304-308",
          "snippet": "static inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pm->pmMapBlkCnt"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\n#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */\n#define HFS_PMAP_BLK\t\t1 /* First block of partition map */\n\nstatic int hfs_parse_new_pmap(struct super_block *sb, void *buf,\n\t\tstruct new_pmap *pm, sector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint size = be32_to_cpu(pm->pmMapBlkCnt);\n\tint buf_size = hfsplus_min_io_size(sb);\n\tint res;\n\tint i = 0;\n\n\tdo {\n\t\tif (!memcmp(pm->pmPartType, \"Apple_HFS\", 9) &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++i >= size)\n\t\t\treturn -ENOENT;\n\n\t\tpm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);\n\t\tif ((u8 *)pm - (u8 *)buf >= buf_size) {\n\t\t\tres = hfsplus_submit_bio(sb,\n\t\t\t\t\t\t *part_start + HFS_PMAP_BLK + i,\n\t\t\t\t\t\t buf, (void **)&pm, READ);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "hfs_parse_old_pmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
    "lines": "70-89",
    "snippet": "static int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint i;\n\n\tfor (i = 0; i < 42; i++) {\n\t\tstruct old_pmap_entry *p = &pm->pdEntry[i];\n\n\t\tif (p->pdStart && p->pdSize &&\n\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct old_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "p->pdSize"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "p->pdStart"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0x54465331"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nstruct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct old_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;\n\nstatic int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint i;\n\n\tfor (i = 0; i < 42; i++) {\n\t\tstruct old_pmap_entry *p = &pm->pdEntry[i];\n\n\t\tif (p->pdStart && p->pdSize &&\n\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}"
  }
]