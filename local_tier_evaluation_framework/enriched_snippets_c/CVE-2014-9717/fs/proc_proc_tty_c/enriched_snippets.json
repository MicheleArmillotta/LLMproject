[
  {
    "function_name": "proc_tty_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "175-189",
    "snippet": "void __init proc_tty_init(void)\n{\n\tif (!proc_mkdir(\"tty\", NULL))\n\t\treturn;\n\tproc_mkdir(\"tty/ldisc\", NULL);\t/* Preserved: it's userspace visible */\n\t/*\n\t * /proc/tty/driver/serial reveals the exact character counts for\n\t * serial links which is just too easy to abuse for inferring\n\t * password lengths and inter-keystroke timings during password\n\t * entry.\n\t */\n\tproc_tty_driver = proc_mkdir_mode(\"tty/driver\", S_IRUSR|S_IXUSR, NULL);\n\tproc_create(\"tty/ldiscs\", 0, NULL, &tty_ldiscs_proc_fops);\n\tproc_create(\"tty/drivers\", 0, NULL, &proc_tty_drivers_operations);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_tty_driver;",
      "static const struct file_operations proc_tty_drivers_operations = {\n\t.open\t\t= tty_drivers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"tty/drivers\"",
            "0",
            "NULL",
            "&proc_tty_drivers_operations"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir_mode",
          "args": [
            "\"tty/driver\"",
            "S_IRUSR|S_IXUSR",
            "NULL"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "444-448",
          "snippet": "struct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,\n\t\t\t\t       struct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, mode, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,\n\t\t\t\t       struct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, mode, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"tty/ldisc\"",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic struct proc_dir_entry *proc_tty_driver;\nstatic const struct file_operations proc_tty_drivers_operations = {\n\t.open\t\t= tty_drivers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nvoid __init proc_tty_init(void)\n{\n\tif (!proc_mkdir(\"tty\", NULL))\n\t\treturn;\n\tproc_mkdir(\"tty/ldisc\", NULL);\t/* Preserved: it's userspace visible */\n\t/*\n\t * /proc/tty/driver/serial reveals the exact character counts for\n\t * serial links which is just too easy to abuse for inferring\n\t * password lengths and inter-keystroke timings during password\n\t * entry.\n\t */\n\tproc_tty_driver = proc_mkdir_mode(\"tty/driver\", S_IRUSR|S_IXUSR, NULL);\n\tproc_create(\"tty/ldiscs\", 0, NULL, &tty_ldiscs_proc_fops);\n\tproc_create(\"tty/drivers\", 0, NULL, &proc_tty_drivers_operations);\n}"
  },
  {
    "function_name": "proc_tty_unregister_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "159-170",
    "snippet": "void proc_tty_unregister_driver(struct tty_driver *driver)\n{\n\tstruct proc_dir_entry *ent;\n\n\tent = driver->proc_entry;\n\tif (!ent)\n\t\treturn;\n\t\t\n\tremove_proc_entry(driver->driver_name, proc_tty_driver);\n\t\n\tdriver->proc_entry = NULL;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_tty_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "driver->driver_name",
            "proc_tty_driver"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic struct proc_dir_entry *proc_tty_driver;\n\nvoid proc_tty_unregister_driver(struct tty_driver *driver)\n{\n\tstruct proc_dir_entry *ent;\n\n\tent = driver->proc_entry;\n\tif (!ent)\n\t\treturn;\n\t\t\n\tremove_proc_entry(driver->driver_name, proc_tty_driver);\n\t\n\tdriver->proc_entry = NULL;\n}"
  },
  {
    "function_name": "proc_tty_register_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "143-154",
    "snippet": "void proc_tty_register_driver(struct tty_driver *driver)\n{\n\tstruct proc_dir_entry *ent;\n\t\t\n\tif (!driver->driver_name || driver->proc_entry ||\n\t    !driver->ops->proc_fops)\n\t\treturn;\n\n\tent = proc_create_data(driver->driver_name, 0, proc_tty_driver,\n\t\t\t       driver->ops->proc_fops, driver);\n\tdriver->proc_entry = ent;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_tty_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "driver->driver_name",
            "0",
            "proc_tty_driver",
            "driver->ops->proc_fops",
            "driver"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic struct proc_dir_entry *proc_tty_driver;\n\nvoid proc_tty_register_driver(struct tty_driver *driver)\n{\n\tstruct proc_dir_entry *ent;\n\t\t\n\tif (!driver->driver_name || driver->proc_entry ||\n\t    !driver->ops->proc_fops)\n\t\treturn;\n\n\tent = proc_create_data(driver->driver_name, 0, proc_tty_driver,\n\t\t\t       driver->ops->proc_fops, driver);\n\tdriver->proc_entry = ent;\n}"
  },
  {
    "function_name": "tty_drivers_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "127-130",
    "snippet": "static int tty_drivers_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &tty_drivers_op);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations tty_drivers_op = {\n\t.start\t= t_start,\n\t.next\t= t_next,\n\t.stop\t= t_stop,\n\t.show\t= show_tty_driver\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&tty_drivers_op"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic const struct seq_operations tty_drivers_op = {\n\t.start\t= t_start,\n\t.next\t= t_next,\n\t.stop\t= t_stop,\n\t.show\t= show_tty_driver\n};\n\nstatic int tty_drivers_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &tty_drivers_op);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "115-118",
    "snippet": "static void t_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&tty_mutex);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tty_mutex"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic void t_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&tty_mutex);\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "110-113",
    "snippet": "static void *t_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &tty_drivers, pos);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&tty_drivers",
            "pos"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic void *t_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &tty_drivers, pos);\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "104-108",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&tty_mutex);\n\treturn seq_list_start(&tty_drivers, *pos);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&tty_drivers",
            "*pos"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tty_mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&tty_mutex);\n\treturn seq_list_start(&tty_drivers, *pos);\n}"
  },
  {
    "function_name": "show_tty_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "67-101",
    "snippet": "static int show_tty_driver(struct seq_file *m, void *v)\n{\n\tstruct tty_driver *p = list_entry(v, struct tty_driver, tty_drivers);\n\tdev_t from = MKDEV(p->major, p->minor_start);\n\tdev_t to = from + p->num;\n\n\tif (&p->tty_drivers == tty_drivers.next) {\n\t\t/* pseudo-drivers first */\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/tty\", \"tty\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 0);\n\t\tseq_puts(m, \"system:/dev/tty\\n\");\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/console\", \"console\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 1);\n\t\tseq_puts(m, \"system:console\\n\");\n#ifdef CONFIG_UNIX98_PTYS\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/ptmx\", \"ptmx\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 2);\n\t\tseq_puts(m, \"system\\n\");\n#endif\n#ifdef CONFIG_VT\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/vc/0\", \"vc/0\");\n\t\tseq_printf(m, \"%3d %7d \", TTY_MAJOR, 0);\n\t\tseq_puts(m, \"system:vtmaster\\n\");\n#endif\n\t}\n\n\twhile (MAJOR(from) < MAJOR(to)) {\n\t\tdev_t next = MKDEV(MAJOR(from)+1, 0);\n\t\tshow_tty_range(m, p, from, next - from);\n\t\tfrom = next;\n\t}\n\tif (from != to)\n\t\tshow_tty_range(m, p, from, to - from);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_tty_range",
          "args": [
            "m",
            "p",
            "from",
            "to - from"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "show_tty_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
          "lines": "26-65",
          "snippet": "static void show_tty_range(struct seq_file *m, struct tty_driver *p,\n\tdev_t from, int num)\n{\n\tseq_printf(m, \"%-20s \", p->driver_name ? p->driver_name : \"unknown\");\n\tseq_printf(m, \"/dev/%-8s \", p->name);\n\tif (p->num > 1) {\n\t\tseq_printf(m, \"%3d %d-%d \", MAJOR(from), MINOR(from),\n\t\t\tMINOR(from) + num - 1);\n\t} else {\n\t\tseq_printf(m, \"%3d %7d \", MAJOR(from), MINOR(from));\n\t}\n\tswitch (p->type) {\n\tcase TTY_DRIVER_TYPE_SYSTEM:\n\t\tseq_puts(m, \"system\");\n\t\tif (p->subtype == SYSTEM_TYPE_TTY)\n\t\t\tseq_puts(m, \":/dev/tty\");\n\t\telse if (p->subtype == SYSTEM_TYPE_SYSCONS)\n\t\t\tseq_puts(m, \":console\");\n\t\telse if (p->subtype == SYSTEM_TYPE_CONSOLE)\n\t\t\tseq_puts(m, \":vtmaster\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_CONSOLE:\n\t\tseq_puts(m, \"console\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_SERIAL:\n\t\tseq_puts(m, \"serial\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_PTY:\n\t\tif (p->subtype == PTY_TYPE_MASTER)\n\t\t\tseq_puts(m, \"pty:master\");\n\t\telse if (p->subtype == PTY_TYPE_SLAVE)\n\t\t\tseq_puts(m, \"pty:slave\");\n\t\telse\n\t\t\tseq_puts(m, \"pty\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"type:%d.%d\", p->type, p->subtype);\n\t}\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic void show_tty_range(struct seq_file *m, struct tty_driver *p,\n\tdev_t from, int num)\n{\n\tseq_printf(m, \"%-20s \", p->driver_name ? p->driver_name : \"unknown\");\n\tseq_printf(m, \"/dev/%-8s \", p->name);\n\tif (p->num > 1) {\n\t\tseq_printf(m, \"%3d %d-%d \", MAJOR(from), MINOR(from),\n\t\t\tMINOR(from) + num - 1);\n\t} else {\n\t\tseq_printf(m, \"%3d %7d \", MAJOR(from), MINOR(from));\n\t}\n\tswitch (p->type) {\n\tcase TTY_DRIVER_TYPE_SYSTEM:\n\t\tseq_puts(m, \"system\");\n\t\tif (p->subtype == SYSTEM_TYPE_TTY)\n\t\t\tseq_puts(m, \":/dev/tty\");\n\t\telse if (p->subtype == SYSTEM_TYPE_SYSCONS)\n\t\t\tseq_puts(m, \":console\");\n\t\telse if (p->subtype == SYSTEM_TYPE_CONSOLE)\n\t\t\tseq_puts(m, \":vtmaster\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_CONSOLE:\n\t\tseq_puts(m, \"console\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_SERIAL:\n\t\tseq_puts(m, \"serial\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_PTY:\n\t\tif (p->subtype == PTY_TYPE_MASTER)\n\t\t\tseq_puts(m, \"pty:master\");\n\t\telse if (p->subtype == PTY_TYPE_SLAVE)\n\t\t\tseq_puts(m, \"pty:slave\");\n\t\telse\n\t\t\tseq_puts(m, \"pty\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"type:%d.%d\", p->type, p->subtype);\n\t}\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "MAJOR(from)+1",
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "from"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "to"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "from"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"system:vtmaster\\n\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3d %7d \"",
            "TTY_MAJOR",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "p->major",
            "p->minor_start"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structtty_driver",
            "tty_drivers"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic int show_tty_driver(struct seq_file *m, void *v)\n{\n\tstruct tty_driver *p = list_entry(v, struct tty_driver, tty_drivers);\n\tdev_t from = MKDEV(p->major, p->minor_start);\n\tdev_t to = from + p->num;\n\n\tif (&p->tty_drivers == tty_drivers.next) {\n\t\t/* pseudo-drivers first */\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/tty\", \"tty\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 0);\n\t\tseq_puts(m, \"system:/dev/tty\\n\");\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/console\", \"console\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 1);\n\t\tseq_puts(m, \"system:console\\n\");\n#ifdef CONFIG_UNIX98_PTYS\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/ptmx\", \"ptmx\");\n\t\tseq_printf(m, \"%3d %7d \", TTYAUX_MAJOR, 2);\n\t\tseq_puts(m, \"system\\n\");\n#endif\n#ifdef CONFIG_VT\n\t\tseq_printf(m, \"%-20s /dev/%-8s \", \"/dev/vc/0\", \"vc/0\");\n\t\tseq_printf(m, \"%3d %7d \", TTY_MAJOR, 0);\n\t\tseq_puts(m, \"system:vtmaster\\n\");\n#endif\n\t}\n\n\twhile (MAJOR(from) < MAJOR(to)) {\n\t\tdev_t next = MKDEV(MAJOR(from)+1, 0);\n\t\tshow_tty_range(m, p, from, next - from);\n\t\tfrom = next;\n\t}\n\tif (from != to)\n\t\tshow_tty_range(m, p, from, to - from);\n\treturn 0;\n}"
  },
  {
    "function_name": "show_tty_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
    "lines": "26-65",
    "snippet": "static void show_tty_range(struct seq_file *m, struct tty_driver *p,\n\tdev_t from, int num)\n{\n\tseq_printf(m, \"%-20s \", p->driver_name ? p->driver_name : \"unknown\");\n\tseq_printf(m, \"/dev/%-8s \", p->name);\n\tif (p->num > 1) {\n\t\tseq_printf(m, \"%3d %d-%d \", MAJOR(from), MINOR(from),\n\t\t\tMINOR(from) + num - 1);\n\t} else {\n\t\tseq_printf(m, \"%3d %7d \", MAJOR(from), MINOR(from));\n\t}\n\tswitch (p->type) {\n\tcase TTY_DRIVER_TYPE_SYSTEM:\n\t\tseq_puts(m, \"system\");\n\t\tif (p->subtype == SYSTEM_TYPE_TTY)\n\t\t\tseq_puts(m, \":/dev/tty\");\n\t\telse if (p->subtype == SYSTEM_TYPE_SYSCONS)\n\t\t\tseq_puts(m, \":console\");\n\t\telse if (p->subtype == SYSTEM_TYPE_CONSOLE)\n\t\t\tseq_puts(m, \":vtmaster\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_CONSOLE:\n\t\tseq_puts(m, \"console\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_SERIAL:\n\t\tseq_puts(m, \"serial\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_PTY:\n\t\tif (p->subtype == PTY_TYPE_MASTER)\n\t\t\tseq_puts(m, \"pty:master\");\n\t\telse if (p->subtype == PTY_TYPE_SLAVE)\n\t\t\tseq_puts(m, \"pty:slave\");\n\t\telse\n\t\t\tseq_puts(m, \"pty\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"type:%d.%d\", p->type, p->subtype);\n\t}\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"type:%d.%d\"",
            "p->type",
            "p->subtype"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"pty\""
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "from"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "from"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "from"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "from"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "from"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic void show_tty_range(struct seq_file *m, struct tty_driver *p,\n\tdev_t from, int num)\n{\n\tseq_printf(m, \"%-20s \", p->driver_name ? p->driver_name : \"unknown\");\n\tseq_printf(m, \"/dev/%-8s \", p->name);\n\tif (p->num > 1) {\n\t\tseq_printf(m, \"%3d %d-%d \", MAJOR(from), MINOR(from),\n\t\t\tMINOR(from) + num - 1);\n\t} else {\n\t\tseq_printf(m, \"%3d %7d \", MAJOR(from), MINOR(from));\n\t}\n\tswitch (p->type) {\n\tcase TTY_DRIVER_TYPE_SYSTEM:\n\t\tseq_puts(m, \"system\");\n\t\tif (p->subtype == SYSTEM_TYPE_TTY)\n\t\t\tseq_puts(m, \":/dev/tty\");\n\t\telse if (p->subtype == SYSTEM_TYPE_SYSCONS)\n\t\t\tseq_puts(m, \":console\");\n\t\telse if (p->subtype == SYSTEM_TYPE_CONSOLE)\n\t\t\tseq_puts(m, \":vtmaster\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_CONSOLE:\n\t\tseq_puts(m, \"console\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_SERIAL:\n\t\tseq_puts(m, \"serial\");\n\t\tbreak;\n\tcase TTY_DRIVER_TYPE_PTY:\n\t\tif (p->subtype == PTY_TYPE_MASTER)\n\t\t\tseq_puts(m, \"pty:master\");\n\t\telse if (p->subtype == PTY_TYPE_SLAVE)\n\t\t\tseq_puts(m, \"pty:slave\");\n\t\telse\n\t\t\tseq_puts(m, \"pty\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"type:%d.%d\", p->type, p->subtype);\n\t}\n\tseq_putc(m, '\\n');\n}"
  }
]