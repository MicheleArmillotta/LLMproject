[
  {
    "function_name": "xfs_qm_dqrele_all_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "939-946",
    "snippet": "void\nxfs_qm_dqrele_all_inodes(\n\tstruct xfs_mount *mp,\n\tuint\t\t flags)\n{\n\tASSERT(mp->m_quotainfo);\n\txfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_ag_iterator",
          "args": [
            "mp",
            "xfs_dqrele_inode",
            "flags",
            "NULL"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_ag_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "637-662",
          "snippet": "int\nxfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_quotainfo"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nvoid\nxfs_qm_dqrele_all_inodes(\n\tstruct xfs_mount *mp,\n\tuint\t\t flags)\n{\n\tASSERT(mp->m_quotainfo);\n\txfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\n}"
  },
  {
    "function_name": "xfs_dqrele_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "899-930",
    "snippet": "STATIC int\nxfs_dqrele_inode(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\t/* skip quota inodes */\n\tif (ip == ip->i_mount->m_quotainfo->qi_uquotaip ||\n\t    ip == ip->i_mount->m_quotainfo->qi_gquotaip ||\n\t    ip == ip->i_mount->m_quotainfo->qi_pquotaip) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\treturn 0;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif ((flags & XFS_UQUOTA_ACCT) && ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif ((flags & XFS_GQUOTA_ACCT) && ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif ((flags & XFS_PQUOTA_ACCT) && ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_pdquot == NULL"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_gdquot == NULL"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_udquot == NULL"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\nxfs_dqrele_inode(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\t/* skip quota inodes */\n\tif (ip == ip->i_mount->m_quotainfo->qi_uquotaip ||\n\t    ip == ip->i_mount->m_quotainfo->qi_gquotaip ||\n\t    ip == ip->i_mount->m_quotainfo->qi_pquotaip) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\treturn 0;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif ((flags & XFS_UQUOTA_ACCT) && ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif ((flags & XFS_GQUOTA_ACCT) && ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif ((flags & XFS_PQUOTA_ACCT) && ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_export_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "876-896",
    "snippet": "STATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}"
  },
  {
    "function_name": "xfs_qm_scall_getquota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "791-874",
    "snippet": "int\nxfs_qm_scall_getquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t/*\n\t * Try to get the dquot. We don't want it allocated on disk, so\n\t * we aren't passing the XFS_QMOPT_DOALLOC flag. If it doesn't\n\t * exist, we'll get ENOENT back.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, 0, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If everything's NULL, this dquot doesn't quite exist as far as\n\t * our utility programs are concerned.\n\t */\n\tif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\terror = -ENOENT;\n\t\tgoto out_put;\n\t}\n\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->d_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\n\tdst->d_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\n\tdst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tdst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\tdst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);\n\tdst->d_ino_count = dqp->q_res_icount;\n\tdst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);\n\tdst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);\n\tdst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);\n\tdst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);\n\tdst->d_rt_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\n\tdst->d_rt_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\n\tdst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);\n\tdst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\tdst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\n\t/*\n\t * Internally, we don't reset all the timers when quota enforcement\n\t * gets turned off. No need to confuse the user level code,\n\t * so return zeroes in that case.\n\t */\n\tif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_USER) ||\n\t    (!XFS_IS_GQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_GROUP) ||\n\t    (!XFS_IS_PQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_PROJ)) {\n\t\tdst->d_spc_timer = 0;\n\t\tdst->d_ino_timer = 0;\n\t\tdst->d_rt_spc_timer = 0;\n\t}\n\n#ifdef DEBUG\n\tif (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&\n\t    id != 0) {\n\t\tif ((dst->d_space > dst->d_spc_softlimit) &&\n\t\t    (dst->d_spc_softlimit > 0)) {\n\t\t\tASSERT(dst->d_spc_timer != 0);\n\t\t}\n\t\tif ((dst->d_ino_count > dst->d_ino_softlimit) &&\n\t\t    (dst->d_ino_softlimit > 0)) {\n\t\t\tASSERT(dst->d_ino_timer != 0);\n\t\t}\n\t}\n#endif\nout_put:\n\txfs_qm_dqput(dqp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqput",
          "args": [
            "dqp"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "839-856",
          "snippet": "void\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dst->d_ino_timer != 0"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dst->d_spc_timer != 0"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ENFORCED",
          "args": [
            "mp"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_rtbwarns"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_rtbtimer"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "dqp->q_res_rtbcount"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "be64_to_cpu(dqp->q_core.d_rtb_softlimit)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtb_softlimit"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "be64_to_cpu(dqp->q_core.d_rtb_hardlimit)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtb_hardlimit"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_bwarns"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_iwarns"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_itimer"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_btimer"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "dqp->q_res_bcount"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_softlimit"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_hardlimit"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "be64_to_cpu(dqp->q_core.d_blk_softlimit)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_softlimit"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "be64_to_cpu(dqp->q_core.d_blk_hardlimit)"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_hardlimit"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "sizeof(*dst)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_DQUOT_UNINITIALIZED",
          "args": [
            "dqp"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "mp",
            "NULL",
            "id",
            "type",
            "0",
            "&dqp"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_getquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t/*\n\t * Try to get the dquot. We don't want it allocated on disk, so\n\t * we aren't passing the XFS_QMOPT_DOALLOC flag. If it doesn't\n\t * exist, we'll get ENOENT back.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, 0, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If everything's NULL, this dquot doesn't quite exist as far as\n\t * our utility programs are concerned.\n\t */\n\tif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\terror = -ENOENT;\n\t\tgoto out_put;\n\t}\n\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->d_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\n\tdst->d_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\n\tdst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tdst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\tdst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);\n\tdst->d_ino_count = dqp->q_res_icount;\n\tdst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);\n\tdst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);\n\tdst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);\n\tdst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);\n\tdst->d_rt_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\n\tdst->d_rt_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\n\tdst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);\n\tdst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\tdst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\n\t/*\n\t * Internally, we don't reset all the timers when quota enforcement\n\t * gets turned off. No need to confuse the user level code,\n\t * so return zeroes in that case.\n\t */\n\tif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_USER) ||\n\t    (!XFS_IS_GQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_GROUP) ||\n\t    (!XFS_IS_PQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_PROJ)) {\n\t\tdst->d_spc_timer = 0;\n\t\tdst->d_ino_timer = 0;\n\t\tdst->d_rt_spc_timer = 0;\n\t}\n\n#ifdef DEBUG\n\tif (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&\n\t    id != 0) {\n\t\tif ((dst->d_space > dst->d_spc_softlimit) &&\n\t\t    (dst->d_spc_softlimit > 0)) {\n\t\t\tASSERT(dst->d_spc_timer != 0);\n\t\t}\n\t\tif ((dst->d_ino_count > dst->d_ino_softlimit) &&\n\t\t    (dst->d_ino_softlimit > 0)) {\n\t\t\tASSERT(dst->d_ino_timer != 0);\n\t\t}\n\t}\n#endif\nout_put:\n\txfs_qm_dqput(dqp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_log_quotaoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "747-788",
    "snippet": "STATIC int\nxfs_qm_log_quotaoff(\n\txfs_mount_t\t       *mp,\n\txfs_qoff_logitem_t     **qoffstartp,\n\tuint\t\t       flags)\n{\n\txfs_trans_t\t       *tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t     *qoffi;\n\n\t*qoffstartp = NULL;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_quotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\txfs_log_sb(tp);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out;\n\n\t*qoffstartp = qoffi;\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_sb",
          "args": [
            "tp"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1083-1100",
          "snippet": "int\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_quotaoff_item",
          "args": [
            "tp",
            "qoffi"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_quotaoff_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "863-870",
          "snippet": "void\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_qoff_item",
          "args": [
            "tp",
            "NULL",
            "flags & XFS_ALL_QUOTA_ACCT"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_qoff_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "837-855",
          "snippet": "xfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nxfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_qm_quotaoff",
            "0",
            "0"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_QM_QUOTAOFF"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC int\nxfs_qm_log_quotaoff(\n\txfs_mount_t\t       *mp,\n\txfs_qoff_logitem_t     **qoffstartp,\n\tuint\t\t       flags)\n{\n\txfs_trans_t\t       *tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t     *qoffi;\n\n\t*qoffstartp = NULL;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_quotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\txfs_log_sb(tp);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out;\n\n\t*qoffstartp = qoffi;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_log_quotaoff_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "714-744",
    "snippet": "STATIC int\nxfs_qm_log_quotaoff_end(\n\txfs_mount_t\t\t*mp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t\t*qoffi;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF_END);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_equotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, startqoff,\n\t\t\t\t\tflags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_quotaoff_item",
          "args": [
            "tp",
            "qoffi"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_quotaoff_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "863-870",
          "snippet": "void\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_qoff_item",
          "args": [
            "tp",
            "startqoff",
            "flags & XFS_ALL_QUOTA_ACCT"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_qoff_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "837-855",
          "snippet": "xfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nxfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_qm_equotaoff",
            "0",
            "0"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_QM_QUOTAOFF_END"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC int\nxfs_qm_log_quotaoff_end(\n\txfs_mount_t\t\t*mp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t\t*qoffi;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF_END);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_equotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, startqoff,\n\t\t\t\t\tflags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_scall_setqlim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "551-712",
    "snippet": "int\nxfs_qm_scall_setqlim(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*newlim)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t/*\n\t * We don't want to race with a quotaoff so take the quotaoff lock.\n\t * We don't hold an inode lock, so there's nothing else to stop\n\t * a quotaoff from happening.\n\t */\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * Get the dquot (locked) before we start, as we need to do a\n\t * transaction to allocate it if it doesn't exist. Once we have the\n\t * dquot, unlock it so we can start the next transaction safely. We hold\n\t * a reference to the dquot, so it's safe to do this unlock/lock without\n\t * it being reclaimed in the mean time.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_unlock;\n\t}\n\txfs_dqunlock(dqp);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_SETQLIM);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_setqlim, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_rele;\n\t}\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\tddq = &dqp->q_core;\n\n\t/*\n\t * Make sure that hardlimits are >= soft limits before changing.\n\t */\n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_blk_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_blk_softlimit = cpu_to_be64(soft);\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\t\tif (id == 0) {\n\t\t\tq->qi_bhardlimit = hard;\n\t\t\tq->qi_bsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"blkhard %Ld < blksoft %Ld\", hard, soft);\n\t}\n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_rtb_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_rtb_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_rtbhardlimit = hard;\n\t\t\tq->qi_rtbsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"rtbhard %Ld < rtbsoft %Ld\", hard, soft);\n\t}\n\n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_ino_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_ino_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_ihardlimit = hard;\n\t\t\tq->qi_isoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"ihard %Ld < isoft %Ld\", hard, soft);\n\t}\n\n\t/*\n\t * Update warnings counter(s) if requested\n\t */\n\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\tddq->d_bwarns = cpu_to_be16(newlim->d_spc_warns);\n\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\tddq->d_iwarns = cpu_to_be16(newlim->d_ino_warns);\n\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\tddq->d_rtbwarns = cpu_to_be16(newlim->d_rt_spc_warns);\n\n\tif (id == 0) {\n\t\t/*\n\t\t * Timelimits for the super user set the relative time\n\t\t * the other users can be over quota for this file system.\n\t\t * If it is zero a default is used.  Ditto for the default\n\t\t * soft and hard limit values (already done, above), and\n\t\t * for warnings.\n\t\t */\n\t\tif (newlim->d_fieldmask & QC_SPC_TIMER) {\n\t\t\tq->qi_btimelimit = newlim->d_spc_timer;\n\t\t\tddq->d_btimer = cpu_to_be32(newlim->d_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_INO_TIMER) {\n\t\t\tq->qi_itimelimit = newlim->d_ino_timer;\n\t\t\tddq->d_itimer = cpu_to_be32(newlim->d_ino_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_TIMER) {\n\t\t\tq->qi_rtbtimelimit = newlim->d_rt_spc_timer;\n\t\t\tddq->d_rtbtimer = cpu_to_be32(newlim->d_rt_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\t\tq->qi_bwarnlimit = newlim->d_spc_warns;\n\t\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\t\tq->qi_iwarnlimit = newlim->d_ino_warns;\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\t\tq->qi_rtbwarnlimit = newlim->d_rt_spc_warns;\n\t} else {\n\t\t/*\n\t\t * If the user is now over quota, start the timelimit.\n\t\t * The user will not be 'warned'.\n\t\t * Note that we keep the timers ticking, whether enforcement\n\t\t * is on or off. We don't really want to bother with iterating\n\t\t * over all ondisk dquots and turning the timers on/off.\n\t\t */\n\t\txfs_qm_adjust_dqtimers(mp, ddq);\n\t}\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_trans_log_dquot(tp, dqp);\n\n\terror = xfs_trans_commit(tp, 0);\n\nout_rele:\n\txfs_qm_dqrele(dqp);\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define XFS_QC_MASK \\\n\t(QC_LIMIT_MASK | QC_TIMER_MASK | QC_WARNS_MASK)"
    ],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "dqp"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_dquot",
          "args": [
            "tp",
            "dqp"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_adjust_dqtimers",
          "args": [
            "mp",
            "ddq"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_adjust_dqtimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "133-220",
          "snippet": "void\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newlim->d_rt_spc_timer"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newlim->d_ino_timer"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newlim->d_spc_timer"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "newlim->d_rt_spc_warns"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "newlim->d_ino_warns"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "newlim->d_spc_warns"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"ihard %Ld < isoft %Ld\"",
            "hard",
            "soft"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "soft"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "hard"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_ino_softlimit"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_ino_hardlimit"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"rtbhard %Ld < rtbsoft %Ld\"",
            "hard",
            "soft"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "soft"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "hard"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_rtb_softlimit"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "newlim->d_rt_spc_softlimit"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_rtb_hardlimit"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "newlim->d_rt_spc_hardlimit"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"blkhard %Ld < blksoft %Ld\"",
            "hard",
            "soft"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dquot_set_prealloc_limits",
          "args": [
            "dqp"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_set_prealloc_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "272-291",
          "snippet": "void\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "soft"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "hard"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_blk_softlimit"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "newlim->d_spc_softlimit"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_blk_hardlimit"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "newlim->d_spc_hardlimit"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_dqjoin",
          "args": [
            "tp",
            "dqp"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dqjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "39-58",
          "snippet": "void\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_qm_setqlim",
            "0",
            "0"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_QM_SETQLIM"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "mp",
            "NULL",
            "id",
            "type",
            "XFS_QMOPT_DQALLOC",
            "&dqp"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\n#define XFS_QC_MASK \\\n\t(QC_LIMIT_MASK | QC_TIMER_MASK | QC_WARNS_MASK)\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_setqlim(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*newlim)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t/*\n\t * We don't want to race with a quotaoff so take the quotaoff lock.\n\t * We don't hold an inode lock, so there's nothing else to stop\n\t * a quotaoff from happening.\n\t */\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * Get the dquot (locked) before we start, as we need to do a\n\t * transaction to allocate it if it doesn't exist. Once we have the\n\t * dquot, unlock it so we can start the next transaction safely. We hold\n\t * a reference to the dquot, so it's safe to do this unlock/lock without\n\t * it being reclaimed in the mean time.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_unlock;\n\t}\n\txfs_dqunlock(dqp);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_SETQLIM);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_setqlim, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_rele;\n\t}\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\tddq = &dqp->q_core;\n\n\t/*\n\t * Make sure that hardlimits are >= soft limits before changing.\n\t */\n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_blk_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_blk_softlimit = cpu_to_be64(soft);\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\t\tif (id == 0) {\n\t\t\tq->qi_bhardlimit = hard;\n\t\t\tq->qi_bsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"blkhard %Ld < blksoft %Ld\", hard, soft);\n\t}\n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_rtb_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_rtb_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_rtbhardlimit = hard;\n\t\t\tq->qi_rtbsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"rtbhard %Ld < rtbsoft %Ld\", hard, soft);\n\t}\n\n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_ino_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_ino_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_ihardlimit = hard;\n\t\t\tq->qi_isoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"ihard %Ld < isoft %Ld\", hard, soft);\n\t}\n\n\t/*\n\t * Update warnings counter(s) if requested\n\t */\n\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\tddq->d_bwarns = cpu_to_be16(newlim->d_spc_warns);\n\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\tddq->d_iwarns = cpu_to_be16(newlim->d_ino_warns);\n\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\tddq->d_rtbwarns = cpu_to_be16(newlim->d_rt_spc_warns);\n\n\tif (id == 0) {\n\t\t/*\n\t\t * Timelimits for the super user set the relative time\n\t\t * the other users can be over quota for this file system.\n\t\t * If it is zero a default is used.  Ditto for the default\n\t\t * soft and hard limit values (already done, above), and\n\t\t * for warnings.\n\t\t */\n\t\tif (newlim->d_fieldmask & QC_SPC_TIMER) {\n\t\t\tq->qi_btimelimit = newlim->d_spc_timer;\n\t\t\tddq->d_btimer = cpu_to_be32(newlim->d_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_INO_TIMER) {\n\t\t\tq->qi_itimelimit = newlim->d_ino_timer;\n\t\t\tddq->d_itimer = cpu_to_be32(newlim->d_ino_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_TIMER) {\n\t\t\tq->qi_rtbtimelimit = newlim->d_rt_spc_timer;\n\t\t\tddq->d_rtbtimer = cpu_to_be32(newlim->d_rt_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\t\tq->qi_bwarnlimit = newlim->d_spc_warns;\n\t\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\t\tq->qi_iwarnlimit = newlim->d_ino_warns;\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\t\tq->qi_rtbwarnlimit = newlim->d_rt_spc_warns;\n\t} else {\n\t\t/*\n\t\t * If the user is now over quota, start the timelimit.\n\t\t * The user will not be 'warned'.\n\t\t * Note that we keep the timers ticking, whether enforcement\n\t\t * is on or off. We don't really want to bother with iterating\n\t\t * over all ondisk dquots and turning the timers on/off.\n\t\t */\n\t\txfs_qm_adjust_dqtimers(mp, ddq);\n\t}\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_trans_log_dquot(tp, dqp);\n\n\terror = xfs_trans_commit(tp, 0);\n\nout_rele:\n\txfs_qm_dqrele(dqp);\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_scall_getqstatv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "478-543",
    "snippet": "int\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "pip"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "gip"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "uip"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "mp->m_sb.sb_pquotino",
            "0",
            "0",
            "&pip"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_export_flags",
          "args": [
            "mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD)"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_export_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "876-896",
          "snippet": "STATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nint\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_scall_getqstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "397-472",
    "snippet": "int\nxfs_qm_scall_getqstat(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_stat\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tmemset(out, 0, sizeof(fs_quota_stat_t));\n\n\tout->qs_version = FS_QSTAT_VERSION;\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\t/*\n\t * Q_XGETQSTAT doesn't have room for both group and project quotas.\n\t * So, allow the project quota values to be copied out only if\n\t * there is no group quota information available.\n\t */\n\tif (!gip) {\n\t\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\t\ttemppqip = true;\n\t\t}\n\t} else\n\t\tpip = NULL;\n\tif (uip) {\n\t\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\t\tout->qs_gquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "pip"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "gip"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "uip"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "mp->m_sb.sb_pquotino",
            "0",
            "0",
            "&pip"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_export_flags",
          "args": [
            "mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_export_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "876-896",
          "snippet": "STATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC uint\nxfs_qm_export_flags(\n\tuint flags)\n{\n\tuint uflags;\n\n\tuflags = 0;\n\tif (flags & XFS_UQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_UDQ_ACCT;\n\tif (flags & XFS_GQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_GDQ_ACCT;\n\tif (flags & XFS_PQUOTA_ACCT)\n\t\tuflags |= FS_QUOTA_PDQ_ACCT;\n\tif (flags & XFS_UQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_UDQ_ENFD;\n\tif (flags & XFS_GQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_GDQ_ENFD;\n\tif (flags & XFS_PQUOTA_ENFD)\n\t\tuflags |= FS_QUOTA_PDQ_ENFD;\n\treturn uflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "sizeof(fs_quota_stat_t)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nint\nxfs_qm_scall_getqstat(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_stat\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tmemset(out, 0, sizeof(fs_quota_stat_t));\n\n\tout->qs_version = FS_QSTAT_VERSION;\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\t/*\n\t * Q_XGETQSTAT doesn't have room for both group and project quotas.\n\t * So, allow the project quota values to be copied out only if\n\t * there is no group quota information available.\n\t */\n\tif (!gip) {\n\t\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\t\ttemppqip = true;\n\t\t}\n\t} else\n\t\tpip = NULL;\n\tif (uip) {\n\t\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\t\tout->qs_gquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_scall_quotaon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "308-390",
    "snippet": "int\nxfs_qm_scall_quotaon(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror;\n\tuint\t\tqf;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\t/*\n\t * Switching on quota accounting must be done at mount time.\n\t */\n\tflags &= ~(XFS_ALL_QUOTA_ACCT);\n\n\tif (flags == 0) {\n\t\txfs_debug(mp, \"%s: zero flags, m_qflags=%x\",\n\t\t\t__func__, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't enforce without accounting. We check the superblock\n\t * qflags here instead of m_qflags because rootfs can have\n\t * quota acct on ondisk without m_qflags' knowing.\n\t */\n\tif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_UQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_GQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_PQUOTA_ENFD))) {\n\t\txfs_debug(mp,\n\t\t\t\"%s: Can't enforce without acct, flags=%x sbflags=%x\",\n\t\t\t__func__, flags, mp->m_sb.sb_qflags);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * If everything's up to-date incore, then don't waste time.\n\t */\n\tif ((mp->m_qflags & flags) == flags)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Change sb_qflags on disk but not incore mp->qflags\n\t * if this is the root filesystem.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tqf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = qf | flags;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * There's nothing to change if it's the same.\n\t */\n\tif ((qf & flags) == flags)\n\t\treturn -EEXIST;\n\n\terror = xfs_sync_sb(mp, false);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If we aren't trying to switch on quota enforcement, we are done.\n\t */\n\tif  (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_UQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_PQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_GQUOTA_ACCT)))\n\t\treturn 0;\n\n\tif (! XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ESRCH;\n\n\t/*\n\t * Switch on quota enforcement in core.\n\t */\n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mp->m_quotainfo->qi_quotaofflock"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mp->m_quotainfo->qi_quotaofflock"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"%s: Can't enforce without acct, flags=%x sbflags=%x\"",
            "__func__",
            "flags",
            "mp->m_sb.sb_qflags"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"%s: zero flags, m_qflags=%x\"",
            "__func__",
            "mp->m_qflags"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_quotaon(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror;\n\tuint\t\tqf;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\t/*\n\t * Switching on quota accounting must be done at mount time.\n\t */\n\tflags &= ~(XFS_ALL_QUOTA_ACCT);\n\n\tif (flags == 0) {\n\t\txfs_debug(mp, \"%s: zero flags, m_qflags=%x\",\n\t\t\t__func__, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't enforce without accounting. We check the superblock\n\t * qflags here instead of m_qflags because rootfs can have\n\t * quota acct on ondisk without m_qflags' knowing.\n\t */\n\tif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_UQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_GQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_PQUOTA_ENFD))) {\n\t\txfs_debug(mp,\n\t\t\t\"%s: Can't enforce without acct, flags=%x sbflags=%x\",\n\t\t\t__func__, flags, mp->m_sb.sb_qflags);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * If everything's up to-date incore, then don't waste time.\n\t */\n\tif ((mp->m_qflags & flags) == flags)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Change sb_qflags on disk but not incore mp->qflags\n\t * if this is the root filesystem.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tqf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = qf | flags;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * There's nothing to change if it's the same.\n\t */\n\tif ((qf & flags) == flags)\n\t\treturn -EEXIST;\n\n\terror = xfs_sync_sb(mp, false);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If we aren't trying to switch on quota enforcement, we are done.\n\t */\n\tif  (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_UQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_PQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_GQUOTA_ACCT)))\n\t\treturn 0;\n\n\tif (! XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ESRCH;\n\n\t/*\n\t * Switch on quota enforcement in core.\n\t */\n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_scall_trunc_qfiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "273-301",
    "snippet": "int\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\n\t    (flags & ~XFS_DQ_ALLTYPES)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_DQ_USER) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_GROUP) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_PROJ)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_trunc_qfile",
          "args": [
            "mp",
            "mp->m_sb.sb_pquotino"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_trunc_qfiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "273-301",
          "snippet": "int\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\n\t    (flags & ~XFS_DQ_ALLTYPES)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_DQ_USER) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_GROUP) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_PROJ)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"%s: flags=%x m_qflags=%x\"",
            "__func__",
            "flags",
            "mp->m_qflags"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\n\t    (flags & ~XFS_DQ_ALLTYPES)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_DQ_USER) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_GROUP) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_PROJ)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_scall_trunc_qfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "222-271",
    "snippet": "STATIC int\nxfs_qm_scall_trunc_qfile(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (ino == NULLFSINO)\n\t\treturn 0;\n\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_TRUNCATE_FILE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\tgoto out_put;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t     XFS_TRANS_ABORT);\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL);\nout_put:\n\tIRELE(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "ip",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nextents == 0"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t     XFS_TRANS_ABORT"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_itruncate_extents",
          "args": [
            "&tp",
            "ip",
            "XFS_DATA_FORK",
            "0"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_itruncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1492-1605",
          "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [
            "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_TRUNCATE_FILE"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "0",
            "0",
            "&ip"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\nxfs_qm_scall_trunc_qfile(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (ino == NULLFSINO)\n\t\treturn 0;\n\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_TRUNCATE_FILE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\tgoto out_put;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t     XFS_TRANS_ABORT);\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL);\nout_put:\n\tIRELE(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_scall_quotaoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
    "lines": "51-220",
    "snippet": "int\nxfs_qm_scall_quotaoff(\n\txfs_mount_t\t\t*mp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tuint\t\t\tdqtype;\n\tint\t\t\terror;\n\tuint\t\t\tinactivate_flags;\n\txfs_qoff_logitem_t\t*qoffstart;\n\n\t/*\n\t * No file system can have quotas enabled on disk but not in core.\n\t * Note that quota utilities (like quotaoff) _expect_\n\t * errno == -EEXIST here.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\treturn -EEXIST;\n\terror = 0;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\n\t/*\n\t * We don't want to deal with two quotaoffs messing up each other,\n\t * so we're going to serialize it. quotaoff isn't exactly a performance\n\t * critical thing.\n\t * If quotaoff, then we must be dealing with the root filesystem.\n\t */\n\tASSERT(q);\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * If we're just turning off quota enforcement, change mp and go.\n\t */\n\tif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\n\t\tmp->m_qflags &= ~(flags);\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tmp->m_sb.sb_qflags = mp->m_qflags;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\n\t\t/* XXX what to do if error ? Revert back to old vals incore ? */\n\t\treturn xfs_sync_sb(mp, false);\n\t}\n\n\tdqtype = 0;\n\tinactivate_flags = 0;\n\t/*\n\t * If accounting is off, we must turn enforcement off, clear the\n\t * quota 'CHKD' certificate to make it known that we have to\n\t * do a quotacheck the next time this quota is turned on.\n\t */\n\tif (flags & XFS_UQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_UQUOTA;\n\t\tflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_UQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_GQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_GQUOTA;\n\t\tflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_GQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_PQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_PQUOTA;\n\t\tflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_PQUOTA_ACTIVE;\n\t}\n\n\t/*\n\t * Nothing to do?  Don't complain. This happens when we're just\n\t * turning off quota enforcement.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Write the LI_QUOTAOFF log record, and do SB changes atomically,\n\t * and synchronously. If we fail to write, we should abort the\n\t * operation as it cannot be recovered safely if we crash.\n\t */\n\terror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Next we clear the XFS_MOUNT_*DQ_ACTIVE bit(s) in the mount struct\n\t * to take care of the race between dqget and quotaoff. We don't take\n\t * any special locks to reset these bits. All processes need to check\n\t * these bits *after* taking inode lock(s) to see if the particular\n\t * quota type is in the process of being turned off. If *ACTIVE, it is\n\t * guaranteed that all dquot structures and all quotainode ptrs will all\n\t * stay valid as long as that inode is kept locked.\n\t *\n\t * There is no turning back after this.\n\t */\n\tmp->m_qflags &= ~inactivate_flags;\n\n\t/*\n\t * Give back all the dquot reference(s) held by inodes.\n\t * Here we go thru every single incore inode in this file system, and\n\t * do a dqrele on the i_udquot/i_gdquot that it may have.\n\t * Essentially, as long as somebody has an inode locked, this guarantees\n\t * that quotas will not be turned off. This is handy because in a\n\t * transaction once we lock the inode(s) and check for quotaon, we can\n\t * depend on the quota inodes (and other things) being valid as long as\n\t * we keep the lock(s).\n\t */\n\txfs_qm_dqrele_all_inodes(mp, flags);\n\n\t/*\n\t * Next we make the changes in the quota flag in the mount struct.\n\t * This isn't protected by a particular lock directly, because we\n\t * don't want to take a mrlock every time we depend on quotas being on.\n\t */\n\tmp->m_qflags &= ~flags;\n\n\t/*\n\t * Go through all the dquots of this file system and purge them,\n\t * according to what was turned off.\n\t */\n\txfs_qm_dqpurge_all(mp, dqtype);\n\n\t/*\n\t * Transactions that had started before ACTIVE state bit was cleared\n\t * could have logged many dquots, so they'd have higher LSNs than\n\t * the first QUOTAOFF log record does. If we happen to crash when\n\t * the tail of the log has gone past the QUOTAOFF record, but\n\t * before the last dquot modification, those dquots __will__\n\t * recover, and that's not good.\n\t *\n\t * So, we have QUOTAOFF start and end logitems; the start\n\t * logitem won't get overwritten until the end logitem appears...\n\t */\n\terror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\n\tif (error) {\n\t\t/* We're screwed now. Shutdown is the only option. */\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If all quotas are completely turned off, close shop.\n\t */\n\tif (mp->m_qflags == 0) {\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release our quotainode references if we don't need them anymore.\n\t */\n\tif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\n\t\tIRELE(q->qi_uquotaip);\n\t\tq->qi_uquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\n\t\tIRELE(q->qi_gquotaip);\n\t\tq->qi_gquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\n\t\tIRELE(q->qi_pquotaip);\n\t\tq->qi_pquotaip = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
      "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
      "STATIC uint\txfs_qm_export_flags(uint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "q->qi_pquotaip"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "q->qi_gquotaip"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "q->qi_uquotaip"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_destroy_quotainfo",
          "args": [
            "mp"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_destroy_quotainfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "680-707",
          "snippet": "void\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_log_quotaoff_end",
          "args": [
            "mp",
            "qoffstart",
            "flags"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_log_quotaoff_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "714-744",
          "snippet": "STATIC int\nxfs_qm_log_quotaoff_end(\n\txfs_mount_t\t\t*mp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t\t*qoffi;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF_END);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_equotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, startqoff,\n\t\t\t\t\tflags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC int\nxfs_qm_log_quotaoff_end(\n\txfs_mount_t\t\t*mp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t\t*qoffi;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF_END);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_equotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, startqoff,\n\t\t\t\t\tflags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqpurge_all",
          "args": [
            "mp",
            "dqtype"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqpurge_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "196-207",
          "snippet": "void\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrele_all_inodes",
          "args": [
            "mp",
            "flags"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele_all_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "939-946",
          "snippet": "void\nxfs_qm_dqrele_all_inodes(\n\tstruct xfs_mount *mp,\n\tuint\t\t flags)\n{\n\tASSERT(mp->m_quotainfo);\n\txfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nvoid\nxfs_qm_dqrele_all_inodes(\n\tstruct xfs_mount *mp,\n\tuint\t\t flags)\n{\n\tASSERT(mp->m_quotainfo);\n\txfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_log_quotaoff",
          "args": [
            "mp",
            "&qoffstart",
            "flags"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_log_quotaoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "747-788",
          "snippet": "STATIC int\nxfs_qm_log_quotaoff(\n\txfs_mount_t\t       *mp,\n\txfs_qoff_logitem_t     **qoffstartp,\n\tuint\t\t       flags)\n{\n\txfs_trans_t\t       *tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t     *qoffi;\n\n\t*qoffstartp = NULL;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_quotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\txfs_log_sb(tp);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out;\n\n\t*qoffstartp = qoffi;\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nSTATIC int\nxfs_qm_log_quotaoff(\n\txfs_mount_t\t       *mp,\n\txfs_qoff_logitem_t     **qoffstartp,\n\tuint\t\t       flags)\n{\n\txfs_trans_t\t       *tp;\n\tint\t\t\terror;\n\txfs_qoff_logitem_t     *qoffi;\n\n\t*qoffstartp = NULL;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_quotaoff, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out;\n\t}\n\n\tqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\n\txfs_trans_log_quotaoff_item(tp, qoffi);\n\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\txfs_log_sb(tp);\n\n\t/*\n\t * We have to make sure that the transaction is secure on disk before we\n\t * return and actually stop quota accounting. So, make it synchronous.\n\t * We don't care about quotoff's performance.\n\t */\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out;\n\n\t*qoffstartp = qoffi;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->qi_quotaofflock"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "q"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_quotaoff(\n\txfs_mount_t\t\t*mp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tuint\t\t\tdqtype;\n\tint\t\t\terror;\n\tuint\t\t\tinactivate_flags;\n\txfs_qoff_logitem_t\t*qoffstart;\n\n\t/*\n\t * No file system can have quotas enabled on disk but not in core.\n\t * Note that quota utilities (like quotaoff) _expect_\n\t * errno == -EEXIST here.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\treturn -EEXIST;\n\terror = 0;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\n\t/*\n\t * We don't want to deal with two quotaoffs messing up each other,\n\t * so we're going to serialize it. quotaoff isn't exactly a performance\n\t * critical thing.\n\t * If quotaoff, then we must be dealing with the root filesystem.\n\t */\n\tASSERT(q);\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * If we're just turning off quota enforcement, change mp and go.\n\t */\n\tif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\n\t\tmp->m_qflags &= ~(flags);\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tmp->m_sb.sb_qflags = mp->m_qflags;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\n\t\t/* XXX what to do if error ? Revert back to old vals incore ? */\n\t\treturn xfs_sync_sb(mp, false);\n\t}\n\n\tdqtype = 0;\n\tinactivate_flags = 0;\n\t/*\n\t * If accounting is off, we must turn enforcement off, clear the\n\t * quota 'CHKD' certificate to make it known that we have to\n\t * do a quotacheck the next time this quota is turned on.\n\t */\n\tif (flags & XFS_UQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_UQUOTA;\n\t\tflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_UQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_GQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_GQUOTA;\n\t\tflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_GQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_PQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_PQUOTA;\n\t\tflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_PQUOTA_ACTIVE;\n\t}\n\n\t/*\n\t * Nothing to do?  Don't complain. This happens when we're just\n\t * turning off quota enforcement.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Write the LI_QUOTAOFF log record, and do SB changes atomically,\n\t * and synchronously. If we fail to write, we should abort the\n\t * operation as it cannot be recovered safely if we crash.\n\t */\n\terror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Next we clear the XFS_MOUNT_*DQ_ACTIVE bit(s) in the mount struct\n\t * to take care of the race between dqget and quotaoff. We don't take\n\t * any special locks to reset these bits. All processes need to check\n\t * these bits *after* taking inode lock(s) to see if the particular\n\t * quota type is in the process of being turned off. If *ACTIVE, it is\n\t * guaranteed that all dquot structures and all quotainode ptrs will all\n\t * stay valid as long as that inode is kept locked.\n\t *\n\t * There is no turning back after this.\n\t */\n\tmp->m_qflags &= ~inactivate_flags;\n\n\t/*\n\t * Give back all the dquot reference(s) held by inodes.\n\t * Here we go thru every single incore inode in this file system, and\n\t * do a dqrele on the i_udquot/i_gdquot that it may have.\n\t * Essentially, as long as somebody has an inode locked, this guarantees\n\t * that quotas will not be turned off. This is handy because in a\n\t * transaction once we lock the inode(s) and check for quotaon, we can\n\t * depend on the quota inodes (and other things) being valid as long as\n\t * we keep the lock(s).\n\t */\n\txfs_qm_dqrele_all_inodes(mp, flags);\n\n\t/*\n\t * Next we make the changes in the quota flag in the mount struct.\n\t * This isn't protected by a particular lock directly, because we\n\t * don't want to take a mrlock every time we depend on quotas being on.\n\t */\n\tmp->m_qflags &= ~flags;\n\n\t/*\n\t * Go through all the dquots of this file system and purge them,\n\t * according to what was turned off.\n\t */\n\txfs_qm_dqpurge_all(mp, dqtype);\n\n\t/*\n\t * Transactions that had started before ACTIVE state bit was cleared\n\t * could have logged many dquots, so they'd have higher LSNs than\n\t * the first QUOTAOFF log record does. If we happen to crash when\n\t * the tail of the log has gone past the QUOTAOFF record, but\n\t * before the last dquot modification, those dquots __will__\n\t * recover, and that's not good.\n\t *\n\t * So, we have QUOTAOFF start and end logitems; the start\n\t * logitem won't get overwritten until the end logitem appears...\n\t */\n\terror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\n\tif (error) {\n\t\t/* We're screwed now. Shutdown is the only option. */\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If all quotas are completely turned off, close shop.\n\t */\n\tif (mp->m_qflags == 0) {\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release our quotainode references if we don't need them anymore.\n\t */\n\tif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\n\t\tIRELE(q->qi_uquotaip);\n\t\tq->qi_uquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\n\t\tIRELE(q->qi_gquotaip);\n\t\tq->qi_gquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\n\t\tIRELE(q->qi_pquotaip);\n\t\tq->qi_pquotaip = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}"
  }
]