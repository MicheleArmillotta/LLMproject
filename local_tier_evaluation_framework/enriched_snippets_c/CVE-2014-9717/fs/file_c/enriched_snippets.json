[
  {
    "function_name": "iterate_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "894-914",
    "snippet": "int iterate_fd(struct files_struct *files, unsigned n,\n\t\tint (*f)(const void *, struct file *, unsigned),\n\t\tconst void *p)\n{\n\tstruct fdtable *fdt;\n\tint res = 0;\n\tif (!files)\n\t\treturn 0;\n\tspin_lock(&files->file_lock);\n\tfor (fdt = files_fdtable(files); n < fdt->max_fds; n++) {\n\t\tstruct file *file;\n\t\tfile = rcu_dereference_check_fdtable(files, fdt->fd[n]);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tres = f(p, file, n);\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&files->file_lock);\n\treturn res;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "p",
            "file",
            "n"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "f_dupfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "881-892",
          "snippet": "int f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check_fdtable",
          "args": [
            "files",
            "fdt->fd[n]"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint iterate_fd(struct files_struct *files, unsigned n,\n\t\tint (*f)(const void *, struct file *, unsigned),\n\t\tconst void *p)\n{\n\tstruct fdtable *fdt;\n\tint res = 0;\n\tif (!files)\n\t\treturn 0;\n\tspin_lock(&files->file_lock);\n\tfor (fdt = files_fdtable(files); n < fdt->max_fds; n++) {\n\t\tstruct file *file;\n\t\tfile = rcu_dereference_check_fdtable(files, fdt->fd[n]);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tres = f(p, file, n);\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&files->file_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "f_dupfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "881-892",
    "snippet": "int f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "err",
            "file"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fd",
          "args": [
            "from",
            "flags"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "503-506",
          "snippet": "static int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "replace_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "795-815",
    "snippet": "int replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_dup2",
          "args": [
            "files",
            "file",
            "fd",
            "flags"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "do_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "751-793",
          "snippet": "static int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "expand_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "187-203",
          "snippet": "static int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__close_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "__close_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "573-594",
          "snippet": "int __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__clear_close_on_exec(fd, fdt);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__clear_close_on_exec(fd, fdt);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "do_dup2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "751-793",
    "snippet": "static int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "tofree",
            "files"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "210-213",
          "snippet": "static inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "205-208",
          "snippet": "static inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "__set_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "215-218",
          "snippet": "static inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "file"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_is_open",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&files->file_lock"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "get_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "739-749",
    "snippet": "bool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "726-737",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nbool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}"
  },
  {
    "function_name": "set_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "726-737",
    "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "210-213",
          "snippet": "static inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "205-208",
          "snippet": "static inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__fdget_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "706-718",
    "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file->f_pos_lock"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_count",
          "args": [
            "file"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fdget",
          "args": [
            "fd"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
  },
  {
    "function_name": "__fdget_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "701-704",
    "snippet": "unsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget_light",
          "args": [
            "fd",
            "0"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "678-694",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}"
  },
  {
    "function_name": "__fdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "695-698",
    "snippet": "unsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget_light",
          "args": [
            "fd",
            "FMODE_PATH"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "678-694",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}"
  },
  {
    "function_name": "__fget_light",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "678-694",
    "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "mask"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "678-694",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file->f_mode & mask"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&files->count"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
  },
  {
    "function_name": "fget_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "656-659",
    "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "0"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "678-694",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
  },
  {
    "function_name": "fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "650-653",
    "snippet": "struct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "FMODE_PATH"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "678-694",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH);\n}"
  },
  {
    "function_name": "__fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "632-648",
    "snippet": "static struct file *__fget(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = fcheck_files(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken */\n\t\tif ((file->f_mode & mask) ||\n\t\t    !atomic_long_inc_not_zero(&file->f_count))\n\t\t\tfile = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_not_zero",
          "args": [
            "&file->f_count"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct file *__fget(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = fcheck_files(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken */\n\t\tif ((file->f_mode & mask) ||\n\t\t    !atomic_long_inc_not_zero(&file->f_count))\n\t\t\tfile = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}"
  },
  {
    "function_name": "do_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "596-630",
    "snippet": "void do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "514-520",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__close_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "573-594",
    "snippet": "int __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__clear_close_on_exec(fd, fdt);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "514-520",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "210-213",
          "snippet": "static inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__clear_close_on_exec(fd, fdt);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}"
  },
  {
    "function_name": "fd_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "563-566",
    "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fd_install",
          "args": [
            "current->files",
            "fd",
            "file"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "552-561",
          "snippet": "void __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\tspin_unlock(&files->file_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
  },
  {
    "function_name": "__fd_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "552-561",
    "snippet": "void __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "file"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fdt->fd[fd] != NULL"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "put_unused_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "522-528",
    "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "514-520",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__put_unused_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "514-520",
    "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "220-223",
          "snippet": "static inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
  },
  {
    "function_name": "get_unused_fd_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "508-511",
    "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_fd",
          "args": [
            "current->files",
            "0",
            "rlimit(RLIMIT_NOFILE)",
            "flags"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "445-501",
          "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
  },
  {
    "function_name": "alloc_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "503-506",
    "snippet": "static int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_fd",
          "args": [
            "current->files",
            "start",
            "rlimit(RLIMIT_NOFILE)",
            "flags"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "445-501",
          "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}"
  },
  {
    "function_name": "__alloc_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "445-501",
    "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\"",
            "fd"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "fdt->fd[fd]"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "210-213",
          "snippet": "static inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "205-208",
          "snippet": "static inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__set_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "215-218",
          "snippet": "static inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "expand_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "187-203",
          "snippet": "static int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "fdt->open_fds",
            "fdt->max_fds",
            "fd"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "exit_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "418-428",
    "snippet": "void exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}"
  },
  {
    "function_name": "reset_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "406-416",
    "snippet": "void reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "old"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}"
  },
  {
    "function_name": "put_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "394-404",
    "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "files_cachep",
            "files"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "fdt"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "47-52",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_files",
          "args": [
            "files"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "close_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "349-379",
          "snippet": "static struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tint i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched_rcu_qs();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tint i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched_rcu_qs();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&files->count"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
  },
  {
    "function_name": "get_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "381-392",
    "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&files->count"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
  },
  {
    "function_name": "close_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "349-379",
    "snippet": "static struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tint i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched_rcu_qs();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_rcu_qs",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&fdt->fd[i]",
            "NULL"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "files->fdt"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tint i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched_rcu_qs();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}"
  },
  {
    "function_name": "dup_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "244-347",
    "snippet": "struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)\n{\n\tstruct files_struct *newf;\n\tstruct file **old_fds, **new_fds;\n\tint open_files, size, i;\n\tstruct fdtable *old_fdt, *new_fdt;\n\n\t*errorp = -ENOMEM;\n\tnewf = kmem_cache_alloc(files_cachep, GFP_KERNEL);\n\tif (!newf)\n\t\tgoto out;\n\n\tatomic_set(&newf->count, 1);\n\n\tspin_lock_init(&newf->file_lock);\n\tnewf->next_fd = 0;\n\tnew_fdt = &newf->fdtab;\n\tnew_fdt->max_fds = NR_OPEN_DEFAULT;\n\tnew_fdt->close_on_exec = newf->close_on_exec_init;\n\tnew_fdt->open_fds = newf->open_fds_init;\n\tnew_fdt->fd = &newf->fd_array[0];\n\n\tspin_lock(&oldf->file_lock);\n\told_fdt = files_fdtable(oldf);\n\topen_files = count_open_files(old_fdt);\n\n\t/*\n\t * Check whether we need to allocate a larger fd array and fd set.\n\t */\n\twhile (unlikely(open_files > new_fdt->max_fds)) {\n\t\tspin_unlock(&oldf->file_lock);\n\n\t\tif (new_fdt != &newf->fdtab)\n\t\t\t__free_fdtable(new_fdt);\n\n\t\tnew_fdt = alloc_fdtable(open_files - 1);\n\t\tif (!new_fdt) {\n\t\t\t*errorp = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/* beyond sysctl_nr_open; nothing to do */\n\t\tif (unlikely(new_fdt->max_fds < open_files)) {\n\t\t\t__free_fdtable(new_fdt);\n\t\t\t*errorp = -EMFILE;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/*\n\t\t * Reacquire the oldf lock and a pointer to its fd table\n\t\t * who knows it may have a new bigger fd table. We need\n\t\t * the latest pointer.\n\t\t */\n\t\tspin_lock(&oldf->file_lock);\n\t\told_fdt = files_fdtable(oldf);\n\t\topen_files = count_open_files(old_fdt);\n\t}\n\n\told_fds = old_fdt->fd;\n\tnew_fds = new_fdt->fd;\n\n\tmemcpy(new_fdt->open_fds, old_fdt->open_fds, open_files / 8);\n\tmemcpy(new_fdt->close_on_exec, old_fdt->close_on_exec, open_files / 8);\n\n\tfor (i = open_files; i != 0; i--) {\n\t\tstruct file *f = *old_fds++;\n\t\tif (f) {\n\t\t\tget_file(f);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The fd may be claimed in the fd bitmap but not yet\n\t\t\t * instantiated in the files array if a sibling thread\n\t\t\t * is partway through open().  So make sure that this\n\t\t\t * fd is available to the new process.\n\t\t\t */\n\t\t\t__clear_open_fd(open_files - i, new_fdt);\n\t\t}\n\t\trcu_assign_pointer(*new_fds++, f);\n\t}\n\tspin_unlock(&oldf->file_lock);\n\n\t/* compute the remainder to be cleared */\n\tsize = (new_fdt->max_fds - open_files) * sizeof(struct file *);\n\n\t/* This is long word aligned thus could use a optimized version */\n\tmemset(new_fds, 0, size);\n\n\tif (new_fdt->max_fds > open_files) {\n\t\tint left = (new_fdt->max_fds - open_files) / 8;\n\t\tint start = open_files / BITS_PER_LONG;\n\n\t\tmemset(&new_fdt->open_fds[start], 0, left);\n\t\tmemset(&new_fdt->close_on_exec[start], 0, left);\n\t}\n\n\trcu_assign_pointer(newf->fdt, new_fdt);\n\n\treturn newf;\n\nout_release:\n\tkmem_cache_free(files_cachep, newf);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "files_cachep",
            "newf"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "newf->fdt",
            "new_fdt"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_fdt->close_on_exec[start]",
            "0",
            "left"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_fdt->open_fds[start]",
            "0",
            "left"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_fds",
            "0",
            "size"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oldf->file_lock"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*new_fds++",
            "f"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_open_fd",
          "args": [
            "open_files - i",
            "new_fdt"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "220-223",
          "snippet": "static inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "f"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_fdt->close_on_exec",
            "old_fdt->close_on_exec",
            "open_files / 8"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_fdt->open_fds",
            "old_fdt->open_fds",
            "open_files / 8"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_open_files",
          "args": [
            "old_fdt"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "count_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "225-237",
          "snippet": "static int count_open_files(struct fdtable *fdt)\n{\n\tint size = fdt->max_fds;\n\tint i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int count_open_files(struct fdtable *fdt)\n{\n\tint size = fdt->max_fds;\n\tint i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "oldf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oldf->file_lock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "new_fdt"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "47-52",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_fdt->max_fds < open_files"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fdtable",
          "args": [
            "open_files - 1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "82-133",
          "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "open_files > new_fdt->max_fds"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "oldf"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&newf->file_lock"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&newf->count",
            "1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "files_cachep",
            "GFP_KERNEL"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstruct files_struct *dup_fd(struct files_struct *oldf, int *errorp)\n{\n\tstruct files_struct *newf;\n\tstruct file **old_fds, **new_fds;\n\tint open_files, size, i;\n\tstruct fdtable *old_fdt, *new_fdt;\n\n\t*errorp = -ENOMEM;\n\tnewf = kmem_cache_alloc(files_cachep, GFP_KERNEL);\n\tif (!newf)\n\t\tgoto out;\n\n\tatomic_set(&newf->count, 1);\n\n\tspin_lock_init(&newf->file_lock);\n\tnewf->next_fd = 0;\n\tnew_fdt = &newf->fdtab;\n\tnew_fdt->max_fds = NR_OPEN_DEFAULT;\n\tnew_fdt->close_on_exec = newf->close_on_exec_init;\n\tnew_fdt->open_fds = newf->open_fds_init;\n\tnew_fdt->fd = &newf->fd_array[0];\n\n\tspin_lock(&oldf->file_lock);\n\told_fdt = files_fdtable(oldf);\n\topen_files = count_open_files(old_fdt);\n\n\t/*\n\t * Check whether we need to allocate a larger fd array and fd set.\n\t */\n\twhile (unlikely(open_files > new_fdt->max_fds)) {\n\t\tspin_unlock(&oldf->file_lock);\n\n\t\tif (new_fdt != &newf->fdtab)\n\t\t\t__free_fdtable(new_fdt);\n\n\t\tnew_fdt = alloc_fdtable(open_files - 1);\n\t\tif (!new_fdt) {\n\t\t\t*errorp = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/* beyond sysctl_nr_open; nothing to do */\n\t\tif (unlikely(new_fdt->max_fds < open_files)) {\n\t\t\t__free_fdtable(new_fdt);\n\t\t\t*errorp = -EMFILE;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/*\n\t\t * Reacquire the oldf lock and a pointer to its fd table\n\t\t * who knows it may have a new bigger fd table. We need\n\t\t * the latest pointer.\n\t\t */\n\t\tspin_lock(&oldf->file_lock);\n\t\told_fdt = files_fdtable(oldf);\n\t\topen_files = count_open_files(old_fdt);\n\t}\n\n\told_fds = old_fdt->fd;\n\tnew_fds = new_fdt->fd;\n\n\tmemcpy(new_fdt->open_fds, old_fdt->open_fds, open_files / 8);\n\tmemcpy(new_fdt->close_on_exec, old_fdt->close_on_exec, open_files / 8);\n\n\tfor (i = open_files; i != 0; i--) {\n\t\tstruct file *f = *old_fds++;\n\t\tif (f) {\n\t\t\tget_file(f);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The fd may be claimed in the fd bitmap but not yet\n\t\t\t * instantiated in the files array if a sibling thread\n\t\t\t * is partway through open().  So make sure that this\n\t\t\t * fd is available to the new process.\n\t\t\t */\n\t\t\t__clear_open_fd(open_files - i, new_fdt);\n\t\t}\n\t\trcu_assign_pointer(*new_fds++, f);\n\t}\n\tspin_unlock(&oldf->file_lock);\n\n\t/* compute the remainder to be cleared */\n\tsize = (new_fdt->max_fds - open_files) * sizeof(struct file *);\n\n\t/* This is long word aligned thus could use a optimized version */\n\tmemset(new_fds, 0, size);\n\n\tif (new_fdt->max_fds > open_files) {\n\t\tint left = (new_fdt->max_fds - open_files) / 8;\n\t\tint start = open_files / BITS_PER_LONG;\n\n\t\tmemset(&new_fdt->open_fds[start], 0, left);\n\t\tmemset(&new_fdt->close_on_exec[start], 0, left);\n\t}\n\n\trcu_assign_pointer(newf->fdt, new_fdt);\n\n\treturn newf;\n\nout_release:\n\tkmem_cache_free(files_cachep, newf);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "count_open_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "225-237",
    "snippet": "static int count_open_files(struct fdtable *fdt)\n{\n\tint size = fdt->max_fds;\n\tint i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int count_open_files(struct fdtable *fdt)\n{\n\tint size = fdt->max_fds;\n\tint i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}"
  },
  {
    "function_name": "__clear_open_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "220-223",
    "snippet": "static inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "fd",
            "fdt->open_fds"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n}"
  },
  {
    "function_name": "__set_open_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "215-218",
    "snippet": "static inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "fd",
            "fdt->open_fds"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n}"
  },
  {
    "function_name": "__clear_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "210-213",
    "snippet": "static inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "fd",
            "fdt->close_on_exec"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->close_on_exec);\n}"
  },
  {
    "function_name": "__set_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "205-208",
    "snippet": "static inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "fd",
            "fdt->close_on_exec"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
  },
  {
    "function_name": "expand_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "187-203",
    "snippet": "static int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_fdtable",
          "args": [
            "files",
            "nr"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "expand_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "142-177",
          "snippet": "static int expand_fdtable(struct files_struct *files, int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\t/*\n\t * Check again since another task may have expanded the fd table while\n\t * we dropped the lock\n\t */\n\tcur_fdt = files_fdtable(files);\n\tif (nr >= cur_fdt->max_fds) {\n\t\t/* Continue as planned */\n\t\tcopy_fdtable(new_fdt, cur_fdt);\n\t\trcu_assign_pointer(files->fdt, new_fdt);\n\t\tif (cur_fdt != &files->fdtab)\n\t\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t} else {\n\t\t/* Somebody else expanded, so undo our attempt */\n\t\t__free_fdtable(new_fdt);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic int expand_fdtable(struct files_struct *files, int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\t/*\n\t * Check again since another task may have expanded the fd table while\n\t * we dropped the lock\n\t */\n\tcur_fdt = files_fdtable(files);\n\tif (nr >= cur_fdt->max_fds) {\n\t\t/* Continue as planned */\n\t\tcopy_fdtable(new_fdt, cur_fdt);\n\t\trcu_assign_pointer(files->fdt, new_fdt);\n\t\tif (cur_fdt != &files->fdtab)\n\t\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t} else {\n\t\t/* Somebody else expanded, so undo our attempt */\n\t\t__free_fdtable(new_fdt);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, int nr)\n{\n\tstruct fdtable *fdt;\n\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn 0;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\t/* All good, so we try */\n\treturn expand_fdtable(files, nr);\n}"
  },
  {
    "function_name": "expand_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "142-177",
    "snippet": "static int expand_fdtable(struct files_struct *files, int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\t/*\n\t * Check again since another task may have expanded the fd table while\n\t * we dropped the lock\n\t */\n\tcur_fdt = files_fdtable(files);\n\tif (nr >= cur_fdt->max_fds) {\n\t\t/* Continue as planned */\n\t\tcopy_fdtable(new_fdt, cur_fdt);\n\t\trcu_assign_pointer(files->fdt, new_fdt);\n\t\tif (cur_fdt != &files->fdtab)\n\t\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t} else {\n\t\t/* Somebody else expanded, so undo our attempt */\n\t\t__free_fdtable(new_fdt);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "new_fdt"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "47-52",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&cur_fdt->rcu",
            "free_fdtable_rcu"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "files->fdt",
            "new_fdt"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fdtable",
          "args": [
            "new_fdt",
            "cur_fdt"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "63-80",
          "snippet": "static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)(nfdt->fd) + cpy, 0, set);\n\n\tcpy = ofdt->max_fds / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)(nfdt->open_fds) + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)(nfdt->close_on_exec) + cpy, 0, set);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)(nfdt->fd) + cpy, 0, set);\n\n\tcpy = ofdt->max_fds / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)(nfdt->open_fds) + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)(nfdt->close_on_exec) + cpy, 0, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_fdt->max_fds <= nr"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fdtable",
          "args": [
            "nr"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "82-133",
          "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "files->file_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "files->file_lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic int expand_fdtable(struct files_struct *files, int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\t/*\n\t * Check again since another task may have expanded the fd table while\n\t * we dropped the lock\n\t */\n\tcur_fdt = files_fdtable(files);\n\tif (nr >= cur_fdt->max_fds) {\n\t\t/* Continue as planned */\n\t\tcopy_fdtable(new_fdt, cur_fdt);\n\t\trcu_assign_pointer(files->fdt, new_fdt);\n\t\tif (cur_fdt != &files->fdtab)\n\t\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t} else {\n\t\t/* Somebody else expanded, so undo our attempt */\n\t\t__free_fdtable(new_fdt);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "82-133",
    "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fdt"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->fd"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fdmem",
          "args": [
            "max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fdmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "33-45",
          "snippet": "static void *alloc_fdmem(size_t size)\n{\n\t/*\n\t * Very large allocations can stress page reclaim, so fall back to\n\t * vmalloc() if the allocation size will be considered \"large\" by the VM.\n\t */\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tvoid *data = kmalloc(size, GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY);\n\t\tif (data != NULL)\n\t\t\treturn data;\n\t}\n\treturn vmalloc(size);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void *alloc_fdmem(size_t size)\n{\n\t/*\n\t * Very large allocations can stress page reclaim, so fall back to\n\t * vmalloc() if the allocation size will be considered \"large\" by the VM.\n\t */\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tvoid *data = kmalloc(size, GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY);\n\t\tif (data != NULL)\n\t\t\treturn data;\n\t}\n\treturn vmalloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "2 * nr / BITS_PER_BYTE",
            "L1_CACHE_BYTES"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct fdtable)",
            "GFP_KERNEL"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr > sysctl_nr_open"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "nr + 1"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = alloc_fdmem(nr * sizeof(struct file *));\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = alloc_fdmem(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE, L1_CACHE_BYTES));\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "copy_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "63-80",
    "snippet": "static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)(nfdt->fd) + cpy, 0, set);\n\n\tcpy = ofdt->max_fds / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)(nfdt->open_fds) + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)(nfdt->close_on_exec) + cpy, 0, set);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)(nfdt->close_on_exec) + cpy",
            "0",
            "set"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->close_on_exec",
            "ofdt->close_on_exec",
            "cpy"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)(nfdt->open_fds) + cpy",
            "0",
            "set"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->open_fds",
            "ofdt->open_fds",
            "cpy"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)(nfdt->fd) + cpy",
            "0",
            "set"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->fd",
            "ofdt->fd",
            "cpy"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nfdt->max_fds < ofdt->max_fds"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)(nfdt->fd) + cpy, 0, set);\n\n\tcpy = ofdt->max_fds / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)(nfdt->open_fds) + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)(nfdt->close_on_exec) + cpy, 0, set);\n}"
  },
  {
    "function_name": "free_fdtable_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "54-57",
    "snippet": "static void free_fdtable_rcu(struct rcu_head *rcu)\n{\n\t__free_fdtable(container_of(rcu, struct fdtable, rcu));\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void free_fdtable_rcu(struct rcu_head *rcu)\n{\n\t__free_fdtable(container_of(rcu, struct fdtable, rcu));\n}"
  },
  {
    "function_name": "__free_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "47-52",
    "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fdt"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->open_fds"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->fd"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
  },
  {
    "function_name": "alloc_fdmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
    "lines": "33-45",
    "snippet": "static void *alloc_fdmem(size_t size)\n{\n\t/*\n\t * Very large allocations can stress page reclaim, so fall back to\n\t * vmalloc() if the allocation size will be considered \"large\" by the VM.\n\t */\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tvoid *data = kmalloc(size, GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY);\n\t\tif (data != NULL)\n\t\t\treturn data;\n\t}\n\treturn vmalloc(size);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void *alloc_fdmem(size_t size)\n{\n\t/*\n\t * Very large allocations can stress page reclaim, so fall back to\n\t * vmalloc() if the allocation size will be considered \"large\" by the VM.\n\t */\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tvoid *data = kmalloc(size, GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY);\n\t\tif (data != NULL)\n\t\t\treturn data;\n\t}\n\treturn vmalloc(size);\n}"
  }
]